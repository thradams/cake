<!DOCTYPE html>
<html>
<head>
  
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <link rel="stylesheet" href="style.css" />
    <title>Cake C Compiler</title>
    <meta name="description" content="Cake C Compiler">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <script>
    function Try(elm)
    {
        //collect the text previous sample
        var source = elm.parentElement.previousElementSibling.innerText;

        var link = "./playground.html?code=" + encodeURIComponent(btoa(source)) +
            "&to=" + encodeURI("-2") +
            "&options=" + encodeURI("");

        window.open(link, '_blank');
    }
// find-replace for this
// <button onclick="Try(this)">try</button> 
</script></head>
<body>
    <article style="max-width: 40em; margin:auto">
<p><a href="index.html">Home</a> | <a href="manual.html">Manual</a> | <a href="ownership.html">Ownership</a> | <a href="playground.html">Playground</a></p>
<article>
<h1>Cake - C23 and Beyond</h1>
<ul>
<li>
<a href="#toc_0">Using cake</a>
<ul>
<li>
<a href="#toc_1">Include directories</a>
</li>
<li>
<a href="#toc_2">Command line</a>
</li>
<li>
<a href="#toc_3">Options</a>
</li>
<li>
<a href="#toc_4">Output</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">C89</a>
</li>
<li>
<a href="#toc_6">C99</a>
<ul>
<li>
<a href="#toc_7">C99 restrict pointers</a>
</li>
<li>
<a href="#toc_8">C99 Variable-length array (VLA)</a>
</li>
<li>
<a href="#toc_9">C99 Flexible array members</a>
</li>
<li>
<a href="#toc_10">C99 static and type qualifiers in parameter array declarators</a>
</li>
<li>
<a href="#toc_11">C99 Complex and imaginary support</a>
</li>
<li>
<a href="#toc_12">C99 Universal character names (\u and \U)</a>
</li>
<li>
<a href="#toc_13">C99 Hexadecimal floating constants</a>
</li>
<li>
<a href="#toc_14">C99 Compound literals</a>
</li>
<li>
<a href="#toc_15">C99 Designated initializers</a>
</li>
<li>
<a href="#toc_16">C99 Line comments</a>
</li>
<li>
<a href="#toc_17">Declarations in for loop initializers</a>
</li>
<li>
<a href="#toc_18">C99 inline functions</a>
</li>
<li>
<a href="#toc_19">C99 _Pragma preprocessing operator</a>
</li>
<li>
<a href="#toc_20">C99 __func__ predefined identifier</a>
</li>
<li>
<a href="#toc_21">C99 Variadic macros</a>
</li>
<li>
<a href="#toc_22">C99 _Bool</a>
</li>
</ul>
</li>
<li>
<a href="#toc_23">C11</a>
<ul>
<li>
<a href="#toc_24">C11 _Static_assert</a>
</li>
<li>
<a href="#toc_25">C11 Anonymous structures and unions</a>
</li>
<li>
<a href="#toc_26">C11 _Noreturn</a>
</li>
<li>
<a href="#toc_27">C11 Thread_local/Atomic</a>
</li>
<li>
<a href="#toc_28">C11 type-generic expressions (_Generic)</a>
</li>
<li>
<a href="#toc_29">C11 u&#39; &#39; U&#39; &#39; character constants</a>
</li>
<li>
<a href="#toc_30">C11 u8&quot;literals&quot;</a>
</li>
<li>
<a href="#toc_31">C11 _Alignof or C23 alignof</a>
</li>
<li>
<a href="#toc_32">C11 _Alignas or C23 alignas</a>
</li>
</ul>
</li>
<li>
<a href="#toc_33">C23</a>
<ul>
<li>
<a href="#toc_34">C23 _Decimal32, _Decimal64, and _Decimal128</a>
</li>
<li>
<a href="#toc_35">C23 static_assert / single-argument static_assert</a>
</li>
<li>
<a href="#toc_36">C23 u8 character prefix</a>
</li>
<li>
<a href="#toc_37">C23 No function declarators without prototypes</a>
</li>
<li>
<a href="#toc_38">C23 Improved Tag Compatibility</a>
</li>
<li>
<a href="#toc_39">C23 Unnamed parameters in function definitions</a>
</li>
<li>
<a href="#toc_40">C23 Digit separators</a>
</li>
<li>
<a href="#toc_41">C23 Binary literals</a>
</li>
<li>
<a href="#toc_42">C23 Introduce the nullptr constant</a>
</li>
<li>
<a href="#toc_43">C23 Make false and true first-class language features</a>
</li>
<li>
<a href="#toc_44">C23 {} empty initializer</a>
</li>
<li>
<a href="#toc_45">C23 auto</a>
</li>
<li>
<a href="#toc_46">C23 typeof / typeof_unqual</a>
</li>
<li>
<a href="#toc_47">C23 Improved Normal Enumerations</a>
</li>
<li>
<a href="#toc_48">C23 constexpr</a>
</li>
<li>
<a href="#toc_49">C23 Enhancements to Enumerations</a>
</li>
<li>
<a href="#toc_50">C23 [[Attributes]]</a>
</li>
<li>
<a href="#toc_51">C23 [[fallthrough]] attribute</a>
</li>
<li>
<a href="#toc_52">C23 [[deprecated]] attribute</a>
</li>
<li>
<a href="#toc_53">C23 [[maybe_unused]] attribute</a>
</li>
<li>
<a href="#toc_54">C23 [[nodiscard]] attribute</a>
</li>
<li>
<a href="#toc_55">C23 [[unsequenced]] and [[reproducible]]</a>
</li>
<li>
<a href="#toc_56">C23 __has_attribute</a>
</li>
<li>
<a href="#toc_57">C23 __has_include</a>
</li>
<li>
<a href="#toc_58">C23 #warning</a>
</li>
<li>
<a href="#toc_59">C23 #embed</a>
</li>
<li>
<a href="#toc_60">C23 #elifdef #elifndef</a>
</li>
<li>
<a href="#toc_61">C23 __VA_OPT__</a>
</li>
<li>
<a href="#toc_62">C23 BitInt(N))</a>
</li>
<li>
<a href="#toc_63">C23 Compound Literals with storage specifier</a>
</li>
<li>
<a href="#toc_64">C23 Variably-modified (VM) types</a>
</li>
</ul>
</li>
<li>
<a href="#toc_65">C2Y</a>
<ul>
<li>
<a href="#toc_66">C2Y Obsolete implicitly octal literals</a>
</li>
<li>
<a href="#toc_67">C2Y case range expressions</a>
</li>
<li>
<a href="#toc_68">C2Y _Countof operator</a>
</li>
<li>
<a href="#toc_69">C2Y defer</a>
</li>
<li>
<a href="#toc_70">C2Y if declarations, v4</a>
</li>
<li>
<a href="#toc_71">C2Y typename on _Generic</a>
</li>
<li>
<a href="#toc_72">C2Y __COUNTER__</a>
</li>
<li>
<a href="#toc_73">C2Y Local functions</a>
</li>
<li>
<a href="#toc_74">C2Y Function Literals</a>
</li>
<li>
<a href="#toc_75">C2Y Statement expressions</a>
</li>
</ul>
</li>
<li>
<a href="#toc_76">Cake Extensions</a>
<ul>
<li>
<a href="#toc_77">Pre-defined macros in Cake</a>
</li>
<li>
<a href="#toc_78">assert built-in</a>
</li>
<li>
<a href="#toc_79">try { throw; } catch {}</a>
</li>
<li>
<a href="#toc_80">#pragma dir</a>
</li>
<li>
<a href="#toc_81">offsetof</a>
</li>
<li>
<a href="#toc_82">Type traits</a>
</li>
<li>
<a href="#toc_83">Extension - Object lifetime checks</a>
</li>
</ul>
</li>
<li>
<a href="#toc_84">GCC extensions</a>
</li>
<li>
<a href="#toc_85">MSVC extensions</a>
</li>
</ul>
<h2 id="toc_0">Using cake</h2>

<p>Cake works as an extension for MSVC on Windows and as an extension for GCC on Linux.
This approach makes Cake useful in real and existing programs. </p>

<p>When applicable, Cake uses the same command line options of MSVC and GCC.</p>

<h3 id="toc_1">Include directories</h3>

<p>Include directories are specified in <code>cakeconfig.h</code> file.</p>

<p>On Windows, to manually discover which directories are included, you can run at 
Visual Studio command prompt the command:</p>

<pre><code>echo %INCLUDE%
</code></pre>

<p>To find out what are the directories used by GCC type:</p>

<pre><code>echo | gcc -E -Wp,-v -
</code></pre>

<p>Sample of <code>cakeconfig.h</code></p>

<pre><code class="language-c">
#ifdef __linux__
/*
   To find the include directories used my GCC type:   
   echo | gcc -E -Wp,-v -
*/
#pragma dir &quot;/usr/lib/gcc/x86_64-linux-gnu/11/include&quot;
#pragma dir &quot;/usr/local/include&quot;
#pragma dir &quot;/usr/include/x86_64-linux-gnu&quot;
#pragma dir &quot;/usr/include&quot;

#endif

#ifdef _WIN32
/*
   To find the include directories used my  MSVC,
   open Visual Studio Developer Commmand prompt and type:
   echo %INCLUDE%.
   Running Cake inside mscv command prompt uses %INCLUDE% automatically.
*/
#pragma dir &quot;C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.38.33130/include&quot;
#pragma dir &quot;C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.38.33130/ATLMFC/include&quot;
#pragma dir &quot;C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Auxiliary/VS/include&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/ucrt&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/um&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/shared&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/winrt&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/cppwinrt&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/NETFXSDK/4.8/include/um&quot;

#endif

</code></pre>

<p>The command line <code>cake -autoconfig</code> generates the cake config file.</p>

<p>We can have a <code>cakeconfig.h</code> per project and call a more generic <code>cakeconfig.h</code> for system includes.</p>

<p>Sample: </p>

<p><code>yourproject\cakeconfig.h</code></p>

<pre><code class="language-c">
//system includes...etc
#include &quot;C:\Program Files (x86)\cake\cakeconfig.h&quot;

//project extra includes
#pragma dir &quot;.\openssl\include&quot;

</code></pre>

<h3 id="toc_2">Command line</h3>

<pre><code>cake [options] source1.c source2.c ...

SAMPLES

    cake source.c
    Compiles source.c and outputs /[default-target]/source.c

    cake -target=X86_msvc source.c
    Compiles source.c and outputs C11 code at /X86_msvc/source.c

    cake file.c -o file.cc &amp;&amp; cl file.cc
    Compiles file.c and outputs file.cc then use cl to compile file.cc

  
</code></pre>

<h3 id="toc_3">Options</h3>

<ul>
<li><p><code>-I</code>  (same as GCC and MSVC)
Adds a directory to the list of directories searched for include files</p></li>
<li><p><code>-no-output</code>
Cake will not generate output</p></li>
<li><p><code>-D</code> (same as GCC and MSVC)
Defines a preprocessing symbol for a source file</p></li>
<li><p><code>-E</code> (same as GCC and MSVC)
Copies preprocessor output to standard output</p></li>
<li><p><code>-o name.c</code> (same as GCC and MSVC)
Defines the output name, when we compile a single file</p></li>
<li><p><code>-dump-tokens</code>
Output tokens before preprocessor</p></li>
<li><p><code>-Wnumber -Wno-number</code>
Enables or disable warnings.
See <a href="warnings.html">warnings</a></p></li>
<li><p><code>-disable-assert</code>
Disable cake extension where assert is an statement.</p></li>
<li><p><code>-H</code> (same as gcc, /showIncludes in MSVC)
Causes the compiler to output a list of the include files. </p></li>
<li><p><code>*-preprocess-def-macro</code>
preprocess def macros after expansion</p></li>
<li><p><code>-Wall</code>
Enables all warnings</p></li>
<li><p><code>-sarif</code>
Generates sarif files.
Sarif Visual Studio plugin <a href="https://marketplace.visualstudio.com/items?itemName=WDGIS.MicrosoftSarifViewer">https://marketplace.visualstudio.com/items?itemName=WDGIS.MicrosoftSarifViewer</a></p></li>
<li><p><code>-sarif-path</code>
Specifies the Sarif output dir. &quot;Visual Studio -&gt; External Tools&quot; 
<code>-Wstyle  -msvc-output  -no-output -sarif -sarif-path &quot;$(SolutionDir).sarif&quot; $(ItemPath)</code></p></li>
<li><p><code>-target</code>
Defines how the source code is interpreted (integers sizes, align etc) and specifies the
C89 output that is compatible with the target compiler.
Options: x86_x64_gcc, x64_msvc, x64_msvc, catalina, ccu8</p></li>
<li><p><code>-msvc-output</code> Output is compatible with Visual Studio IDE. </p></li>
<li><p><code>-fdiagnostics-color=never</code> (same as GCC) Output will not use colors</p></li>
<li><p><code>-fanalyzer</code> runs cake flow analysis</p></li>
<li><p><code>-auto-config</code> Generates cakeconfig.h header (see includes)</p></li>
<li><p><code>-style=name</code> Set the style used in (w011) style warnings. Options are <code>-style=cake</code>, <code>-style=gnu</code>, <code>-style=microsoft</code></p></li>
<li><p><code>-comment-to-attr</code> Converts at preprocessor phase, comment like this <code>/*w12*/</code> to attributes <code>[[cake::w12]]</code></p></li>
<li><p><code>-const-literal</code> Makes the compiler handle string literals as const char[] rather than char[].</p></li>
</ul>

<h3 id="toc_4">Output</h3>

<p>The current backend generates C89-compatible code, which can be pipelined with existing 
compilers to produce executables. </p>

<p>The output is a simplified version of C89.
It does not include the following features:</p>

<ul>
<li>preprocessor</li>
<li>typedefs</li>
<li>enums</li>
<li>const</li>
<li>auto</li>
<li>Structs/unions declared inside other structs/unions</li>
<li>constant expressions are pre-computed</li>
<li>no sizeof</li>
<li>static variables are non-local.</li>
<li>arrays size [] = {...} are pre-calculated</li>
<li>no switch </li>
</ul>

<p>The goal is for this simplified version to function as an intermediate language (IL).</p>

<p>One directory called <strong>out</strong> is created keeping the same directory structure of the input files.</p>

<p>For instance:</p>

<pre><code class="language-c">cake c:\project\file1.c
</code></pre>

<p>output:</p>

<pre><code>  c:\project
  ├── file1.c
  ├── target
      ├── file1.c
</code></pre>

<p>More files..</p>

<pre><code>cake c:\project\file1.c c:\project\other\file2.c
</code></pre>

<p>output</p>

<pre><code>  c:\project
  ├── file1.c
  ├── other
  │   ├── file2.c
  ├── target
      ├── file1.c
      ├── other
          ├── file2.c
</code></pre>

<h2 id="toc_5">C89</h2>

<p><a href="https://nvlpubs.nist.gov/nistpubs/Legacy/FIPS/fipspub160.pdf">https://nvlpubs.nist.gov/nistpubs/Legacy/FIPS/fipspub160.pdf</a></p>

<h2 id="toc_6">C99</h2>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n325.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n325.pdf</a>
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf</a></p>

<pre><code class="language-c"> #define __STDC_VERSION__ 199901L  //C99
</code></pre>

<h3 id="toc_7">C99 restrict pointers</h3>

<pre><code class="language-c">void f(const char* restrict s);
int main(){
    f(&quot;&quot;);
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>Currently restrict is being removed on the generated code.</p>

<h3 id="toc_8">C99 Variable-length array (VLA)</h3>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int n = 2;
    int m = 3;
    int (*p)[n][m] = malloc(sizeof * p);

    printf(&quot;%zu\n&quot;, sizeof(*p));

    free(p);
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n683.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n683.htm</a></p>

<p>Not implemented yet.</p>

<h3 id="toc_9">C99 Flexible array members</h3>

<pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct X {
    int count;
    double values[]; // flexible array
};

/*
    The size of a structure with a flexible array member is
    determined as if the flexible array member were omitted,
    EXCEPT that it may have more trailing padding than the
    omission would imply
*/

int main() {

    int n = 3;

    printf(&quot;sizeof(struct X) = %d\\n&quot;, (int) sizeof(struct X));
    printf(&quot;allocated = %d\\n&quot;, (int) sizeof(struct X) + n * sizeof(double));

    struct X* p = malloc(sizeof(struct X) + n * sizeof(double));
    if (p == NULL) return 0;

    p-&gt;count = n;
    p-&gt;values[0] = 10.0;
    p-&gt;values[1] = 20.0;
    p-&gt;values[2] = 30.0;

    for (int i = 0; i &lt; p-&gt;count; ++i)
        printf(&quot;%f\\n&quot;, p-&gt;values[i]);

    free(p);

    return 0;
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_10">C99 static and type qualifiers in parameter array declarators</h3>

<pre><code class="language-c">#include &lt;stdlib.h&gt;

void F(int a[static 5]) {
}

int main() 
{    
    F(0);
    F(NULL);
    F(nullptr);

    int a[] = {1, 2, 3};    
    F(a);//error
    
    int b[] = { 1, 2, 3 , 4, 5};
    F(b); 

    int c[] = { 1, 2, 3 , 4, 5, 6};
    F(c);
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>Cake will perform the same checks regardless of the static keyword.</p>

<h3 id="toc_11">C99 Complex and imaginary support</h3>

<p>Not implemented</p>

<h3 id="toc_12">C99 Universal character names (\u and \U)</h3>

<p>Not implemented</p>

<h3 id="toc_13">C99 Hexadecimal floating constants</h3>

<pre><code class="language-c">double d = 0x1p+1;
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>Cake converts hexadecimal floating-point values to decimal 
floating-point representation using strtod followed by snprintf.
This conversion may introduce precision loss.</p>

<pre><code>0x1.234p1 means:

           2       3     4
r1= 1 +   ---  +  --- + ---   = 1.1376953125 
            1        2     3
          16       16     16

                1
1.1376953125 x 2  = 2.275390625 (final number)

</code></pre>

<h3 id="toc_14">C99 Compound literals</h3>

<pre><code class="language-c">struct s {
  int i;
};

int f(void) {
  struct s * p = 0, * q;
  int j = 0;
  again:
    q = p, p = &amp; ((struct s) { j++ });
  if (j &lt; 2) goto again;
  return p == q &amp;&amp; q -&gt; i == 1;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>N716
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n716.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n716.htm</a></p>

<h3 id="toc_15">C99 Designated initializers</h3>

<pre><code class="language-c"> int main()
 {
  int a[6] = {[4] = 29, [2] = 15 };

  struct point { int x, y; };

  struct point p = { .y = 2, .x = 3 };
 }

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>N494
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n494.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n494.pdf</a></p>

<h3 id="toc_16">C99 Line comments</h3>

<pre><code class="language-c">
//line comments

</code></pre>

<h3 id="toc_17">Declarations in for loop initializers</h3>

<pre><code class="language-c">int main()
{
   const int max = 10;
   for (int n = max - 1; n &gt;= 0; n--)
   {
     // body of loop
   }
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_18">C99 inline functions</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n709.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n709.htm</a>  (30 May 1997)
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n741.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n741.htm</a></p>

<pre><code class="language-c">inline int sum(int a, int b)
{
    return a + b;
}
int main(void)
{
    int r = sum(1, 2);
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_19">C99 _Pragma preprocessing operator</h3>

<pre><code class="language-c">
// Use -E option
//6.10.11 Pragma operator

#define LISTING(x) PRAGMA(listing on #x)
#define PRAGMA(x) _Pragma(#x)

LISTING (..listing.dir)


</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_20">C99 __func__ predefined identifier</h3>

<p>N611 13 Sep 96 Mooney, __FUNC__</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
    printf(&quot;%s\n&quot;, __func__);
    printf(&quot;%s\n&quot;, __func__);
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_21">C99 Variadic macros</h3>

<pre><code class="language-c">
#include &lt;stdio.h&gt;

#define debug(...) fprintf(stderr, __VA_ARGS__)

int main()
{
  int x = 1;
  debug(&quot;X = %d\n&quot;, 1);
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>N707
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n707.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n707.htm</a></p>

<h3 id="toc_22">C99 _Bool</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n815.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n815.htm</a>  (1998)</p>

<pre><code class="language-c">int main(void)
{
    _Bool b = 1;
    return 0;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h2 id="toc_23">C11</h2>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf</a>
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2310.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2310.pdf</a></p>

<pre><code class="language-c">#define __STDC_VERSION__ 201112L //C11
</code></pre>

<h3 id="toc_24">C11 _Static_assert</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1330.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1330.pdf</a></p>

<pre><code class="language-c">int main()
{
    _Static_assert(1 == 1, &quot;error&quot;);    
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>_Static_assert became static_assert in C23.</p>

<h3 id="toc_25">C11 Anonymous structures and unions</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1406.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1406.pdf</a></p>

<pre><code class="language-c">struct v {
  union { /* anonymous union*/
     struct { int i, j; }; /* anonymous structure*/
     struct { long k, l; } w;
  };
  int m;
} v1;

int main(){
  v1.i = 2; /* valid*/
  v1.w.k = 5; /* valid*/
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_26">C11 _Noreturn</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1478.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1478.htm</a></p>

<pre><code class="language-c">_Noreturn void f () {
  abort(); // ok
}
</code></pre>

<p><code>_Noreturn</code> became <code>[[noreturn]]</code> in C23.</p>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_27">C11 Thread_local/Atomic</h3>

<p>Thread_local uses __declspec(thread) in MSVC output and __thread with GCC output.</p>

<p>Atomic - not implemented</p>

<h3 id="toc_28">C11 type-generic expressions (_Generic)</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1441.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1441.htm</a></p>

<pre><code class="language-c">#include &lt;math.h&gt;

#define cbrt(X) _Generic((X),    \
                  double: cbrtl, \
                  float: cbrtf , \
                  default: cbrtl \
              )(X)


int main(void)
{
    cbrt(1.0);
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_29">C11 u&#39; &#39; U&#39; &#39; character constants</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1326.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1326.pdf</a></p>

<pre><code class="language-c"> int i = U&#39;ç&#39;;
 int i2 = u&#39;ç&#39;;
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>Important: Cake assume source is utf8 encoded.</p>

<h3 id="toc_30">C11 u8&quot;literals&quot;</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1488.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1488.htm</a></p>

<pre><code class="language-c">char * s1 = u8&quot;maçã&quot;;
char * s2 = u8&quot;maca&quot;;
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>Important: Cake assume source is utf8 encoded.</p>

<h3 id="toc_31">C11 _Alignof or C23 alignof</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1397.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1397.htm</a></p>

<pre><code class="language-c"> int main()
 {
   int align = alignof(int);
 }
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p><code>_Alignof</code> became <code>alignof</code> in C23.</p>

<h3 id="toc_32">C11 _Alignas or C23 alignas</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1335.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1335.pdf</a></p>

<p>Uses <code>__declspec(align(n))</code> in MSVC output and <code>__attribute__((aligned(n)))</code> in GCC output.</p>

<h2 id="toc_33">C23</h2>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3096.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n3096.pdf</a></p>

<pre><code class="language-c">#define __STDC_VERSION__ 201710L  //C17
#define __STDC_VERSION__ 202311L  //C23
</code></pre>

<h3 id="toc_34">C23 _Decimal32, _Decimal64, and _Decimal128</h3>

<p>Not implemented.
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1107.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1107.htm</a></p>

<h3 id="toc_35">C23 static_assert / single-argument static_assert</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1330.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1330.pdf</a></p>

<pre><code class="language-c">int main(void)
{
    static_assert(1 == 2);
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_36">C23 u8 character prefix</h3>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2418.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2418.pdf</a></p>

<pre><code class="language-c">int main(){
    unsigned char c = u8&#39;~&#39;;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_37">C23 No function declarators without prototypes</h3>

<p><a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2841.htm">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2841.htm</a></p>

<pre><code class="language-c">int main(){
    func(); //this is an error in C23
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>See also Remove support for function definitions with identifier lists  </p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2432.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2432.pdf</a></p>

<h3 id="toc_38">C23 Improved Tag Compatibility</h3>

<p>Not implemented yet.</p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3037.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3037.pdf</a></p>

<pre><code class="language-c">struct foo { int a; } p;
void bar(void)
{
  struct foo { int a; } q;
  q = p;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_39">C23 Unnamed parameters in function definitions</h3>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2480.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2480.pdf</a></p>

<pre><code class="language-c">int f(int );

int f(int ) {
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>Missing a dummy name when generating c89.</p>

<h3 id="toc_40">C23 Digit separators</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2626.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2626.pdf</a></p>

<pre><code class="language-c">int main()
{
    int a = 1000&#39;00;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_41">C23 Binary literals</h3>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">#define X  0b1010

int main()
{
    int a = X;
    int b = 0B1010;
}

</code></pre>

<h3 id="toc_42">C23 Introduce the nullptr constant</h3>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3042.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n3042.htm</a></p>

<pre><code class="language-c">
int main()
{
  void * p = nullptr;
  auto p2 = nullptr;
  typeof(nullptr) p3 = nullptr;
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_43">C23 Make false and true first-class language features</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2935.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2935.pdf</a></p>

<pre><code class="language-c">
#if true
#warning yes..
#endif

int main()
{
    bool b = true;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_44">C23 {} empty initializer</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2900.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2900.htm</a>
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3011.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3011.htm</a></p>

<pre><code class="language-c">
int main()
{
    struct X {
        int i;
    } x = {};

    x = (struct X) {};

    struct Y
    {
        struct X x;
    } y = { {} };
}  

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_45">C23 auto</h3>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3007.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n3007.htm</a></p>

<pre><code class="language-c">static auto a = 3.5;
auto p = &amp;a;

double A[3] = { 0 };
auto pA = A;
auto qA = &amp;A;
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_46">C23 typeof / typeof_unqual</h3>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2927.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n2927.htm</a>
<a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2930.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2930.pdf</a></p>

<pre><code class="language-c">
#define SWAP(a, b) \
  do {\
    typeof(a) temp = a; a = b; b = temp; \
  } while (0)


int main()
{
    /*simple case*/
    int a = 1;
    typeof(a) b = 1;

    /*pay attention to the pointer*/
    typeof(int*) p1, p2;

    /*let&#39;s expand this macro and see inside*/
    SWAP(a, b);

    /*for anonymous structs we insert a tag*/
    struct { int i; } x;
    typeof(x) x2;
    typeof(x) x3;

   /*Things get a little more complicated*/
   int *array[2];
   typeof(array) a1, a2;
   
   typeof(array) a3[3];
   typeof(array) *a4[4];

   /*abstract declarator*/
   int k = sizeof(typeof(array));

   /*new way to declare pointer to functions?*/
   typeof(void (int)) * pf = nullptr;
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_47">C23 Improved Normal Enumerations</h3>

<p>//TODO</p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3029.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n3029.htm</a></p>

<pre><code class="language-c">enum a {
    a0 = 0xFFFFFFFFFFFFFFFFULL
};

static_assert(_Generic(a0,
        unsigned long long: 0,
        int: 1,
        default: 2 == 0));
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>The type of the enum must be adjusted.</p>

<h3 id="toc_48">C23 constexpr</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3018.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3018.htm</a></p>

<pre><code class="language-c">
#include &lt;stdio.h&gt;

constexpr int c = 123;

constexpr int c2 = c + 1000;

int a[c];

constexpr double PI = 3.14;


static_assert(PI + 1 == 3.14 + 1.0);

struct Y {
    int a;
    int ar[3];
    int b;
};

void T3()
{
    constexpr struct Y y = { .ar[1] = 2, 3, 4 };
    static_assert(y.a == 0);
    static_assert(y.ar[0] == 0);
    static_assert(y.ar[1] == 2);
    static_assert(y.ar[2] == 3);
    static_assert(y.b == 4);
    static_assert(y.ar[1] + y.ar[2] == 5);
}

static_assert(&quot;abc&quot;[0] == &#39;a&#39;);


int main()
{
    constexpr char ch = &#39;a&#39;;

    printf(&quot;%f %c&quot;, PI, ch);
}


</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_49">C23 Enhancements to Enumerations</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3030.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3030.htm</a></p>

<pre><code class="language-c">enum X : short {
  A
};

int main() {
   enum X x = A;   
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_50">C23 [[Attributes]]</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2335.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2335.pdf</a>
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2554.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2554.pdf</a></p>

<h3 id="toc_51">C23 [[fallthrough]] attribute</h3>

<p>TODO</p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2408.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2408.pdf</a></p>

<pre><code class="language-c">void g(){}
void h(){}
void i(){}
 
void f(int n) {
    void g(void), h(void), i(void);
    switch (n) {
        case 1: /* diagnostic on fallthrough discouraged */
        case 2:
            g();
            [[fallthrough]];
        case 3: /* diagnostic on fallthrough discouraged */
            h();
        case 4: /* fallthrough diagnostic encouraged */
            i();
            //[[fallthrough]]; /* constraint violation */            
    }
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_52">C23 [[deprecated]] attribute</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2334.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2334.pdf</a></p>

<pre><code class="language-c">// Compil with -w03
[[deprecated]] void f2() {}
struct [[deprecated]] S {  int a;};
enum [[deprecated]] E1 { one };

int main(void) {
    struct S s;
    enum E1 e;
    f2();
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_53">C23 [[maybe_unused]] attribute</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2270.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2270.pdf</a></p>

<pre><code class="language-c">//
// Compile with -w02 -w06
//
void f( [[maybe_unused]] int arg1, int arg2) //warning C0006: &#39;arg2&#39;: unreferenced formal parameter
{
    [[maybe_unused]] int local1;
    int local2; //warning C0002: &#39;local2&#39;: unreferenced declarator
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_54">C23 [[nodiscard]] attribute</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2267.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2267.pdf</a></p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2448.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2448.pdf</a></p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;

struct [[nodiscard]] error_info { int error; };

struct error_info enable_missile_safety_mode(void);

void launch_missiles(void);

void test_missiles(void) {
    enable_missile_safety_mode();
    launch_missiles();
}

[[nodiscard(&quot;must check armed state&quot;)]]
bool arm_detonator(int within);

void detonate();

void call(void) {
  arm_detonator(3);
  detonate();
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>Cake implementation is missing the message.</p>

<h3 id="toc_55">C23 [[unsequenced]] and [[reproducible]]</h3>

<p>TODO</p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2956.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n2956.htm</a></p>

<pre><code class="language-c">typedef double f_t [[reproducible]] (double);    // invalid, applies to identifier f_t
typedef double g_t(double) [[reproducible]];     // valid, applies to type
extern g_t f [[unsequenced]];                    // invalid, applies to identifier f
extern typeof(double(double)) [[unsequenced]] g; // valid, applies to type specifier
extern g_t [[unsequenced]] g;                    // valid, applies to type specifier
</code></pre>

<h3 id="toc_56">C23 __has_attribute</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2799.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2799.pdf</a></p>

<pre><code class="language-c">
#if __has_c_attribute(fallthrough)
#warning YES
#else
#warning NO
#endif
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_57">C23 __has_include</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2799.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2799.pdf</a></p>

<pre><code class="language-c">
#if __has_include(&lt;stdio.h&gt;)
#warning  YES
#endif

#if __has_include(&lt;any.h&gt;)
#warning  YES
#else
#warning  NO
#endif

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_58">C23 #warning</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2686.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2686.pdf</a></p>

<pre><code class="language-c">int main()
{
  #warning my warning message  
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_59">C23 #embed</h3>

<p>Partially implemented.</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
  static const char file_txt[] = {
   #embed &quot;stdio.h&quot;
   ,0
  };

  printf(&quot;%s\n&quot;, file_txt);
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_60">C23 #elifdef #elifndef</h3>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">#define Y

#ifdef X
#define VERSION 1
#elifdef  Y
#define VERSION 2
#else
#define VERSION 3
#endif
</code></pre>

<h3 id="toc_61">C23 __VA_OPT__</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3033.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3033.htm</a></p>

<pre><code class="language-c">
#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)
#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)
#define SDEF(sname, ...) S sname __VA_OPT__(= { __VA_ARGS__ })
#define EMP


void f(int i, ...) {}


int main()
{
  int a = 1;
  int b = 2;
  int c = 3;
  
  F(a, b, c);
  F();
  F(EMP);
  G(a, b, c);
  G(a, );
  G(a);

}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_62">C23 BitInt(N))</h3>

<p>TODO 
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2763.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2763.pdf</a></p>

<pre><code class="language-c">int main()
{
    _BitInt(2) a2 = 1;
    _BitInt(3) a3 = 2;
    _BitInt(33) a33 = 1;
    char c = 3;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_63">C23 Compound Literals with storage specifier</h3>

<p>TODO</p>

<pre><code class="language-c">void F(int *p){}

int main()
{
   F((static int []){1, 2, 3, 0})
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3038.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3038.htm</a></p>

<h3 id="toc_64">C23 Variably-modified (VM) types</h3>

<p>TODO</p>

<p>Variably modified types part of C23. 
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2778.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2778.pdf</a></p>

<p>Only variable length arrays with automatic storage duration that are optional.</p>

<h2 id="toc_65">C2Y</h2>

<h3 id="toc_66">C2Y Obsolete implicitly octal literals</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3353.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3353.htm</a></p>

<pre><code class="language-c">
static_assert(0o52 == 052);
static_assert(0O52 == 052);
static_assert(0O52 == 42);

int main()
{
    int i = 0o52;
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_67">C2Y case range expressions</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3370.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3370.htm</a></p>

<pre><code class="language-c">  #include &lt;stdio.h&gt;

  void f(int n)
  {
    switch (n)
    {
       case 1 ... 10:
       printf(&quot;n in range 1...10\n&quot;);
       break;
       default:
       break;
    }
  }

  int main(){
    f(1);
    f(11);
  }
 ```

### C2Y #def

https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3524.txt

```c
//Use -E
#def foo(x)
        do {
            bar(x);
            baz(x);
        }
        while (0)
#enddef

foo(1)
foo(2)
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>It may not be part of C2Y, but it is implemented in Cake while 
we wait to see whether we will keep it as an extension or remove it.</p>

<h3 id="toc_68">C2Y _Countof operator</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3369.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3369.pdf</a></p>

<pre><code class="language-c">void f(int n)
{
  int v[123][n];
  static_assert(_Countof(v) == 123);
}

int main()
{
  int a[7][3];
  int n = _Countof(a);
  static_assert(_Countof(a) == 7);

  int n2 = _Countof(int [7][3]);
  static_assert(_Countof(int [2][3]) == 2);
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>Obs: Cake extends countof to enums, returning the number
of enumerators. (this is not part of C2Y)
It can be a new keyword in cake.</p>

<pre><code class="language-c">#include &lt;string.h&gt;
enum E { A, B, C, D, E, F };

void f(enum E e)
{
    switch (e)
    {
        case A:
            break;
        case B:
            break;
        default:
            static_assert(_Countof(e) == 6);
    }
}

enum E parse_enum_e(const char* s)
{
    if (strcmp(s, &quot;A&quot;) == 0) return A;
    if (strcmp(s, &quot;B&quot;) == 0) return B;
    if (strcmp(s, &quot;C&quot;) == 0) return C;
    if (strcmp(s, &quot;D&quot;) == 0) return D;
    if (strcmp(s, &quot;E&quot;) == 0) return E;
    if (strcmp(s, &quot;F&quot;) == 0) return F;
    static_assert(_Countof(enum E) == 6);

    return A;
}

int main() { }
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_69">C2Y defer</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3734.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3734.pdf</a></p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3733.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3733.htm</a></p>

<pre><code class="language-c">// 12 EXAMPLE 1 Defer statements cannot be jumped over.
#include &lt;stdio.h&gt;

int main() 
{    
    goto target;  // constraint violation
 
    _Defer { fputs(&quot; meow&quot;, stdout); }
    
    target:

    fputs(&quot;cat says&quot;, stdout);
    return 1;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">
/*g*/

#include &lt;stdio.h&gt;

int main()
{
    // print &quot;cat says&quot; to standard output
    return fputs(&quot;cat says&quot;, stdout);

    _Defer { fputs(&quot; meow&quot;, stdout); }  // okay: no constraint violation,

    // not executed
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*h*/

#include &lt;stdio.h&gt;
int main()
{    
    goto target;
    {
        // okay: no constraint violation
        _Defer { fputs(&quot; meow&quot;, stdout); }
    }

    target:

    fputs(&quot;cat says&quot;, stdout);
    return 1;  // prints &quot;cat says&quot; to standard output
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">
/*i*/

#include &lt;stdio.h&gt;
int main()
{    
    {
        _Defer { fputs(&quot;cat says&quot;, stdout); }

        // okay: no constraint violation
        goto target;
    }

target:

    fputs(&quot; meow&quot;, stdout);
    return 1;  // prints &quot;cat says meow&quot; to standard output
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*j*/

#include &lt;stdio.h&gt;
int main()
{    
    _Defer {
        goto target;  // constraint violation
        fputs(&quot; meow&quot;, stdout);
    }

target:

    fputs(&quot;cat says&quot;, stdout);
    return 1;

}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">
/*k*/

#include &lt;stdio.h&gt;
int main()
{    
    _Defer {
        return 5;  // constraint violation
        fputs(&quot; meow&quot;, stdout);
    }

    fputs(&quot;cat says&quot;, stdout);
    return 1;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*l*/
#include &lt;stdio.h&gt;
int main()
{    
    _Defer 
    {
        target:
        fputs(&quot; meow&quot;, stdout);
    }
    goto target;  // constraint violation

    fputs(&quot;cat says&quot;, stdout);
    return 1;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*m*/

#include &lt;stdio.h&gt;
int main()
{   
    goto target;  // okay: no constraint violation

    {
        target:
        _Defer { fputs(&quot;cat says&quot;, stdout); }
    }

    fputs(&quot; meow&quot;, stdout);

    return 1;  // prints &quot;cat says meow&quot; to standard output
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*n*/

#include &lt;stdio.h&gt;
int main()
{    
    goto target;  // constraint violation!!

    {
       _Defer {fputs(&quot; meow&quot;, stdout); }
       target:
    }

    fputs(&quot;cat says&quot;, stdout);
    return 1;

}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*o*/

#include &lt;stdio.h&gt;
int main()
{   
    {
        _Defer fputs(&quot;cat says&quot;, stdout);
        goto target;
    }

target:;

    fputs(&quot; meow&quot;, stdout);
    return 1;  // prints &quot;cat says meow&quot;

}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*p*/
#include &lt;stdio.h&gt;
int main()
{    
    {
        goto target;
        _Defer fputs(&quot; meow&quot;, stdout);
    }

target:;

    fputs(&quot;cat says&quot;, stdout);
    return 1;  // prints &quot;cat says&quot; 
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*q*/

#include &lt;stdio.h&gt;
int main()
{    
    {
        _Defer { fputs(&quot; meow&quot;, stdout); }
        target:
    }

    goto target;  // constraint violation !!

    fputs(&quot;cat says&quot;, stdout);
    return 1;

}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*r*/

#include &lt;stdio.h&gt;
int main()
{   
    {
        target:
        _Defer { fputs(&quot;cat says&quot;, stdout); }
    }

    goto target;  // ok

    fputs(&quot; meow\n&quot;, stdout);

    return 1;  // prints &quot;cat says&quot; repeatedly
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*s*/
#include &lt;stdio.h&gt;
int main()
{    
   {
       target:
        _Defer { fputs(&quot;cat says&quot;, stdout); }
       goto target;  // ok
   }
   
   // never reached
   
   fputs(&quot; meow&quot;, stdout);
   
   return 1;  // prints &quot;cat says&quot; repeatedly
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*t*/

#include &lt;stdio.h&gt;
int main()
{   
    int count = 0;
    {
        target:

        _Defer { fputs(&quot;cat says &quot;, stdout); }

        ++count;
        if (count &lt;= 2) {
            goto target;  // ok
        }
    }

    fputs(&quot;meow&quot;, stdout);

    return 1;  // prints &quot;cat says cat says cat says meow&quot;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*u*/
#include &lt;stdio.h&gt;
int main()
{   
    int count = 0;
    
    {
        _Defer { fputs(&quot;cat says&quot;, stdout); }

        target:
        
        if (count &lt; 5) {
            ++count;
            goto target;  // ok
        }
    }

    fputs(&quot; meow&quot;, stdout);
    return 1;  // prints &quot;cat says meow&quot;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*v*/
#include &lt;stdio.h&gt;
int main()
{   
    int count = 0;
 
    target:

    if (count &gt;= 2) {
        fputs(&quot;meow&quot;, stdout);
        return 1;  // prints &quot;cat says cat says meow &quot;
    }

    _Defer { fputs(&quot;cat says &quot;, stdout); }

    count++;
    goto target;

    return 0;  // never reached
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

/*
   13 EXAMPLE 2 All the expressions and statements of an 
   enclosing block are  evaluated before executing defer 
   statements, including any conversions. After all defer 
   statements are executed, the block is then exited.
*/

int main()
{   
    int r = 4;
    int* p = &amp;r;
    _Defer { *p = 5; }
    return *p;  // return 4;

}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">
#include &lt;stddef.h&gt;
#include &lt;stdlib.h&gt;

int use_buffer(size_t n, void* buf) 
{
    /* ... */
    return 0;
}

int main()
{
    const int size = 20;
    void* buf = malloc(size);
    _Defer { free(buf); }
    // buffer is not freed until AFTER use_buffer returns
    return use_buffer(size, buf);
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">
/*
  14 EXAMPLE 3 It is not defined if defer statements execute 
  their deferred blocks if the exiting / non- returning 
  functions detailed previously are called.
*/

#include &lt;stdlib.h&gt;

int f() 
{
    void* p = malloc(1);

    if (p == NULL) {
        return 0;
    }

    _Defer free(p);

    exit(1);  // &quot;p&quot; may be leaked
    return 1;
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">

/*
 15 EXAMPLE 4 Defer statements, when execution reaches them, 
 are tied to the scope of the defer statement within their 
 enclosing block, even if it is a secondary block without 
 braces.
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() 
{
    {
        _Defer { fputs(&quot; meow&quot;, stdout); }
        if (true) _Defer fputs(&quot;cat&quot;, stdout);
        fputs(&quot; says&quot;, stdout);
    }
    // &quot;cat says meow&quot; is printed to standard output
    exit(0);
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">/*
  16 This applies to any enclosing block, even for loops 
  without braces around its body.
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main() {
    const char* arr[] = {&quot;cat&quot;, &quot;kitty&quot;, &quot;ferocious little baby&quot;};
    _Defer { fputs(&quot; meow&quot;, stdout); }
    for (unsigned int i = 0; i &lt; 3; ++i) _Defer printf(&quot;my %s,\n&quot;, arr[i]);
    fputs(&quot;says&quot;, stdout);
    // &quot;my cat,
    // my kitty,
    // my ferocious little baby,
    // says meow&quot;
    // is printed to standard output
    return 0;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">
/*
 17 EXAMPLE 5 Defer statements execute their deferred blocks 
 in reverse order of the appearance of the defer statements, 
 and nested defer statements execute their deferred blocks 
 in reverse order but at the end of the deferred block they 
 were invoked within. The following program:
*/

int main() {
    int r = 0;
    {
        _Defer {
            _Defer r *= 4;
            r *= 2;
            _Defer { r += 3; }
        }
        _Defer r += 1;
    }
    return r;  // return 20;
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">
/*
   18 EXAMPLE 6 Defer statements can be executed within a 
   switch, but a switch cannot be used to jump into the scope 
   of a defer statement.
*/

#include &lt;stdlib.h&gt;
int main() 
{
    void* p = malloc(1);

    switch (1) {
        _Defer free(p);  // constraint violation
        default:
            _Defer free(p);
            break;
    }
    return 0;
}


</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">
/*
  19 EXAMPLE 7 Defer statements can not be exited by means 
  of break or continue
*/

int main() {
    switch (1) {
        default:
            _Defer {
                break;  // constraint violation
            }
    }
    for (;;) {
        _Defer {
            break;  // constraint violation
        }
    }
    for (;;) {
        _Defer {
            continue;  // constraint violation
        }
    }
    return 0;
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">
/*
 20 EXAMPLE 8 Defer statements that are not reached are 
 not executed.
*/
 
#include &lt;stdlib.h&gt;
int main() {
    void* p = malloc(1);
    return 0;
    _Defer free(p);  // not executed, p is leaked
}


</code></pre>

<p><button onclick="Try(this)">try</button></p>

<pre><code class="language-c">
/*
  21 EXAMPLE 9 Defer statements can contain other 
  compound statements.
*/

typedef struct meow* handle;
extern int purr(handle* h);
extern void un_purr(handle h);

int main()
{
    handle h;
    int err = purr(&amp;h);
    _Defer if (!err) un_purr(h);
    return 0;
}


</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_70">C2Y if declarations, v4</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3388.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3388.htm</a></p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
   int size = 10;
   if (FILE* f = fopen(&quot;file.txt&quot;, &quot;r&quot;); f)
   {
     /*...*/
     fclose(f);
   }

   if (FILE* f = fopen(&quot;file.txt&quot;, &quot;r&quot;))
   {
     /*...*/
     fclose(f);
   }
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_71">C2Y typename on _Generic</h3>

<p>This feature was created in Cake and now it is part of C2Y!</p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3260.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3260.pdf</a></p>

<pre><code class="language-c"> int main()
{
    const int * const p;
    static_assert(_Generic(p, const int *: 1));

    /*extension*/
    static_assert(_Generic(int, int : 1));
    static_assert(_Generic(typeof(p), const int * const: 1));
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_72">C2Y __COUNTER__</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3457.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3457.htm</a></p>

<pre><code class="language-c">
/*
 Compile with -E
*/

#define X(Z) Z Z
X(__COUNTER__) // 0 0
X(__COUNTER__) // 1 1

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_73">C2Y Local functions</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3678.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3678.pdf</a></p>

<pre><code class="language-c">int main()
{
   static int dup(int a) { return a * 2; }
   return dup(1);
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_74">C2Y Function Literals</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3679.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3679.pdf</a></p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
  printf(&quot;%d&quot;, (int (void)){
    return 1;
  }());
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_75">C2Y Statement expressions</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3643.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3643.htm</a></p>

<pre><code class="language-c">
#include &lt;stdio.h&gt; 

#define maxint(a,b) \
  ({int _a = (a), _b = (b); _a &gt; _b ? _a : _b; })

int main()
{
  printf(&quot;%d&quot;, maxint(1, 2));
}

</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h2 id="toc_76">Cake Extensions</h2>

<h3 id="toc_77">Pre-defined macros in Cake</h3>

<pre><code class="language-c"> #define __CAKE__           202311L
 #define __STDC_VERSION__   202311L
 
</code></pre>

<h3 id="toc_78">assert built-in</h3>

<p>In cake assert is an built-in function.
The reason is because it works as tips for flow analysis.</p>

<p>For instance, in a linked list when <code>head</code> is null <code>tail</code> is also null,
and <code>tail-&gt;next</code> always points to null.</p>

<p>Assertion will check these properties in runtime and also make 
the static analysis assume that assert evaluates to true.</p>

<pre><code class="language-c">
void list_push_back(struct list* list,
                    struct item* _Owner p_item)
{
   if (list-&gt;head == NULL) {
      list-&gt;head = p_item;
   }
   else {
      assert(list-&gt;tail != nullptr);
      assert(list-&gt;tail-&gt;next == nullptr);
      list-&gt;tail-&gt;next = p_item;
   }
   list-&gt;tail = p_item;
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<p>However, <code>assert</code> is not a &quot;blind override command.&quot; In situations like:</p>

<pre><code class="language-c">    int i = 0;
    assert(i != 0);
</code></pre>

<p>In situations where static analysis can identify two or more possible states, 
assert works as a state selector, similar to what happens in if statements but without the scope.</p>

<pre><code class="language-c">    void f(int * _Opt p)
    {
        if (p != NULL) {
           //p is not null here...
        }
    }
    
    void f2(int * _Opt p)
    {
        assert(p != NULL);
        //we assume p is not null here...        
    }
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_79">try { throw; } catch {}</h3>

<pre><code>   try-statement:
      try secondary-block
      try secondary-block catch secondary-block   
</code></pre>

<pre><code>jump-statement:
  throw;
</code></pre>

<p>try catch is a external block that we can jump off.</p>

<p>try catch is a <strong>LOCAL jump</strong> this is on purpose not a limitation.</p>

<p>catch block is optional.</p>

<pre><code class="language-c">extern int error;

int main()
{
    try
    {
        for (int i = 0 ; i &lt; 10; i++) 
        {
            for (int j = 0 ; j &lt; 10; j++) 
            {
                /*...*/
                if (error) throw;
                /*...*/
            }
        }
    }
    catch
    {
    }
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_80">#pragma dir</h3>

<pre><code class="language-c">#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10//include/10.0.22000.0/cppwinrt&quot;
</code></pre>

<p>Add the path to the list of directory paths used to seach include files.</p>

<h3 id="toc_81">offsetof</h3>

<p>In cake offset (<a href="https://en.cppreference.com/w/cpp/types/offsetof.html">https://en.cppreference.com/w/cpp/types/offsetof.html</a>) is an operator</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
 
struct S
{
    char   m0;
    double m1;
    short  m2;
    char   m3;
};
 
int main()
{
    printf(&quot;offset of char   m0 = %zu&quot;, offsetof(struct S, m0));
    printf(&quot;offset of char   m0 = %zu&quot;, offsetof(struct S, m1));
    printf(&quot;offset of char   m0 = %zu&quot;, offsetof(struct S, m2));
    printf(&quot;offset of char   m0 = %zu&quot;, offsetof(struct S, m3));
}
</code></pre>

<p><button onclick="Try(this)">try</button></p>

<h3 id="toc_82">Type traits</h3>

<p>We have some compile time functions to infer properties of types.</p>

<pre><code class="language-c">
_is_char()
The three types char, signed char, and unsigned char are collectively called the character types.

_is_pointer
Pointer to object or function

_is_array
Array type

_is_function
A function type describes a function with specified return type. 

_is_floating_point
float, double, and long double return true

_is_integral
The standard signed integer types and standard unsigned integer types are collectively called the
standard integer types;

_is_arithmetic
Integer and floating types are collectively called arithmetic types. 

_is_scalar
Arithmetic types, pointer types, and the nullptr_t type are collectively called scalar types

</code></pre>

<p>Note: Type traits that can be easily created with _Generic will be removed.
_</p>

<h3 id="toc_83">Extension - Object lifetime checks</h3>

<p>See <a href="ownership.html">ownership</a></p>

<pre><code>_Owner
_Opt
_View
</code></pre>

<h2 id="toc_84">GCC extensions</h2>

<ul>
<li>__builtin_va_list</li>
<li>__builtin_c23_va_start</li>
<li>__builtin_va_start</li>
<li>__builtin_va_end</li>
<li>__builtin_va_arg</li>
<li>__builtin_va_copy</li>
<li>__builtin_offsetof (same as cake offsetof)</li>
<li>__attribute__</li>
<li>__typeof__ alias same as typeof</li>
</ul>

<p>Other builtins are declared at <code>\src\include\x86_x64_gcc_builtins.h</code></p>

<p>Pre-defined macros for GCC compatibility
<a href="https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html">https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html</a></p>

<p>See <code>\src\include\x86_x64_gcc_builtins.h</code></p>

<h2 id="toc_85">MSVC extensions</h2>

<ul>
<li>__ptr32, __ptr64</li>
<li>__int8 ... __int64</li>
<li>__declspec</li>
<li>__cdecl</li>
<li>__fastcall, __stdcall</li>
<li>__forceinline alias for inline in cake</li>
<li>__pragma</li>
<li>__unaligned </li>
</ul>

<p>Pre-defined macros for MSVC compatibility
<a href="https://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170#standard-predefined-macros">https://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170#standard-predefined-macros</a></p>

<p>See <code>\src\include\x86_msvc_macros.h</code> and <code>\src\include\x64_msvc_macros.h</code></p>
</article></body></html>
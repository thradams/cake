<!DOCTYPE html>
<html>
<head>
  
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <link rel="stylesheet" href="style.css" />
    <title>Cake C Compiler</title>
    <meta name="description" content="Cake C Compiler">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <script>
    function Try(elm)
    {
        //collect the text previous sample
        var source = elm.parentElement.previousElementSibling.innerText;

        var link = "./playground.html?code=" + encodeURIComponent(btoa(source)) +
            "&to=" + encodeURI("-2") +
            "&options=" + encodeURI("");

        window.open(link, 'popup','width=800,height=600');
    }
// find-replace for this
// <button onclick="Try(this)">try</button> 
</script></head>
<body>
    <article style="max-width: 40em; margin:auto">
<p><a href="index.html">Home</a> | <a href="manual.html">Manual</a> | <a href="playground.html">Playground</a></p>
<article>
<h1>Cake - C23 and Beyond</h1>
<ul>
<li>
<a href="#toc_0">Using cake</a>
<ul>
<li>
<a href="#toc_1">Include directories</a>
</li>
<li>
<a href="#toc_2">Command line</a>
</li>
<li>
<a href="#toc_3">Options</a>
</li>
<li>
<a href="#toc_4">Output</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">C89</a>
</li>
<li>
<a href="#toc_6">C99</a>
<ul>
<li>
<a href="#toc_7">C99 restrict pointers</a>
</li>
<li>
<a href="#toc_8">C99 Variable-length array (VLA)</a>
</li>
<li>
<a href="#toc_9">C99 Flexible array members</a>
</li>
<li>
<a href="#toc_10">C99 static and type qualifiers in parameter array declarators</a>
</li>
<li>
<a href="#toc_11">C99 Complex and imaginary support</a>
</li>
<li>
<a href="#toc_12">C99 Universal character names (\u and \U)</a>
</li>
<li>
<a href="#toc_13">C99 Hexadecimal floating constants</a>
</li>
<li>
<a href="#toc_14">C99 Compound literals</a>
</li>
<li>
<a href="#toc_15">C99 Designated initializers</a>
</li>
<li>
<a href="#toc_16">C99 Line comments</a>
</li>
<li>
<a href="#toc_17">Declarations in for loop initializers</a>
</li>
<li>
<a href="#toc_18">C99 inline functions</a>
</li>
<li>
<a href="#toc_19">C99 _Pragma preprocessing operator</a>
</li>
<li>
<a href="#toc_20">C99 __func__ predefined identifier</a>
</li>
<li>
<a href="#toc_21">C99 Variadic macros</a>
</li>
<li>
<a href="#toc_22">C99 _Bool</a>
</li>
</ul>
</li>
<li>
<a href="#toc_23">C11</a>
<ul>
<li>
<a href="#toc_24">C11 _Static_assert</a>
</li>
<li>
<a href="#toc_25">C11 Anonymous structures and unions</a>
</li>
<li>
<a href="#toc_26">C11 _Noreturn</a>
</li>
<li>
<a href="#toc_27">C11 Thread_local/Atomic</a>
</li>
<li>
<a href="#toc_28">C11 type-generic expressions (_Generic)</a>
</li>
<li>
<a href="#toc_29">C11 u&#39; &#39; U&#39; &#39; character constants</a>
</li>
<li>
<a href="#toc_30">C11 u8&quot;literals&quot;</a>
</li>
<li>
<a href="#toc_31">C11 _Alignof or C23 alignof</a>
</li>
<li>
<a href="#toc_32">C11 _Alignas or C23 alignas</a>
</li>
</ul>
</li>
<li>
<a href="#toc_33">C23</a>
<ul>
<li>
<a href="#toc_34">C23 _Decimal32, _Decimal64, and _Decimal128</a>
</li>
<li>
<a href="#toc_35">C23 static_assert / single-argument static_assert</a>
</li>
<li>
<a href="#toc_36">C23 u8 character prefix</a>
</li>
<li>
<a href="#toc_37">C23 No function declarators without prototypes</a>
</li>
<li>
<a href="#toc_38">C23 Improved Tag Compatibility</a>
</li>
<li>
<a href="#toc_39">C23 Unnamed parameters in function definitions</a>
</li>
<li>
<a href="#toc_40">C23 Digit separators</a>
</li>
<li>
<a href="#toc_41">C23 Binary literals</a>
</li>
<li>
<a href="#toc_42">C23 Introduce the nullptr constant</a>
</li>
<li>
<a href="#toc_43">C23 Make false and true first-class language features</a>
</li>
<li>
<a href="#toc_44">C23 {} empty initializer</a>
</li>
<li>
<a href="#toc_45">C23 auto</a>
</li>
<li>
<a href="#toc_46">C23 typeof / typeof_unqual</a>
</li>
<li>
<a href="#toc_47">C23 Improved Normal Enumerations</a>
</li>
<li>
<a href="#toc_48">C23 constexpr</a>
</li>
<li>
<a href="#toc_49">C23 Enhancements to Enumerations</a>
</li>
<li>
<a href="#toc_50">C23 Attributes</a>
</li>
<li>
<a href="#toc_51">C23 fallthrough attribute</a>
</li>
<li>
<a href="#toc_52">C23 deprecated attribute</a>
</li>
<li>
<a href="#toc_53">C23 maybe_unused attribute</a>
</li>
<li>
<a href="#toc_54">C23 nodiscard attribute</a>
</li>
<li>
<a href="#toc_55">C23 [[unsequenced]] and [[reproducible]]</a>
</li>
<li>
<a href="#toc_56">C23 __has_attribute</a>
</li>
<li>
<a href="#toc_57">C23 __has_include</a>
</li>
<li>
<a href="#toc_58">C23 #warning</a>
</li>
<li>
<a href="#toc_59">C23 #embed</a>
</li>
<li>
<a href="#toc_60">C23 #elifdef #elifndef</a>
</li>
<li>
<a href="#toc_61">C23 __VA_OPT__</a>
</li>
<li>
<a href="#toc_62">C23 BitInt(N))</a>
</li>
<li>
<a href="#toc_63">C23 Compound Literals with storage specifier</a>
</li>
<li>
<a href="#toc_64">C23 Variably-modified (VM) types</a>
</li>
</ul>
</li>
<li>
<a href="#toc_65">C2Y</a>
<ul>
<li>
<a href="#toc_66">Obsolete implicitly octal literals</a>
</li>
<li>
<a href="#toc_67">case range expressions</a>
</li>
<li>
<a href="#toc_68">#def</a>
</li>
<li>
<a href="#toc_69">_Countof operator</a>
</li>
<li>
<a href="#toc_70">defer</a>
</li>
<li>
<a href="#toc_71">Function literals and local functions</a>
</li>
<li>
<a href="#toc_72">if declarations, v4</a>
</li>
<li>
<a href="#toc_73">C2Y typename on _Generic</a>
</li>
</ul>
</li>
<li>
<a href="#toc_74">Cake Extensions</a>
<ul>
<li>
<a href="#toc_75">Pre-defined macros in Cake</a>
</li>
<li>
<a href="#toc_76">assert built-in</a>
</li>
<li>
<a href="#toc_77">try { throw; } catch {}</a>
</li>
<li>
<a href="#toc_78">#pragma dir</a>
</li>
<li>
<a href="#toc_79">offsetof</a>
</li>
<li>
<a href="#toc_80">Type traits</a>
</li>
<li>
<a href="#toc_81">Extension - Object lifetime checks</a>
</li>
</ul>
</li>
<li>
<a href="#toc_82">GCC extensions</a>
</li>
<li>
<a href="#toc_83">MSVC extensions</a>
</li>
</ul>
<h2 id="toc_0">Using cake</h2>

<p>Cake works as an extension for MSVC on Windows and as an extension for GCC on Linux.
This approach makes Cake useful in real and existing programs. </p>

<p>When applicable, Cake uses the same command line options of MSVC and GCC.</p>

<h3 id="toc_1">Include directories</h3>

<p>Include directories are specified in <code>cakeconfig.h</code> file.</p>

<p>On Windows, to manually discover which directories are included, you can run at 
Visual Studio command prompt the command:</p>

<pre><code>echo %INCLUDE%
</code></pre>

<p>To find out what are the directories used by GCC type:</p>

<pre><code>echo | gcc -E -Wp,-v -
</code></pre>

<p>Sample of <code>cakeconfig.h</code></p>

<pre><code class="language-c">
#ifdef __linux__
/*
   To find the include directories used my GCC type:   
   echo | gcc -E -Wp,-v -
*/
#pragma dir &quot;/usr/lib/gcc/x86_64-linux-gnu/11/include&quot;
#pragma dir &quot;/usr/local/include&quot;
#pragma dir &quot;/usr/include/x86_64-linux-gnu&quot;
#pragma dir &quot;/usr/include&quot;

#endif

#ifdef _WIN32
/*
   To find the include directories used my  MSVC,
   open Visual Studio Developer Commmand prompt and type:
   echo %INCLUDE%.
   Running Cake inside mscv command prompt uses %INCLUDE% automatically.
*/
#pragma dir &quot;C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.38.33130/include&quot;
#pragma dir &quot;C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.38.33130/ATLMFC/include&quot;
#pragma dir &quot;C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Auxiliary/VS/include&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/ucrt&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/um&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/shared&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/winrt&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/cppwinrt&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/NETFXSDK/4.8/include/um&quot;

#endif

</code></pre>

<p>The command line <code>cake -autoconfig</code> generates the cake config file.</p>

<p>We can have a <code>cakeconfig.h</code> per project and call a more generic <code>cakeconfig.h</code> for system includes.</p>

<p>Sample: </p>

<p><code>yourproject\cakeconfig.h</code></p>

<pre><code class="language-c">
//system includes...etc
#include &quot;C:\Program Files (x86)\cake\cakeconfig.h&quot;

//project extra includes
#pragma dir &quot;.\openssl\include&quot;

</code></pre>

<h3 id="toc_2">Command line</h3>

<pre><code>cake [options] source1.c source2.c ...

SAMPLES

    cake source.c
    Compiles source.c and outputs /[default-target]/source.c

    cake -target=X86_msvc source.c
    Compiles source.c and outputs C11 code at /X86_msvc/source.c

    cake file.c -o file.cc &amp;&amp; cl file.cc
    Compiles file.c and outputs file.cc then use cl to compile file.cc

  
</code></pre>

<h3 id="toc_3">Options</h3>

<ul>
<li><p><code>-I</code>  (same as GCC and MSVC)
Adds a directory to the list of directories searched for include files</p></li>
<li><p><code>-no-output</code>
Cake will not generate output</p></li>
<li><p><code>-D</code> (same as GCC and MSVC)
Defines a preprocessing symbol for a source file</p></li>
<li><p><code>-E</code> (same as GCC and MSVC)
Copies preprocessor output to standard output</p></li>
<li><p><code>-o name.c</code> (same as GCC and MSVC)
Defines the output name, when we compile a single file</p></li>
<li><p><code>-dump-tokens</code>
Output tokens before preprocessor</p></li>
<li><p><code>-Wnumber -Wno-number</code>
Enables or disable warnings.
See <a href="warnings.html">warnings</a></p></li>
<li><p><code>-disable-assert</code>
Disable cake extension where assert is an statement.</p></li>
<li><p><code>-H</code> (same as gcc, /showIncludes in MSVC)
Causes the compiler to output a list of the include files. </p></li>
<li><p><code>*-preprocess-def-macro</code>
preprocess def macros after expansion</p></li>
<li><p><code>-Wall</code>
Enables all warnings</p></li>
<li><p><code>-sarif</code>
Generates sarif files.
Sarif Visual Studio plugin <a href="https://marketplace.visualstudio.com/items?itemName=WDGIS.MicrosoftSarifViewer">https://marketplace.visualstudio.com/items?itemName=WDGIS.MicrosoftSarifViewer</a></p></li>
<li><p><code>-sarif-path</code>
Specifies the Sarif output dir. &quot;Visual Studio -&gt; External Tools&quot; 
<code>-Wstyle  -msvc-output  -no-output -sarif -sarif-path &quot;$(SolutionDir).sarif&quot; $(ItemPath)</code></p></li>
<li><p><code>-target</code>
Defines how the source code is interpreted (integers sizes, align etc) and specifies the
C89 output that is compatible with the target compiler.
Options: x86_x64_gcc, x64_msvc, x64_msvc, catalina, ccu8</p></li>
<li><p><code>-msvc-output</code> Output is compatible with Visual Studio IDE. </p></li>
<li><p><code>-fdiagnostics-color=never</code> (same as GCC) Output will not use colors</p></li>
<li><p><code>-fanalyzer</code> runs cake flow analysis</p></li>
<li><p><code>-auto-config</code> Generates cakeconfig.h header (see includes)</p></li>
<li><p><code>-style=name</code> Set the style used in (w011) style warnings. Options are <code>-style=cake</code>, <code>-style=gnu</code>, <code>-style=microsoft</code></p></li>
<li><p><code>-comment-to-attr</code> Converts at preprocessor phase, comment like this <code>/*w12*/</code> to attributes <code>[[cake::w12]]</code></p></li>
<li><p><code>-const-literal</code> Makes the compiler handle string literals as const char[] rather than char[].</p></li>
</ul>

<h3 id="toc_4">Output</h3>

<p>The current backend generates C89-compatible code, which can be pipelined with existing 
compilers to produce executables. </p>

<p>The output is a simplified version of C89.
It does not include the following features:</p>

<ul>
<li>preprocessor</li>
<li>typedefs</li>
<li>enums</li>
<li>const</li>
<li>auto</li>
<li>Structs/unions declared inside other structs/unions</li>
<li>constant expressions are pre-computed</li>
<li>no sizeof</li>
<li>static variables are non-local.</li>
<li>arrays size [] = {...} are pre-calculated</li>
<li>no switch </li>
</ul>

<p>The goal is for this simplified version to function as an intermediate language (IL).</p>

<p>One directory called <strong>out</strong> is created keeping the same directory structure of the input files.</p>

<p>For instance:</p>

<pre><code class="language-c">cake c:\project\file1.c
</code></pre>

<p>output:</p>

<pre><code>  c:\project
  ├── file1.c
  ├── target
      ├── file1.c
</code></pre>

<p>More files..</p>

<pre><code>cake c:\project\file1.c c:\project\other\file2.c
</code></pre>

<p>output</p>

<pre><code>  c:\project
  ├── file1.c
  ├── other
  │   ├── file2.c
  ├── target
      ├── file1.c
      ├── other
          ├── file2.c
</code></pre>

<h2 id="toc_5">C89</h2>

<p><a href="https://nvlpubs.nist.gov/nistpubs/Legacy/FIPS/fipspub160.pdf">https://nvlpubs.nist.gov/nistpubs/Legacy/FIPS/fipspub160.pdf</a></p>

<h2 id="toc_6">C99</h2>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n325.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n325.pdf</a>
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf</a></p>

<pre><code class="language-c"> #define __STDC_VERSION__ 199901L  //C99
</code></pre>

<h3 id="toc_7">C99 restrict pointers</h3>

<pre><code class="language-c">void f(const char* restrict s);
</code></pre>

<h3 id="toc_8">C99 Variable-length array (VLA)</h3>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int n = 2;
    int m = 3;
    int (*p)[n][m] = malloc(sizeof * p);

    printf(&quot;%zu\n&quot;, sizeof(*p));

    free(p);
}
cdd
</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n683.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n683.htm</a></p>

<p>Not implemented yet.</p>

<h3 id="toc_9">C99 Flexible array members</h3>

<pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct X {
    int count;
    double values[]; // flexible array
};

/*
    The size of a structure with a flexible array member is
    determined as if the flexible array member were omitted,
    EXCEPT that it may have more trailing padding than the
    omission would imply
*/

int main() {

    int n = 3;

    printf(&quot;sizeof(struct X) = %d\\n&quot;, (int) sizeof(struct X));
    printf(&quot;allocated = %d\\n&quot;, (int) sizeof(struct X) + n * sizeof(double));

    struct X* p = malloc(sizeof(struct X) + n * sizeof(double));
    if (p == NULL) return 0;

    p-&gt;count = n;
    p-&gt;values[0] = 10.0;
    p-&gt;values[1] = 20.0;
    p-&gt;values[2] = 30.0;

    for (int i = 0; i &lt; p-&gt;count; ++i)
        printf(&quot;%f\\n&quot;, p-&gt;values[i]);

    free(p);

    return 0;
}

</code></pre>

<h3 id="toc_10">C99 static and type qualifiers in parameter array declarators</h3>

<pre><code class="language-c">#include &lt;stdlib.h&gt;

void F(int a[static 5]) {
}

int main() 
{    
    F(0);
    F(NULL);
    F(nullptr);

    int a[] = {1, 2, 3};    
    F(a);//error
    
    int b[] = { 1, 2, 3 , 4, 5};
    F(b); 

    int c[] = { 1, 2, 3 , 4, 5, 6};
    F(c);
}

</code></pre>

<h3 id="toc_11">C99 Complex and imaginary support</h3>

<p>Not implemented</p>

<h3 id="toc_12">C99 Universal character names (\u and \U)</h3>

<p>Not implemented</p>

<h3 id="toc_13">C99 Hexadecimal floating constants</h3>

<pre><code class="language-c">double d = 0x1p+1;
</code></pre>

<p>Cake converts hexadecimal floating-point values to decimal 
floating-point representation using strtod followed by snprintf.
This conversion may introduce precision loss.</p>

<pre><code>0x1.234p1 means:

           2       3     4
r1= 1 +   ---  +  --- + ---   = 1.1376953125 
            1        2     3
          16       16     16

                1
1.1376953125 x 2  = 2.275390625 (final number)

</code></pre>

<h3 id="toc_14">C99 Compound literals</h3>

<pre><code class="language-c">struct s {
  int i;
};

int f(void) {
  struct s * p = 0, * q;
  int j = 0;
  again:
    q = p, p = &amp; ((struct s) { j++ });
  if (j &lt; 2) goto again;
  return p == q &amp;&amp; q -&gt; i == 1;
}
</code></pre>

<p>N716
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n716.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n716.htm</a></p>

<h3 id="toc_15">C99 Designated initializers</h3>

<pre><code class="language-c"> int main()
 {
  int a[6] = {[4] = 29, [2] = 15 };

  struct point { int x, y; };

  struct point p = { .y = 2, .x = 3 }
 }

</code></pre>

<p>N494
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n494.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n494.pdf</a></p>

<h3 id="toc_16">C99 Line comments</h3>

<h3 id="toc_17">Declarations in for loop initializers</h3>

<pre><code class="language-c">int main()
{
   const int max = 10;
   for (int n = max - 1; n &gt;= 0; n--)
   {
     // body of loop
   }
}

</code></pre>

<h3 id="toc_18">C99 inline functions</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n709.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n709.htm</a>  (30 May 1997)
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n741.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n741.htm</a></p>

<pre><code class="language-c">inline int sum(int a, int b)
{
    return a + b;
}
int main(void)
{
    int r = sum(1, 2);
}
</code></pre>

<h3 id="toc_19">C99 _Pragma preprocessing operator</h3>

<p>NXXXX?</p>

<h3 id="toc_20">C99 __func__ predefined identifier</h3>

<p>N611 13 Sep 96 Mooney, <strong>FUNC</strong></p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
    printf(&quot;%s\n&quot;, __func__);
    printf(&quot;%s\n&quot;, __func__);
}
</code></pre>

<h3 id="toc_21">C99 Variadic macros</h3>

<pre><code class="language-c">
#include &lt;stdio.h&gt;

#define debug(...) fprintf(stderr, __VA_ARGS__)

int main()
{
  int x = 1;
  debug(&quot;X = %d\n&quot;, 1);
}
</code></pre>

<p>N707
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n707.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n707.htm</a></p>

<h3 id="toc_22">C99 _Bool</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n815.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n815.htm</a>  (1998)</p>

<pre><code class="language-c">int main(void)
{
    _Bool b = 1;
    return 0;
}
</code></pre>

<h2 id="toc_23">C11</h2>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf</a>
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2310.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2310.pdf</a></p>

<pre><code class="language-c">#define __STDC_VERSION__ 201112L //C11
</code></pre>

<h3 id="toc_24">C11 _Static_assert</h3>

<pre><code class="language-c">int main()
{
    _Static_assert(1 == 1, &quot;error&quot;);    
}
</code></pre>

<h3 id="toc_25">C11 Anonymous structures and unions</h3>

<pre><code class="language-c">struct v {
  union { /* anonymous union*/
     struct { int i, j; }; /* anonymous structure*/
     struct { long k, l; } w;
  };
  int m;
} v1;

int main(){
  v1.i = 2; /* valid*/
  v1.w.k = 5; /* valid*/
}
</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1406.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1406.pdf</a></p>

<h3 id="toc_26">C11 _Noreturn</h3>

<pre><code class="language-c">_Noreturn void f () {
  abort(); // ok
}
</code></pre>

<h3 id="toc_27">C11 Thread_local/Atomic</h3>

<p>Thread_local uses __declspec(thread) in MSVC output and __thread with GCC output.</p>

<p>Atomic - not implemented</p>

<h3 id="toc_28">C11 type-generic expressions (_Generic)</h3>

<p>N1441
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1441.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1441.htm</a></p>

<pre><code class="language-c">#include &lt;math.h&gt;

#define cbrt(X) _Generic((X),    \
                  double: cbrtl, \
                  float: cbrtf , \
                  default: cbrtl \
              )(X)


int main(void)
{
    cbrt(1.0);
}
</code></pre>

<h3 id="toc_29">C11 u&#39; &#39; U&#39; &#39; character constants</h3>

<pre><code class="language-c"> int i = U&#39;ç&#39;;
 int i2 = u&#39;ç&#39;;
</code></pre>

<p>Important: Cake assume source is utf8 encoded.</p>

<h3 id="toc_30">C11 u8&quot;literals&quot;</h3>

<pre><code class="language-c">char * s1 = u8&quot;maçã&quot;;
char * s2 = u8&quot;maca&quot;;
</code></pre>

<p>N1488
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1488.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1488.htm</a></p>

<p>Important: Cake assume source is utf8 encoded.</p>

<h3 id="toc_31">C11 _Alignof or C23 alignof</h3>

<pre><code class="language-c"> int main()
 {
   int align = alignof(int);
 }
</code></pre>

<h3 id="toc_32">C11 _Alignas or C23 alignas</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1335.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1335.pdf</a></p>

<p>Uses __declspec(align(n)) in MSVC output and <strong>attribute</strong>((aligned(n))) in GCC output.</p>

<h2 id="toc_33">C23</h2>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3096.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n3096.pdf</a></p>

<pre><code class="language-c">#define __STDC_VERSION__ 201710L  //C17
#define __STDC_VERSION__ 202311L  //C23
</code></pre>

<h3 id="toc_34">C23 _Decimal32, _Decimal64, and _Decimal128</h3>

<p>Not implemented.
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1107.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1107.htm</a></p>

<h3 id="toc_35">C23 static_assert / single-argument static_assert</h3>

<p>N1330
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1330.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1330.pdf</a></p>

<h3 id="toc_36">C23 u8 character prefix</h3>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2418.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2418.pdf</a></p>

<pre><code class="language-c">int main(){
    unsigned char c = u8&#39;~&#39;;
}
</code></pre>

<h3 id="toc_37">C23 No function declarators without prototypes</h3>

<p><a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2841.htm">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2841.htm</a></p>

<pre><code class="language-c">int main(){
    func(); //this is an error in C23
}
</code></pre>

<p>See also Remove support for function definitions with identifier lists  </p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2432.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2432.pdf</a></p>

<h3 id="toc_38">C23 Improved Tag Compatibility</h3>

<p>Not implemented yet.</p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3037.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3037.pdf</a></p>

<pre><code class="language-c">struct foo { int a; } p;
void bar(void)
{
  struct foo { int a; } q;
  q = p;
}
</code></pre>

<h3 id="toc_39">C23 Unnamed parameters in function definitions</h3>

<pre><code class="language-c">int f(int );

int f(int ) {
}
</code></pre>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2480.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2480.pdf</a></p>

<p>C89 backened.
We should add a dummy name when generating - Not implemented yet.</p>

<h3 id="toc_40">C23 Digit separators</h3>

<pre><code class="language-c">int main()
{
    int a = 1000&#39;00;
}
</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2626.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2626.pdf</a></p>

<h3 id="toc_41">C23 Binary literals</h3>

<pre><code class="language-c">#define X  0b1010

int main()
{
    int a = X;
    int b = 0B1010;
}

</code></pre>

<h3 id="toc_42">C23 Introduce the nullptr constant</h3>

<pre><code class="language-c">
int main()
{
  void * p = nullptr;
  auto p2 = nullptr;
  typeof(nullptr) p3 = nullptr;
}

</code></pre>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3042.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n3042.htm</a></p>

<h3 id="toc_43">C23 Make false and true first-class language features</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2935.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2935.pdf</a></p>

<h3 id="toc_44">C23 {} empty initializer</h3>

<pre><code class="language-c">
int main()
{
    struct X {
        int i;
    } x = {};

    x = (struct X) {};

    struct Y
    {
        struct X x;
    } y = { {} };
}  

</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2900.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2900.htm</a>
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3011.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3011.htm</a></p>

<h3 id="toc_45">C23 auto</h3>

<pre><code class="language-c">static auto a = 3.5;
auto p = &amp;a;

double A[3] = { 0 };
auto pA = A;
auto qA = &amp;A;
</code></pre>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3007.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n3007.htm</a></p>

<h3 id="toc_46">C23 typeof / typeof_unqual</h3>

<pre><code class="language-c">
#define SWAP(a, b) \
  do {\
    typeof(a) temp = a; a = b; b = temp; \
  } while (0)


int main()
{
    /*simple case*/
    int a = 1;
    typeof(a) b = 1;

    /*pay attention to the pointer*/
    typeof(int*) p1, p2;

    /*let&#39;s expand this macro and see inside*/
    SWAP(a, b);

    /*for anonymous structs we insert a tag*/
    struct { int i; } x;
    typeof(x) x2;
    typeof(x) x3;

   /*Things get a little more complicated*/
   int *array[2];
   typeof(array) a1, a2;
   
   typeof(array) a3[3];
   typeof(array) *a4[4];

   /*abstract declarator*/
   int k = sizeof(typeof(array));

   /*new way to declare pointer to functions?*/
   typeof(void (int)) * pf = NULL;
}

</code></pre>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2927.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n2927.htm</a>
<a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2930.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2930.pdf</a></p>

<h3 id="toc_47">C23 Improved Normal Enumerations</h3>

<p>//TODO</p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3029.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n3029.htm</a></p>

<pre><code class="language-c">enum a {
    a0 = 0xFFFFFFFFFFFFFFFFULL
};

static_assert(_Generic(a0,
        unsigned long long: 0,
        int: 1,
        default: 2 == 0));
</code></pre>

<p>The type of the enum must be adjusted.</p>

<h3 id="toc_48">C23 constexpr</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3018.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3018.htm</a></p>

<pre><code class="language-c">
#include &lt;stdio.h&gt;

constexpr int c = 123;

constexpr int c2 = c + 1000;

int a[c];

constexpr double PI = 3.14;


static_assert(PI + 1 == 3.14 + 1.0);

struct Y {
    int a;
    int ar[3];
    int b;
};

void T3()
{
    constexpr struct Y y = { .ar[1] = 2, 3, 4 };
    static_assert(y.a == 0);
    static_assert(y.ar[0] == 0);
    static_assert(y.ar[1] == 2);
    static_assert(y.ar[2] == 3);
    static_assert(y.b == 4);
    static_assert(y.ar[1] + y.ar[2] == 5);
}

static_assert(&quot;abc&quot;[0] == &#39;a&#39;);


int main()
{
    constexpr char ch = &#39;a&#39;;

    printf(&quot;%f %c&quot;, PI, ch);
}


</code></pre>

<h3 id="toc_49">C23 Enhancements to Enumerations</h3>

<pre><code class="language-c">enum X : short {
  A
};

int main() {
   enum X x = A;   
}
</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3030.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3030.htm</a></p>

<h3 id="toc_50">C23 Attributes</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2335.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2335.pdf</a>
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2554.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2554.pdf</a></p>

<h3 id="toc_51">C23 fallthrough attribute</h3>

<p>Not implemented</p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2408.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2408.pdf</a></p>

<h3 id="toc_52">C23 deprecated attribute</h3>

<p>Partially implemented
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2334.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2334.pdf</a></p>

<h3 id="toc_53">C23 maybe_unused attribute</h3>

<p>Implemented
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2270.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2270.pdf</a></p>

<h3 id="toc_54">C23 nodiscard attribute</h3>

<p>Partially implemented</p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2267.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2267.pdf</a></p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2448.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2448.pdf</a></p>

<h3 id="toc_55">C23 [[unsequenced]] and [[reproducible]]</h3>

<p>//TODO</p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2956.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n2956.htm</a></p>

<h3 id="toc_56">C23 __has_attribute</h3>

<h3 id="toc_57">C23 __has_include</h3>

<pre><code class="language-c">
#if __has_include(&lt;stdio.h&gt;)
#warning  YES
#endif

#if __has_include(&lt;any.h&gt;)
#warning  YES
#else
#warning  NO
#endif

</code></pre>

<h3 id="toc_58">C23 #warning</h3>

<pre><code class="language-c">int main()
{
  #warning my warning message  
}

Implemented
C89 backend - n/a
</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2686.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2686.pdf</a></p>

<h3 id="toc_59">C23 #embed</h3>

<p>Partially implemented.</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
  static const char file_txt[] = {
   #embed &quot;stdio.h&quot;
   ,0
  };

  printf(&quot;%s\n&quot;, file_txt);
}
</code></pre>

<h3 id="toc_60">C23 #elifdef #elifndef</h3>

<p>Implemented</p>

<pre><code class="language-c">#define Y

#ifdef X
#define VERSION 1
#elifdef  Y
#define VERSION 2
#else
#define VERSION 3
#endif
</code></pre>

<h3 id="toc_61">C23 __VA_OPT__</h3>

<p>Implemented.</p>

<pre><code class="language-c">
#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)
#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)
#define SDEF(sname, ...) S sname __VA_OPT__(= { __VA_ARGS__ })
#define EMP


void f(int i, ...) {}


int main()
{
  int a = 1;
  int b = 2;
  int c = 3;
  
  F(a, b, c);
  F();
  F(EMP);
  G(a, b, c);
  G(a, );
  G(a);

}

</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3033.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3033.htm</a></p>

<h3 id="toc_62">C23 BitInt(N))</h3>

<p>Not implemented</p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2763.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2763.pdf</a></p>

<h3 id="toc_63">C23 Compound Literals with storage specifier</h3>

<p>Not implemented yet.</p>

<pre><code class="language-c">void F(int *p){}

int main()
{
   F((static int []){1, 2, 3, 0})
}
</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3038.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3038.htm</a></p>

<h3 id="toc_64">C23 Variably-modified (VM) types</h3>

<p>Not implemented
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2778.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2778.pdf</a></p>

<h2 id="toc_65">C2Y</h2>

<h3 id="toc_66">Obsolete implicitly octal literals</h3>

<pre><code class="language-c">
static_assert(0o52 == 052);
static_assert(0O52 == 052);
static_assert(0O52 == 42);

int main()
{
    int i = 0o52;
}

</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3353.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3353.htm</a></p>

<h3 id="toc_67">case range expressions</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3370.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3370.htm</a></p>

<h3 id="toc_68">#def</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3524.txt">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3524.txt</a></p>

<h3 id="toc_69">_Countof operator</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3369.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3369.pdf</a></p>

<p>Obs: Cake extends countof to enums, returning the number
of enumerators.</p>

<h3 id="toc_70">defer</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3199.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3199.htm</a></p>

<p><em>defer</em> will call the defer statement before the block exit at inverse order of declaration.</p>

<pre><code>     defer-statement:
        defer secondary-block
</code></pre>

<p>For instance:</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
  do {
     FILE* f = fopen(&quot;in.txt&quot;, &quot;r&quot;);
     if (f == NULL) break;
     defer fclose(f);

     FILE* f2 = fopen(&quot;out.txt&quot;, &quot;w&quot;);
     if (f2 == NULL) break;
     defer fclose(f2);
     //...    
  }
  while(0);
}
</code></pre>

<h3 id="toc_71">Function literals and local functions</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3645.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3645.pdf</a></p>

<h3 id="toc_72">if declarations, v4</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3388.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3388.htm</a></p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
   int size = 10;
   if (FILE* f = fopen(&quot;file.txt&quot;, &quot;r&quot;); f)
   {
     /*...*/
     fclose(f);
   }
}
</code></pre>

<p>C++ proposal
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r0.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r0.html</a></p>

<h3 id="toc_73">C2Y typename on _Generic</h3>

<p>This feature was created in Cake and now it is part of C2Y!</p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3260.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3260.pdf</a></p>

<pre><code class="language-c"> int main()
{
    const int * const p;
    static_assert(_Generic(p, const int *: 1));

    /*extension*/
    static_assert(_Generic(int, int : 1));
    static_assert(_Generic(typeof(p), const int * const: 1));
}
</code></pre>

<h2 id="toc_74">Cake Extensions</h2>

<h3 id="toc_75">Pre-defined macros in Cake</h3>

<pre><code class="language-c"> #define __CAKE__ 202311L
 #define __STDC_VERSION__ 202311L
 #define __STDC_OWNERSHIP__ 1
</code></pre>

<p>The define <strong>STDC_OWNERSHIP</strong> indicates that the compiler suports owneship checks</p>

<h3 id="toc_76">assert built-in</h3>

<p>In cake assert is an built-in function.
The reason is because it works as tips for flow analysis.</p>

<p>For instance, in a linked list when <code>head</code> is null <code>tail</code> is also null,
and <code>tail-&gt;next</code> always points to null.</p>

<p>Assertion will check these properties in runtime and also make 
the static analysis assume that assert evaluates to true.</p>

<pre><code class="language-c">
void list_push_back(struct list* list,
                    struct item* _Owner p_item)
{
   if (list-&gt;head == NULL) {
      list-&gt;head = p_item;
   }
   else {
      assert(list-&gt;tail != nullptr);
      assert(list-&gt;tail-&gt;next == nullptr);
      list-&gt;tail-&gt;next = p_item;
   }
   list-&gt;tail = p_item;
}
</code></pre>

<p>However, <code>assert</code> is not a &quot;blind override command.&quot; In situations like:</p>

<pre><code class="language-c">    int i = 0;
    assert(i != 0);
</code></pre>

<p>In situations where static analysis can identify two or more possible states, 
assert works as a state selector, similar to what happens in if statements but without the scope.</p>

<pre><code class="language-c">    void f(int * _Opt p)
    {
        if (p != NULL) {
           //p is not null here...
        }
    }
    
    void f2(int * _Opt p)
    {
        assert(p != NULL);
        //we assume p is not null here...        
    }
</code></pre>

<h3 id="toc_77">try { throw; } catch {}</h3>

<pre><code>   try-statement:
      try secondary-block
      try secondary-block catch secondary-block   
</code></pre>

<pre><code>jump-statement:
  throw;
</code></pre>

<p>try catch is a external block that we can jump off.</p>

<p>try catch is a <strong>LOCAL jump</strong> this is on purpose not a limitation.</p>

<p>catch block is optional.</p>

<pre><code class="language-c">try
{
   for (int i = 0 ; i &lt; 10; i++) {
      for (int j = 0 ; j &lt; 10; j++) {
        ... 
        if (error) throw;
        ...
      }
   }
}
catch
{
}
</code></pre>

<h3 id="toc_78">#pragma dir</h3>

<pre><code class="language-c">#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10//include/10.0.22000.0/cppwinrt&quot;
</code></pre>

<p>pragma dir makes the preprocessor include the directory when searching for includes.</p>

<h3 id="toc_79">offsetof</h3>

<p>In cake offset (<a href="https://en.cppreference.com/w/cpp/types/offsetof.html">https://en.cppreference.com/w/cpp/types/offsetof.html</a>) is an operator</p>

<h3 id="toc_80">Type traits</h3>

<p>We have some compile time functions to infer properties of types.</p>

<pre><code class="language-c">
_is_char()
The three types char, signed char, and unsigned char are collectively called the character types.

_is_pointer
Pointer to object or function

_is_array
Array type

_is_function
A function type describes a function with specified return type. 

_is_floating_point
float, double, and long double return true

_is_integral
The standard signed integer types and standard unsigned integer types are collectively called the
standard integer types;

_is_arithmetic
Integer and floating types are collectively called arithmetic types. 

_is_scalar
Arithmetic types, pointer types, and the nullptr_t type are collectively called scalar types

</code></pre>

<p>Note: Type traits that can be easily created with _Generic will be removed.
_</p>

<h3 id="toc_81">Extension - Object lifetime checks</h3>

<p>See <a href="ownership.html">ownership</a></p>

<pre><code>_Owner
_Opt
_View
</code></pre>

<h2 id="toc_82">GCC extensions</h2>

<ul>
<li>__builtin_va_list</li>
<li>__builtin_c23_va_start</li>
<li>__builtin_va_start</li>
<li>__builtin_va_end</li>
<li>__builtin_va_arg</li>
<li>__builtin_va_copy</li>
<li>__builtin_offsetof (same as cake offsetof)</li>
<li>__attribute__</li>
<li>__typeof__ alias same as typeof</li>
</ul>

<p>Other builtins are declared at <code>\src\include\x86_x64_gcc_builtins.h</code></p>

<p>Pre-defined macros for GCC compatibility
<a href="https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html">https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html</a></p>

<p>See <code>\src\include\x86_x64_gcc_builtins.h</code></p>

<h2 id="toc_83">MSVC extensions</h2>

<ul>
<li>__ptr32, __ptr64</li>
<li>__int8 ... __int64</li>
<li>__declspec</li>
<li>__cdecl</li>
<li>__fastcall, __stdcall</li>
<li>__forceinline alias for inline in cake</li>
<li>__pragma</li>
</ul>

<p>Pre-defined macros for MSVC compatibility
<a href="https://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170#standard-predefined-macros">https://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170#standard-predefined-macros</a></p>

<p>See <code>\src\include\x86_msvc_macros.h</code> and <code>\src\include\x64_msvc_macros.h</code></p>
</article></body></html>
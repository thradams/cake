
#include "compile.h"

#pragma safety enable

#include "ownership.h"

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include "tokenizer.h"
#include "parser.h"
#include <string.h>
#include "console.h"
#include "fs.h"

#ifdef _WIN32
#include <Windows.h>
#endif
#include "version.h"
#include "object.h"

#if defined _MSC_VER && !defined __POCC__
#include <crtdbg.h>
#include <debugapi.h>
#endif

#include "visit_il.h"
#include <time.h>


static char* _Opt strrchr2(const char* s, int c)
{
    const char* _Opt last = NULL;
    unsigned char ch = (unsigned char)c;

    while (*s)
    {
        if ((unsigned char)*s == ch)
        {
            last = s;  // record last match
        }
        s++;
    }

    // Handle case where c == '\0': return pointer to string terminator
    if (ch == '\0')
    {
        return (char*)s;
    }

    return (char*)last;
}


int fill_preprocessor_options(int argc, const char** argv, struct preprocessor_ctx* prectx)
{
    /*first loop used to collect options*/
    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] != '-')
            continue;

        if (argv[i][1] == 'I')
        {
            include_dir_add(&prectx->include_dir, argv[i] + 2);
            continue;
        }
        if (argv[i][1] == 'D')
        {
            char buffer[200] = { 0 };
            snprintf(buffer, sizeof buffer, "#define %s \n", argv[i] + 2);

            /*TODO make it more precise*/
            char* p = &buffer[7];
            while (*p)
            {
                if (*p == '=')
                {
                    *p = ' ';
                    break;
                }
                p++;
            }

            struct tokenizer_ctx tctx = { 0 };
            struct token_list l1 = tokenizer(&tctx, buffer, "", 0, TK_FLAG_NONE);
            struct token_list r = preprocessor(prectx, &l1, 0);
            token_list_destroy(&l1);
            token_list_destroy(&r);
            continue;
        }
    }
    return 0;
}

#ifdef _WIN32

WINBASEAPI unsigned long WINAPI GetEnvironmentVariableA(const char* name,
char* buffer,
unsigned long size);

#endif

void append_msvc_include_dir(struct preprocessor_ctx* prectx)
{

#ifdef _WIN32
    char env[2000] = { 0 };
    int n = GetEnvironmentVariableA("INCLUDE", env, sizeof(env));

    if (n > 0)
    {

        const char* p = env;
        for (;;)
        {
            if (*p == '\0')
            {
                break;
            }
            char filename_local[500] = { 0 };
            int count = 0;
            while (*p != '\0' && (*p != ';' && *p != '\n'))
            {
                filename_local[count] = *p;
                p++;
                count++;
            }
            filename_local[count] = 0;
            if (count > 0)
            {
                strcat(filename_local, "/");
                include_dir_add(&prectx->include_dir, filename_local);
            }
            if (*p == '\0')
            {
                break;
            }
            p++;
        }
    }
#endif
}


int generate_config_file(const char* configpath)
{
    FILE* _Owner _Opt outfile = NULL;
    int error = 0;
    try
    {
        outfile = fopen(configpath, "w");
        if (outfile == NULL)
        {
            printf("Cannot open the file '%s' for writing.\n", configpath);
            error = errno;
            throw;
        }

        fprintf(outfile, "//This was generated by running cake -autoconfig \n");


#ifdef __linux__

        fprintf(outfile, "This file was generated reading the output of\n");
        fprintf(outfile, "//echo | gcc -v -E - 2>&1\n");
        fprintf(outfile, "\n");

        char path[400] = { 0 };
        char* command = "echo | gcc -v -E - 2>&1";
        int in_include_section = 0;

        // Open the command for reading
        FILE* fp = popen(command, "r");
        if (fp == NULL)
        {
            fprintf(stderr, "Failed to run command\n");
            error = errno;
            throw;
        }

        // Read the output a line at a time
        while (fgets(path, sizeof(path), fp) != NULL)
        {
            // Check if we are in the "#include <...> search starts here:" section
            if (strstr(path, "#include <...> search starts here:") != NULL)
            {
                in_include_section = 1;
                continue;
            }
            // Check if we have reached the end of the include section
            if (in_include_section && strstr(path, "End of search list.") != NULL)
            {
                break;
            }
            // Print the include directories
            if (in_include_section)
            {
                const char* p = path;
                while (*p == ' ') p++;

                int len = strlen(path);
                if (path[len - 1] == '\n')
                    path[len - 1] = '\0';

                fprintf(outfile, "#pragma dir \"%s\"\n", p);
            }
        }

        fprintf(outfile, "\n");

        // Close the command stream
        pclose(fp);

#endif

#ifdef _WIN32
        char env[2000] = { 0 };
        int n = GetEnvironmentVariableA("INCLUDE", env, sizeof(env));

        if (n <= 0)
        {
            printf("INCLUDE not found.\nPlease, run cake -autoconfig inside visual studio command prompt.\n");
            error = 1;
            throw;
        }

        fprintf(outfile, "//This file was generated reading the variable INCLUDE inside Visual Studio Command Prompt.\n");
        fprintf(outfile, "//echo %%INCLUDE%% \n");

        const char* p = env;
        for (;;)
        {
            if (*p == '\0')
            {
                break;
            }
            char filename_local[500] = { 0 };
            int count = 0;
            while (*p != '\0' && (*p != ';' && *p != '\n'))
            {
                filename_local[count] = *p;
                p++;
                count++;
            }
            filename_local[count] = 0;
            if (count > 0)
            {
                strcat(filename_local, "/");
                char* pch = filename_local;
                while (*pch)
                {
                    if (*pch == '\\')
                        *pch = '/';
                    pch++;
                }

                fprintf(outfile, "#pragma dir \"%s\"\n", filename_local);
            }
            if (*p == '\0')
            {
                break;
            }
            p++;
        }
#endif
    }
    catch
    {
    }
    if (outfile)
        fclose(outfile);

    if (error == 0)
    {
        printf("file '%s'\n", configpath);
        printf("successfully generated\n");
    }
    return error;
}

static int get_first_line_len(const char* s)
{
    int n = 0;
    while (*s && (*s != '\r' && *s != '\n'))
    {
        s++;
        n++;
    }
    return n;
}

int compile_one_file(const char* file_name,
    struct options* options,
    const char* out_file_name,
    int argc,
    const char** argv,
    struct report* report)
{
    bool color_enabled = !options->color_disabled;

    printf("%s\n", file_name);
    struct preprocessor_ctx prectx = { 0 };
    prectx.options = *options;
    prectx.macros.capacity = 5000;

    add_standard_macros(&prectx, options->target);

    if (include_config_header(&prectx, file_name) != 0)
    {
        //cakeconfig.h is optional               
    }
    // print_all_macros(&prectx);

    struct ast ast = { 0 };

    const char* _Owner _Opt s = NULL;

    _Opt struct parser_ctx ctx = { 0 };

    struct tokenizer_ctx tctx = { 0 };
    struct token_list tokens = { 0 };

    ctx.options = *options;
    ctx.p_report = report;
    char* _Owner _Opt content = NULL;

    try
    {
        //-D , -I etc..
        if (fill_preprocessor_options(argc, argv, &prectx) != 0)
        {
            throw;
        }

        prectx.options = *options;
        append_msvc_include_dir(&prectx);

        content = read_file(file_name, true /*append new line*/);
        if (content == NULL)
        {
            report->error_count++;
            printf("file not found '%s'\n", file_name);
            throw;
        }

        if (options->sarif_output)
        {
            char sarif_file_name[260] = { 0 };
            if (options->sarifpath[0] != '\0')
            {
                mkdir(options->sarifpath, 0777);
                snprintf(sarif_file_name, sizeof sarif_file_name, "%s/%s.cake.sarif", options->sarifpath, basename(file_name));
            }
            else
            {
                snprintf(sarif_file_name, sizeof sarif_file_name, "%s.cake.sarif", file_name);
            }

            ctx.sarif_file = (FILE * _Owner _Opt) fopen(sarif_file_name, "w");
            if (ctx.sarif_file)
            {
                const char* begin_sarif =
                    "{\n"
                    "  \"version\": \"2.1.0\",\n"
                    "  \"$schema\": \"https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.5.json\",\n"
                    "  \"runs\": [\n"
                    "    {\n"
                    "      \"results\": [\n"
                    "\n";

                fprintf(ctx.sarif_file, "%s", begin_sarif);
            }
            else
            {
                report->error_count++;
                printf("cannot open Sarif output file '%s'\n", sarif_file_name);
                throw;
            }
        }

        tokens = tokenizer(&tctx, content, file_name, 0, TK_FLAG_NONE);

        if (tctx.n_errors > 0)
            throw;

        if (options->dump_tokens)
        {
            print_tokens(color_enabled, tokens.head);
        }

        prectx.options.diagnostic_stack.stack[prectx.options.diagnostic_stack.top_index].notes |= (1ULL << W_NOTE);
        ast.token_list = preprocessor(&prectx, &tokens, 0);

        report->warnings_count += prectx.n_warnings;
        report->error_count += prectx.n_errors;

        if (prectx.n_errors > 0)
        {
            throw;
        }

        if (options->dump_pptokens)
        {
            if (ast.token_list.head != NULL)
                print_tokens(color_enabled, ast.token_list.head);
        }

        if (options->preprocess_only)
        {
            const char* _Owner _Opt s2 = print_preprocessed_to_string2(ast.token_list.head);
            printf("%s", s2);
            free((void* _Owner _Opt)s2);
        }
        else
        {
            bool berror = false;
            ast.declaration_list = parse(&ctx, &ast.token_list, &berror);
            if (berror || report->error_count > 0)
                throw;

            if (!options->no_output)
            {

                struct osstream ss = { 0 };
                struct d_visit_ctx ctx2 = { 0 };
                ctx2.ast = ast;
                ctx2.options = ctx.options;
                d_visit(&ctx2, &ss);
                s = ss.c_str; //MOVE
                d_visit_ctx_destroy(&ctx2);

                FILE* _Owner _Opt outfile = fopen(out_file_name, "w");
                if (outfile)
                {
                    if (s)
                        fprintf(outfile, "%s", s);

                    fclose(outfile);
                }
                else
                {
                    report->error_count++;
                    printf("cannot open output file '%s' - %s\n", out_file_name, get_posix_error_message(errno));
                    throw;
                }
            }
        }

        if (ctx.sarif_file)
        {

#define SARIF_FOOTER                                                             \
    "      ],\n"                                                        \
    "      \"tool\": {\n"                                               \
    "        \"driver\": {\n"                                           \
    "          \"name\": \"cake\",\n"                                   \
    "          \"fullName\": \"cake code analysis\",\n"                 \
    "          \"version\": \"" CAKE_VERSION  "\",\n"                   \
    "          \"informationUri\": \"https://https://github.com/thradams/cake\"\n" \
    "        }\n"                                                       \
    "      }\n"                                                         \
    "    }\n"                                                           \
    "  ]\n"                                                             \
    "}\n"                                                               \
    "\n"
            fprintf(ctx.sarif_file, "%s", SARIF_FOOTER);
            fclose(ctx.sarif_file);
            ctx.sarif_file = NULL;
        }
    }
    catch
    {
        // printf("Error %s\n", error->message);
    }

    if (ctx.options.test_mode)
    {
        //lets check if the generated file is the expected
        char file_name_no_ext[FS_MAX_PATH] = { 0 };
        remove_file_extension(file_name, sizeof(file_name_no_ext), file_name_no_ext);

        char buf[FS_MAX_PATH] = { 0 };
        snprintf(buf, sizeof buf, "%s_%s.out", file_name_no_ext, get_platform(ctx.options.target)->name);

        char* _Owner _Opt content_expected = read_file(buf, false /*append new line*/);
        if (content_expected)
        {
            //We don't compare the fist line because it has the version that changes.
            int s_first_line_len = get_first_line_len(s);
            int content_expected_first_line_len = get_first_line_len(content_expected);
            if (s && strcmp(content_expected + content_expected_first_line_len, s + s_first_line_len) != 0)
            {
                printf("different");
                report->error_count++;
            }
            free(content_expected);
        }

        if (report->error_count > 0 || report->warnings_count > 0)
        {

            printf("-------------------------------------------\n");
            printf("%s", content);
            printf("\n-------------------------------------------\n");
            if (color_enabled)
            {
                printf(LIGHTRED "TEST FAILED" COLOR_RESET " : error=%d, warnings=%d\n", report->error_count, report->warnings_count);
            }
            else
            {
                printf("TEST FAILED" " : error=%d, warnings=%d\n", report->error_count, report->warnings_count);
            }
            printf("\n\n");
            report->test_failed++;
        }
        else
        {
            report->test_succeeded++;
            if (color_enabled)
            {
                printf(LIGHTGREEN "TEST OK\n" COLOR_RESET);
            }
            else
            {
                printf("TEST OK\n");
            }
        }
    }

    token_list_destroy(&tokens);

    parser_ctx_destroy(&ctx);
    free((void* _Owner _Opt)s);
    free(content);
    ast_destroy(&ast);
    preprocessor_ctx_destroy(&prectx);

    return report->error_count > 0;
}

static int compile_many_files(const char* file_name,
    struct options* options,
    const char* out_file_name,
    int argc,
    const char** argv,
    struct report* report)
{
    const char* const file_name_name = basename(file_name);
    const char* _Opt const file_name_extension = strrchr2((char*)file_name_name, '.');

    if (file_name_extension == NULL)
    {
        assert(false);
    }

    int num_files = 0;

    char path[FS_MAX_PATH] = { 0 };
    snprintf(path, sizeof path, "%s", file_name);
    dirname(path);
    DIR* _Owner _Opt dir = opendir(path);

    if (dir == NULL)
    {
        return errno;
    }

    struct dirent* _Opt dp;
    while ((dp = readdir(dir)) != NULL)
    {
        if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
        {
            /* skip self and parent */
            continue;
        }

        char fromlocal[257] = { 0 };
        snprintf(fromlocal, sizeof fromlocal, "%s/%s", "", dp->d_name);

        if (dp->d_type & DT_DIR)
        {

        }
        else
        {
            const char* const file_name_iter = basename(dp->d_name);
            const char* _Opt const file_extension = strrchr2((char*)file_name_iter, '.');

            if (file_name_extension &&
                file_extension &&
                strcmp(file_name_extension, file_extension) == 0)
            {
                //Fixes the output file name replacing the current name
                char out_file_name_final[FS_MAX_PATH] = { 0 };
                strcpy(out_file_name_final, out_file_name);
                dirname(out_file_name_final);
                strcat(out_file_name_final, "/");
                strcat(out_file_name_final, file_name_iter);

                char in_file_name_final[FS_MAX_PATH] = { 0 };
                strcpy(in_file_name_final, file_name);
                dirname(in_file_name_final);
                strcat(in_file_name_final, "/");
                strcat(in_file_name_final, file_name_iter);


                struct report report_local = { 0 };
                report_local.test_mode = report->test_mode;
                compile_one_file(in_file_name_final,
                                 options,
                                 out_file_name_final,
                                 argc,
                                 argv,
                                 &report_local);



                report->error_count += report_local.error_count;
                report->warnings_count += report_local.warnings_count;
                report->info_count += report_local.info_count;
                report->test_succeeded += report_local.test_succeeded;
                report->test_failed += report_local.test_failed;
                num_files++;
            }
        }
    }

    closedir(dir);
    return num_files;
}

static void longest_common_path(int argc, const char** argv, char root_dir[FS_MAX_PATH])
{
    /*
     find the longest common path
    */
    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] == '-')
            continue;

        char fullpath_i[FS_MAX_PATH] = { 0 };
        realpath(argv[i], fullpath_i);
        strcpy(root_dir, fullpath_i);
        dirname(root_dir);

        for (int k = 0; k < FS_MAX_PATH; k++)
        {
            const char ch = fullpath_i[k];
            for (int j = 2; j < argc; j++)
            {
                if (argv[j][0] == '-')
                    continue;

                char fullpath_j[FS_MAX_PATH] = { 0 };
                realpath(argv[j], fullpath_j);
                if (fullpath_j[k] != ch)
                {
                    strncpy(root_dir, fullpath_j, k);
                    root_dir[k] = '\0';
                    dirname(root_dir);
                    goto exit;
                }
            }
            if (ch == '\0')
                break;
        }
    }
exit:;
}

static int create_multiple_paths(const char* root, const char* outdir)
{
    /*
       This function creates all dirs (folder1, forder2 ..) after root
       root   : C:/folder
       outdir : C:/folder/folder1/folder2 ...
    */
#if !defined __EMSCRIPTEN__
    const char* p = outdir + strlen(root) + 1;
    for (;;)
    {
        if (*p != '\0' && *p != '/' && *p != '\\')
        {
            p++;
            continue;
        }

        char temp[FS_MAX_PATH] = { 0 };
        strncpy(temp, outdir, p - outdir);

        int er = mkdir(temp, 0777);
        if (er != 0)
        {
            er = errno;
            if (er != EEXIST)
            {
                printf("error creating output folder '%s' - %s\n", temp, get_posix_error_message(er));
                return er;
            }
        }
        if (*p == '\0')
            break;
        p++;
    }
    return 0;
#else
    return -1;
#endif
}

int compile(int argc, const char** argv, struct report* report)
{
    struct options options = { 0 };
    if (fill_options(&options, argc, argv) != 0)
    {
        return 1;
    }

    if (options.target != CAKE_COMPILE_TIME_SELECTED_TARGET)
    {
        printf("emulating %s\n", get_platform(options.target)->name);
    }

    char executable_path[FS_MAX_PATH - sizeof(CAKE_CFG_FNAME)] = { 0 };
    get_self_path(executable_path, sizeof(executable_path));
    dirname(executable_path);
    char cakeconfig_path[FS_MAX_PATH] = { 0 };
    snprintf(cakeconfig_path, sizeof cakeconfig_path, "%s" CAKE_CFG_FNAME, executable_path);

    if (options.auto_config) //-autoconfig
    {
        report->ignore_this_report = true;
        return generate_config_file(cakeconfig_path);
    }

    report->test_mode = options.test_mode;

    clock_t begin_clock = clock();
    int no_files = 0;

    char root_dir[FS_MAX_PATH] = { 0 };

    if (!options.no_output)
    {
        longest_common_path(argc, argv, root_dir);
    }

    const size_t root_dir_len = strlen(root_dir);

    /*second loop to compile each file*/
    for (int i = 1; i < argc; i++)
    {
        if (strcmp(argv[i], "-o") == 0 ||
            strcmp(argv[i], "-sarif-path") == 0)
        {
            //consumes next
            i++;
            continue;
        }

        if (argv[i][0] == '-')
            continue;

        no_files++;
        char output_file[FS_MAX_PATH] = { 0 };

        if (!options.no_output)
        {
            if (no_files == 1 && options.output[0] != '\0')
            {
                /*
                   -o outputname
                   works when we compile just one file
                */
                strcat(output_file, options.output);
            }
            else
            {
                char fullpath[FS_MAX_PATH] = { 0 };
                realpath(argv[i], fullpath);

                strcpy(output_file, root_dir);
                strcat(output_file, "/");
                strcat(output_file, get_platform(options.target)->name);

                strcat(output_file, fullpath + root_dir_len);

                char outdir[FS_MAX_PATH] = { 0 };
                strcpy(outdir, output_file);
                dirname(outdir);
                if (create_multiple_paths(root_dir, outdir) != 0)
                {
                    return 1;
                }
            }
        }

        char fullpath[FS_MAX_PATH] = { 0 };
        realpath(argv[i], fullpath);

        const char* file_extension = basename(fullpath);

        if (file_extension[0] == '*')
        {
            no_files--; //does not count *.c 
            no_files += compile_many_files(fullpath, &options, output_file, argc, argv, report);
        }
        else
        {
            struct report report_local = { 0 };
            compile_one_file(fullpath, &options, output_file, argc, argv, &report_local);


            report->error_count += report_local.error_count;
            report->warnings_count += report_local.warnings_count;
            report->info_count += report_local.info_count;
            report->test_succeeded += report_local.test_succeeded;
            report->test_failed += report_local.test_failed;
        }
    }

    clock_t end_clock = clock();
    double cpu_time_used = ((double)(end_clock - begin_clock)) / CLOCKS_PER_SEC;
    report->no_files = no_files;
    report->cpu_time_used_sec = cpu_time_used;
    return 0;
}


/*
* given a string s, produce argv by modifying the input string
* return argc
*/
static int strtoargv(char* s, int n, const char* argv[/*n*/])
{
    int argvc = 0;
    char* p = s;
    while (*p)
    {
        while (*p == ' ')
            p++;
        if (*p == 0)
            break;
        argv[argvc] = p;
        argvc++;
        while (*p != ' ' && *p != '\0')
            p++;
        if (*p == 0)
            break;
        *p = 0;
        p++;
        if (argvc >= n)
            break; /*nao tem mais lugares*/
    }
    return argvc;
}

const char* _Owner _Opt compile_source(const char* pszoptions, const char* content, struct report* report)
{
    const char* argv[100] = { 0 };
    char string[200] = { 0 };
    snprintf(string, sizeof string, "exepath %s", pszoptions);

    const int argc = strtoargv(string, 10, argv);

    const char* _Owner _Opt s = NULL;

    struct preprocessor_ctx prectx = { 0 };
    struct ast ast = { 0 };
    struct options options = { .input = LANGUAGE_CAK };


    try
    {
        if (fill_options(&options, argc, argv) != 0)
        {
            throw;
        }

        prectx.options = options;
        add_standard_macros(&prectx, options.target);

        if (options.preprocess_only)
        {
            struct tokenizer_ctx tctx = { 0 };
            struct token_list tokens = tokenizer(&tctx, content, "c:/main.c", 0, TK_FLAG_NONE);

            struct token_list token_list = preprocessor(&prectx, &tokens, 0);
            if (prectx.n_errors == 0)
            {
                s = print_preprocessed_to_string2(token_list.head);
            }

            token_list_destroy(&tokens);
            token_list_destroy(&token_list);
        }
        else
        {
            ast = get_ast(&options, "c:/main.c", content, report);
            if (report->error_count > 0)
                throw;


            struct osstream ss = { 0 };
            struct d_visit_ctx ctx2 = { 0 };
            ctx2.ast = ast;
            ctx2.options = options;
            d_visit(&ctx2, &ss);
            s = ss.c_str; //MOVED                
            //ss.c_str = NULL;
            //ss_close(&ss);
            d_visit_ctx_destroy(&ctx2);


        }
    }
    catch
    {
    }

    preprocessor_ctx_destroy(&prectx);

    ast_destroy(&ast);

    return s;
}

char* _Owner _Opt CompileText(const char* pszoptions, const char* content)
{
    /*
      This function is called by the web playground
    */
    printf(WHITE "Cake " CAKE_VERSION COLOR_RESET "\n");
    printf(WHITE "cake %s main.c\n", pszoptions);

    struct report report = { 0 };
    return (char* _Owner _Opt)compile_source(pszoptions, content, &report);
}


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

#pragma safety enable





#ifndef __OWNERSHIP_H__
#define __OWNERSHIP_H__

#ifdef __STDC_OWNERSHIP__


#ifdef _WIN64
    typedef struct _iobuf FILE;
    typedef unsigned __int64 size_t;    
#elif defined _WIN32
    typedef struct _iobuf FILE;
    typedef unsigned int     size_t;
#endif

#ifdef __linux__

    typedef struct _IO_FILE FILE;
    typedef __SIZE_TYPE__ size_t; // valid since C23

#endif

/*
  ownership is suported
*/
void* _Owner _Opt calloc(size_t nmemb, size_t size);
void free(void* _Owner _Opt ptr);
void* _Owner _Opt malloc(size_t size);
void* _Owner _Opt realloc(void* _Opt ptr, size_t size);
char* _Owner _Opt strdup(const char* src);

inline char* _Opt strrchr(char const *  _String, int _Ch);

int snprintf(
        _Ctor char*       const _Buffer,
        size_t      const _BufferCount,
        char const* const _Format,
        ...);

long strtol(
    char const* _String,
    char**     _Opt _EndPtr,
    int         _Radix
    );


FILE* _Owner _Opt fopen(char const* _FileName, char const* _Mode);
int fclose(FILE* _Owner _Stream);

size_t fread(
        _Ctor void*  _Buffer,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE*  _Stream
        );

long long strtoll(
    char const* _String,
    char** _Opt _EndPtr,
    int         _Radix
    );

double strtod(
    char const* _String,
    char**      _Opt _EndPtr
    );

long double strtold(char const* _String,char** _Opt _EndPtr);


unsigned long long strtoull(
    char const* _String,
    char**      _Opt _EndPtr,
    int         _Radix
    );

float strtof(char const* _String, char** _Opt _EndPtr);

//typedef unsigned long long time_t;
//static time_t time(time_t* const _Opt _Time);

#else
/*
  ownership not suported
*/

#define _Ctor
#define _Opt
#define _Owner
#define _Dtor
#define _View
#define static_debug(x)
#define static_set(x, s)
#endif

#endif




#include <assert.h>


#include <stdio.h>


#include <string.h>


#include <stdlib.h>



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once



#include <stdbool.h>

bool enable_vt_mode(void);

/*change foreground color*/

#define BLACK     "\x1b[30m" 
#define BLUE     "\x1b[34m"
#define GREEN     "\x1b[32m"
#define CYAN     "\x1b[36m"
#define RED "\x1b[31;1m"
#define MAGENTA     "\x1b[35m"
#define BROWN     "\x1b[31m"
#define LIGHTGRAY "\x1b[37m"
#define DARKGRAY "\x1b[90m"
#define LIGHTBLUE    "\x1b[34;1m"
#define  LIGHTGREEN "\x1b[92m"
#define LIGHTCYAN "\x1b[36;1m"
#define LIGHTRED "\x1b[91m"
#define LIGHTMAGENTA "\x1b[95m"
#define YELLOW "\x1b[93m"
#define WHITE "\x1b[97m"

//https//en.wikipedia.org/wiki/ANSI_escape_code


#define BK_BLACK "\x1b[40m"
#define BK_BLUE "\x1b[44m"
#define BK_GREEN  "\x1b[42m"
#define BK_CYAN "\x1b[46m"
#define BK_RED "\x1b[41;1m"
#define BK_MAGENTA "\x1b[45m"
#define BK_BROWN "\x1b[41m"
#define BK_LIGHTGRAY "\x1b[40;1m"
#define BK_DARKGRAY "\x1b[40m"
#define BK_LIGHTBLUE "\x1b[44;1m"
#define BK_LIGHTGREEN "\x1b[42,1m"
#define BK_LIGHTCYAN "\x1b[46;1m"
#define BK_LIGHTRED "\x1b[41;1m"
#define BK_LIGHTMAGENTA "\x1b[45;1m"
#define BK_YELLOW             "\x1b[43;1m"
#define BK_WHITE             "\x1b[47;1m"
#define BK_BLINK "\x1b[40m"

#define RESET "\x1b[0m"


int c_kbhit(void);
int c_getch(void);
void c_clrscr();
void c_gotoxy(int x, int y);


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

//#pragma once



#include <stdarg.h>

struct osstream
{
    char* _Owner _Opt c_str;
    int size;
    int capacity;
};


void ss_close( _Dtor struct osstream * stream);

int ss_vafprintf(struct osstream* stream, const char* fmt, va_list args);
int ss_fprintf(struct osstream* stream, const char* fmt, ...);
int ss_putc(char ch, struct osstream* stream);
void ss_clear(struct osstream* stream);
void ss_swap(struct osstream* a, struct osstream* b);



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

//#pragma once


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

//#pragma once

struct declarator;
struct enumerator;
struct enum_specifier;
struct init_declarator;
struct struct_or_union_specifier;
struct macro;
struct struct_entry;

void declarator_delete(struct declarator* _Owner _Opt p);
void init_declarator_delete(struct init_declarator* _Owner _Opt p);

void enumerator_delete(struct enumerator* _Owner _Opt p);
void enum_specifier_delete(struct enum_specifier* _Owner _Opt p);
void struct_or_union_specifier_delete(struct struct_or_union_specifier* _Owner _Opt p);
void struct_entry_delete(struct struct_entry* _Opt _Owner p);

void macro_delete(struct macro* _Owner _Opt p);


/*
* tag allow more than one type of object be inserted at the same map
*/
enum tag
{
    TAG_TYPE_NUMBER,

    TAG_TYPE_ENUN_SPECIFIER,
    TAG_TYPE_STRUCT_OR_UNION_SPECIFIER,

    TAG_TYPE_ENUMERATOR,
    TAG_TYPE_DECLARATOR,
    TAG_TYPE_INIT_DECLARATOR,
    TAG_TYPE_MACRO,
    TAG_TYPE_STRUCT_ENTRY
};


struct map_entry 
{
    struct map_entry* _Owner _Opt next;
    unsigned int hash;
    char* _Owner key;

    enum tag type; /*type of the object pointed by p*/

    union 
    {
        size_t number;
        struct enum_specifier* _Opt _Owner p_enum_specifier;
        struct enumerator* _Opt _Owner p_enumerator;
        struct struct_or_union_specifier* _Opt _Owner p_struct_or_union_specifier;
        struct declarator* _Opt _Owner p_declarator;
        struct init_declarator* _Opt _Owner p_init_declarator;
        struct macro* _Opt _Owner p_macro;
        struct struct_entry* _Opt _Owner p_struct_entry;
    } data;
    
};

struct hash_map 
{
    struct map_entry* _Owner _Opt * _Owner _Opt table;
    int capacity;
    int  size;
};

void hashmap_remove_all(struct hash_map* map);
void hashmap_destroy(_Dtor struct hash_map* map);
struct map_entry* _Opt hashmap_find(struct hash_map* map, const char* key);
void* _Opt hashmap_remove(struct hash_map* map, const char* key, enum tag* _Opt p_type_opt);

/*
  hash_item_set is used to insert pointer with it type into a hashmap and also
  used to undo the map insertion using map and key info.
*/
struct hash_item_set
{
    size_t  number;
    struct enum_specifier* _Owner _Opt p_enum_specifier;
    struct enumerator* _Owner _Opt p_enumerator;
    struct struct_or_union_specifier* _Owner _Opt p_struct_or_union_specifier;
    struct declarator* _Owner _Opt p_declarator;
    struct init_declarator* _Owner _Opt p_init_declarator;
    struct macro* _Owner _Opt p_macro;
    struct struct_entry* _Owner _Opt p_struct_entry;
};
void hash_item_set_destroy(_Dtor struct hash_item_set* p);

int hashmap_set(struct hash_map* map, const char* key, struct hash_item_set * item);



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

//#pragma once

enum token_type
{
    /*When changing here we need also change in tokenizer.c::get_token_name*/
    TK_NONE = 0,
    TK_NEWLINE = '\n',
    TK_WHITE_SPACE = ' ',
    TK_EXCLAMATION_MARK = '!',
    TK_QUOTATION_MARK = '"',
    TK_NUMBER_SIGN = '#',
    TK_DOLLAR_SIGN = '$',
    TK_PERCENT_SIGN = '%',
    TK_AMPERSAND = '&',
    TK_APOSTROPHE = '\'',
    TK_LEFT_PARENTHESIS = '(',
    TK_RIGHT_PARENTHESIS = ')',
    TK_ASTERISK = '*',
    TK_PLUS_SIGN = '+',
    TK_COMMA = ',',
    TK_HYPHEN_MINUS = '-',
    TK_FULL_STOP = '.',
    TK_SOLIDUS = '/',
    TK_COLON = ':',
    TK_SEMICOLON = ';',
    TK_LESS_THAN_SIGN = '<',
    TK_EQUALS_SIGN = '=',
    TK_GREATER_THAN_SIGN = '>',
    TK_QUESTION_MARK = '?',
    TK_COMMERCIAL_AT = '@',
    TK_LEFT_SQUARE_BRACKET = '[',
    TK_REVERSE_SOLIDUS = '//',
    TK_RIGHT_SQUARE_BRACKET = ']',
    TK_CIRCUMFLEX_ACCENT = '^',
    TK_FLOW_LINE = '_',
    TK_GRAVE_ACCENT = '`',
    TK_LEFT_CURLY_BRACKET = '{',
    TK_VERTICAL_LINE = '|',
    TK_RIGHT_CURLY_BRACKET = '}',
    TK_TILDE = '~',
    TK_PREPROCESSOR_LINE,
    TK_PRAGMA,
    TK_PRAGMA_END, /*marks the end of pragma internal usage*/
    TK_STRING_LITERAL,
    TK_CHAR_CONSTANT,    
    TK_LINE_COMMENT,
    TK_COMMENT,
    TK_PPNUMBER,

    ANY_OTHER_PP_TOKEN, //@ por ex

    /*PPNUMBER is converted to one of these at parser phase*/
    TK_COMPILER_DECIMAL_CONSTANT,
    TK_COMPILER_OCTAL_CONSTANT,
    TK_COMPILER_HEXADECIMAL_CONSTANT,
    TK_COMPILER_BINARY_CONSTANT,
    TK_COMPILER_DECIMAL_FLOATING_CONSTANT,
    TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT,


    TK_PLACEMARKER,

    TK_BLANKS,
    TK_PLUSPLUS = '++',
    TK_MINUSMINUS = '--',
    TK_ARROW = '->',
    TK_SHIFTLEFT = '<<',
    TK_SHIFTRIGHT = '>>',
    TK_LOGICAL_OPERATOR_OR = '||',
    TK_LOGICAL_OPERATOR_AND = '&&',
    
    TK_PLUS_ASSIGN = '+=',
    TK_MINUS_ASSIGN = '-=',
    TK_MULTI_ASSIGN = '*=',
    TK_DIV_ASSIGN = '/=',
    TK_MOD_ASSIGN = '%=',
    TK_SHIFT_LEFT_ASSIGN = '<<=',
    TK_SHIFT_RIGHT_ASSIGN = '>>=',
    TK_AND_ASSIGN = '&=',
    TK_OR_ASSIGN ='|=',
    TK_NOT_ASSIGN = '^=',

    TK_MACRO_CONCATENATE_OPERATOR = '##',

    TK_IDENTIFIER,
    TK_IDENTIFIER_RECURSIVE_MACRO, /*used to avoid macro recursion*/

    TK_BEGIN_OF_FILE,

    //C23 keywords
    TK_KEYWORD_AUTO,
    TK_KEYWORD_BREAK,
    TK_KEYWORD_CASE,
    TK_KEYWORD_CONSTEXPR,
    TK_KEYWORD_CHAR,
    TK_KEYWORD_CONST,
    TK_KEYWORD_CONTINUE,
    TK_KEYWORD_CAKE_CATCH, /*extension*/
    TK_KEYWORD_DEFAULT,
    TK_KEYWORD_DO,
    TK_KEYWORD_DEFER, /*extension*/
    TK_KEYWORD_DOUBLE,
    TK_KEYWORD_ELSE,
    TK_KEYWORD_ENUM,
    TK_KEYWORD_EXTERN,
    TK_KEYWORD_FLOAT,
    TK_KEYWORD_FOR,
    TK_KEYWORD_GOTO,
    TK_KEYWORD_IF,
    TK_KEYWORD_INLINE,
    TK_KEYWORD_INT,
    TK_KEYWORD_LONG,
    TK_KEYWORD_MSVC__INT8,
    TK_KEYWORD_MSVC__INT16,
    TK_KEYWORD_MSVC__INT32,
    TK_KEYWORD_MSVC__INT64,

    TK_KEYWORD_REGISTER,
    TK_KEYWORD_RESTRICT,
    TK_KEYWORD_RETURN,
    TK_KEYWORD_SHORT,
    TK_KEYWORD_SIGNED,
    
    TK_KEYWORD_SIZEOF,
    TK_KEYWORD__COUNTOF, //C2Y

    
    TK_KEYWORD_STATIC,
    TK_KEYWORD_STRUCT,
    TK_KEYWORD_SWITCH,
    TK_KEYWORD_TYPEDEF,
    TK_KEYWORD_CAKE_TRY, /*extension*/
    TK_KEYWORD_CAKE_THROW, /*extension*/
    TK_KEYWORD_UNION,
    TK_KEYWORD_UNSIGNED,
    TK_KEYWORD_VOID,
    TK_KEYWORD_VOLATILE,
    TK_KEYWORD_WHILE,
    
    TK_KEYWORD__ALIGNAS,
    TK_KEYWORD__ALIGNOF,
    TK_KEYWORD__ATOMIC,
    
    TK_KEYWORD_GCC__ATTRIBUTE,

    TK_KEYWORD_GCC__BUILTIN_VA_LIST,

    TK_KEYWORD_GCC__BUILTIN_VA_END,
    TK_KEYWORD_GCC__BUILTIN_VA_ARG,
    TK_KEYWORD_GCC__BUILTIN_C23_VA_START,    
    TK_KEYWORD_GCC__BUILTIN_VA_COPY,
    TK_KEYWORD_GCC__BUILTIN_OFFSETOF,
//#ifdef _WIN32 

    //https://learn.microsoft.com/en-us/cpp/cpp/ptr32-ptr64?view=msvc-170&redirectedfrom=MSDN
    TK_KEYWORD_MSVC__PTR32,
    TK_KEYWORD_MSVC__PTR64,

    TK_KEYWORD_MSVC__FASTCALL,
    TK_KEYWORD_MSVC__STDCALL,
    TK_KEYWORD_MSVC__CDECL,    
    TK_KEYWORD_MSVC__DECLSPEC,
//#endif

    TK_KEYWORD__ASM, 
    TK_KEYWORD__BOOL,
    TK_KEYWORD__COMPLEX,
    TK_KEYWORD__DECIMAL128,
    TK_KEYWORD__DECIMAL32,
    TK_KEYWORD__DECIMAL64,
    TK_KEYWORD__GENERIC,
    TK_KEYWORD__IMAGINARY,
    TK_KEYWORD__NORETURN,
    TK_KEYWORD__STATIC_ASSERT,    
    TK_KEYWORD_ASSERT, /*extension*/
    TK_KEYWORD__THREAD_LOCAL,

    TK_KEYWORD_TYPEOF, /*C23*/
    
    TK_KEYWORD_TRUE,  /*C23*/
    TK_KEYWORD_FALSE,  /*C23*/
    TK_KEYWORD_NULLPTR,  /*C23*/
    TK_KEYWORD_TYPEOF_UNQUAL, /*C23*/
    TK_KEYWORD__BITINT /*C23*/,

    

    /*cake extension*/
    TK_KEYWORD_CAKE_OWNER,
    TK_KEYWORD__CTOR,
    TK_KEYWORD__DTOR, 
    TK_KEYWORD_CAKE_VIEW,    
    TK_KEYWORD_CAKE_OPT, 
    

    /*extension compile time functions*/
    TK_KEYWORD_CAKE_STATIC_DEBUG, /*extension*/
    TK_KEYWORD_CAKE_STATIC_DEBUG_EX, /*extension*/
    TK_KEYWORD_STATIC_STATE, /*extension*/
    TK_KEYWORD_STATIC_SET, /*extension*/
    
    /*https://en.cppreference.com/w/cpp/header/type_traits*/
    
    TK_KEYWORD_IS_POINTER,
    TK_KEYWORD_IS_LVALUE,
    TK_KEYWORD_IS_CONST,
    TK_KEYWORD_IS_OWNER,
    TK_KEYWORD_IS_ARRAY,
    TK_KEYWORD_IS_FUNCTION,
    TK_KEYWORD_IS_SCALAR,
    TK_KEYWORD_IS_ARITHMETIC,
    TK_KEYWORD_IS_FLOATING_POINT,
    TK_KEYWORD_IS_INTEGRAL,
    

};

enum token_flags
{
    TK_FLAG_NONE = 0,
    TK_FLAG_FINAL = 1 << 0,                    /*compiler will see this token*/
    TK_FLAG_MACRO_EXPANDED = 1 << 1,           /*this token was generated from macro expansion*/
    TK_FLAG_HAS_SPACE_BEFORE = 1 << 2,         /*this token has spaces before*/
    TK_FLAG_HAS_NEWLINE_BEFORE = 1 << 3,       /*this token has newline before*/
    TK_FLAG_IDENTIFIER_IS_TYPEDEF = 1 << 4,    /*saves time on typedef search*/
    TK_FLAG_IDENTIFIER_IS_NOT_TYPEDEF = 1 << 5,

    TK_C_BACKEND_FLAG_HIDE = 1 << 6,                 /*c backend hidden*/
    
    TK_FLAG_IDENTIFIER_IS_ENUMERATOR = 1 << 7,       /*saves time on search*/

    TK_FLAG_IDENTIFIER_IS_NOT_ENUMERATOR = 1 << 8,   /*we know it is not enumerator*/    

    TK_FLAG_SLICED = 1 << 9,                         /*line-slicing in the middle*/

    TK_FLAG_LINE_CONTINUATION = 1 << 10 ,            /*token has one or more line-slicing*/

    TK_C_BACKEND_FLAG_SHOW_AGAIN = 1 << 11,          /*was hidden but maybe reappears*/
};

struct token
{
    enum token_type type;
    char* _Owner lexeme; //TODO make const
    char* original;

    int line;
    int col;

    /*include level - 0 is the current file*/
    int level;

    enum token_flags flags;

    /*points to the token with file name or macro*/
    struct token* token_origin;

    struct token* _Owner _Opt next;
    struct token* _Opt prev;
};

void token_delete( struct token* _Owner _Opt p);

struct token_list
{
    struct token* _Owner _Opt head;
    struct token* _Opt tail;
};

void token_list_set_file(struct token_list* list, struct token* filetoken, int line, int col);
bool token_list_is_empty(struct token_list* p);
void token_list_swap(struct token_list* a, struct token_list* b);

struct token* _Owner _Opt clone_token(struct token* p);
struct token* token_list_add(struct token_list* list, struct token* _Owner pnew);
void token_list_remove(struct token_list* list, struct token* first, struct token* last);
struct token_list token_list_remove_get(struct token_list* list, struct token* first, struct token* last);
void token_list_append_list(struct token_list* dest, struct token_list* source);
void token_list_append_list_at_beginning(struct token_list* dest, struct token_list* source);
struct token* token_list_clone_and_add(struct token_list* list, struct token* pnew);
char* _Owner _Opt token_list_join_tokens(struct token_list* list, bool bliteral);
void token_list_clear(struct token_list* list);
bool token_is_blank(const struct token* _Opt p);
bool token_is_identifier_or_keyword(enum token_type t);
void token_range_add_flag(struct token* first, struct token* last, enum token_flags flag);
void token_range_remove_flag(struct token* first, struct token* last, enum token_flags flag);
void token_range_add_show(struct token* first, struct token* last);

void print_tokens_html(struct token* p_token);

struct marker
{    
    const char* _Opt file;
    int line;
    int start_col;
    int end_col;

    // Line
    //~~~~~~~~^~~~~~~~~
    //begin  caret   end

    const struct token* _Opt p_token_caret;
    const struct token* _Opt p_token_begin;
    const struct token* _Opt p_token_end;
};

void print_line_and_token(struct marker* p_marker, bool visual_studio_ouput_format);

void print_position(const char* path, int line, int col, bool msvc_format);

struct stream
{
    const char* const source;
    const char* current;
    int line;
    int col;
    int line_continuation_count;
    const char* path;
};

int is_digit(const struct stream* p);
int is_nondigit(const struct stream* p);
void stream_match(struct stream* stream);

bool style_has_space(const struct token*  token);
bool style_has_one_space(const struct token*  token);

enum token_type parse_number(const char* lexeme, char suffix[4], _Ctor char erromsg[100]);
const unsigned char* _Opt utf8_decode(const unsigned char* s, _Ctor unsigned int* c);
const unsigned char* _Opt escape_sequences_decode_opt(const unsigned char* p, unsigned int* out_value);


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once

typedef int errno_t;

#if __STDC_VERSION__  >= 202311L 
#define NODISCARD [[nodiscard]]
#else
#define NODISCARD
#endif


#ifndef __CAKE__

//emulate _Countof
#define _Countof(A) (sizeof(A)/sizeof((A)[0]))

#define try  
#define catch if (0) catch_label:
#define throw do { throw_break_point(); goto catch_label;}while (0)

#endif

const char* get_posix_error_message(int error);
int windows_error_to_posix(int i);

void throw_break_point();


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

//#pragma once

/*
* Compiler options shared with compiler and preprocessor
*/

enum target
{
    TARGET_DEFAULT = 0,    
    TARGET_X86_X64_GCC ,
    TARGET_X86_MSVC ,
    TARGET_X64_MSVC ,
};

const char* target_to_string(enum target target);

enum language_version
{
    LANGUAGE_C23,
    LANGUAGE_C2Y,
    LANGUAGE_CAK,
};

enum diagnostic_id {

    W_NONE = 0,  /*not a real warning, used in especial cases*/
    
    
    W_UNUSED_VARIABLE, //-Wunused-variable
    W_DEPRECATED,
    W_ENUN_CONVERSION,//-Wenum-conversion

    W_ADDRESS, //-Waddress (always true)
    W_UNUSED_PARAMETER, //-Wno-unused-parameter
    W_DECLARATOR_HIDE, // gcc no
    W_TYPEOF_ARRAY_PARAMETER,//
    W_ATTRIBUTES, //-Wattributes
    W_UNUSED_VALUE, //-Wunused-value
    W_STYLE, //-Wstyle
    W_COMMENT,
    W_LINE_SLICING,
    W_STRING_SLICED,
    W_DISCARDED_QUALIFIERS,
    W_DECLARATOR_STATE,
    W_UNINITIALZED,
    W_RETURN_LOCAL_ADDR,
    W_MUST_USE_ADDRESSOF,
    W_ARRAY_INDIRECTION,
    /*ownership type system errors*/
    W_OWNERSHIP_MISSING_OWNER_QUALIFIER,
    W_OWNERSHIP_NOT_OWNER,
    W_OWNERSHIP_USING_TEMPORARY_OWNER,
    W_OWNERSHIP_MOVE_ASSIGNMENT_OF_NON_OWNER,
    W_OWNERSHIP_NON_OWNER_TO_OWNER_ASSIGN,
    W_OWNERSHIP_DISCARDING_OWNER,
    W_OWNERSHIP_NON_OWNER_MOVE,    
    //////////////////////////////////////////////
    W_FLOW_NON_NULL, //-Wnonnull
    W_FLOW_MISSING_DTOR,
    W_FLOW_UNINITIALIZED,
    W_FLOW_LIFETIME_ENDED,
    W_FLOW_MOVED,
    W_FLOW_NULL_DEREFERENCE,
    W_FLOW_MAYBE_NULL_TO_NON_OPT_ARG,
    W_FLOW_NULLABLE_TO_NON_NULLABLE,
    W_FLOW_DIVIZION_BY_ZERO,    
    //////////////////////////////////////////////
    W_DIVIZION_BY_ZERO,
    W_CONSTANT_VALUE, /*sample 0 * a */
    W_PASSING_NULL_AS_ARRAY,
    W_INCOMPATIBLE_ENUN_TYPES,
    W_MULTICHAR_ERROR,
    W_OUT_OF_BOUNDS,
    W_ASSIGNMENT_OF_ARRAY_PARAMETER,
    W_CONDITIONAL_IS_CONSTANT,
    W_SWITCH,
    W_UNSUAL_NULL_POINTER_CONSTANT,
    W_SIZEOF_ARRAY_ARGUMENT,
    W_CONST_NOT_INITIALIZED,
    W_NULL_CONVERTION,
    W_IMPLICITLY_UNSIGNED_LITERAL,
    W_INTEGER_OVERFLOW,
    W_ARRAY_SIZE,
    
    
    W_EMPTY_STATEMENT,
    W_ERROR_INCOMPATIBLE_TYPES,
    W_UNUSED_LABEL,
    W_REDEFINING_BUITIN_MACRO,
    W_UNUSED_FUNCTION,
    W_NOT_DEFINED57,
    W_NOT_DEFINED58,
    W_NOT_DEFINED59,
    W_NOT_DEFINED60,
    W_NOT_DEFINED61,

    W_LOCATION, /*prints code location*/
    W_NOTE,

    //----------------------------------------------------------------
    
    W_TO_MANY_INITIALIZERS = 100,

    //---------------------------------------------------------------

    C_ERROR_INVALID_QUALIFIER_FOR_POINTER = 640,
    C_ERROR_UNEXPECTED = 650,
    C_ERROR_TOO_MANY_ARGUMENTS = 660,
    C_ERROR_TOO_FEW_ARGUMENTS = 670,
    C_ERROR_NOT_FOUND = 680,
    C_ERROR_NO_MATCH_FOR_GENERIC = 690,
    C_ERROR_SUBSCRIPTED_VALUE_IS_NEITHER_ARRAY_NOR_POINTER = 700,
    C_ERROR_CALLED_OBJECT_IS_NOT_FUNCTION_OR_FUNCTION_POINTER = 710,
    C_ERROR_STRUCT_MEMBER_NOT_FOUND = 720,
    C_ERROR_STRUCTURE_OR_UNION_REQUIRED = 730,
    C_ERROR_STRUCT_IS_INCOMPLETE = 740,
    C_ERROR_DECLARATOR_NOT_FOUND = 750,
    C_ERROR_EXPECTED_DECLARATOR_NAME = 760,
    C_ERROR_UNKNOWN_ATTRIBUTE_NAME = 770,
    C_ERROR_INDIRECTION_REQUIRES_POINTER_OPERAND = 780,
    C_ERROR_INVALID_TOKEN = 790,
    C_ERROR_EXPECTED_STRUCT_TYPE = 800,
    C_ERROR_EXPECTED_TYPE_NAME = 810,
    C_ERROR_LEFT_IS_NOT_ARITHMETIC = 820,
    C_ERROR_RIGHT_IS_NOT_ARITHMETIC = 830,
    C_ERROR_LEFT_IS_NOT_INTEGER = 840,
    C_ERROR_RIGHT_IS_NOT_INTEGER = 850,
    C_ERROR_INVALID_TYPE = 860,
    C_ERROR_LEFT_IS_NOT_SCALAR = 870,
    C_ERROR_RIGHT_IS_NOT_SCALAR = 880,
    C_ERROR_INCOMPATIBLE_POINTER_TYPES = 890, //warning?
    C_ERROR_ASSIGNMENT_OF_FUNCTION = 900,
    C_ERROR_ASSIGNMENT_TO_EXPRESSION_WITH_ARRAY_TYPE = 910,
    C_ERROR_ASSIGNMENT_OF_READ_ONLY_OBJECT = 920,
    C_ERROR_LVALUE_ASSIGNMENT = 930,
    C_ERROR_CONDITION_MUST_HAVE_SCALAR_TYPE = 940,
    C_ERROR_INCOMPATIBLE_TYPES = 950,
    C_ERROR_EXPECTED_CONSTANT_EXPRESSION = 960,
    C_ERROR_UNEXPECTED_TOKEN = 970,
    C_ERROR_CANNOT_COMBINE_WITH_PREVIOUS_LONG_LONG = 980,
    C_ERROR_EXPECTED_DECLARATION = 990,
    C_ERROR_STATIC_OR_TYPE_QUALIFIERS_NOT_ALLOWED_IN_NON_PARAMETER = 1000,
    C_ERROR_OBJ_OWNER_CAN_BE_USED_ONLY_IN_POINTER = 1010,
    C_ERROR_REDECLARATION = 1020,
    C_ERROR_TAG_TYPE_DOES_NOT_MATCH_PREVIOUS_DECLARATION = 1030,
    C_ERROR_MISSING_ENUM_TAG_NAME = 1040,
    C_ERROR_MULTIPLE_DEFINITION_ENUM = 1050,
    C_ERROR_STATIC_ASSERT_FAILED = 1060,
    C_ERROR_STATIC_SET = 1070,
    C_ANALIZER_ERROR_STATIC_STATE_FAILED = 1080,
    C_ERROR_ATTR_UNBALANCED = 1090,
    C_ERROR_UNEXPECTED_END_OF_FILE = 1100,
    C_ERROR_THROW_STATEMENT_NOT_WITHIN_TRY_BLOCK = 1110,
    C_ERROR_VOID_FUNCTION_SHOULD_NOT_RETURN_VALUE = 1120,
    C_ERROR_NON_VOID_FUNCTION_SHOULD_RETURN_VALUE = 1121,
    C_ERROR_ARGUMENT_SIZE_SMALLER_THAN_PARAMETER_SIZE = 1130,
    C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS = 1140,
    C_ERROR_FILE_NOT_FOUND = 1150,
    C_ERROR_MISSING_CLOSE_PARENTHESIS = 1160,
    C_ERROR_EXPRESSION_ERROR = 1170,
    C_ERROR_PREPROCESSOR_C_ERROR_DIRECTIVE = 1180,
    C_ERROR_TOO_FEW_ARGUMENTS_TO_FUNCTION_LIKE_MACRO = 1190,
    C_ERROR_TOO_MANY_ARGUMENTS_TO_FUNCTION_LIKE_MACRO = 1191,
    C_ERROR_PREPROCESSOR_MACRO_INVALID_ARG = 1200,
    C_ERROR_PREPROCESSOR_MISSING_MACRO_ARGUMENT = 1210,
    C_ERROR_ADDRESS_OF_REGISTER = 1220,
    C_ERROR_OPERATOR_NEEDS_LVALUE = 1230, //C2105
    C_ERROR_CHARACTER_TOO_LARGE = 1240,
    C_ERROR_PRAGMA_ERROR = 1250,
    C_ERROR_OUT_OF_MEM = 1260,
    C_ERROR_STORAGE_SIZE = 1270,
    C_ERROR_RETURN_LOCAL_OWNER_TO_NON_OWNER = 1280,
    C_ERROR_AUTO_NEEDS_SINGLE_DECLARATOR = 1290,
    C_ERROR_TWO_OR_MORE_SPECIFIERS = 1300,
    C_ERROR_OPERATOR_INCREMENT_CANNOT_BE_USED_IN_OWNER = 1310,
    C_ERROR_OPERATOR_DECREMENT_CANNOT_BE_USED_IN_OWNER = 1320,
    C_PRE_DIVISION_BY_ZERO = 1330,
    C_ERROR_INT_TO_POINTER = 1340,
    C_ERROR_LITERAL_OVERFLOW = 1350,
    C_CHARACTER_NOT_ENCODABLE_IN_A_SINGLE_CODE_UNIT = 1360,
    C_MULTICHAR_ERROR = 1370,
    C_INVALID_TOKEN = 1380,
    C_INVALID_ARGUMENT_NELEMENTSOF = 1390,
    C_ERROR_RETURN_CANNOT_BE_USED_INSIDE_DEFER = 1400,
    C_ERROR_FUNCTION_RETURNS_FUNCTION = 1410,
    C_ERROR_FUNCTION_RETURNS_ARRAY = 1420,    
    C_ERROR_LABEL_NOT_DEFINED = 1430,    
    C_ERROR_DUPLICATED_LABEL = 1440,
    C_ERROR_DUPLICATED_CASE = 1450,
    C_ERROR_SUBSCRIPT_IS_NOT_AN_INTEGER = 1560,    
    C_ERROR_DUPLICATE_DEFAULT_GENERIC_ASSOCIATION = 1570, 
    C_ERROR_MULTIPLE_DEFAULT_LABELS_IN_ONE_SWITCH = 1780,
    C_ERROR_POINTER_TO_FLOATING_TYPE = 1790,
    C_ERROR_FLOATING_TYPE_TO_POINTER = 1800,
    C_ERROR_NULLPTR_CAST_ERROR = 1810,
    C_ERROR_MACRO_REDEFINITION = 1820,
    C_ERROR_INVALID_PREPROCESSING_DIRECTIVE = 1830,
    C_ERROR_FUNCTION_CANNOT_BE_MEMBER  = 1840,
    C_ERROR_NON_INTEGRAL_ENUM_TYPE = 1850,
    C_ERROR_REQUIRES_COMPILE_TIME_VALUE = 1860,
    C_ERROR_OUTER_SCOPE = 1870,
};


bool is_diagnostic_configurable(enum diagnostic_id id);
bool is_diagnostic_warning(enum diagnostic_id id);
bool is_diagnostic_error(enum diagnostic_id id);
bool is_diagnostic_note(enum diagnostic_id id);


/*
* These warnings are removed when "nullable=disable"
*/
#define WFLAG(W) (1ULL << W)
#define NULLABLE_DISABLE_REMOVED_WARNINGS  (WFLAG(W_FLOW_NULL_DEREFERENCE) | WFLAG(W_FLOW_NULLABLE_TO_NON_NULLABLE))

#define OWNERSHIP_DISABLE_REMOVED_WARNINGS  (WFLAG(W_FLOW_UNINITIALIZED))


int get_diagnostic_phase(enum diagnostic_id w);

enum style
{
    STYLE_CAKE,

    // https://llvm.org/docs/CodingStandards.html
    STYLE_LLVM,// A style complying with the LLVM coding standards

    //https://google.github.io/styleguide/cppguide.html
    STYLE_GOOGLE,// A style complying with Google’s C++ style guide

    //https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md
    //https://www.kernel.org/doc/html/latest/process/coding-style.html
    STYLE_CHROMIUM,// A style complying with Chromium’s style guide

    //https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html
    STYLE_MOZILLA,// A style complying with Mozilla’s style guide

    //https://www.webkit.org/code-style-guidelines/
    STYLE_WEBKIT,// A style complying with WebKit’s style guide

    STYLE_MICROSOFT,// A style complying with Microsoft’s style guide

    STYLE_GNU,// A style complying with the GNU coding standards

};
int get_warning_name(enum diagnostic_id w, int n, char buffer[/*n*/]);
unsigned long long  get_warning_bit_mask(const char* wname);

enum diagnostic_id  get_warning(const char* wname);

struct diagnostic
{
    /*
      each message has number (0-63) that corresponds to the bit index
      Messages bigger than W_NOTE are errors or bigger than 63
    */

    /*set of warnings reported as errors*/
    unsigned long long errors;
    /*set of warnings reported as warnings*/
    unsigned long long warnings;
    /*set of warnings reported as notes*/
    unsigned long long notes;
};

int get_diagnostic_type(struct diagnostic* d, enum diagnostic_id w);
extern struct diagnostic default_diagnostic;

void diagnostic_remove(struct diagnostic *d, enum diagnostic_id w);

struct diagnostic_stack
{
    int top_index;
    struct diagnostic stack[10];
};

int diagnostic_stack_push_empty(struct diagnostic_stack* diagnostic_stack);
void diagnostic_stack_pop(struct diagnostic_stack* diagnostic_stack);


struct options
{
    enum language_version input;
    enum target target;

    /*
      #pragma CAKE diagnostic push
      #pragma CAKE diagnostic pop
    */
    struct diagnostic_stack diagnostic_stack;

    enum style style;

    /*
       Causes the compiler to output a list of the include files.
       The option also displays nested include files, that is,
       the files included by the files that you include.
    */
    bool show_includes;

    /*
       -disable-assert
    */
    bool disable_assert;

    
    /*
       -flow-analysis
    */
    bool flow_analysis;

    /*
    * -testmode
    */
    bool test_mode;

    /*
    * -nullchecks
    */
    bool null_checks_enabled;

    bool ownership_enabled;

    /*
      -E
    */
    bool preprocess_only;

    /*
      -preprocess-def-macro
    */
    bool preprocess_def_macro;

    bool clear_error_at_end; //used by tests
    
    /*
      -sarif
    */
    bool sarif_output;

    /*
      -no-output
      if true cake does not generate output
    */
    bool no_output;

    /*
     -const-literal
     makes literal strings const
    */
    bool const_literal;

    /*
      -fdiagnostics-format=msvc
      -msvc-output
    */
    bool visual_studio_ouput_format;

    /*
      -dump-tokens
      print tokens before preprocessor
    */
    bool dump_tokens;

    /*
      -dump-pp-tokens
      (print tokens after preprocessor)
    */
    bool dump_pptokens;

    /*
      -autoconfig
    */
    bool auto_config;

    bool do_static_debug;
    int static_debug_lines;

    /*
      -o filename
      defines the ouputfile when 1 file is used
    */
    char output[200];
    char sarifpath[200];
};

int fill_options(struct options* options,
                 int argc,
                 const char** argv);

void print_help();



#define CAKE_CFG_FNAME "/cakeconfig.h"

struct include_dir
{
    const char* _Owner path;
    struct include_dir* _Owner _Opt next;
};

struct include_dir_list
{
    struct include_dir* _Owner _Opt head;
    struct include_dir* _Opt tail;
};

enum preprocessor_ctx_flags
{
    PREPROCESSOR_CTX_FLAGS_NONE = 0,
    PREPROCESSOR_CTX_FLAGS_ONLY_FINAL = 1 << 0
};

struct preprocessor_ctx
{
    struct options options;
    enum preprocessor_ctx_flags flags;
    struct hash_map macros;
    struct include_dir_list include_dir;

    /*map of pragma once already included files*/
    struct hash_map pragma_once_map;
    
    struct token* _Opt current;
    struct token_list input_list;
    unsigned int count_macro_value;
    bool conditional_inclusion;
    int n_warnings;
    int n_errors;    
};

void preprocessor_ctx_destroy( _Dtor struct preprocessor_ctx* p);

void pre_unexpected_end_of_file(struct token* _Opt p_token, struct preprocessor_ctx* ctx);
bool preprocessor_diagnostic(enum diagnostic_id w, struct preprocessor_ctx* ctx, const struct token* _Opt p_token, const char* fmt, ...);


struct tokenizer_ctx
{
    struct options options;
    int n_warnings;
    int n_errors;    
};

struct token_list tokenizer(struct tokenizer_ctx* ctx, const char* text, const char* _Opt filename_opt, int level, enum token_flags addflags);
void add_standard_macros(struct preprocessor_ctx* ctx);
struct include_dir* _Opt include_dir_add(struct include_dir_list* list, const char* path);

struct token_list preprocessor(struct preprocessor_ctx* ctx, struct token_list* input_list, int level);
struct token_list copy_replacement_list(struct preprocessor_ctx* ctx, const struct token_list* list);

void token_list_append_list(struct token_list* dest, _Dtor struct token_list* source);
void print_list(struct token_list* list);
void token_list_destroy(_Opt _Dtor struct token_list* list);
bool token_is_blank(const struct token* p);
void token_list_pop_back(struct token_list* list);
void token_list_pop_front(struct token_list* list);
struct token* _Owner _Opt token_list_pop_front_get(struct token_list* list);
void remove_line_continuation(char* s);
struct token* token_list_clone_and_add(struct token_list* list, struct token* pnew);
bool token_list_is_equal(const struct token_list* list_a, const struct token_list* list_b);
void token_list_insert_after(struct token_list* list, struct token* _Opt after, struct token_list* append);
void token_list_insert_before(struct token_list* token_list, struct token* after, struct token_list* append_list);
void token_list_paste_string_after(struct token_list* list,
    struct token* after,
    const char* s);
void token_list_paste_string_before(struct token_list* list,
    struct token* before,
    const char* s);
struct token_list tokenizer(struct tokenizer_ctx* p, const char* text, const char* _Opt filename_opt, int level, enum token_flags addflags);

void print_code_as_we_see(const struct token_list* list, bool remove_comments);
const char* _Owner _Opt get_code_as_compiler_see(const struct token_list* list);
const char* _Owner _Opt get_code_as_we_see_plus_macros(const struct token_list* list);
const char* _Owner _Opt get_code_as_we_see(const struct token_list* list, bool remove_comments);

void print_tokens(const struct token* _Opt p_token);
void print_preprocessed(const struct token* p_token);
const char* _Owner _Opt print_preprocessed_to_string(const struct token* p_token);
const char* _Owner _Opt print_preprocessed_to_string2(const struct token* _Opt p_token);
void check_unused_macros(const struct hash_map* map);

const char* get_token_name(enum token_type tk);
void print_all_macros(const struct preprocessor_ctx* prectx);

int string_literal_char_byte_size(const char* s);
int string_literal_byte_size_not_zero_included(const char* s);

int get_char_type(const char* s);
int include_config_header(struct preprocessor_ctx* ctx, const char* file_name);
int stringify(const char* input, int n, char output[]);


#ifdef _WIN32


#include <Windows.h>
#endif

#if defined _MSC_VER && !defined __POCC__


#include <crtdbg.h>
#endif

#if defined _MSC_VER && !defined __POCC__


#include <debugapi.h>
#endif

/*
  PROVISORY - unchecked was removed, now we control flow ownership error with pragma
  TODO review alternatives from Domingo's branch.
*/
#ifdef __CAKE__
#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wdiscard-owner"
#pragma cake diagnostic ignored "-Wmissing-destructor"
#pragma cake diagnostic ignored "-Wnon-owner-move"
#pragma cake diagnostic ignored "-Wnon-owner-to-_Owner-move"
#endif

//#pragma cake diagnostic pop

bool style_has_space(const struct token* token)
{
    return token_is_blank(token->prev);
}

bool style_has_one_space(const struct token* token)
{
    return token->prev &&
        token->prev->type == TK_BLANKS;
}

void print_literal2(const char* s);

void token_list_clear(struct token_list* list)
{
    struct token* _Owner _Opt p = list->head;
    while (p)
    {
        struct token* _Owner _Opt next = p->next;
        p->next = NULL;
        token_delete(p);
        p = next;
    }

    list->head = NULL;
    list->tail = NULL;
}


void token_range_add_show(struct token* first, struct token* last)
{
    for (struct token* current = first;
         current != last->next;
         current = current->next)
    {
        current->flags = current->flags & ~TK_C_BACKEND_FLAG_HIDE;
        if (current->next == NULL)
            break;
    }
}

void token_range_remove_flag(struct token* first, struct token* last, enum token_flags flag)
{
    for (struct token* _Opt current = first;
        current && current != last->next;
        current = current->next)
    {
        current->flags = current->flags & ~flag;
    }
}

void token_range_add_flag(struct token* first, struct token* last, enum token_flags flag)
{
    for (struct token* _Opt current = first;
        current && current != last->next;
        current = current->next)
    {
        current->flags |= flag;
    }
}

void token_list_pop_back(struct token_list* list)
{
    if (list->head == NULL)
        return;

    if (list->head == list->tail)
    {
        token_delete(list->head);
        list->head = NULL;
        list->tail = NULL;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->prev != NULL);
        list->tail = list->tail->prev;
        token_delete(list->tail->next);
        list->tail->next = NULL;
        if (list->tail == list->head)
        {
            list->tail->prev = NULL;
        }
    }
    assert(list->head == NULL || list->head->prev == NULL);
}

void token_list_pop_front(struct token_list* list) /*unchecked*/
{
    if (list->head == NULL)
        return;

    struct token* _Owner _Opt p = list->head;
    assert(p->prev == NULL);

    if (list->head == list->tail)
    {
        list->head = NULL;
        list->tail = NULL;
    }
    else
    {
        list->head = p->next;
        if (list->head)
            list->head->prev = NULL;
    }
    p->next = NULL;
    p->prev = NULL;
    token_delete(p);

    assert(list->head == NULL || list->head->prev == NULL);
}

struct token* _Owner _Opt token_list_pop_front_get(struct token_list* list)
{
    if (list->head == NULL)
        return NULL;

    struct token* _Owner _Opt old_head = list->head;

    list->head = old_head->next; // move head forward

    if (list->head != NULL)
    {
        list->head->prev = NULL;
    }
    else
    {
        list->tail = NULL;
    }

    assert(list->head == NULL || list->head->prev == NULL);

    old_head->prev = NULL;
    old_head->next = NULL;
    return old_head;
}

void token_list_swap(struct token_list* a, struct token_list* b)
{
    struct token_list temp = *a;
    *a = *b;
    *b = temp;
}

void token_delete(struct token* _Owner _Opt p)
{
    if (p)
    {
        /*
         * ownership warning here is about the p->next
         * we need a way to remove only this specific warning
        */
        assert(p->next == NULL);
        free(p->lexeme);
        free(p);
    }
}

void token_list_set_file(struct token_list* list, struct token* filetoken, int line, int col)
{
    struct token* _Opt p = list->head;
    while (p)
    {
        p->token_origin = filetoken;
        p->line = line;
        p->col = col;
        p = p->next;
    }
}

void token_list_destroy(_Opt _Dtor struct token_list* list)
{
    struct token* _Owner _Opt p = list->head;
    while (p)
    {
        struct token* _Owner _Opt next = p->next;
        p->next = NULL;
        token_delete(p);
        p = next;
    }
}

char* _Owner _Opt token_list_join_tokens(struct token_list* list, bool bliteral)
{
    struct osstream ss = { 0 };
    if (bliteral)
        ss_fprintf(&ss, "\"");
    bool has_space = false;
    struct token* _Opt current = list->head;

    while (current)
    {
        if (token_is_blank(current))
        {
            has_space = true;
            current = current->next;
            continue;
        }

        if (has_space)
            ss_fprintf(&ss, " ");

        const char* p = current->lexeme;
        while (*p)
        {
            if (*p == '"')
                ss_fprintf(&ss, "\\\"");
            else
                ss_fprintf(&ss, "%c", *p);
            p++;
        }


        current = current->next;
        if (current)
            has_space = current->flags & TK_FLAG_HAS_SPACE_BEFORE;
    }

    if (bliteral)
        ss_fprintf(&ss, "\"");

    char* _Owner _Opt cstr = ss.c_str;
    ss.c_str = NULL; /*MOVED*/

    ss_close(&ss);

    return cstr;
}


void token_list_paste_string_after(struct token_list* list,
    struct token* after,
    const char* s)
{
    struct tokenizer_ctx tctx = { 0 };
    struct token_list l = tokenizer(&tctx, s, NULL, 0, TK_FLAG_FINAL);
    token_list_insert_after(list, after, &l);
    token_list_destroy(&l);
}

void token_list_paste_string_before(struct token_list* list,
    struct token* before,
    const char* s)
{
    struct tokenizer_ctx tctx = { 0 };
    struct token_list l = tokenizer(&tctx, s, NULL, 0, TK_FLAG_FINAL);
    token_list_insert_before(list, before, &l);
    token_list_destroy(&l);
}


void token_list_insert_after(struct token_list* token_list, struct token* _Opt after, struct token_list* append_list)
{
    if (append_list->head == NULL)
    {
        return;//nothing to append
    }

    if (token_list->head == NULL)
    {
        assert(after == NULL);
        token_list->head = append_list->head;
        token_list->tail = append_list->tail;
        append_list->head = NULL;
        append_list->tail = NULL;
        return;
    }

    if (after == NULL)
    {
        assert(append_list->tail != NULL);
        assert(append_list->tail->next == NULL);
        append_list->tail->next = token_list->head;
        token_list->head->prev = append_list->tail; //TODO empty case

        token_list->head = append_list->head;
        append_list->head->prev = NULL;
    }
    else
    {
        struct token* _Owner _Opt follow = after->next;
        if (token_list->tail == after)
        {
            token_list->tail = append_list->tail;
        }
        else if (token_list->head == after)
        {
        }
        assert(append_list->tail != NULL);
        assert(append_list->tail->next == NULL);
        append_list->tail->next = follow;
        follow->prev = append_list->tail;
        after->next = append_list->head;
        append_list->head->prev = after;

    }

    append_list->head = NULL;
    append_list->tail = NULL;
    assert(token_list->head == NULL || token_list->head->prev == NULL);
}

void token_list_insert_before(struct token_list* token_list, struct token* after, struct token_list* append_list)
{
    token_list_insert_after(token_list, after->prev, append_list);
}

bool token_list_is_equal(const struct token_list* list_a, const struct token_list* list_b)
{
    struct token* _Opt p_tka = list_a->head;
    struct token* _Opt p_tkb = list_b->head;

    while (p_tka && p_tkb)
    {
        if (p_tka->type != p_tkb->type)
            return false;

        if (strcmp(p_tka->lexeme, p_tkb->lexeme) != 0)
            return false;

        p_tka = p_tka->next;
        p_tkb = p_tkb->next;
    }

    return p_tka == NULL && p_tkb == NULL;
}

struct token* token_list_add(struct token_list* list, struct token* _Owner pnew) /*unchecked*/
{
    assert(pnew->next == NULL);
    assert(pnew->prev == NULL);

    if (list->head == NULL)
    {
        pnew->prev = NULL;
        pnew->next = NULL;
        list->head = pnew;
        list->tail = pnew;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);

        pnew->prev = list->tail;
        list->tail->next = pnew;
        list->tail = pnew;
    }
    assert(list->tail != NULL);
    assert(list->tail->next == NULL);

    assert(list->head == NULL || list->head->prev == NULL);

    return list->tail;

}

int is_digit(const struct stream* p)
{
    /*
     digit : one of
     0 1 2 3 4 5 6 7 8 9
    */
    return (p->current[0] >= '0' && p->current[0] <= '9');
}

bool token_is_identifier_or_keyword(enum token_type t)
{
    switch (t)
    {
    case TK_IDENTIFIER: return true;

    case TK_KEYWORD_AUTO:
    case TK_KEYWORD_BREAK:
    case TK_KEYWORD_CASE:
    case TK_KEYWORD_CONSTEXPR:
    case TK_KEYWORD_CHAR:
    case TK_KEYWORD_CONST:
    case TK_KEYWORD_CONTINUE:
    case TK_KEYWORD_CAKE_CATCH: /*extension*/
    case TK_KEYWORD_DEFAULT:
    case TK_KEYWORD_DO:
    case TK_KEYWORD_DEFER: /*extension*/
    case TK_KEYWORD_DOUBLE:
    case TK_KEYWORD_ELSE:
    case TK_KEYWORD_ENUM:
    case TK_KEYWORD_EXTERN:
    case TK_KEYWORD_FLOAT:
    case TK_KEYWORD_FOR:
    case TK_KEYWORD_GOTO:
    case TK_KEYWORD_IF:
    case TK_KEYWORD_INLINE:
    case TK_KEYWORD_INT:
    case TK_KEYWORD_LONG:
    case TK_KEYWORD_MSVC__INT8:
    case TK_KEYWORD_MSVC__INT16:
    case TK_KEYWORD_MSVC__INT32:
    case TK_KEYWORD_MSVC__INT64:

    case TK_KEYWORD_REGISTER:
    case TK_KEYWORD_RESTRICT:
    case TK_KEYWORD_RETURN:
    case TK_KEYWORD_SHORT:
    case TK_KEYWORD_SIGNED:
    case TK_KEYWORD_SIZEOF:

    case TK_KEYWORD_STATIC:
    case TK_KEYWORD_STRUCT:
    case TK_KEYWORD_SWITCH:
    case TK_KEYWORD_TYPEDEF:
    case TK_KEYWORD_CAKE_TRY: /*extension*/
    case TK_KEYWORD_CAKE_THROW: /*extension*/
    case TK_KEYWORD_UNION:
    case TK_KEYWORD_UNSIGNED:
    case TK_KEYWORD_VOID:
    case TK_KEYWORD_VOLATILE:
    case TK_KEYWORD_WHILE:

    case TK_KEYWORD__ALIGNAS:
    case TK_KEYWORD__ALIGNOF:
    case TK_KEYWORD__ATOMIC:
        //microsoft
        //KEYWORD__FASTCALL:
        //KEYWORD__STDCALL
        // 
    case TK_KEYWORD__ASM:
        //end microsoft
    case TK_KEYWORD__BOOL:
    case TK_KEYWORD__COMPLEX:
    case TK_KEYWORD__DECIMAL128:
    case TK_KEYWORD__DECIMAL32:
    case TK_KEYWORD__DECIMAL64:
    case TK_KEYWORD__GENERIC:
    case TK_KEYWORD__IMAGINARY:
    case TK_KEYWORD__NORETURN:
    case TK_KEYWORD__STATIC_ASSERT:
    case TK_KEYWORD_ASSERT: /*extension*/
    case TK_KEYWORD__THREAD_LOCAL:

    case TK_KEYWORD_TYPEOF: /*C23*/

    case TK_KEYWORD_TRUE:  /*C23*/
    case TK_KEYWORD_FALSE:  /*C23*/
    case TK_KEYWORD_NULLPTR:  /*C23*/
    case TK_KEYWORD_TYPEOF_UNQUAL: /*C23*/
    case TK_KEYWORD__BITINT /*C23*/:



        /*cake extension*/
    case TK_KEYWORD_CAKE_OWNER:
    case TK_KEYWORD__CTOR:
    case TK_KEYWORD__DTOR:
    case TK_KEYWORD_CAKE_VIEW:
    case TK_KEYWORD_CAKE_OPT:


        /*extension compile time functions*/
    case TK_KEYWORD_CAKE_STATIC_DEBUG: /*extension*/
    case TK_KEYWORD_CAKE_STATIC_DEBUG_EX: /*extension*/
    case TK_KEYWORD_STATIC_STATE: /*extension*/
    case TK_KEYWORD_STATIC_SET: /*extension*/

        /*https://en.cppreference.com/w/cpp/header/type_traits*/

    case TK_KEYWORD_IS_POINTER:
    case TK_KEYWORD_IS_LVALUE:
    case TK_KEYWORD_IS_CONST:
    case TK_KEYWORD_IS_OWNER:
    case TK_KEYWORD_IS_ARRAY:
    case TK_KEYWORD_IS_FUNCTION:
    case TK_KEYWORD_IS_SCALAR:
    case TK_KEYWORD_IS_ARITHMETIC:
    case TK_KEYWORD_IS_FLOATING_POINT:
    case TK_KEYWORD_IS_INTEGRAL:
        return true;
    default:
        break;
    }

    return false;
}


bool token_is_blank(const struct token* p)
{
    return p->type == TK_BEGIN_OF_FILE ||
        p->type == TK_BLANKS ||
        p->type == TK_LINE_COMMENT ||
        p->type == TK_COMMENT;
}

struct token* _Opt token_list_clone_and_add(struct token_list* list, struct token* pnew)
{
    struct token* _Owner _Opt clone = clone_token(pnew);

    if (clone == NULL)
        return NULL;

    return token_list_add(list, clone);
}

void token_list_append_list_at_beginning(struct token_list* dest, struct token_list* source)
{
    if (source->head == NULL)
    {
        return;
    }

    if (dest->head == NULL)
    {
        dest->head = source->head;
        dest->tail = source->tail;
    }
    else
    {
        assert(source->tail != NULL);
        assert(source->tail->next == NULL);
        source->tail->next = dest->head;
        dest->head = source->head;
    }

    source->head = NULL;
    source->tail = NULL;
    assert(dest->head == NULL || dest->head->prev == NULL);
}

void token_list_append_list(struct token_list* dest, struct token_list* source)
{
    if (source->head == NULL)
    {
        return;
    }
    if (dest->head == NULL)
    {
        dest->head = source->head;
        dest->tail = source->tail;
    }
    else
    {
        assert(dest->tail != NULL);
        assert(dest->tail->next == NULL);
        dest->tail->next = source->head;
        source->head->prev = dest->tail;
        dest->tail = source->tail;
    }
    source->head = NULL;
    source->tail = NULL;
    assert(dest->head == NULL || dest->head->prev == NULL);
}


struct token* _Owner _Opt clone_token(struct token* p)
{
    _Opt struct token* _Owner _Opt token = calloc(1, sizeof * token);
    if (token == NULL)
        return NULL;

    char* _Owner _Opt lexeme = strdup(p->lexeme);
    if (lexeme == NULL)
    {
        free(token);
        return NULL;
    }

    *token = *p;
    token->lexeme = lexeme;
    token->next = NULL;
    token->prev = NULL;

    return token;
}


struct token_list token_list_remove_get(struct token_list* list, struct token* first, struct token* last)
{
    /*
       token_list_remove_get removes a range of tokens from a doubly - linked token list and 
       returns them as a new list.  It does not delete the tokens; it just detaches them from 
       the original list.
    */

    struct token_list r = { 0 };

    struct token* _Opt before_first = first->prev;
    struct token* _Owner _Opt after_last = last->next; /*MOVED*/

    if (before_first)
    {
        before_first->next = after_last;
    }
    else
    {
        list->head = last->next;
    }

    if (after_last)
    {
        after_last->prev = before_first;
    }
    else
    {
        list->tail = NULL;
    }

    last->next = NULL; /*MOVED*/

    r.head = (struct token* _Owner)first;
    first->prev = NULL;
    r.tail = last;


    return r;
}

void token_list_remove(struct token_list* list, struct token* first, struct token* last)
{
    struct token_list r = token_list_remove_get(list, first, last);
    token_list_destroy(&r);
}


bool token_list_is_empty(struct token_list* p)
{
    assert((p->head == NULL && p->tail == NULL) ||
        (p->head != NULL && p->tail != NULL));

    return p->head == NULL;
}

void print_list(struct token_list* list)
{
    struct token* _Opt current = list->head;
    while (current)
    {
        if (current != list->head)
        {
            printf("\xcb\xb0");
            //printf("`");
        }
        print_literal2(current->lexeme);
        printf(RESET);
        if (current == list->tail)
        {
            //printf("`");
        }
        current = current->next;
    }
    printf("\n");
}

void print_literal2(const char* s)
{
    while (*s)
    {
        switch (*s)
        {
        case '\n':
            printf("\\n");
            break;
        default:
            printf("%c", *s);
        }
        s++;
    }
    //printf("`");
}


void print_token(const struct token* p_token)
{
    for (int i = 0; i < p_token->level; i++)
    {
        printf("  ");
    }
    if (p_token->flags & TK_FLAG_FINAL)
        printf(LIGHTGREEN);
    else
        printf(LIGHTGRAY);
    char buffer0[50] = { 0 };
    snprintf(buffer0, sizeof buffer0, "%d:%d", p_token->line, p_token->col);
    printf("%-6s ", buffer0);
    printf("%-20s ", get_token_name(p_token->type));
    if (p_token->flags & TK_FLAG_MACRO_EXPANDED)
    {
        printf(LIGHTCYAN);
    }
    char buffer[50] = { 0 };
    strcat(buffer, "[");
    if (p_token->flags & TK_FLAG_FINAL)
    {
        strcat(buffer, "final ");
    }
    if (p_token->flags & TK_C_BACKEND_FLAG_HIDE)
    {
        strcat(buffer, "hide ");
    }
    if (p_token->flags & TK_FLAG_MACRO_EXPANDED)
    {
        strcat(buffer, "expanded ");
    }
    if (p_token->flags & TK_FLAG_HAS_SPACE_BEFORE)
    {
        strcat(buffer, "space ");
    }
    if (p_token->flags & TK_FLAG_HAS_NEWLINE_BEFORE)
    {
        strcat(buffer, "newline ");
    }
    strcat(buffer, "]");
    printf("%-20s ", buffer);
    print_literal2(p_token->lexeme);
    printf("\n");
    printf(RESET);
}

void print_tokens(const struct token* _Opt p_token)
{
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n" RESET);
    const struct token* _Opt current = p_token;
    while (current)
    {
        print_token(current);
        current = current->next;
    }
    printf("\n");
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n" RESET);
    printf(RESET);
}


void print_token_html(struct token* p_token)
{
    printf("<span class=\"");


    if (!(p_token->flags & TK_FLAG_FINAL))
    {
        printf("notfinal ");
    }

    if (p_token->flags & TK_FLAG_FINAL)
    {
        printf("final ");
    }
    if (p_token->flags & TK_C_BACKEND_FLAG_HIDE)
    {
        printf("hide ");
    }
    if (p_token->flags & TK_FLAG_MACRO_EXPANDED)
    {
        printf("expanded ");
    }
    if (p_token->flags & TK_FLAG_HAS_SPACE_BEFORE)
    {
        printf("space ");
    }
    if (p_token->flags & TK_FLAG_HAS_NEWLINE_BEFORE)
    {
        printf("newline ");
    }

    printf("\">");

    print_literal2(p_token->lexeme);

    printf("</span>");

    if (p_token->type == TK_NEWLINE || p_token->type == TK_BEGIN_OF_FILE)
    {
        printf("<br>\n");
    }
}

/*
 CSS for html ouput

 <style>
        .final {
          color:blue;
        }

        .notfinal {
          color:gray;
        }

        .hide {
          text-decoration: line-through;
          color:red;
        }

        .expanded {
           background-color:yellow;
        }

        span {
            border-style: solid;
            border-color: gray;
            border-width: 1px 1px;
            padding:1px;
            margin:2px;
        }

</style>

*/
void print_tokens_html(struct token* p_token)
{
    printf("<pre>\n");
    struct token* _Opt current = p_token;
    while (current)
    {
        print_token_html(current);
        current = current->next;
    }
    printf("\n</pre>");
}

void print_position(const char* path, int line, int col, bool visual_studio_ouput_format)
{

    if (visual_studio_ouput_format)
    {
        //MSVC format
        printf("%s(%d,%d): ", path ? path : "<>", line, col);
    }
    else
    {
        //GCC format
        printf(WHITE "%s:%d:%d: ", path ? path : "<>", line, col);
    }
}

void print_line_and_token(struct marker* p_marker, bool visual_studio_ouput_format)
{

    try
    {
        const struct token* _Opt p_token = p_marker->p_token_caret ? p_marker->p_token_caret : p_marker->p_token_begin;

        if (p_token == NULL)
            throw;

        const int line = p_marker->line;

        if (!visual_studio_ouput_format)
            printf(RESET);

        char nbuffer[20] = { 0 };
        int n = snprintf(nbuffer, sizeof nbuffer, "%d", line);
        printf(" %s |", nbuffer);


        //lets find the begin of line
        const struct token* p_line_begin = p_token;
        while (p_line_begin->prev && (p_line_begin->prev->type != TK_NEWLINE && p_line_begin->prev->type != TK_BEGIN_OF_FILE))
        {
            p_line_begin = p_line_begin->prev;
        }


        const struct token* _Opt p_token_begin = p_marker->p_token_begin ? p_marker->p_token_begin : p_marker->p_token_caret;
        const struct token* _Opt p_token_end = p_marker->p_token_end ? p_marker->p_token_end : p_marker->p_token_caret;

        if (p_token_begin == NULL)
            throw;


        //only expand macros if the error is inside
        const bool expand_macro = p_token_begin->flags & TK_FLAG_MACRO_EXPANDED;

        if (!visual_studio_ouput_format)
            printf(LIGHTBLUE);

        const struct token* _Opt p_item = p_line_begin;
        while (p_item)
        {
            if (!visual_studio_ouput_format)
            {
                if (p_item->flags & TK_FLAG_MACRO_EXPANDED)
                {
                    printf(DARKGRAY);
                }
                else if (p_item->type >= TK_KEYWORD_AUTO &&
                         p_item->type <= TK_KEYWORD_IS_INTEGRAL)
                {
                    printf(BLUE);
                }
                else if (p_item->type == TK_COMMENT ||
                         p_item->type == TK_LINE_COMMENT)
                {
                    printf(YELLOW);
                }
            }

            if (!(p_item->flags & TK_FLAG_MACRO_EXPANDED) || expand_macro)
            {
                const char* p = p_item->lexeme;
                while (*p)
                {
                    putc(*p, stdout);
                    p++;
                }
            }

            if (!visual_studio_ouput_format)
            {
                printf(RESET);
            }

            if (p_item->type == TK_NEWLINE)
                break;
            p_item = p_item->next;
        }

        if (!visual_studio_ouput_format)
            printf(RESET);

        if (p_item == NULL) printf("\n");

        printf(" %*s |", n, " ");
        bool complete = false;
        int start_col = 1;
        int end_col = 1;
        bool onoff = false;
        p_item = p_line_begin;
        while (p_item)
        {
            if (p_item == p_token_begin)
            {
                if (!visual_studio_ouput_format)
                    printf(LIGHTGREEN);
                onoff = true;
                end_col = start_col;
            }

            if (!(p_item->flags & TK_FLAG_MACRO_EXPANDED) || expand_macro)
            {
                const char* p = p_item->lexeme;
                while (*p)
                {

                    if (onoff)
                    {
                        putc('~', stdout);
                        end_col++;
                    }
                    else
                    {
                        putc(' ', stdout);
                        if (!complete) start_col++;
                    }
                    p++;
                }
            }

            if (p_item->type == TK_NEWLINE)
                break;

            if (p_item == p_token_end)
            {
                complete = true;
                onoff = false;
                if (!visual_studio_ouput_format)
                    printf(RESET);
            }

            p_item = p_item->next;
        }

        if (!visual_studio_ouput_format)
            printf(RESET);

        printf("\n");
        p_marker->start_col = start_col;
        p_marker->end_col = end_col;
    }
    catch
    {
    }
}

static void digit_sequence_opt(struct stream* stream)
{
    while (is_digit(stream))
    {
        stream_match(stream);
    }
}

static void binary_exponent_part(struct stream* stream)
{
    // p signopt digit - sequence
    // P   signopt digit - sequence

    stream_match(stream); // p or P
    if (stream->current[0] == '+' || stream->current[0] == '-')
    {
        stream_match(stream); // p or P
    }
    digit_sequence_opt(stream);
}

static bool is_hexadecimal_digit(struct stream* stream)
{
    return (stream->current[0] >= '0' && stream->current[0] <= '9') ||
        (stream->current[0] >= 'a' && stream->current[0] <= 'f') ||
        (stream->current[0] >= 'A' && stream->current[0] <= 'F');
}

static bool is_octal_digit(struct stream* stream)
{
    return stream->current[0] >= '0' && stream->current[0] <= '7';
}

static void hexadecimal_digit_sequence(struct stream* stream)
{
    /*
     hexadecimal-digit-sequence:
     hexadecimal-digit
     hexadecimal-digit ’_Opt hexadecimal-digit
    */

    stream_match(stream);
    while (stream->current[0] == '\'' ||
        is_hexadecimal_digit(stream))
    {
        if (stream->current[0] == '\'')
        {
            stream_match(stream);
            if (!is_hexadecimal_digit(stream))
            {
                // erro
            }
            stream_match(stream);
        }
        else
            stream_match(stream);
    }
}

static void integer_suffix_opt(struct stream* stream, char suffix[4])
{
    /*
        (6.4.4.2) integer-suffix:
          unsigned-suffix long-suffixopt
          unsigned-suffix long-long-suffix
          unsigned-suffix bit-precise-int-suffix
          long-suffix unsigned-suffixopt
          long-long-suffix unsigned-suffixopt
          bit-precise-int-suffix unsigned-suffixop
    */

    //test 3100
    if (/*unsigned-suffix*/
        stream->current[0] == 'U' || stream->current[0] == 'u')
    {
        suffix[0] = 'U';
        stream_match(stream);


        /*long-suffixopt*/
        if (stream->current[0] == 'l' || stream->current[0] == 'L')
        {
            suffix[1] = 'L';
            stream_match(stream);
        }

        /*long-long-suffix*/
        if (stream->current[0] == 'l' || stream->current[0] == 'L')
        {
            suffix[2] = 'L';
            stream_match(stream);
        }
    }
    else if ((stream->current[0] == 'l' || stream->current[0] == 'L'))
    {
        suffix[0] = 'L';

        /*long-suffix*/
        stream_match(stream);

        /*long-long-suffix*/
        if ((stream->current[0] == 'l' || stream->current[0] == 'L'))
        {
            suffix[1] = 'L';
            stream_match(stream);
        }

        if (/*unsigned-suffix*/
            stream->current[0] == 'U' || stream->current[0] == 'u')
        {

            //normalize the output from LLU to ul 
            suffix[3] = suffix[2];
            suffix[2] = suffix[1];
            suffix[1] = suffix[0];
            suffix[0] = 'U';
            stream_match(stream);
        }
    }
    ///////////////MICROSOFT ////////////////////////
        //TODO unit test
    else if (stream->current[0] == 'i' &&
             stream->current[1] == '8')
    {
        stream_match(stream);
        stream_match(stream);
        stream_match(stream);
        suffix[0] = 'i';
        suffix[1] = '8';
    }
    else if (stream->current[0] == 'i' &&
             stream->current[1] == '3' &&
             stream->current[2] == '2')
    {
        stream_match(stream);
        stream_match(stream);
        stream_match(stream);
        suffix[0] = 'i';
        suffix[1] = '3';
        suffix[2] = '2';
    }
    else if (stream->current[0] == 'i' &&
             stream->current[1] == '6' &&
             stream->current[2] == '4')
    {
        stream_match(stream);
        stream_match(stream);
        stream_match(stream);
        suffix[0] = 'i';
        suffix[1] = '6';
        suffix[2] = '4';
    }
    ///////////////MICROSOFT ////////////////////////
}

static void exponent_part_opt(struct stream* stream)
{
    /*
    exponent-part:
    e signopt digit-sequence
    E signopt digit-sequence
    */
    if (stream->current[0] == 'e' || stream->current[0] == 'E')
    {
        stream_match(stream);

        if (stream->current[0] == '-' || stream->current[0] == '+')
        {
            stream_match(stream);
        }
        digit_sequence_opt(stream);
    }
}

static void floating_suffix_opt(struct stream* stream, char suffix[4])
{

    if (stream->current[0] == 'l' || stream->current[0] == 'L')
    {
        suffix[0] = 'L';
        stream_match(stream);
    }
    else if (stream->current[0] == 'f' || stream->current[0] == 'F')
    {
        suffix[0] = 'F';
        stream_match(stream);
    }
}

static bool is_binary_digit(struct stream* stream)
{
    return stream->current[0] >= '0' && stream->current[0] <= '1';
}

static bool is_nonzero_digit(struct stream* stream)
{
    return stream->current[0] >= '1' && stream->current[0] <= '9';
}

enum token_type parse_number_core(struct stream* stream, char suffix[4], _Ctor char errmsg[100])
{
    errmsg[0] = '\0';

    enum token_type type = TK_NONE;
    if (stream->current[0] == '.')
    {
        type = TK_COMPILER_DECIMAL_FLOATING_CONSTANT;
        stream_match(stream);

        if (stream->current[0] == '.')
        {
            snprintf(errmsg, 100, "too many decimal points in number");
            return TK_NONE;
        }

        digit_sequence_opt(stream);
        exponent_part_opt(stream);
        floating_suffix_opt(stream, suffix);
    }
    else if (stream->current[0] == '0' && (stream->current[1] == 'x' || stream->current[1] == 'X'))
    {
        type = TK_COMPILER_HEXADECIMAL_CONSTANT;

        stream_match(stream);
        stream_match(stream);

        if (is_hexadecimal_digit(stream))
        {
            while (is_hexadecimal_digit(stream))
            {
                stream_match(stream);
            }
        }
        else
        {
            snprintf(errmsg, 100, "expected hexadecimal digit");
            return TK_NONE;
        }

        integer_suffix_opt(stream, suffix);

        if (stream->current[0] == '.')
        {
            type = TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT;
            hexadecimal_digit_sequence(stream);
        }

        if (stream->current[0] == 'p' ||
            stream->current[0] == 'P')
        {
            type = TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT;
            binary_exponent_part(stream);
        }

        if (type == TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT)
        {
            floating_suffix_opt(stream, suffix);
        }
    }
    else if (stream->current[0] == '0' && (stream->current[1] == 'b' || stream->current[1] == 'B'))
    {
        type = TK_COMPILER_BINARY_CONSTANT;
        stream_match(stream);
        stream_match(stream);
        if (is_binary_digit(stream))
        {
            while (is_binary_digit(stream))
            {
                stream_match(stream);
            }
        }
        else
        {
            snprintf(errmsg, 100, "expected binary digit");
            return TK_NONE;
        }
        integer_suffix_opt(stream, suffix);
    }
    else if (stream->current[0] == '0') // octal
    {
        type = TK_COMPILER_OCTAL_CONSTANT;

        stream_match(stream);

        if (stream->current[0] == 'O' || stream->current[0] == 'o')
        {
            //C2Y
            //https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3319.htm
            stream_match(stream);
        }

        while (is_octal_digit(stream))
        {
            stream_match(stream);
        }
        integer_suffix_opt(stream, suffix);

        if (stream->current[0] == '.')
        {
            type = TK_COMPILER_DECIMAL_FLOATING_CONSTANT;
            hexadecimal_digit_sequence(stream);
            floating_suffix_opt(stream, suffix);
        }
    }
    else if (is_nonzero_digit(stream)) // decimal
    {
        type = TK_COMPILER_DECIMAL_CONSTANT;

        stream_match(stream);
        while (is_digit(stream))
        {
            stream_match(stream);
        }
        integer_suffix_opt(stream, suffix);

        if (stream->current[0] == 'e' || stream->current[0] == 'E')
        {
            exponent_part_opt(stream);
            floating_suffix_opt(stream, suffix);

        }
        else if (stream->current[0] == '.')
        {
            stream_match(stream);
            type = TK_COMPILER_DECIMAL_FLOATING_CONSTANT;

            if (stream->current[0] == '.')
            {
                snprintf(errmsg, 100, "too many decimal points in number");
                return TK_NONE;
            }

            digit_sequence_opt(stream);

            exponent_part_opt(stream);
            floating_suffix_opt(stream, suffix);
        }
    }

    return type;
}

enum token_type parse_number(const char* lexeme, char suffix[4], _Ctor char errmsg[100])
{
    struct stream stream = {
        .source = lexeme,
        .current = lexeme,
        .line = 1,
        .col = 1,
        .path = "",
    };

    return parse_number_core(&stream, suffix, errmsg);
}

/*
    https://en.wikipedia.org/wiki/UTF-8
    Since the restriction of the Unicode code-space to 21-bit values in 2003,
    UTF-8 is defined to encode code points in one to four bytes, depending on the number
    of significant bits in the numerical value of the code point. The following table shows
    the structure of the encoding. The x characters are replaced by the bits of the code point.

    Code point <->UTF - 8 conversion
    First         | Last           | Byte 1   | Byte 2   | Byte 3   | Byte 4
    --------------| -------------- |----------|----------|----------| ----------
    U+0000      0 | U+007F     127 | 0xxxxxxx |          |          |
    U+0080    128 | U+07FF    2047 | 110xxxxx | 10xxxxxx |          |
    U+0800   2048 | U+FFFF   65535 | 1110xxxx | 10xxxxxx | 10xxxxxx |
    U+10000 65536 | U+10FFFF 69631 | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx
*/

const unsigned char* _Opt utf8_decode(const unsigned char* s, _Ctor unsigned int* c)
{
    *c = 0; //out

    if (s[0] == '\0')
    {
        *c = 0;
        return NULL; /*end*/
    }

    const unsigned char* _Opt next = NULL;
    if (s[0] < 0x80)
    {
        *c = s[0];
        assert(*c >= 0x0000 && *c <= 0x007F);
        next = s + 1;
    }
    else if ((s[0] & 0xe0) == 0xc0)
    {
        *c = ((int)(s[0] & 0x1f) << 6) |
            ((int)(s[1] & 0x3f) << 0);
        assert(*c >= 0x0080 && *c <= 0x07FF);
        next = s + 2;
    }
    else if ((s[0] & 0xf0) == 0xe0)
    {
        *c = ((int)(s[0] & 0x0f) << 12) |
            ((int)(s[1] & 0x3f) << 6) |
            ((int)(s[2] & 0x3f) << 0);
        assert(*c >= 0x0800 && *c <= 0xFFFF);
        next = s + 3;
    }
    else if ((s[0] & 0xf8) == 0xf0 && (s[0] <= 0xf4))
    {
        *c = ((int)(s[0] & 0x07) << 18) |
            ((int)(s[1] & 0x3f) << 12) |
            ((int)(s[2] & 0x3f) << 6) |
            ((int)(s[3] & 0x3f) << 0);
        assert(*c >= 0x10000 && *c <= 0x10FFFF);
        next = s + 4;
    }
    else
    {
        *c = 0;      // invalid
        next = s + 1; // skip this byte
    }

    if (*c >= 0xd800 && *c <= 0xdfff)
    {
        *c = 0; // surrogate half
    }

    return next;
}

static bool is_hex_digit(unsigned char c)
{
    if (c >= '0' && c <= '9')
        return true;
    else if (c >= 'a' && c <= 'f')
        return true;
    else if (c >= 'A' && c <= 'F')
        return true;
    return false;
}

const unsigned char* _Opt escape_sequences_decode_opt(const unsigned char* p, unsigned int* out_value)
{
    // TODO OVERFLOW CHECK
    if (*p == 'x')
    {
        p++;
        int result = 0;
        while (is_hex_digit(*p))
        {
            int byte = 0;
            if (*p >= '0' && *p <= '9')
                byte = (*p - '0');
            else if (*p >= 'a' && *p <= 'f')
                byte = (*p - 'a') + 10;
            else if (*p >= 'A' && *p <= 'F')
                byte = (*p - 'A') + 10;

            result = (result << 4) | (byte & 0xF);
            p++;
        }

        *out_value = result;
    }
    else if (*p == 'u' || *p == 'U')
    {
        // TODO  assuming input is checked
        // missing tests
        const int num_of_hex_digits = *p == 'U' ? 8 : 4;

        p++;
        unsigned long long result = 0;
        for (int i = 0; i < num_of_hex_digits; i++)
        {
            int byte = 0;
            if (*p >= '0' && *p <= '9')
                byte = (*p - '0');
            else if (*p >= 'a' && *p <= 'f')
                byte = (*p - 'a') + 10;
            else if (*p >= 'A' && *p <= 'F')
                byte = (*p - 'A') + 10;

            result = (result << 4) | (byte & 0xF);
            p++;
        }

        *out_value = (int)result;
    }
    else if (*p == '0')
    {
        // octal digit
        p++;

        int result = 0;
        while ((*p >= '0' && *p <= '7'))
        {
            int byte;
            byte = (*p - '0');
            result = (result << 4) | (byte & 0xF);
            p++;
        }
        *out_value = result;
    }
    else
    {
        switch (*p)
        {
        case 'a':
            *out_value = '\a';
            break;
        case 'b':
            *out_value = '\b';
            break;
        case 'f':
            *out_value = '\f';
            break;
        case 'n':
            *out_value = '\n';
            break;
        case 'r':
            *out_value = '\r';
            break;
            ;
        case 't':
            *out_value = '\t';
            break;
        case '\'':
            *out_value = '\'';
            break;
        case '\\':
            *out_value = '\\';
            break;
        case '"':
            *out_value = '"';
            break;
        default:
            // this is handled at tokenizer
            assert(false);
            return NULL;
        }
        p++;
    }

    return p;
}

#ifdef TEST

void token_list_remove_get_test()
{
    struct token_list list = { 0 };
    struct token* pnew = calloc(1, sizeof * pnew);
    token_list_add(&list, pnew);
    struct token_list r = token_list_remove_get(&list, pnew, pnew);
    assert(list.head == NULL);
    assert(list.tail == NULL);
}

void token_list_remove_get_test2()
{
    struct token_list list = { 0 };
    struct token* pnew1 = calloc(1, sizeof * pnew1);
    token_list_add(&list, pnew1);
    struct token* pnew2 = calloc(1, sizeof * pnew2);
    token_list_add(&list, pnew2);

    struct token_list r = token_list_remove_get(&list, pnew1, pnew1);
    assert(list.head == pnew2);
    assert(list.tail == pnew2);
}


#endif


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

#pragma safety enable


#ifdef _WIN32
#endif

#if defined _MSC_VER
#endif

static unsigned int string_hash(const char* key)
{
    // hash key to unsigned int value by pseudorandomizing transform
    // (algorithm copied from STL char hash in xfunctional)
    unsigned int hash_val = 2166136261U;
    unsigned int first = 0;
    unsigned int last = (unsigned int)strlen(key);
    unsigned int stride = 1 + last / 10;

    for (; first < last; first += stride)
    {
        hash_val = 16777619U * hash_val ^ (unsigned int)key[first];
    }

    return (hash_val);
}


void map_entry_delete(struct map_entry* _Owner _Opt p)
{
    if (p == NULL)
        return;

    switch (p->type)
    {
    case TAG_TYPE_NUMBER:break;

    case TAG_TYPE_ENUN_SPECIFIER:
        enum_specifier_delete(p->data.p_enum_specifier);
        break;
    case TAG_TYPE_STRUCT_OR_UNION_SPECIFIER:
        struct_or_union_specifier_delete(p->data.p_struct_or_union_specifier);
        break;

    case TAG_TYPE_ENUMERATOR:
        enumerator_delete(p->data.p_enumerator);
        break;
    case TAG_TYPE_DECLARATOR:
        declarator_delete(p->data.p_declarator);
        break;
    case TAG_TYPE_INIT_DECLARATOR:
        init_declarator_delete(p->data.p_init_declarator);
        break;
    case TAG_TYPE_MACRO:
        macro_delete(p->data.p_macro);
        break;

    case TAG_TYPE_STRUCT_ENTRY:
        struct_entry_delete(p->data.p_struct_entry);
        break;
    }

    free(p->key);
    free(p);
}

void hashmap_remove_all(struct hash_map* map)
{

    if (map->table != NULL)
    {
        for (int i = 0; i < map->capacity; i++)
        {
            struct map_entry* _Owner _Opt pentry = map->table[i];

            while (pentry != NULL)
            {
                struct map_entry* _Owner _Opt next = pentry->next;
                map_entry_delete(pentry);
                pentry = next;
            }
        }

        free(map->table);
        map->table = NULL;
        map->size = 0;
    }
}

void hashmap_destroy(_Dtor struct hash_map* map)
{
    hashmap_remove_all(map);
    assert(map->table == NULL);
}

struct map_entry* _Opt hashmap_find(struct hash_map* map, const char* key)
{
    if (map->table == NULL)
        return NULL;

    const unsigned int hash = string_hash(key);
    const int index = hash % map->capacity;

    struct map_entry* _Opt pentry = map->table[index];

    for (; pentry != NULL; pentry = pentry->next)
    {
        if (pentry->hash == hash && strcmp(pentry->key, key) == 0)
        {
            return pentry;
        }
    }

    return NULL;
}


void* _Opt hashmap_remove(struct hash_map* map, const char* key, enum tag* _Opt p_type_opt)
{
    if (map->table != NULL)
    {
        const unsigned int hash = string_hash(key);
        struct map_entry** pp_entry = &map->table[hash % map->capacity];
        struct map_entry* _Opt p_entry = *pp_entry;

        for (; p_entry != NULL; p_entry = p_entry->next)
        {
            if ((p_entry->hash == hash) && (strcmp(p_entry->key, key) == 0))
            {
                *pp_entry = p_entry->next;

                if (p_type_opt)
                    *p_type_opt = p_entry->type;

                void* _Opt p = p_entry->data.p_declarator;
                free((void* _Owner)p_entry->key);
                free((void* _Owner)p_entry);

                return p;
            }
            pp_entry = &p_entry->next;
        }
    }

    return NULL;
}

void hash_item_set_destroy(_Dtor struct hash_item_set* p)
{
    declarator_delete(p->p_declarator);
    enumerator_delete(p->p_enumerator);
    enum_specifier_delete(p->p_enum_specifier);
    init_declarator_delete(p->p_init_declarator);
    struct_or_union_specifier_delete(p->p_struct_or_union_specifier);
    macro_delete(p->p_macro);

}

int hashmap_set(struct hash_map* map, const char* key, struct hash_item_set* item /*in out*/)
{
    int result = 0;

    void* _Opt p = NULL;
    enum tag type = TAG_TYPE_NUMBER;
    if (item->p_declarator)
    {
        type = TAG_TYPE_DECLARATOR;
        p = item->p_declarator;
        item->p_declarator = NULL;//

    }
    else if (item->p_enumerator)
    {
        type = TAG_TYPE_ENUMERATOR;
        p = item->p_enumerator;
        item->p_enumerator = NULL;

    }
    else if (item->p_enum_specifier)
    {
        type = TAG_TYPE_ENUN_SPECIFIER;
        p = item->p_enum_specifier;
        item->p_enum_specifier = NULL;

    }
    else if (item->p_init_declarator)
    {
        type = TAG_TYPE_INIT_DECLARATOR;
        p = item->p_init_declarator;
        item->p_init_declarator = NULL;

    }
    else if (item->p_struct_or_union_specifier)
    {
        type = TAG_TYPE_STRUCT_OR_UNION_SPECIFIER;
        p = item->p_struct_or_union_specifier;
        item->p_struct_or_union_specifier = NULL;

    }
    else if (item->p_macro)
    {
        type = TAG_TYPE_MACRO;
        p = item->p_macro;
        item->p_macro = NULL;
    }
    else if (item->p_struct_entry)
    {
        type = TAG_TYPE_STRUCT_ENTRY;
        p = item->p_struct_entry;
        item->p_struct_entry = NULL;
    }
    else //if (item->number)
    {
        type = TAG_TYPE_NUMBER;
        p = (void*)item->number;
    }
    // else
    // {
     //    assert(false);
     //}

    try
    {
        if (map->table == NULL)
        {
            if (map->capacity < 1)
            {
                map->capacity = 1000;
            }

            map->table = calloc(map->capacity, sizeof(map->table[0]));
            if (map->table == NULL) throw;
        }

        if (map->table != NULL)
        {
            unsigned int hash = string_hash(key);
            int index = hash % map->capacity;

            struct map_entry* _Opt pentry = map->table[index];

            for (; pentry != NULL; pentry = pentry->next)
            {
                if (pentry->hash == hash && strcmp(pentry->key, key) == 0)
                {
                    break;
                }
            }

            if (pentry == NULL)
            {
                struct map_entry* _Owner _Opt p_new_entry = calloc(1, sizeof(*pentry));
                if (p_new_entry == NULL) throw;

                p_new_entry->hash = hash;

                p_new_entry->data.p_declarator = (void*)p;

                p_new_entry->type = type;

                char* _Opt _Owner temp_key = strdup(key);
                if (temp_key == NULL)
                {
                    map_entry_delete(p_new_entry);
                    throw;
                }

                p_new_entry->key = temp_key;
                p_new_entry->next = map->table[index];
                map->table[index] = p_new_entry;
                map->size++;
                result = 0;
            }
            else
            {
                switch (pentry->type)
                {
                case TAG_TYPE_NUMBER:break;

                case TAG_TYPE_ENUN_SPECIFIER:
                    assert(pentry->data.p_enum_specifier != NULL);
                    item->p_enum_specifier = pentry->data.p_enum_specifier;
                    break;
                case TAG_TYPE_STRUCT_OR_UNION_SPECIFIER:
                    assert(pentry->data.p_struct_or_union_specifier != NULL);
                    item->p_struct_or_union_specifier = pentry->data.p_struct_or_union_specifier;
                    break;

                case TAG_TYPE_ENUMERATOR:
                    assert(pentry->data.p_enumerator != NULL);
                    item->p_enumerator = pentry->data.p_enumerator;
                    break;
                case TAG_TYPE_DECLARATOR:
                    assert(pentry->data.p_declarator != NULL);
                    item->p_declarator = pentry->data.p_declarator;
                    break;
                case TAG_TYPE_INIT_DECLARATOR:
                    assert(pentry->data.p_init_declarator != NULL);
                    item->p_init_declarator = pentry->data.p_init_declarator;
                    break;
                case TAG_TYPE_MACRO:
                    assert(pentry->data.p_macro != NULL);
                    item->p_macro = pentry->data.p_macro;
                    break;
                case TAG_TYPE_STRUCT_ENTRY:
                    assert(pentry->data.p_struct_entry != NULL);
                    item->p_struct_entry = pentry->data.p_struct_entry;
                    break;
                }

                result = 1;
                pentry->data.p_declarator = (void*)p;
                pentry->type = type;
            }
        }
    }
    catch
    {
    }
    return result;
}



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable


#ifdef _WIN32


#include <conio.h>
#else


#include <termios.h>


#include <unistd.h>


#include <fcntl.h>


#include <sys/ioctl.h>
#endif

#ifndef WIN32

bool enable_vt_mode(void)
{
    return true;
}

int c_kbhit(void)
{
    struct termios oldt = { 0 };
    struct termios newt = { 0 };
    int ch;
    int oldf;

    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
    oldf = fcntl(STDIN_FILENO, F_GETFL, 0);
    fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK);

    ch = getchar();

    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    fcntl(STDIN_FILENO, F_SETFL, oldf);

    if (ch != EOF)
    {
        ungetc(ch, stdin);
        return 1;
    }

    return 0;
}

/* Read 1 character without echo */
int c_getch(void)
{
    struct termios old = { 0 };
    struct termios new = { 0 };
    int ch;

    tcgetattr(0, &old);

    new = old;
    new.c_lflag &= ~ICANON;
    new.c_lflag &= ~ECHO;
    tcsetattr(0, TCSANOW, &new);

    ch = getchar();

    tcsetattr(0, TCSANOW, &old);

    return ch;
}

#else

bool enable_vt_mode(void)
{
    //missing in mingw (installed with codeblocs)
#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING  
#define ENABLE_VIRTUAL_TERMINAL_PROCESSING  0x0004
#endif

    DWORD mode = 0;
    HANDLE h_out = GetStdHandle(STD_OUTPUT_HANDLE);
    if (h_out != INVALID_HANDLE_VALUE &&
            GetConsoleMode(h_out, &mode) != 0 &&
            SetConsoleMode(h_out, mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING) != 0 &&
            SetConsoleOutputCP(CP_UTF8) != 0)
    {
        return true;//ok
    }
    return false;//error
}

int c_kbhit(void)
{
    return _kbhit();
}
int c_getch(void)
{
    return _getch();
}

#endif

void c_clrscr()
{
    puts("\x1b[2J\x1b[1;1H");
    puts("\x1b[3J");
    fflush(stdout);
}

void c_gotoxy(int x, int y)
{
    printf("\x1b[%d;%dH", y, x);
    fflush(stdout);
}

/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma safety enable

/*

   1 - The initial input is a string.
   2 - This string is transformed into a linked list of tokens

   ┌───┐   ┌───┐   ┌───┐   ┌───┐
   │   ├──►│   ├──►│   ├──►│   │──► NULL
   └───┘   └───┘   └───┘   └───┘

   The list is then expanded using includes and macros through a preprocessor.


   ┌───┐                  ┌───┐   ┌───┐   ┌───┐
   │   ├──────┐           │   ├──►│x  ├──►│x  │ ──► NULL   Level 0
   └───┘      │           └───┘   └───┘   └───┘
            ┌─▼─┐   ┌───┐   ▲
            │   ├───┤   ├───┘  (includes)                  Level 1
            └───┘   └───┘


    Each item in the list has additional properties:

    level         :  An integer indicating the level of inclusion.

    bmacroexpanded: A boolean indicating whether the token was generated
                    from macro expansion.

    bfinal        : A boolean indicating whether the token is the
                    final, the one seen by the parser.

*/



#include <ctype.h>


#include <sys/stat.h>


#include <errno.h>


#include <stddef.h>


#include <time.h>


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

//#pragma once
 

#ifdef _WIN32 


#include <direct.h>


#include <sys/types.h>

#ifdef __CAKE__
#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wstyle"
#endif


//https://docs.microsoft.com/pt-br/cpp/c-runtime-library/reference/mkdir-wmkdir?_View=msvc-160
#define mkdir(a, b) _mkdir(a)
#define rmdir _rmdir
#define chdir _chdir

#ifdef __CAKE__
#pragma cake diagnostic pop
#endif

/*
 opendir,  readdir closedir for windows.
 include dirent.h on linux
*/



enum
{
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
};

struct dirent
{
    ino_t d_ino;             /* Inode number */
    off_t d_off;             /* Not an offset; see below */
    unsigned short d_reclen; /* Length of this record */
    unsigned char d_type;    /* Type of file; not supported
                                     by all filesystem types*/
    char d_name[256];        /* Null-terminated filename */
};

#ifdef __CAKE__
#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wstyle"
#endif
struct TAGDIR;
typedef struct TAGDIR DIR;

#ifdef __CAKE__
#pragma CAKE diagnostic pop
#endif

DIR* _Owner _Opt opendir(const char* name);
int closedir(DIR* _Owner dirp);
struct dirent* _Opt readdir(DIR* dirp);


#else

//TODO fails on macos because it has a diferent declaration
//typedef struct __dirstream DIR;
//DIR * _Owner _Opt opendir (const char *__name);
//int closedir(DIR* _Owner dirp);


#define MAX_PATH 500

//https://man7.org/linux/man-pages/man2/mkdir.2.html


#include <dirent.h>
#endif



char* _Opt realpath(const char* restrict path, char* restrict resolved_path);

int get_self_path(char* buffer, int maxsize);

char* _Owner _Opt read_file(const char* path, bool append_newline);
char* dirname(char* path);
char* basename(const char* filename);

const char* get_posix_error_message(int error);


bool path_is_relative(const char* path);
bool path_is_absolute(const char* path);
void path_normalize(char* path);
bool path_is_normalized(const char* path);




/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

//#pragma once

struct preprocessor_ctx;

int pre_constant_expression(struct preprocessor_ctx* ctx, long long* pvalue);



#ifdef _WIN32
#endif

#if defined _MSC_VER && !defined __POCC__
#endif

#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)


// Includes tokens that are not necessary for compilation at second level of includes
enum { INCLUDE_ALL = 1 };

///////////////////////////////////////////////////////////////////////////////
void naming_convention_macro(struct preprocessor_ctx* ctx, struct token* token);
///////////////////////////////////////////////////////////////////////////////

static bool is_builtin_macro(const char* name);


struct macro_parameter
{
    const char* _Owner name;
    struct macro_parameter* _Owner _Opt next;

    /*
      https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3457.htm#number-of-expansions
      For each such parameter this expansion is performed exactly once
      (this list and flag are clean and reused when performing argument expansion)
    */
    struct token_list expanded_list;
    bool already_expanded;
};



struct macro
{
    const struct token* p_name_token;
    const char* _Owner name;
    struct token_list replacement_list; /*copy*/
    struct macro_parameter* _Owner _Opt parameters;
    bool is_function;
    int usage;


    bool def_macro;
};


void macro_delete(struct macro* _Owner _Opt macro);
bool macro_is_same(const struct macro* macro_a, const struct macro* macro_b);


void include_dir_list_destroy(_Dtor struct include_dir_list* list)
{
    struct include_dir* _Owner _Opt p = list->head;
    while (p)
    {
        struct include_dir* _Owner _Opt next = p->next;
        free((void* _Owner)p->path);
        free(p);
        p = next;
    }
}

void preprocessor_ctx_destroy(_Dtor struct preprocessor_ctx* p)
{
    hashmap_destroy(&p->macros);
    include_dir_list_destroy(&p->include_dir);
    hashmap_destroy(&p->pragma_once_map);
    token_list_destroy(&p->input_list);
}

struct token_list preprocessor(struct preprocessor_ctx* ctx, struct token_list* input_list, int level);

static void tokenizer_set_error(struct tokenizer_ctx* ctx, struct stream* stream, const char* fmt, ...)
{
    ctx->n_errors++;

    char buffer[200] = { 0 };

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"



    va_list args = { 0 };
    va_start(args, fmt);
    /*int n =*/ vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);

#pragma CAKE diagnostic pop

    print_position(stream->path, stream->line, stream->col, ctx->options.visual_studio_ouput_format);
    if (ctx->options.visual_studio_ouput_format)
    {
        printf("error: "  "%s\n", buffer);
    }
    else
    {
        printf(LIGHTRED "error: " WHITE "%s\n", buffer);
    }
}


static void tokenizer_set_warning(struct tokenizer_ctx* ctx, struct stream* stream, const char* fmt, ...)
{
    ctx->n_warnings++;


    char buffer[200] = { 0 };

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"


    va_list args = { 0 };
    va_start(args, fmt);
    /*int n =*/ vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);

#pragma CAKE diagnostic pop

    print_position(stream->path, stream->line, stream->col, ctx->options.visual_studio_ouput_format);
    if (ctx->options.visual_studio_ouput_format)
    {
        printf("warning: " "%s\n", buffer);
    }
    else
    {
        printf(LIGHTMAGENTA "warning: " WHITE "%s\n", buffer);
    }

}


void pre_unexpected_end_of_file(struct token* _Opt p_token, struct preprocessor_ctx* ctx)
{
    preprocessor_diagnostic(C_ERROR_UNEXPECTED_TOKEN,
        ctx,
        p_token,
        "unexpected end of file");
}

bool preprocessor_diagnostic(enum diagnostic_id w, struct preprocessor_ctx* ctx, const struct token* _Opt p_token_opt, const char* fmt, ...)
{
    struct marker marker = { 0 };

    if (p_token_opt == NULL) return false;

    marker.file = p_token_opt->token_origin->lexeme;
    marker.line = p_token_opt->line;
    marker.start_col = p_token_opt->col;
    marker.end_col = p_token_opt->col;
    marker.p_token_caret = p_token_opt;

    /*warnings inside headers are ignored*/
    const bool included_file_location = p_token_opt->level > 0;

    bool is_error = false;
    bool is_warning = false;
    bool is_note = false;

    if (w > W_NOTE)
    {
        is_error = true;
    }
    else
    {
        is_error =
            (ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors & (1ULL << w)) != 0;

        is_warning =
            (ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings & (1ULL << w)) != 0;

        is_note =
            ((ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes & (1ULL << w)) != 0);
    }

    if (is_error)
    {
        ctx->n_errors++;
    }
    else if (is_warning)
    {
        ctx->n_warnings++;
    }
    else if (is_note)
    {

    }
    else
    {
        return false;
    }

    if (!is_error && included_file_location)
    {
        //notes are warning are not printed in included files
        return false;
    }

    print_position(marker.file, marker.line, marker.start_col, ctx->options.visual_studio_ouput_format);

    char buffer[200] = { 0 };

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"

    va_list args = { 0 };

    va_start(args, fmt);
    /*int n =*/ vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);
#pragma CAKE diagnostic pop

    if (ctx->options.visual_studio_ouput_format)
    {
        if (is_warning)
            printf("warning: " "%s\n", buffer);
        else if (is_error)
            printf("warning: " "%s\n", buffer);
        else if (is_note)
            printf("note: " "%s\n", buffer);

        print_line_and_token(&marker, ctx->options.visual_studio_ouput_format);
    }
    else
    {
        if (is_error)
            printf(LIGHTRED "error: " WHITE "%s\n", buffer);
        else if (is_warning)
            printf(LIGHTMAGENTA "warning: " WHITE "%s\n", buffer);
        else if (is_note)
            printf(LIGHTCYAN "note: " WHITE "%s\n", buffer);

        print_line_and_token(&marker, ctx->options.visual_studio_ouput_format);

    }

    return true;
}

struct include_dir* _Opt include_dir_add(struct include_dir_list* list, const char* path)
{
    try
    {
        struct include_dir* _Owner _Opt p_new_include_dir = calloc(1, sizeof * p_new_include_dir);
        if (p_new_include_dir == NULL)
            throw;

        int len = strlen(path);
        if (path[len - 1] == '\\')
        {
            //windows path format ending with \ .
            const char* _Owner _Opt temp = strdup(path);
            if (temp == NULL)
            {
                free(p_new_include_dir);
                throw;
            }
            p_new_include_dir->path = temp;
        }
        else if (path[len - 1] != '/')
        {
            /*
              not ending with \, we add it
            */
            const char* _Owner _Opt temp = calloc(len + 2, sizeof(char));
            if (temp == NULL)
            {
                free(p_new_include_dir);
                throw;
            }

            p_new_include_dir->path = temp;
            snprintf((char*)p_new_include_dir->path, len + 2, "%s/", path);
        }
        else
        {
            const char* _Owner _Opt temp = strdup(path);
            if (temp == NULL)
            {
                free(p_new_include_dir);
                throw;
            }
            p_new_include_dir->path = temp;
        }

        if (list->head == NULL)
        {
            list->head = p_new_include_dir;
            list->tail = p_new_include_dir;
        }
        else
        {
            assert(list->tail != NULL);
            assert(list->tail->next == NULL);
            list->tail->next = p_new_include_dir;
            list->tail = p_new_include_dir;
        }
        return list->tail;
    }
    catch
    {

    }
    return NULL;
}

/*
  We must ensure we have always the same representation for path when searching and inserting
  at pragma once map
*/

static void pragma_once_add(struct preprocessor_ctx* ctx, const char* path)
{
    //FAILING ON EMSCRIPT
    //assert(path_is_absolute(path));
    //assert(path_is_normalized(path));
    struct hash_item_set item = { 0 };
    item.number = 1;
    hashmap_set(&ctx->pragma_once_map, path, &item /*in out*/);
    hash_item_set_destroy(&item);
}

static bool pragma_once_already_included(struct preprocessor_ctx* ctx, const char* path)
{
    //FAILING ON EMSCRIPT
    //assert(path_is_absolute(path));
    //assert(path_is_normalized(path));
    return hashmap_find(&ctx->pragma_once_map, path) != NULL;
}

const char* _Owner _Opt  find_and_read_include_file(struct preprocessor_ctx* ctx,
    const char* path, /*as in include*/
    const char* current_file_dir, /*this is the dir of the file that includes*/
    bool is_angle_bracket_form,
    bool* p_already_included, /*out file already included pragma once*/
    char full_path_out[], /*this is the final full path of the file*/
    int full_path_out_size,
   bool include_next)
{
    char newpath[200] = { 0 };
    full_path_out[0] = '\0';

    if (path_is_absolute(path))
    {
        snprintf(newpath, sizeof newpath, "%s", path);
        path_normalize(newpath);
        if (pragma_once_already_included(ctx, newpath))
        {
            *p_already_included = true;
            return NULL;
        }

        char* _Owner _Opt content = read_file(newpath, true);
        if (content != NULL)
        {
            snprintf(full_path_out, full_path_out_size, "%s", path);
            return content;
        }
        return NULL;
    }


    char* _Owner _Opt content = NULL;

    if (!is_angle_bracket_form)
    {
        /*
          For the angle-bracket form #include <file>, the preprocessor’s default
          behavior is to look only in the standard system directories.
        */

        //https://gcc.gnu.org/onlinedocs/cpp/Search-Path.html
        //https://learn.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp?view=msvc-170

        snprintf(newpath, sizeof newpath, "%s/%s", current_file_dir, path);

#ifdef __EMSCRIPTEN__
        /*realpath returns empty on emscriptem*/
        snprintf(full_path_out, full_path_out_size, "%s", newpath);
#else
        if (!realpath(newpath, full_path_out))
            full_path_out[0] = '\0';
#endif

        path_normalize(full_path_out);


        if (pragma_once_already_included(ctx, full_path_out))
        {
            *p_already_included = true;
            return NULL;
        }

        if (full_path_out[0] != '\0')
        {
            content = read_file(full_path_out, true);
        }
        if (content != NULL)
            return content;
    }

    /*
       Searching on include directories
    */
    struct include_dir* _Opt current = ctx->include_dir.head;
    while (current)
    {
        int len = strlen(current->path);
        if (current->path[len - 1] == '/')
        {
            snprintf(full_path_out, full_path_out_size, "%s%s", current->path, path);
        }
        else
        {
            snprintf(full_path_out, full_path_out_size, "%s/%s", current->path, path);
        }

        path_normalize(full_path_out);
        if (pragma_once_already_included(ctx, full_path_out))
        {
            *p_already_included = true;
            return NULL;
        }

        content = read_file(full_path_out, true);
        if (content != NULL)
        {
            if (include_next)
            {
                free(content);
                content = NULL;
                include_next = false;
            }
            else
                return content;
        }
        current = current->next;
    }
    full_path_out[0] = '\0';
    return NULL;
}

/*used to check recursion*/
struct macro_expanded
{
    const char* name;
    struct macro_expanded* _Opt p_previous;
};


void add_macro(struct preprocessor_ctx* ctx, const char* name)
{
    try
    {
        char* _Owner _Opt name_local = strdup(name);
        if (name_local == NULL)
        {
            throw;
        }

        struct macro* _Owner _Opt macro = calloc(1, sizeof * macro);
        if (macro == NULL)
        {
            free(name_local);
            throw;
        }

        macro->name = name_local;
        struct hash_item_set item = { .p_macro = macro };
        hashmap_set(&ctx->macros, name, &item);
        hash_item_set_destroy(&item);
    }
    catch
    {
    }
}

struct macro_argument
{
    /*the parameter this argument is associated with*/
    struct macro_parameter* _Opt macro_parameter;
    struct token_list tokens;
    struct macro_argument* _Owner _Opt next; /*linked list*/
};

void macro_argument_delete(struct macro_argument* _Owner _Opt p);



struct token_list copy_argument_list_tokens(struct token_list* list)
{
    // Makes a copy of the tokens, trimming the beginning and end
    // Any space, comments, etc., will become a single space
    struct token_list r = { 0 };
    struct token* _Opt current = list->head; /*null is fine*/

    // skip all leading white spaces
    while (current &&
        (token_is_blank(current) ||
            current->type == TK_NEWLINE))
    {
        current = current->next;
    }

    // Removes leading space flag if present
    bool is_first = true;

    for (; current;)
    {
        if (current && (token_is_blank(current) ||
            current->type == TK_NEWLINE))
        {
            if (current == list->tail)
                break;

            current = current->next;
            continue;
        }
        struct token* token = token_list_clone_and_add(&r, current);
        if (token->flags & TK_FLAG_HAS_NEWLINE_BEFORE)
        {
            token->flags = token->flags & ~TK_FLAG_HAS_NEWLINE_BEFORE;
            token->flags |= TK_FLAG_HAS_SPACE_BEFORE;
        }
        if (is_first)
        {
            token->flags = token->flags & ~TK_FLAG_HAS_SPACE_BEFORE;
            token->flags = token->flags & ~TK_FLAG_HAS_NEWLINE_BEFORE;
            is_first = false;
        }
        remove_line_continuation(token->lexeme);

        if (current == list->tail)
            break;

        current = current->next;
    }

    return r;
}

void macro_argument_delete(struct macro_argument* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        token_list_destroy(&p->tokens);
        free(p);
    }
}

struct token_list copy_argument_list(struct macro_argument* p_macro_argument)
{
    try
    {
        struct token_list list = copy_argument_list_tokens(&p_macro_argument->tokens);
        if (list.head == NULL)
        {
            /*it's never empty...if puts a TK PLACEMARKER*/
            struct token* _Owner _Opt p_new_token = calloc(1, sizeof * p_new_token);
            if (p_new_token == NULL) throw;

            char* _Owner _Opt temp = strdup("");
            if (temp == NULL)
            {
                token_delete(p_new_token);
                throw;
            }

            p_new_token->lexeme = temp;
            p_new_token->type = TK_PLACEMARKER;
            token_list_add(&list, p_new_token);
        }
        return list;
    }
    catch
    {
    }

    struct token_list empty = { 0 };
    return empty;
}


struct macro_argument_list
{
    struct token_list tokens;
    struct macro_argument* _Owner _Opt head;
    struct macro_argument* _Opt tail;
};

void macro_argument_list_destroy(_Dtor struct macro_argument_list* list)
{
    token_list_destroy(&list->tokens);
    struct macro_argument* _Owner _Opt p = list->head;
    while (p)
    {
        struct macro_argument* _Owner _Opt next = p->next;
        p->next = NULL;
        macro_argument_delete(p);
        p = next;
    }
}

void print_macro_arguments(struct macro_argument_list* arguments)
{
    struct macro_argument* _Opt p_argument = arguments->head;
    while (p_argument)
    {
        if (p_argument->macro_parameter)
            printf("%s:", p_argument->macro_parameter->name);

        print_list(&p_argument->tokens);
        p_argument = p_argument->next;
    }
}

struct macro_argument* _Opt find_macro_argument_by_name(struct macro_argument_list* parameters, const char* name)
{
    /*
     * The arguments are collected in the macro expansion and each one (except ...)
     * is associated with one of the macro parameters.
     */
    struct macro_argument* _Opt p_macro_argument = parameters->head;
    while (p_macro_argument)
    {
        if (strcmp(p_macro_argument->macro_parameter->name, name) == 0)
        {
            return p_macro_argument;
        }
        p_macro_argument = p_macro_argument->next;
    }
    return NULL;
}

void argument_list_add(struct macro_argument_list* list, struct macro_argument* _Owner pnew)
{
    assert(pnew->next == NULL);
    if (list->head == NULL)
    {
        list->head = pnew;
        assert(list->tail == NULL);
        list->tail = pnew;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = pnew;
        list->tail = pnew;
    }
}

void print_macro(struct macro* macro)
{
    printf("%s", macro->name);
    if (macro->is_function)
        printf("(");
    struct macro_parameter* _Opt parameter = macro->parameters;
    while (parameter)
    {
        if (macro->parameters != parameter)
            printf(",");
        printf("%s", parameter->name);
        parameter = parameter->next;
    }
    if (macro->is_function)
        printf(") ");
    print_list(&macro->replacement_list);
}

void macro_parameters_delete(struct macro_parameter* _Owner _Opt parameters)
{
    struct macro_parameter* _Owner _Opt p = parameters;
    while (p)
    {
        struct macro_parameter* _Owner _Opt p_next = p->next;
        free((void* _Owner)p->name);
        free(p);
        p = p_next;
    }
}

bool macro_is_same(const struct macro* macro_a, const struct macro* macro_b)
{
    if (macro_a->is_function != macro_b->is_function)
        return false;

    if (strcmp(macro_a->name, macro_b->name) != 0)
        return false;

    if (!token_list_is_equal(&macro_a->replacement_list, &macro_b->replacement_list) != 0)
        return false;

    const struct macro_parameter* p_a = macro_a->parameters;
    const struct macro_parameter* p_b = macro_b->parameters;
    while (p_a && p_b)
    {
        if (strcmp(p_a->name, p_b->name) != 0)
            return false;

        p_a = p_a->next;
        p_b = p_b->next;
    }

    return p_a == NULL && p_b == NULL;
}
void macro_delete(struct macro* _Owner _Opt macro)
{
    if (macro)
    {
        token_list_destroy(&macro->replacement_list);

        struct macro_parameter* _Owner _Opt p_macro_parameter = macro->parameters;
        while (p_macro_parameter)
        {
            struct macro_parameter* _Owner _Opt p_next = p_macro_parameter->next;
            free((void* _Owner)p_macro_parameter->name);
            token_list_destroy(&p_macro_parameter->expanded_list);
            free(p_macro_parameter);
            p_macro_parameter = p_next;
        }

        free((void* _Owner) macro->name);
        free(macro);
    }
}

struct macro* _Opt find_macro(struct preprocessor_ctx* ctx, const char* name)
{
    struct map_entry* _Opt p_entry = hashmap_find(&ctx->macros, name);
    if (p_entry == NULL)
        return NULL;

    return p_entry->data.p_macro;
}

void stream_print_line(struct stream* stream)
{
    const char* p = stream->current;
    while ((p - 1) >= stream->source &&
        *(p - 1) != '\n')
    {
        p--;
    }
    while (*p && *(p + 1) != '\n')
    {
        printf("%c", *p);
        p++;
    }
    printf("\n");
    for (int i = 0; i < stream->col - 1; i++)
        printf(" ");
    printf("^\n");
}

void stream_match(struct stream* stream)
{
    if (stream->current[0] == '\n')
    {
        stream->line++;
        stream->col = 1;
    }
    else
    {
        stream->col++;
    }

    if (stream->current[0] == '\0')
        return;
    stream->current++;

    while (stream->current[0] == '\\' &&
             (stream->current[1] == '\n' ||
                 (stream->current[1] == '\r' && stream->current[2] == '\n')
                 ))
    {
        /*
            2. Each instance of a backslash character (\) immediately followed by a new-line character is
            deleted, splicing physical source lines to form logical source lines. Only the last backslash on
            any physical source line shall be eligible for being part of such a splice. A source file that is
            not empty shall end in a new-line character, which shall not be immediately preceded by a
            backslash character before any such splicing takes place.
        */
        if (stream->current[1] == '\r' && stream->current[2] == '\n')
        {
            stream->current++; // 
            stream->current++; // r 
            stream->current++; // n
        }
        else
        {
            stream->current++;
            stream->current++;  // n
        }

        stream->line++;
        stream->col = 1;

        stream->line_continuation_count++;
    }

}

void print_line(struct token* p)
{
    printf("%s\n", p->token_origin->lexeme);
    struct token* _Opt prev = p;
    while (prev->prev && prev->prev->type != TK_NEWLINE)
    {
        prev = prev->prev;
    }
    struct token* _Opt next = prev;
    while (next && next->type != TK_NEWLINE)
    {
        printf("%s", next->lexeme);
        next = next->next;
    }
    printf("\n");
}

int is_nondigit(const struct stream* p)
{
    /*
    nondigit: one of
     _ a b c d e f g h i j k l m
     n o p q r s t u v w x y z
     A B C D E F G H I J K L M
     N O P Q R S T U V W X Y Z
    */
    return (p->current[0] >= 'a' && p->current[0] <= 'z') ||
        (p->current[0] >= 'A' && p->current[0] <= 'Z') ||
        (p->current[0] == '_');
}


enum token_type is_punctuator(struct stream* stream)
{
    enum token_type type = TK_NONE;
    /*
     punctuator: one of
      [ ] ( ) { } . ->
      ++ -- & * + - ~ !
      / % << >> < > <= >= == != ^ | && ||
      ? : :: ; ...
      = *= /= %= += -= <<= >>= &= ^= |=
      , # ##
      <: :> <% %> %: %:%:
    */
    switch (stream->current[0])
    {
    case '[':
        type = '[';
        stream_match(stream);
        break;
    case ']':
        type = ']';
        stream_match(stream);
        break;
    case '(':
        type = '(';
        stream_match(stream);
        break;
    case ')':
        type = ')';
        stream_match(stream);
        break;
    case '{':
        type = '{';
        stream_match(stream);
        break;
    case '}':
        type = '}';
        stream_match(stream);
        break;
    case ';':
        type = ';';
        stream_match(stream);
        break;
    case ',':
        type = ',';
        stream_match(stream);
        break;
    case '!':
        type = '!';
        stream_match(stream);
        if (stream->current[0] == '=')
        {
            type = '!=';
            stream_match(stream);
        }
        break;
    case ':':
        type = ':';
        stream_match(stream);
        if (stream->current[0] == ':')
        {
            type = '::';
            stream_match(stream);
        }
        break;
    case '~':
        type = '~';
        stream_match(stream);
        break;
    case '?':
        type = '?';
        stream_match(stream);
        break;
    case '/':
        type = '/';
        stream_match(stream);
        if (stream->current[0] == '=')
        {
            type = '/=';
            stream_match(stream);
        }
        break;
    case '*':
        type = '*';
        stream_match(stream);
        if (stream->current[0] == '=')
        {
            type = '*=';
            stream_match(stream);
        }
        break;
    case '%':
        type = '%';
        stream_match(stream);
        if (stream->current[0] == '=')
        {
            type = '%=';
            stream_match(stream);
        }
        break;
    case '-':
        type = '-';
        stream_match(stream);
        if (stream->current[0] == '>')
        {
            type = '->';
            stream_match(stream);
        }
        else if (stream->current[0] == '-')
        {
            type = '--';
            stream_match(stream);
        }
        else if (stream->current[0] == '=')
        {
            type = '-=';
            stream_match(stream);
        }
        break;
    case '|':
        type = '|';
        stream_match(stream);
        if (stream->current[0] == '|')
        {
            type = '||';
            stream_match(stream);
        }
        else if (stream->current[0] == '=')
        {
            type = '|=';
            stream_match(stream);
        }
        break;
    case '+':
        type = '+';
        stream_match(stream);
        if (stream->current[0] == '+')
        {
            type = '++';
            stream_match(stream);
        }
        else if (stream->current[0] == '=')
        {
            type = '+=';
            stream_match(stream);
        }
        break;
    case '=':
        type = '=';
        stream_match(stream);
        if (stream->current[0] == '=')
        {
            type = '==';
            stream_match(stream);
        }
        break;
    case '^':
        type = '^';
        stream_match(stream);
        if (stream->current[0] == '=')
        {
            type = '^=';
            stream_match(stream);
        }
        break;
    case '&':
        type = '&';
        stream_match(stream);
        if (stream->current[0] == '&')
        {
            type = '&&';
            stream_match(stream);
        }
        else if (stream->current[0] == '=')
        {
            type = '&=';
            stream_match(stream);
        }
        break;
    case '>':
        type = '>';
        stream_match(stream);
        if (stream->current[0] == '>')
        {
            type = '>>';
            stream_match(stream);
            if (stream->current[0] == '=')
            {
                type = '>>=';
                stream_match(stream);
            }
        }
        else if (stream->current[0] == '=')
        {
            type = '>=';
            stream_match(stream);
        }

        break;
    case '<':
        type = '<';
        stream_match(stream);
        if (stream->current[0] == '<')
        {
            type = '<<';
            stream_match(stream);
            if (stream->current[0] == '=')
            {
                type = '<<=';
                stream_match(stream);
            }
        }
        else if (stream->current[0] == '=')
        {
            type = '<=';
            stream_match(stream);
        }
        break;
    case '#':
        type = '#';
        stream_match(stream);
        if (stream->current[0] == '#')
        {
            type = '##';
            stream_match(stream);
        }
        break;
    case '.':
        type = '.';
        stream_match(stream);
        if (stream->current[0] == '.' && stream->current[1] == '.')
        {
            type = '...';
            stream_match(stream);
            stream_match(stream);
        }
        break;
    }
    return type;
}


struct token* _Owner _Opt new_token(const char* lexeme_head, const char* lexeme_tail, enum token_type type)
{
    struct token* _Owner _Opt p_new_token = NULL;

    try
    {
        p_new_token = calloc(1, sizeof * p_new_token);
        if (p_new_token == NULL) throw;

        size_t sz = lexeme_tail - lexeme_head;
        char* _Owner _Opt temp = calloc(sz + 1, sizeof(char));
        if (temp == NULL) throw;

        p_new_token->lexeme = temp;
        p_new_token->type = type;
        strncpy(p_new_token->lexeme, lexeme_head, sz);
    }
    catch
    {
        token_delete(p_new_token);
        p_new_token = NULL;
    }
    return p_new_token;
}

struct token* _Owner _Opt identifier(struct stream* stream)
{
    const char* start = stream->current;
    stream_match(stream);
    /*
    identifier:
      identifier-nondigit
      identifier identifier-nondigit
      identifier digit

    identifier-nondigit:
      nondigit
      universal-character-name
      other implementation-defined characters
    */
    while (is_nondigit(stream) || is_digit(stream))
    {
        stream_match(stream);
    }

    struct token* _Owner _Opt p_new_token = new_token(start, stream->current, TK_IDENTIFIER);


    return p_new_token;
}


static bool first_of_character_constant(struct stream* stream)
{
    return stream->current[0] == '\'' ||
        (stream->current[0] == 'u' && stream->current[1] == '8' && stream->current[2] == '\'') ||
        (stream->current[0] == 'u' && stream->current[1] == '\'') ||
        (stream->current[0] == 'U' && stream->current[1] == '\'') ||
        (stream->current[0] == 'L' && stream->current[1] == '\'');
}

struct token* _Owner _Opt character_constant(struct tokenizer_ctx* ctx, struct stream* stream)
{
    const char* start = stream->current;

    /*
      encoding-prefix: one of
       u8 u U L
    */
    if (stream->current[0] == 'u')
    {
        stream_match(stream);
        if (stream->current[0] == '8')
            stream_match(stream);
    }
    else if (stream->current[0] == 'U' ||
        stream->current[0] == 'L')
    {
        stream_match(stream);
    }


    stream_match(stream); //"


    while (stream->current[0] != '\'')
    {
        if (stream->current[0] == '\\')
        {
            stream_match(stream);
            stream_match(stream);
        }
        else
            stream_match(stream);

        if (stream->current[0] == '\0' ||
            stream->current[0] == '\n')
        {
            tokenizer_set_warning(ctx, stream, "missing terminating ' character");
            break;
        }
    }
    stream_match(stream);
    struct token* _Owner _Opt p_new_token = new_token(start, stream->current, TK_CHAR_CONSTANT);
    return p_new_token;
}

static bool first_of_string_literal(struct stream* stream)
{
    /*
    string-literal:
    encoding_prefix_opt " s-char-sequenceopt "

    encoding_prefix:
    u8
    u
    U
    L
    */

    return stream->current[0] == '"' ||
        (stream->current[0] == 'u' && stream->current[1] == '8' && stream->current[2] == '"') ||
        (stream->current[0] == 'u' && stream->current[1] == '"') ||
        (stream->current[0] == 'U' && stream->current[1] == '"') ||
        (stream->current[0] == 'L' && stream->current[1] == '"');
}

struct token* _Owner _Opt string_literal(struct tokenizer_ctx* ctx, struct stream* stream)
{
    struct token* _Owner _Opt p_new_token = NULL;
    const char* start = stream->current;

    try
    {
        /*encoding_prefix_opt*/
        if (stream->current[0] == 'u')
        {
            stream_match(stream);
            if (stream->current[0] == '8')
                stream_match(stream);
        }
        else if (stream->current[0] == 'U' ||
            stream->current[0] == 'L')
        {
            stream_match(stream);
        }


        stream_match(stream); //"


        while (stream->current[0] != '"')
        {
            if (stream->current[0] == '\0' ||
                stream->current[0] == '\n')
            {
                tokenizer_set_error(ctx, stream, "missing terminating \" character");
                throw;
            }

            if (stream->current[0] == '\\')
            {
                stream_match(stream);
                stream_match(stream);
            }
            else
                stream_match(stream);
        }
        stream_match(stream);
        p_new_token = new_token(start, stream->current, TK_STRING_LITERAL);
    }
    catch
    {
    }

    return p_new_token;
}

int get_char_type(const char* s)
{
    if (s[0] == 'L')
        return 2; /*wchar*/

    return 1;
}
/*
  Returns the char byte size according with the literal suffix
*/
int string_literal_char_byte_size(const char* s)
{
    if (s[0] == 'u')
    {
        //must be followed by u8 but not checked here
    }
    else if (s[0] == 'U' || s[0] == 'L')
    {
        return (int)sizeof(wchar_t);
    }

    return 1;
}

int string_literal_byte_size_not_zero_included(const char* s)
{

    _Opt struct stream stream = { .source = s };

    stream.current = s;
    stream.line = 1;
    stream.col = 1;
    stream.path = "";

    int size = 0;
    const int charsize = string_literal_char_byte_size(s);

    try
    {
        /*encoding_prefix_opt*/
        if (stream.current[0] == 'u')
        {
            stream_match(&stream);
            if (stream.current[0] == '8')
                stream_match(&stream);
        }
        else if (stream.current[0] == 'U' ||
            stream.current[0] == 'L')
        {
            stream_match(&stream);
        }


        stream_match(&stream); //"


        while (stream.current[0] != '"')
        {
            if (stream.current[0] == '\0' ||
                stream.current[0] == '\n')
            {
                throw;
            }

            if (stream.current[0] == '\\')
            {
                stream_match(&stream);
                stream_match(&stream);
                size++;
            }
            else
            {
                stream_match(&stream);
                size++;
            }
        }
        stream_match(&stream);
    }
    catch
    {
    }

    /*
       Last \0 is not included
    */

    return size * charsize;
}

static struct token* _Owner _Opt ppnumber(struct stream* stream)
{
    /*
     pp-number:
      digit
      . digit
      pp-number identifier-continue
      pp-number ’ digit
      pp-number ’ nondigit
      pp-number e sign
      pp-number E sign
      pp-number p sign
      pp-number P sign
      pp-number .
    */

    /*
     identifier-continue:
       digit
       nondigit
       XID_Continue character
       universal-character-name of class XID_Continue
    */

    const char* start = stream->current;
    if (is_digit(stream))
    {
        stream_match(stream);//digit
    }
    else if (stream->current[0] == '.')
    {
        stream_match(stream); //.
        stream_match(stream); //digit
    }
    else
    {
        assert(false);
    }

    for (;;)
    {
        if (stream->current[0] == '\'')
        {
            //digit separators c23
            stream_match(stream);
            if (is_digit(stream))
            {
                stream_match(stream);
            }
            else if (is_nondigit(stream))
            {
                stream_match(stream);
            }
            else
            {
                assert(false);
                break;
            }
        }
        else if ((stream->current[0] == 'e' ||
            stream->current[0] == 'E' ||
            stream->current[0] == 'p' ||
            stream->current[0] == 'P') &&
            (stream->current[1] == '+' || stream->current[1] == '-'))
        {
            stream_match(stream);//e E  p P
            stream_match(stream);//sign
        }
        else if (stream->current[0] == '.')
        {
            stream_match(stream);//.
        }
        else if (is_digit(stream) || is_nondigit(stream))
        {
            ////identifier-continue
            /*
            * OBS test for is_nondigit must be AFTER
            * test for e E p P
            */
            stream_match(stream);//nondigit
        }
        else
        {
            break;
        }
    }
    struct token* _Owner _Opt p_new_token = new_token(start, stream->current, TK_PPNUMBER);

    return p_new_token;
}

struct token_list embed_tokenizer(struct preprocessor_ctx* ctx,
    const struct token* position,
    const char* filename_opt,
    int level, enum token_flags addflags)
{
    struct token_list list = { 0 };

    FILE* _Owner _Opt file = NULL;

    bool b_first = true;
    int line = 1;
    int col = 1;
    int count = 0;
    try
    {
#ifndef MOCKFILES
        file = (FILE * _Owner _Opt)fopen(filename_opt, "rb");
        if (file == NULL)
        {
            preprocessor_diagnostic(C_ERROR_FILE_NOT_FOUND, ctx, position, "file '%s' not found", filename_opt);
            throw;
        }
#else
        /*web versions only text files that are included*/
        char* textfile = read_file(filename_opt, true);
        if (textfile == NULL)
        {
            preprocessor_diagnostic(C_ERROR_FILE_NOT_FOUND, ctx, ctx->current, "file '%s' not found", filename_opt);
            throw;
        }

        const char* pch = textfile;
#endif

        unsigned char ch = 0;
#ifndef MOCKFILES
        while (fread(&ch, 1, 1, file))
        {
#else
        while (*pch)
        {
            ch = *pch;
            pch++;
#endif
            if (b_first)
            {
                b_first = false;
            }
            else
            {
                char b[] = ",";
                struct token* _Owner _Opt p_new_token = new_token(b, &b[1], TK_COMMA);
                if (p_new_token == NULL)
                {
                    throw;
                }

                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = NULL;
                p_new_token->line = line;
                p_new_token->col = col;
                token_list_add(&list, p_new_token);

                if (count > 0 && count % 25 == 0)
                {
                    /*new line*/
                    char newline[] = "\n";
                    struct token* _Owner _Opt p_new3 = new_token(newline, &newline[1], TK_NEWLINE);
                    if (p_new3 == NULL)
                    {
                        throw;
                    }

                    p_new3->level = level;
                    p_new3->token_origin = NULL;
                    p_new3->line = line;
                    p_new3->col = col;
                    token_list_add(&list, p_new3);
                }
            }

            char buffer[30] = { 0 };
            int c = snprintf(buffer, sizeof buffer, "%d", (int)ch);

            struct token* _Owner _Opt p_new_token = new_token(buffer, &buffer[c], TK_PPNUMBER);
            if (p_new_token == NULL)
            {
                throw;
            }

            p_new_token->flags |= addflags;
            p_new_token->level = level;
            p_new_token->token_origin = NULL;
            p_new_token->line = line;
            p_new_token->col = col;
            token_list_add(&list, p_new_token);


            count++;
        }
#ifdef MOCKFILES
        free(textfile);
#endif

        /*new line*/
        char newline[] = "\n";
        struct token* _Owner _Opt p_new_token = new_token(newline, &newline[1], TK_NEWLINE);
        if (p_new_token == NULL)
        {
            throw;
        }

        p_new_token->level = level;
        p_new_token->token_origin = NULL;
        p_new_token->line = line;
        p_new_token->col = col;
        token_list_add(&list, p_new_token);

        assert(list.head != NULL);
    }
    catch
    {
    }

    if (file)
        fclose(file);

    return list;
}

static bool set_sliced_flag(struct stream* stream, struct token* p_new_token)
{
    if (stream->line_continuation_count > 0)
    {
        p_new_token->flags |= TK_FLAG_LINE_CONTINUATION;
        if (stream->line_continuation_count == 1)
        {
            int l = strlen(p_new_token->lexeme);
            if (p_new_token->lexeme[l - 1] == '\n')
            {
                /*not sliced, line continuation is at end of token*/
            }
            else
            {
                p_new_token->flags |= TK_FLAG_SLICED;
            }
        }
        else
        {
            p_new_token->flags |= TK_FLAG_SLICED;
        }
    }

    return p_new_token->flags & TK_FLAG_SLICED;
}

struct token_list tokenizer(struct tokenizer_ctx* ctx, const char* text, const char* _Opt filename_opt, int level, enum token_flags addflags)
{
    struct token_list list = { 0 };

    struct stream stream =
    {
        .col = 1,
        .line = 1,
        .source = text,
        .current = text,
        .path = filename_opt ? filename_opt : ""
    };

    try
    {
        struct token* _Opt p_first = NULL;
        if (filename_opt != NULL)
        {
            const char* begin = filename_opt;
            const char* end = filename_opt + strlen(filename_opt);
            struct token* _Owner _Opt p_new = new_token(begin, end, TK_BEGIN_OF_FILE);
            if (p_new == NULL)
                throw;

            path_normalize(p_new->lexeme);
            p_new->level = level;
            p_first = token_list_add(&list, p_new);
        }


        //struct token* current = pFirst;
        bool new_line = true;
        bool has_space = false;
        while (1)
        {
            const int line = stream.line;
            const int col = stream.col;
            stream.line_continuation_count = 0;

            if (stream.current[0] == '\0')
            {
                stream_match(&stream);
                break;
            }
            if (is_digit(&stream) ||
                (stream.current[0] == '.' && isdigit(stream.current[0])))
            {
                struct token* _Owner _Opt p_new_token = ppnumber(&stream);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;
                continue;
            }

            /*
             Tem que vir antes identifier
            */
            if (first_of_string_literal(&stream))
            {
                struct token* _Owner _Opt p_new_token = string_literal(ctx, &stream);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;

                continue;
            }

            if (first_of_character_constant(&stream))
            {
                //TODO if we have ' in the middle then it is not character constant
                struct token* _Owner _Opt p_new_token = character_constant(ctx, &stream);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;

                continue;
            }

            if (is_nondigit(&stream))
            {
                struct token* _Owner _Opt p_new_token = identifier(&stream);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;

                new_line = false;
                has_space = false;
                if (set_sliced_flag(&stream, p_new_token))
                {
                    tokenizer_set_warning(ctx, &stream, "token sliced");
                }
                token_list_add(&list, p_new_token);
                continue;
            }

            if (stream.current[0] == ' ' ||
                stream.current[0] == '\t' ||
                stream.current[0] == '\f')
            {
                const char* start = stream.current;
                while (stream.current[0] == ' ' ||
                    stream.current[0] == '\t' ||
                    stream.current[0] == '\f'
                    )
                {
                    stream_match(&stream);
                }
                struct token* _Owner _Opt p_new_token = new_token(start, stream.current, TK_BLANKS);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                /*bNewLine = false;*/ //deixa assim
                has_space = true;

                continue;
            }
            if (stream.current[0] == '/' &&
                stream.current[1] == '/')
            {
                const char* start = stream.current;
                stream_match(&stream);
                stream_match(&stream);
                //line comment
                while (stream.current[0] != '\n')
                {
                    stream_match(&stream);

                    if (stream.current[0] == '\0')
                        break;
                }
                struct token* _Owner _Opt p_new_token = new_token(start, stream.current, TK_LINE_COMMENT);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = true;
                has_space = false;


                if (stream.current[0] == '\0')
                    break;

                continue;
            }
            if (stream.current[0] == '/' &&
                stream.current[1] == '*')
            {
                const char* start = stream.current;
                stream_match(&stream);
                stream_match(&stream);
                //line comment
                for (;;)
                {
                    if (stream.current[0] == '*' && stream.current[1] == '/')
                    {
                        stream_match(&stream);
                        stream_match(&stream);
                        break;
                    }
                    else if (stream.current[0] == '\0')
                    {
                        tokenizer_set_error(ctx, &stream, "missing end of comment");
                        break;
                    }
                    else
                    {
                        stream_match(&stream);
                    }
                }
                struct token* _Owner _Opt p_new_token = new_token(start, stream.current, TK_COMMENT);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;

                /*
                * Ignore line splicing inside comments.
                * if you are curious to see when it happens just add
                * set_sliced_flag
                */

                continue;
            }
            if (new_line && stream.current[0] == '#')
            {
                const char* start = stream.current;
                stream_match(&stream);
                struct token* _Owner _Opt p_new_token = new_token(start, stream.current, '#');
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                p_new_token->type = TK_PREPROCESSOR_LINE;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;

                continue;
            }


            if (stream.current[0] == '\n' || stream.current[0] == '\r')
            {
                if (stream.current[0] == '\r' && stream.current[1] == '\n')
                {
                    stream_match(&stream);
                    stream_match(&stream);
                }
                else
                {
                    stream_match(&stream);
                }
                char  newline[] = "\n";
                struct token* _Owner _Opt p_new_token = new_token(newline, newline + 1, TK_NEWLINE);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = true;
                has_space = false;

                continue;
            }
            const char* start = stream.current;
            enum token_type t = is_punctuator(&stream);
            if (t != TK_NONE)
            {

                struct token* _Owner _Opt p_new_token = new_token(start, stream.current, t);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;

                continue;
            }
            else
            {
                stream_match(&stream);
                struct token* _Owner _Opt p_new_token = new_token(start, stream.current, ANY_OTHER_PP_TOKEN);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;

                continue;
            }

            break;
        }
    }
    catch
    {
    }

    assert(list.head != NULL);
    return list;
}


bool fread2(void* buffer, size_t size, size_t count, FILE * stream, size_t * sz)
{
    *sz = 0;//out
    bool result = false;
    size_t n = fread(buffer, size, count, stream);
    if (n == count)
    {
        *sz = n;
        result = true;
    }
    else if (n < count)
    {
        if (feof(stream))
        {
            *sz = n;
            result = true;
        }
    }
    return result;
}


bool preprocessor_token_ahead_is_identifier(struct token* p, const char* lexeme);
struct token_list group_part(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level);
struct token_list group_opt(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    /*
      group:
       group-part
       group group-part
    */
    struct token_list r = { 0 };
    try
    {

        if (token_list_is_empty(input_list))
        {
            return r;
        }
        while (!token_list_is_empty(input_list))
        {
            assert(input_list->head != NULL);

            if (input_list->head->type == TK_PREPROCESSOR_LINE &&
                (preprocessor_token_ahead_is_identifier(input_list->head, "endif") ||
                    preprocessor_token_ahead_is_identifier(input_list->head, "else") ||
                    preprocessor_token_ahead_is_identifier(input_list->head, "elif") ||
                    preprocessor_token_ahead_is_identifier(input_list->head, "elifdef") ||
                    preprocessor_token_ahead_is_identifier(input_list->head, "elifndef")))
            {
                /*follow of group-part*/
                break;
            }
            else
            {
                struct token_list r2 = group_part(ctx, input_list, is_active, level);
                token_list_append_list(&r, &r2);
                token_list_destroy(&r2);
                if (ctx->n_errors > 0) throw;
            }
        }
    }
    catch
    {
    }

    return r;
}

bool is_parser_token(struct token* p)
{
    return p->type != TK_COMMENT &&
        p->type != TK_BLANKS &&
        p->type != TK_LINE_COMMENT &&
        p->type != TK_NEWLINE;
}

bool is_never_final(enum token_type type)
{
    return type == TK_BEGIN_OF_FILE ||
        type == TK_BLANKS ||
        type == TK_LINE_COMMENT ||
        type == TK_COMMENT ||
        type == TK_PLACEMARKER ||
        type == TK_NEWLINE;
}

enum token_type is_keyword(const char* text);

struct token* _Opt preprocessor_look_ahead_core(struct token* p)
{
    struct token* _Opt current = p->next;

    while (current &&
        (current->type == TK_BLANKS ||
            current->type == TK_PLACEMARKER ||
            current->type == TK_LINE_COMMENT ||
            current->type == TK_COMMENT))
    {
        current = current->next;
    }
    return current;
}

bool preprocessor_token_ahead_is(struct token* p, enum token_type t)
{
    struct token* _Opt p_token = preprocessor_look_ahead_core(p);
    if (p_token != NULL && p_token->type == t)
        return true;
    return false;
}

bool preprocessor_token_ahead_is_identifier(struct token* p, const char* lexeme)
{
    assert(p != NULL);
    struct token* _Opt p_token = preprocessor_look_ahead_core(p);
    if (p_token != NULL && p_token->type == TK_IDENTIFIER)
    {
        return strcmp(p_token->lexeme, lexeme) == 0;
    }
    return false;
}

static void skip_blanks_level(struct preprocessor_ctx* ctx, struct token_list* dest, struct token_list* input_list, int level)
{
    while (input_list->head)
    {
        if (!token_is_blank(input_list->head))
            break;

        if (INCLUDE_ALL || level == 0)
        {
            struct token* _Owner _Opt p =
                token_list_pop_front_get(input_list);
            assert(p != NULL); //because input_list is not empty
            token_list_add(dest, p);
        }
        else
            token_list_pop_front(input_list);
    }
}

static void skip_blanks(struct preprocessor_ctx* ctx, struct token_list* dest, struct token_list* input_list)
{
    while (input_list->head)
    {
        if (!token_is_blank(input_list->head))
            break;
        struct token* _Owner _Opt p =
            token_list_pop_front_get(input_list);
        assert(p != NULL); //because input_list is not empty

        token_list_add(dest, p);
    }
}

void prematch_level(struct token_list* dest, struct token_list* input_list, int level)
{
    if (INCLUDE_ALL || level == 0)
    {
        struct token* _Owner _Opt p = token_list_pop_front_get(input_list);
        if (p)
        {
            token_list_add(dest, p);
        }
    }
    else
        token_list_pop_front(input_list);
}

void prematch(struct token_list* dest, struct token_list* input_list)
{
    struct token* _Owner _Opt p = token_list_pop_front_get(input_list);
    if (p)
    {
        token_list_add(dest, p);
    }
}

struct token_list pp_tokens_opt(struct preprocessor_ctx* ctx, struct token_list* input_list, int level);

struct token_list process_defined(struct preprocessor_ctx* ctx, struct token_list* input_list)
{
    struct token_list r = { 0 };

    try
    {
        while (input_list->head != NULL)
        {
            if (input_list->head->type == TK_IDENTIFIER &&
                strcmp(input_list->head->lexeme, "defined") == 0)
            {
                token_list_pop_front(input_list);
                skip_blanks(ctx, &r, input_list);

                if (input_list->head == NULL)
                {
                    pre_unexpected_end_of_file(r.tail, ctx);
                    throw;
                }

                bool has_parentesis = false;
                if (input_list->head->type == '(')
                {
                    token_list_pop_front(input_list);
                    has_parentesis = true;
                }

                skip_blanks(ctx, &r, input_list);


                if (input_list->head == NULL)
                {
                    pre_unexpected_end_of_file(r.tail, ctx);
                    throw;
                }

                struct macro* _Opt macro = find_macro(ctx, input_list->head->lexeme);
                struct token* _Owner _Opt p_new_token = token_list_pop_front_get(input_list);
                if (p_new_token == NULL)
                {
                    throw;
                }

                p_new_token->type = TK_PPNUMBER;
                char* _Owner _Opt temp = NULL;

                if (macro)
                {
                    temp = strdup("1");
                }
                else
                {
                    temp = strdup("0");
                }

                if (temp == NULL)
                {
                    token_delete(p_new_token);
                    throw;
                }

                free(p_new_token->lexeme);
                p_new_token->lexeme = temp;

                token_list_add(&r, p_new_token);

                if (has_parentesis)
                {
                    if (input_list->head == NULL)
                    {
                        throw;
                    }

                    if (input_list->head->type != ')')
                    {
                        preprocessor_diagnostic(C_ERROR_MISSING_CLOSE_PARENTHESIS, ctx, input_list->head, "missing )");
                        throw;
                    }
                    token_list_pop_front(input_list);
                }


            }
            else if (input_list->head->type == TK_IDENTIFIER &&
                (strcmp(input_list->head->lexeme, "__has_include") == 0 ||
                    strcmp(input_list->head->lexeme, "__has_embed") == 0)
                )
            {
                token_list_pop_front(input_list); //pop __has_include
                skip_blanks(ctx, &r, input_list);
                token_list_pop_front(input_list); //pop (
                skip_blanks(ctx, &r, input_list);


                char path[100] = { 0 };
                bool is_angle_bracket_form = false;

                if (input_list->head == NULL)
                {
                    pre_unexpected_end_of_file(r.tail, ctx);
                    throw;
                }

                if (input_list->head->type == TK_STRING_LITERAL)
                {
                    strcat(path, input_list->head->lexeme);
                    token_list_pop_front(input_list); //pop "file"
                }
                else
                {
                    is_angle_bracket_form = true;
                    token_list_pop_front(input_list); //pop <

                    if (input_list->head == NULL)
                    {
                        pre_unexpected_end_of_file(r.tail, ctx);
                        throw;
                    }

                    while (input_list->head->type != '>')
                    {
                        strcat(path, input_list->head->lexeme);
                        token_list_pop_front(input_list); //pop (

                        if (input_list->head == NULL)
                        {
                            pre_unexpected_end_of_file(r.tail, ctx);
                            throw;
                        }
                    }
                    token_list_pop_front(input_list); //pop >
                }

                char fullpath[300] = { 0 };



                char full_path_result[200] = { 0 };
                bool already_included = false;
                const char* _Owner _Opt s = find_and_read_include_file(ctx,
                    path,
                    fullpath,
                    is_angle_bracket_form,
                    &already_included,
                    full_path_result,
                    sizeof full_path_result,
                  false);

                bool has_include = s != NULL;
                free((void* _Owner)s);

                struct token* _Owner _Opt p_new_token = calloc(1, sizeof * p_new_token);
                if (p_new_token == NULL)
                {
                    throw;
                }

                p_new_token->type = TK_PPNUMBER;

                char* _Owner _Opt temp = strdup(has_include ? "1" : "0");
                if (temp == NULL)
                {
                    token_delete(p_new_token);
                    throw;
                }
                p_new_token->lexeme = temp;
                p_new_token->flags |= TK_FLAG_FINAL;

                token_list_add(&r, p_new_token);
                token_list_pop_front(input_list); //pop )
            }
            else if (input_list->head->type == TK_IDENTIFIER &&
                strcmp(input_list->head->lexeme, "__has_c_attribute") == 0)
            {
                token_list_pop_front(input_list); //pop __has_include
                skip_blanks(ctx, &r, input_list);
                token_list_pop_front(input_list); //pop (
                skip_blanks(ctx, &r, input_list);

                if (input_list->head == NULL)
                {
                    pre_unexpected_end_of_file(r.tail, ctx);
                    throw;
                }

                char path[100] = { 0 };
                while (input_list->head->type != ')')
                {
                    strcat(path, input_list->head->lexeme);
                    token_list_pop_front(input_list); //pop (

                    if (input_list->head == NULL)
                    {
                        pre_unexpected_end_of_file(r.tail, ctx);
                        throw;
                    }
                }
                token_list_pop_front(input_list); //pop >

                /*nodiscard
                * The __has_c_attribute conditional inclusion expression (6.10.1) shall
                * return the value 202003L
                * when given nodiscard as the pp-tokens operand.
                */

                /*maybe_unused
                * The __has_c_attribute conditional inclusion expression (6.10.1) shall return
                * the value 202106L when given maybe_unused as the pp-tokens operand.
                */

                /*deprecated
                * The __has_c_attribute conditional inclusion expression (6.10.1) shall return the value 201904L
                * when given deprecated as the pp-tokens operand
                */

                /*noreturn
                * The __has_c_attribute conditional inclusion expression (6.10.1) shall return the value 202202L
                * when given noreturn as the pp-tokens operand.
                */

                /*reproducible
                 * The __has_c_attribute conditional inclusion expression (6.10.1) shall return the value 202207L
                 * when given reproducible as the pp-tokens operand.
                */

                /*
                * The __has_c_attribute conditional inclusion expression (6.10.1) shall return the value 202207L
                * when given unsequenced as the pp-tokens operand.
                */
                bool has_c_attribute = false;

                struct token* _Owner _Opt p_new_token = calloc(1, sizeof * p_new_token);
                if (p_new_token == NULL)
                {
                    throw;
                }

                p_new_token->type = TK_PPNUMBER;
                char* _Owner _Opt temp = strdup(has_c_attribute ? "1" : "0");
                if (temp == NULL)
                {
                    token_delete(p_new_token);
                    throw;
                }

                p_new_token->lexeme = temp;
                p_new_token->flags |= TK_FLAG_FINAL;

                token_list_add(&r, p_new_token);
                token_list_pop_front(input_list); //pop )
            }
            else
            {
                struct token* _Owner _Opt tk = token_list_pop_front_get(input_list);
                if (tk)
                    token_list_add(&r, tk);
            }
        }
    }
    catch
    {
        //TODO clear?
    }

    return r;
}

struct token_list process_identifiers(struct preprocessor_ctx* ctx, _Dtor struct token_list* list)
{
    assert(!token_list_is_empty(list));

    struct token_list list2 = { 0 };

    try
    {
        while (list->head != NULL)
        {
            if (list->head->type == TK_IDENTIFIER ||
                list->head->type == TK_IDENTIFIER_RECURSIVE_MACRO)
            {
                /*
                after  all  replacements  due  to  macro expansion and evaluations of
                defined    macro    expressions,    has_include    expressions,   and
                has_c_attribute   expressions  have  been  performed,  all  remaining
                identifiers  other  than true (including those lexically identical to
                keywords  such  as  false) are replaced with the pp-number 0, true is
                replaced  with  pp-number  1,  and  then  each preprocessing token is
                converted into a token.
                */

                struct token* _Owner _Opt p_new_token = token_list_pop_front_get(list);
                assert(p_new_token != NULL); //because the list is not empty
                p_new_token->type = TK_PPNUMBER;

                if (strcmp(p_new_token->lexeme, "true") == 0)
                {
                    p_new_token->lexeme[0] = '1';
                    p_new_token->lexeme[1] = '\0';
                }
                else if (strcmp(p_new_token->lexeme, "false") == 0)
                {
                    p_new_token->lexeme[0] = '0';
                    p_new_token->lexeme[1] = '\0';
                }
                else
                {
                    char* _Owner _Opt temp = strdup("0");
                    if (temp == NULL)
                    {
                        token_delete(p_new_token);
                        throw;
                    }
                    free(p_new_token->lexeme);
                    p_new_token->lexeme = temp;
                }

                token_list_add(&list2, p_new_token);
            }
            else
            {
                struct token* _Owner _Opt ptk = token_list_pop_front_get(list);
                assert(ptk != NULL); //because the list is not empty
                token_list_add(&list2, ptk);
            }
        }
        assert(!token_list_is_empty(&list2));
    }
    catch
    {
    }
    return list2;
}

struct token_list ignore_preprocessor_line(struct token_list* input_list)
{
    struct token_list r = { 0 };
    while (input_list->head && input_list->head->type != TK_NEWLINE)
    {
        struct token* _Owner _Opt tk = token_list_pop_front_get(input_list);
        assert(tk != NULL); //because the list is not empty
        token_list_add(&r, tk);
    }
    return r;
}

//todo passar lista para reotnro
long long preprocessor_constant_expression(struct preprocessor_ctx* ctx,
    struct token_list* output_list,
    struct token_list* input_list,
    int level
)
{
    assert(input_list->head != NULL);

    struct token* first = input_list->head;

    ctx->conditional_inclusion = true;

    struct token_list r = { 0 };
    while (input_list->head && input_list->head->type != TK_NEWLINE)
    {
        struct token* _Owner _Opt tk = token_list_pop_front_get(input_list);
        assert(tk != NULL); //because the list is not empty
        token_list_add(&r, tk);

        /*
          We call preprocessor that emmit warnings if line continuation
          is used outside macro directives.
          Let's remove TK_FLAG_LINE_CONTINUATION from the original token
          to avoid warning inside constant expressions
        */
        assert(r.tail != NULL);
        r.tail->flags &= ~TK_FLAG_LINE_CONTINUATION;
    }

    struct token_list list1 = copy_replacement_list(ctx, &r);
    token_list_swap(output_list, &r);


    int flags = ctx->flags;
    ctx->flags |= PREPROCESSOR_CTX_FLAGS_ONLY_FINAL;

    /*defined X  por exemplo é mantido sem ser expandido*/

    struct token_list list2 = preprocessor(ctx, &list1, 1);
    ctx->flags = flags;

    long long value = 0;

    if (list2.head == NULL)
    {
        preprocessor_diagnostic(C_ERROR_EXPRESSION_ERROR, ctx, first, "empty expression");
    }
    else
    {
        /*aonde defined has_c_aatribute sao transformados em constantes*/
        struct token_list list3 = process_defined(ctx, &list2);

        struct token_list list4 = process_identifiers(ctx, &list3);

        assert(list4.head != NULL);

        struct preprocessor_ctx pre_ctx = { 0 };

        pre_ctx.options = ctx->options;
        pre_ctx.input_list = list4;
        pre_ctx.current = pre_ctx.input_list.head;

        if (pre_constant_expression(&pre_ctx, &value) != 0)
        {
            preprocessor_diagnostic(C_ERROR_EXPRESSION_ERROR, ctx, first, "expression error");
        }

        ctx->conditional_inclusion = false;

        preprocessor_ctx_destroy(&pre_ctx);
    }

    token_list_destroy(&list1);
    token_list_destroy(&r);
    token_list_destroy(&list2);

    return value;
}

void match_level(struct token_list* dest, struct token_list* input_list, int level)
{
    if (INCLUDE_ALL || level == 0)
    {
        struct token* _Owner _Opt tk = token_list_pop_front_get(input_list);
        if (tk)
        {
            token_list_add(dest, tk);
        }
    }
    else
        token_list_pop_front(input_list);
}


int match_token_level(struct token_list* dest, struct token_list* input_list, enum token_type type, int level,
    struct preprocessor_ctx* ctx)
{
    try
    {
        if (input_list->head == NULL ||
            input_list->head->type != type)
        {
            if (type == TK_NEWLINE && input_list->head == NULL)
            {
                //vou aceitar final de arquivo como substituro do endline
                //exemplo #endif sem quebra de linha
            }
            else
            {
                if (input_list->head)
                    preprocessor_diagnostic(C_ERROR_UNEXPECTED_TOKEN, ctx, input_list->head, "expected token %s got %s\n", get_token_name(type), get_token_name(input_list->head->type));
                else
                    preprocessor_diagnostic(C_ERROR_UNEXPECTED_TOKEN, ctx, dest->tail, "expected EOF \n");

                throw;
            }
        }
        if (input_list->head != NULL)
        {
            if (INCLUDE_ALL || level == 0)
                token_list_add(dest, token_list_pop_front_get(input_list));
            else
                token_list_pop_front(input_list);
        }
    }
    catch
    {
    }
    return ctx->n_errors > 0;
}


struct token_list if_group(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level, bool* p_result)
{
    *p_result = 0; //out

    assert(input_list->head != NULL);

    struct token_list r = { 0 };
    try
    {
        /*
         if-group:
           # if constant-expression new-line group_opt
           # ifdef identifier new-line group_opt
           # ifndef identifier new-line group_opt
        */
        match_token_level(&r, input_list, TK_PREPROCESSOR_LINE, level, ctx);
        skip_blanks_level(ctx, &r, input_list, level);

        if (input_list->head == NULL)
            throw;

        assert(input_list->head->type == TK_IDENTIFIER);
        if (strcmp(input_list->head->lexeme, "ifdef") == 0)
        {
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //ifdef
            skip_blanks_level(ctx, &r, input_list, level);

            if (input_list->head == NULL)
            {
                pre_unexpected_end_of_file(r.tail, ctx);
                throw;
            }

            if (is_active)
            {
                struct macro* _Opt macro = find_macro(ctx, input_list->head->lexeme);
                *p_result = (macro != NULL) ? 1 : 0;
                //printf("#ifdef %s (%s)\n", input_list->head->lexeme, *p_result ? "true" : "false");
            }
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
            skip_blanks_level(ctx, &r, input_list, level);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
        }
        else if (strcmp(input_list->head->lexeme, "ifndef") == 0)
        {
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //ifndef
            skip_blanks_level(ctx, &r, input_list, level);

            if (input_list->head == NULL)
            {
                pre_unexpected_end_of_file(r.tail, ctx);
                throw;
            }

            if (is_active)
            {
                struct macro* _Opt macro = find_macro(ctx, input_list->head->lexeme);
                *p_result = (macro == NULL) ? 1 : 0;
            }
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
            skip_blanks_level(ctx, &r, input_list, level);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
        }
        else if (strcmp(input_list->head->lexeme, "if") == 0)
        {
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //if
            skip_blanks_level(ctx, &r, input_list, level);
            if (is_active)
            {
                struct token_list r0 = { 0 };
                *p_result = preprocessor_constant_expression(ctx, &r0, input_list, level);
                token_list_append_list(&r, &r0);
                token_list_destroy(&r0);
            }
            else
            {
                struct token_list r0 = ignore_preprocessor_line(input_list);
                token_list_append_list(&r, &r0);
                token_list_destroy(&r0);
            }
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
        }
        else
        {

            preprocessor_diagnostic(C_ERROR_UNEXPECTED, ctx, input_list->head, "unexpected");
            throw;
        }
        struct token_list r2 = group_opt(ctx, input_list, is_active && *p_result, level);
        token_list_append_list(&r, &r2);
        assert(r2.head == NULL);
        assert(r2.tail == NULL);
    }
    catch
    {
    }

    return r;
}

struct token_list elif_group(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level, bool* p_elif_result)
{
    *p_elif_result = 0; //out
    assert(input_list->head != NULL);

    struct token_list r = { 0 };

    try
    {
        /*
         elif-group:
          # elif constant-expression new-line group_opt

          C23
          # elifdef identifier new-line group_opt
          # elifndef identifier new-line group_opt
        */
        match_token_level(&r, input_list, TK_PREPROCESSOR_LINE, level, ctx);
        skip_blanks(ctx, &r, input_list);

        if (input_list->head == NULL)
            throw;

        unsigned long long result = 0;
        if (strcmp(input_list->head->lexeme, "elif") == 0)
        {
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
            skip_blanks(ctx, &r, input_list);

            if (is_active)
            {
                struct token_list r0 = { 0 };
                result = preprocessor_constant_expression(ctx, &r0, input_list, level);
                token_list_append_list(&r, &r0);
                token_list_destroy(&r0);
            }
            else
            {
                struct token_list r0 = ignore_preprocessor_line(input_list);
                token_list_append_list(&r, &r0);
                token_list_destroy(&r0);
            }
        }
        else if (strcmp(input_list->head->lexeme, "elifdef") == 0)
        {
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
            skip_blanks(ctx, &r, input_list);

            if (input_list->head == NULL)
                throw;

            if (is_active)
            {
                result = (hashmap_find(&ctx->macros, input_list->head->lexeme) != NULL) ? 1 : 0;
            }
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
        }
        else if (strcmp(input_list->head->lexeme, "elifndef") == 0)
        {
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
            skip_blanks(ctx, &r, input_list);

            if (input_list->head == NULL)
                throw;

            if (is_active)
            {
                result = (hashmap_find(&ctx->macros, input_list->head->lexeme) == NULL) ? 1 : 0;
            }
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
        }
        *p_elif_result = (result != 0);
        skip_blanks(ctx, &r, input_list);
        match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
        struct token_list r2 = group_opt(ctx, input_list, is_active && *p_elif_result, level);
        token_list_append_list(&r, &r2);
        token_list_destroy(&r2);
    }
    catch
    {
    }

    return r;
}

struct token_list elif_groups(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level, bool* pelif_result)
{
    assert(input_list->head != NULL);

    struct token_list r = { 0 };
    /*
    elif-groups:
      elif-group
      elif-groups elif-group
    */
    try
    {
        bool already_found_elif_true = false;
        bool elif_result = false;
        struct token_list r2 = elif_group(ctx, input_list, is_active, level, &elif_result);

        if (input_list->head == NULL)
        {
            token_list_destroy(&r2);
            throw;
        }

        token_list_append_list(&r, &r2);

        if (elif_result)
            already_found_elif_true = true;

        if (input_list->head->type == TK_PREPROCESSOR_LINE &&
            (
                preprocessor_token_ahead_is_identifier(input_list->head, "elif") ||
                preprocessor_token_ahead_is_identifier(input_list->head, "elifdef") ||
                preprocessor_token_ahead_is_identifier(input_list->head, "elifndef")
                )
            )
        {
            /*
              Depois que acha 1 true already_found_elif_true os outros sao false.
            */
            struct token_list r3 = elif_groups(ctx, input_list, is_active && !already_found_elif_true, level, &elif_result);
            token_list_append_list(&r, &r3);
            if (elif_result)
                already_found_elif_true = true;
            token_list_destroy(&r3);
        }
        /*
           Se algum dos elifs foi true retorna true
        */
        *pelif_result = already_found_elif_true;
        token_list_destroy(&r2);
    }
    catch
    {
        //TODO clear
    }

    return r;
}

struct token_list else_group(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    /*
      else-group:
       # else new-line group_opt
    */

    struct token_list r = { 0 };
    try
    {
        match_token_level(&r, input_list, TK_PREPROCESSOR_LINE, level, ctx);
        skip_blanks_level(ctx, &r, input_list, level);
        if (ctx->n_errors > 0) throw;

        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //else
        skip_blanks_level(ctx, &r, input_list, level);
        match_token_level(&r, input_list, TK_NEWLINE, level, ctx);

        struct token_list r2 = group_opt(ctx, input_list, is_active, level);
        token_list_append_list(&r, &r2);

        token_list_destroy(&r2);
    }
    catch
    {
        //tODO
    }

    return r;
}

struct token_list endif_line(struct preprocessor_ctx* ctx, struct token_list* input_list, int level)
{
    /*
     endif-line:
       # endif new-line
    */

    struct token_list r = { 0 };

    match_token_level(&r, input_list, TK_PREPROCESSOR_LINE, level, ctx); //#
    skip_blanks_level(ctx, &r, input_list, level);
    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //endif
    skip_blanks_level(ctx, &r, input_list, level);
    match_token_level(&r, input_list, TK_NEWLINE, level, ctx);

    return r;
}
struct token_list identifier_list(struct preprocessor_ctx* ctx, struct macro* macro, struct token_list* input_list, int level);
struct token_list replacement_list(struct preprocessor_ctx* ctx, struct macro* macro, struct token_list* input_list, int level);
static bool is_empty_assert(struct token_list* replacement_list);

struct token_list def_line(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level, struct macro** pp_macro)
{
    //https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3524.txt

    /*
    def-line:
       # def identifier new-line
       # def identifier lparen identifier-list(opt) ) new-line
       # def identifier lparen ... ) new-line
       # def identifier lparen identifier-list , ... ) new-line
    */
    struct token_list r = { 0 };

    try
    {
        /*
          This code is the same of define...TODO share
        */
        struct macro* _Owner _Opt macro = calloc(1, sizeof * macro);
        if (macro == NULL)
        {
            preprocessor_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, "out of mem");
            throw;
        }

        macro->def_macro = true;

        match_token_level(&r, input_list, TK_PREPROCESSOR_LINE, level, ctx); //#

        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //def
        skip_blanks_level(ctx, &r, input_list, level);

        if (input_list->head == NULL)
        {
            macro_delete(macro);
            pre_unexpected_end_of_file(r.tail, ctx);
            throw;
        }

        struct token* macro_name_token = input_list->head;

        if (is_builtin_macro(macro_name_token->lexeme))
        {
            preprocessor_diagnostic(W_REDEFINING_BUITIN_MACRO,
                ctx,
                input_list->head,
                "redefining builtin macro");
        }

        if (hashmap_find(&ctx->macros, input_list->head->lexeme) != NULL)
        {
            //printf("warning: '%s' macro redefined at %s %d\n",
              //     input_list->head->lexeme,
                ///   input_list->head->token_origin->lexeme,
                  // input_list->head->line);
        }

        char* _Owner _Opt temp = strdup(input_list->head->lexeme);
        if (temp == NULL)
        {
            macro_delete(macro);
            throw;
        }
        assert(macro->name == NULL);
        macro->name = temp;


        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //nome da macro

        if (input_list->head == NULL)
        {
            macro_delete(macro);
            pre_unexpected_end_of_file(r.tail, ctx);
            throw;
        }

        /*sem skip*/
        //p = preprocessor_match_token(p, is_active, level, false, IDENTIFIER); /*name*/
        if (input_list->head->type == '(')
        {
            macro->is_function = true;

            match_token_level(&r, input_list, '(', level, ctx);
            skip_blanks_level(ctx, &r, input_list, level);

            if (input_list->head == NULL)
            {
                macro_delete(macro);
                pre_unexpected_end_of_file(r.tail, ctx);
                throw;
            }

            if (input_list->head->type == '...')
            {
                struct macro_parameter* _Owner _Opt p_macro_parameter = calloc(1, sizeof * p_macro_parameter);
                if (p_macro_parameter == NULL)
                {
                    macro_delete(macro);
                    throw;
                }

                char* _Owner _Opt temp2 = strdup("__VA_ARGS__");
                if (temp2 == NULL)
                {
                    macro_delete(macro);
                    macro_parameters_delete(p_macro_parameter);
                    throw;
                }

                p_macro_parameter->name = temp2;
                macro->parameters = p_macro_parameter;

                // assert(false);
                match_token_level(&r, input_list, '...', level, ctx); //nome da macro
                skip_blanks_level(ctx, &r, input_list, level);
                match_token_level(&r, input_list, ')', level, ctx); //nome da macro
            }
            else if (input_list->head->type == ')')
            {
                match_token_level(&r, input_list, ')', level, ctx);
                skip_blanks_level(ctx, &r, input_list, level);
            }
            else
            {
                struct token_list r3 = identifier_list(ctx, macro, input_list, level);
                token_list_append_list(&r, &r3);
                token_list_destroy(&r3);

                skip_blanks_level(ctx, &r, input_list, level);
                if (input_list->head == NULL)
                {
                    macro_delete(macro);
                    pre_unexpected_end_of_file(r.tail, ctx);
                    throw;
                }

                if (input_list->head->type == '...')
                {
                    struct macro_parameter* _Owner _Opt p_macro_parameter = calloc(1, sizeof * p_macro_parameter);
                    if (p_macro_parameter == NULL)
                    {
                        macro_delete(macro);
                        throw;
                    }

                    char* _Owner _Opt temp3 = strdup("__VA_ARGS__");
                    if (temp3 == NULL)
                    {
                        macro_delete(macro);
                        macro_parameters_delete(p_macro_parameter);
                        throw;
                    }

                    p_macro_parameter->name = temp3;
                    struct macro_parameter* _Opt p_last = macro->parameters;
                    assert(p_last != NULL);
                    while (p_last->next)
                    {
                        p_last = p_last->next;
                    }
                    p_last->next = p_macro_parameter;

                    match_token_level(&r, input_list, '...', level, ctx);
                }
                skip_blanks_level(ctx, &r, input_list, level);
                match_token_level(&r, input_list, ')', level, ctx);
            }
        }
        else
        {
            macro->is_function = false;
        }
        skip_blanks_level(ctx, &r, input_list, level);
        if (input_list->head == NULL)
        {
            macro_delete(macro);
            pre_unexpected_end_of_file(r.tail, ctx);
            throw;
        }

        naming_convention_macro(ctx, macro_name_token);

        struct hash_item_set item = { 0 };
        item.p_macro = macro;
        hashmap_set(&ctx->macros, macro->name, &item);
        hash_item_set_destroy(&item);
        *pp_macro = macro;
    }
    catch
    {
    }

    return r;
}
struct token_list replacement_group(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    //https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3524.txt

    /*replacement-group:
        pp-tokens(opt) new-line
        replacement-group pp-tokens(opt) new-line
    */
    struct token_list r = { 0 };
    try
    {
        for (;;)
        {
            if (input_list->head == NULL)
            {
                preprocessor_diagnostic(C_ERROR_UNEXPECTED, ctx, r.tail, "missing #enddef");
                throw;
            }

            if (input_list->head->type == TK_PREPROCESSOR_LINE && (
                preprocessor_token_ahead_is_identifier(input_list->head, "enddef")))
            {
                break;
            }
            prematch_level(&r, input_list, level);
        }
    }
    catch
    {
    }
    return r;
}


struct token_list enddef_line(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    //https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3524.txt
    /*
      enddef-line:
        # enddef new-line
    */

    struct token_list r = { 0 };
    try
    {
        if (input_list->head == NULL)
        {
            pre_unexpected_end_of_file(r.tail, ctx);
            throw;
        }

        match_token_level(&r, input_list, TK_PREPROCESSOR_LINE, level, ctx); //#
        skip_blanks_level(ctx, &r, input_list, level);
        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //enddef
        skip_blanks_level(ctx, &r, input_list, level);
        match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
    }
    catch
    {
    }
    return r;
}

struct token_list def_section(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    /*
     def-section:
       def-line replacement-group(opt) enddef-line
    */
    struct token_list r = { 0 };
    try
    {
        struct macro* p_macro = NULL;
        struct token_list r2 = def_line(ctx, input_list, is_active, level, &p_macro);
        token_list_append_list(&r, &r2);

        if (ctx->n_errors > 0 || p_macro == NULL)
        {
            token_list_destroy(&r2);
            throw;
        }

        struct token_list r3 = replacement_group(ctx, input_list, is_active, level);

        if (ctx->n_errors > 0)
        {

            token_list_destroy(&r2);
            token_list_destroy(&r3);
            throw;
        }

        struct token_list copy = copy_replacement_list(ctx, &r3);
        token_list_append_list(&p_macro->replacement_list, &copy);

        token_list_append_list(&r, &r3);
        struct token_list r4 = enddef_line(ctx, input_list, is_active, level);
        token_list_append_list(&r, &r4);

        token_list_destroy(&r2);
        token_list_destroy(&r3);
        token_list_destroy(&r4);
        token_list_destroy(&copy);
    }
    catch
    {
    }


    return r;
}

struct token_list if_section(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    /*
     if-section:
       if-group elif-groups_opt else-group_opt endif-line
    */
    assert(input_list->head != NULL);

    struct token_list r = { 0 };

    try
    {
        bool if_result = false;
        struct token_list r2 = if_group(ctx, input_list, is_active, level, &if_result);
        if (ctx->n_errors > 0)
        {
            token_list_destroy(&r2);
            throw;
        }

        if (input_list->head == NULL)
        {
            token_list_destroy(&r2);
            throw;
        }

        token_list_append_list(&r, &r2);
        bool elif_result = false;
        if (input_list->head->type == TK_PREPROCESSOR_LINE && (
            preprocessor_token_ahead_is_identifier(input_list->head, "elif") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "elifdef") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "elifndef")))
        {
            struct token_list r3 = elif_groups(ctx, input_list, is_active && !if_result, level, &elif_result);
            token_list_append_list(&r, &r3);
            token_list_destroy(&r3);
        }

        if (input_list->head == NULL)
        {
            token_list_destroy(&r2);
            pre_unexpected_end_of_file(r.tail, ctx);
            throw;
        }


        if (input_list->head->type == TK_PREPROCESSOR_LINE &&
            preprocessor_token_ahead_is_identifier(input_list->head, "else"))
        {
            struct token_list r4 = else_group(ctx, input_list, is_active && !if_result && !elif_result, level);
            token_list_append_list(&r, &r4);
            token_list_destroy(&r4);
        }

        if (ctx->n_errors > 0)
        {
            token_list_destroy(&r2);
            throw;
        }

        struct token_list r5 = endif_line(ctx, input_list, level);
        token_list_append_list(&r, &r5);
        token_list_destroy(&r5);
        token_list_destroy(&r2);
    }
    catch
    {
    }

    return r;
}

struct token_list identifier_list(struct preprocessor_ctx* ctx, struct macro* macro, struct token_list* input_list, int level)
{
    assert(input_list->head != NULL);
    struct token_list r = { 0 };

    try
    {
        /*
          identifier-list:
          identifier
          identifier-list , identifier
        */
        skip_blanks(ctx, &r, input_list);

        if (input_list->head == NULL)
            throw;

        struct macro_parameter* _Owner _Opt p_macro_parameter = calloc(1, sizeof * p_macro_parameter);
        if (p_macro_parameter == NULL) throw;

        char* _Owner _Opt temp = strdup(input_list->head->lexeme);
        if (temp == NULL)
        {
            macro_parameters_delete(p_macro_parameter);
            throw;
        }
        p_macro_parameter->name = temp;

        assert(macro->parameters == NULL);
        macro->parameters = p_macro_parameter;

        struct macro_parameter* p_last_parameter = macro->parameters;

        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
        skip_blanks(ctx, &r, input_list);

        if (input_list->head == NULL)
        {
            throw;
        }

        while (input_list->head->type == ',')
        {
            match_token_level(&r, input_list, ',', level, ctx);
            skip_blanks(ctx, &r, input_list);

            if (input_list->head == NULL)
            {
                throw;
            }

            if (input_list->head->type == '...')
            {
                break;
            }

            struct macro_parameter* _Owner _Opt p_new_macro_parameter = calloc(1, sizeof * p_new_macro_parameter);
            if (p_new_macro_parameter == NULL)
                throw;

            char* _Opt _Owner temp2 = strdup(input_list->head->lexeme);
            if (temp2 == NULL)
            {
                macro_parameters_delete(p_new_macro_parameter);
                throw;
            }

            p_new_macro_parameter->name = temp2;

            assert(p_last_parameter->next == NULL);
            p_last_parameter->next = p_new_macro_parameter;
            p_last_parameter = p_last_parameter->next;

            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
            skip_blanks(ctx, &r, input_list);

            if (input_list->head == NULL)
            {
                throw;
            }
        }
    }
    catch
    {
    }
    return r;
}


struct token_list replacement_list(struct preprocessor_ctx* ctx, struct macro* macro, struct token_list* input_list, int level)
{
    struct token_list r = { 0 };

    try
    {
        if (input_list->head == NULL)
        {
            pre_unexpected_end_of_file(NULL, ctx);
            throw;
        }

        while (input_list->head->type != TK_NEWLINE)
        {
            match_level(&r, input_list, level);
            if (input_list->head == NULL)
            {
                //terminou define sem quebra de linha
                break;
            }
        }

        assert(macro->replacement_list.head == NULL);
        struct token_list copy = copy_replacement_list(ctx, &r);
        token_list_append_list(&macro->replacement_list, &copy);
        token_list_destroy(&copy);
    }
    catch
    {
    }
    return r;
}

struct token_list pp_tokens_opt(struct preprocessor_ctx* ctx, struct token_list* input_list, int level)
{
    struct token_list r = { 0 };
    while (input_list->head && input_list->head->type != TK_NEWLINE)
    {
        prematch_level(&r, input_list, level);
    }
    return r;
}

static bool is_empty_assert(struct token_list* replacement_list)
{
    struct token* _Opt token = replacement_list->head;

    if (token == NULL)
        return false;

    if (strcmp(token->lexeme, "(")) return false;
    token = token->next;

    if (token == NULL) return false;
    if (strcmp(token->lexeme, "(")) return false;
    token = token->next;

    if (token == NULL) return false;
    if (strcmp(token->lexeme, "void")) return false;
    token = token->next;

    if (token == NULL) return false;
    if (strcmp(token->lexeme, ")")) return false;
    token = token->next;

    if (token == NULL) return false;
    if (strcmp(token->lexeme, "0")) return false;
    token = token->next;

    if (token == NULL) return false;
    if (strcmp(token->lexeme, ")")) return false;
    token = token->next;

    if (token != NULL) return false;

    return true;
}


struct token_list control_line(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{

    /*
        control-line:
            # "include" pp-tokens new-line
            # "embed" pp-tokens new-line
            # "define" identifier replacement-list new-line
            # "define" identifier ( identifier-list _Opt ) replacement-list new-line
            # "define" identifier ( ... ) replacement-list new-line
            # "define" identifier ( identifier-list , ... ) replacement-list new-line
            # "undef" identifier new-line
            # "line" pp-tokens new-line
            # "error" pp-tokens _Opt new-line
            # "warning" pp-tokens _Opt new-line
            # "pragma" pp-tokens _Opt new-line
            # new-line
    */

    struct token_list r = { 0 };

    try
    {
        if (!is_active)
        {
            //se nao esta ativo eh ignorado
            struct token_list r7 = pp_tokens_opt(ctx, input_list, level);
            token_list_append_list(&r, &r7);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
            token_list_destroy(&r7);
            return r;
        }

        if (input_list->head == NULL)
        {
            pre_unexpected_end_of_file(r.tail, ctx);
            throw;
        }

        //struct token* const ptoken = input_list->head;
        match_token_level(&r, input_list, TK_PREPROCESSOR_LINE, level, ctx);
        skip_blanks_level(ctx, &r, input_list, level);

        if (input_list->head == NULL)
        {
            pre_unexpected_end_of_file(r.tail, ctx);
            throw;
        }

        if (strcmp(input_list->head->lexeme, "include") == 0 ||
            strcmp(input_list->head->lexeme, "include_next") == 0)
        {
            bool include_next = strcmp(input_list->head->lexeme, "include_next") == 0;
            /*
              # include pp-tokens new-line
            */
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //include
            skip_blanks_level(ctx, &r, input_list, level);

            if (input_list->head == NULL)
            {
                pre_unexpected_end_of_file(r.tail, ctx);
                throw;
            }

            char path[100] = { 0 };
            bool is_angle_bracket_form = false;
            if (input_list->head->type == TK_STRING_LITERAL)
            {
                strcat(path, input_list->head->lexeme);
                prematch_level(&r, input_list, level);
            }
            else
            {
                is_angle_bracket_form = true;
                while (input_list->head->type != '>')
                {
                    strcat(path, input_list->head->lexeme);
                    prematch_level(&r, input_list, level);

                    if (input_list->head == NULL)
                    {
                        pre_unexpected_end_of_file(r.tail, ctx);
                        throw;
                    }
                }
                strcat(path, input_list->head->lexeme);
                prematch_level(&r, input_list, level);
            }


            while (input_list->head->type != TK_NEWLINE)
            {
                prematch_level(&r, input_list, level);
                if (input_list->head == NULL)
                {
                    pre_unexpected_end_of_file(r.tail, ctx);
                    throw;
                }
            }

            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);

            path[strlen(path) - 1] = '\0';

            /*this is the dir of the current file*/
            char current_file_dir[300] = { 0 };
            snprintf(current_file_dir, sizeof current_file_dir, "%s", r.tail->token_origin->lexeme);
            dirname(current_file_dir);


            char full_path_result[200] = { 0 };
            bool already_included = false;
            const char* _Owner _Opt content = find_and_read_include_file(ctx,
                path + 1,
                current_file_dir,
                is_angle_bracket_form,
                &already_included,
                full_path_result,
                sizeof full_path_result,
                include_next);

            if (content != NULL)
            {
                if (ctx->options.show_includes)
                {
                    for (int i = 0; i < (level + 1); i++)
                        printf(".");
                    printf("%s\n", full_path_result);
                }

                struct tokenizer_ctx tctx = { 0 };
                struct token_list list = tokenizer(&tctx, content, full_path_result, level + 1, TK_FLAG_NONE);
                free((void* _Owner)content);

                struct token_list list2 = preprocessor(ctx, &list, level + 1);
                token_list_append_list(&r, &list2);

                token_list_destroy(&list2);
                token_list_destroy(&list);
            }
            else
            {
                if (!already_included)
                {
                    preprocessor_diagnostic(C_ERROR_FILE_NOT_FOUND, ctx, r.tail, "file %s not found", path + 1);

                    for (struct include_dir* _Opt p = ctx->include_dir.head; p; p = p->next)
                    {
                        /*let's print the include path*/
                        preprocessor_diagnostic(W_NOTE, ctx, r.tail, "dir = '%s'", p->path);
                    }
                }
                else
                {
                    //pragma once..
                }
            }

        }
        else if (strcmp(input_list->head->lexeme, "embed") == 0)
        {
            struct token_list discard0 = { 0 };
            struct token_list* p_list = &r;

            /*
              C23
              # embed pp-tokens new-line
            */

            const struct token* const p_embed_token = input_list->head;

            match_token_level(p_list, input_list, TK_IDENTIFIER, level, ctx); //embed

            skip_blanks_level(ctx, p_list, input_list, level);


            if (input_list->head == NULL)
            {
                throw;
            }

            char path[100] = { 0 };
            if (input_list->head->type == TK_STRING_LITERAL)
            {
                strcat(path, input_list->head->lexeme);
                prematch_level(p_list, input_list, level);
            }
            else
            {
                while (input_list->head->type != '>')
                {
                    strcat(path, input_list->head->lexeme);
                    prematch_level(p_list, input_list, level);

                    if (input_list->head == NULL)
                    {
                        throw;
                    }
                }
                strcat(path, input_list->head->lexeme);
                prematch_level(p_list, input_list, level);
            }

            if (input_list->head)
            {
                while (input_list->head->type != TK_NEWLINE)
                {
                    prematch_level(p_list, input_list, level);
                    if (input_list->head == NULL)
                    {
                        pre_unexpected_end_of_file(p_list->tail, ctx);
                        throw;
                    }
                }
            }
            match_token_level(p_list, input_list, TK_NEWLINE, level, ctx);

            char fullpath[300] = { 0 };
            path[strlen(path) - 1] = '\0';

            snprintf(fullpath, sizeof(fullpath), "%s", path + 1);


            int nlevel = level;

            enum token_flags f = 0;

            f = TK_FLAG_FINAL;
            //we cannot see it just like include
            nlevel = nlevel + 1;

            struct token_list list = embed_tokenizer(ctx, p_embed_token, fullpath, nlevel, f);

            if (ctx->n_errors > 0)
            {
                token_list_destroy(&list);
                throw;
            }

            token_list_append_list(&r, &list);
            token_list_destroy(&list);
            token_list_destroy(&discard0);
        }
        else if (strcmp(input_list->head->lexeme, "define") == 0)
        {
            //TODO strcmp nao pode ser usado temos que criar uma funcao especial

            /*
             #de\
             fine A 1

            A
            */

            struct macro* _Owner _Opt macro = calloc(1, sizeof * macro);
            if (macro == NULL)
            {
                preprocessor_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, "out of mem");
                throw;
            }

            /*
                # define identifier                           replacement-list new-line
                # define identifier ( identifier-list_opt )    replacement-list new-line
                # define identifier ( ... )                   replacement-list new-line
                # define identifier ( identifier-list , ... ) replacement-list new-line
            */
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //define
            skip_blanks_level(ctx, &r, input_list, level);

            if (input_list->head == NULL)
            {
                macro_delete(macro);
                pre_unexpected_end_of_file(r.tail, ctx);
                throw;
            }

            struct token* macro_name_token = input_list->head;

            if (is_builtin_macro(macro_name_token->lexeme))
            {
                preprocessor_diagnostic(W_REDEFINING_BUITIN_MACRO,
                    ctx,
                    input_list->head,
                    "redefining builtin macro");
            }

            macro->p_name_token = macro_name_token;

            char* _Owner _Opt temp = strdup(input_list->head->lexeme);
            if (temp == NULL)
            {
                macro_delete(macro);
                throw;
            }
            assert(macro->name == NULL);
            macro->name = temp;


            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //nome da macro

            if (input_list->head == NULL)
            {
                macro_delete(macro);
                pre_unexpected_end_of_file(r.tail, ctx);
                throw;
            }

            if (input_list->head->type == '(')
            {
                macro->is_function = true;

                match_token_level(&r, input_list, '(', level, ctx);
                skip_blanks_level(ctx, &r, input_list, level);

                if (input_list->head == NULL)
                {
                    macro_delete(macro);
                    pre_unexpected_end_of_file(r.tail, ctx);
                    throw;
                }

                if (input_list->head->type == '...')
                {
                    struct macro_parameter* _Owner _Opt p_macro_parameter = calloc(1, sizeof * p_macro_parameter);
                    if (p_macro_parameter == NULL)
                    {
                        macro_delete(macro);
                        throw;
                    }

                    char* _Owner _Opt temp2 = strdup("__VA_ARGS__");
                    if (temp2 == NULL)
                    {
                        macro_delete(macro);
                        macro_parameters_delete(p_macro_parameter);
                        throw;
                    }

                    p_macro_parameter->name = temp2;
                    macro->parameters = p_macro_parameter;

                    // assert(false);
                    match_token_level(&r, input_list, '...', level, ctx); //nome da macro
                    skip_blanks_level(ctx, &r, input_list, level);
                    match_token_level(&r, input_list, ')', level, ctx); //nome da macro
                }
                else if (input_list->head->type == ')')
                {
                    match_token_level(&r, input_list, ')', level, ctx);
                    skip_blanks_level(ctx, &r, input_list, level);
                }
                else
                {

                    struct token_list r3 = identifier_list(ctx, macro, input_list, level);
                    token_list_append_list(&r, &r3);
                    token_list_destroy(&r3);

                    skip_blanks_level(ctx, &r, input_list, level);
                    if (input_list->head == NULL)
                    {
                        macro_delete(macro);
                        pre_unexpected_end_of_file(r.tail, ctx);
                        throw;
                    }

                    if (input_list->head->type == '...')
                    {
                        struct macro_parameter* _Owner _Opt p_macro_parameter = calloc(1, sizeof * p_macro_parameter);
                        if (p_macro_parameter == NULL)
                        {
                            macro_delete(macro);
                            throw;
                        }

                        char* _Owner _Opt temp3 = strdup("__VA_ARGS__");
                        if (temp3 == NULL)
                        {
                            macro_delete(macro);
                            macro_parameters_delete(p_macro_parameter);
                            throw;
                        }

                        p_macro_parameter->name = temp3;
                        struct macro_parameter* _Opt p_last = macro->parameters;
                        assert(p_last != NULL);
                        while (p_last->next)
                        {
                            p_last = p_last->next;
                        }
                        p_last->next = p_macro_parameter;

                        match_token_level(&r, input_list, '...', level, ctx);
                    }
                    skip_blanks_level(ctx, &r, input_list, level);
                    match_token_level(&r, input_list, ')', level, ctx);
                }
            }
            else
            {
                macro->is_function = false;
            }
            skip_blanks_level(ctx, &r, input_list, level);
            if (input_list->head == NULL)
            {
                macro_delete(macro);
                pre_unexpected_end_of_file(r.tail, ctx);
                throw;
            }
            struct token_list r4 = replacement_list(ctx, macro, input_list, level);
            token_list_append_list(&r, &r4);
            token_list_destroy(&r4);

            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
            if (!ctx->options.disable_assert && strcmp(macro->name, "assert") == 0)
            {
                //cake overrides macro assert in debug and release to be defined as 
                //assert(__VA_ARGS__)
                if (!is_empty_assert(&macro->replacement_list))
                {
                    macro_parameters_delete(macro->parameters);

                    struct macro_parameter* _Owner _Opt p_macro_parameter = calloc(1, sizeof * p_macro_parameter);
                    if (p_macro_parameter == NULL)
                    {
                        macro_delete(macro);
                        throw;
                    }

                    char* _Owner _Opt temp2 = strdup("__VA_ARGS__");
                    if (temp2 == NULL)
                    {
                        macro_delete(macro);
                        macro_parameters_delete(p_macro_parameter);
                        throw;
                    }
                    p_macro_parameter->name = temp2;
                    macro->parameters = p_macro_parameter;

                    token_list_destroy(&macro->replacement_list);
                    struct tokenizer_ctx tctx = { 0 };
                    macro->replacement_list = tokenizer(&tctx, "assert(__VA_ARGS__)", NULL, level, TK_FLAG_NONE);
                }
            }

            naming_convention_macro(ctx, macro_name_token);

            struct macro* existing_macro = find_macro(ctx, macro->name);
            if (existing_macro)
            {
                if (!macro_is_same(macro, existing_macro))
                {
                    preprocessor_diagnostic(C_ERROR_MACRO_REDEFINITION,
                    ctx,
                    macro->p_name_token,
                    "macro redefinition");

                    preprocessor_diagnostic(W_NOTE,
                    ctx,
                    existing_macro->p_name_token,
                    "previous definition");

                    macro_delete(macro);
                    throw;
                }
                macro_delete(macro);
            }
            else
            {
                struct hash_item_set item = { 0 };
                item.p_macro = macro;
                hashmap_set(&ctx->macros, macro->name, &item);
                hash_item_set_destroy(&item);
            }
        }
        else if (strcmp(input_list->head->lexeme, "undef") == 0)
        {
            /*
             # undef identifier new-line
            */
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//undef
            skip_blanks_level(ctx, &r, input_list, level);

            if (input_list->head == NULL)
            {
                pre_unexpected_end_of_file(r.tail, ctx);
                throw;
            }

            struct macro* _Owner _Opt macro = (struct macro* _Owner _Opt) hashmap_remove(&ctx->macros, input_list->head->lexeme, NULL);
            assert(find_macro(ctx, input_list->head->lexeme) == NULL);
            if (macro)
            {
                macro_delete(macro);
                match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//undef
            }
            else
            {
                match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//undef
                /*no warnings*/
            }
            skip_blanks_level(ctx, &r, input_list, level);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
        }
        else if (strcmp(input_list->head->lexeme, "line") == 0)
        {
            /*
               # line pp-tokens new-line
            */
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//line
            struct token_list r5 = pp_tokens_opt(ctx, input_list, level);
            token_list_append_list(&r, &r5);
            token_list_destroy(&r5);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
        }
        else if (strcmp(input_list->head->lexeme, "error") == 0)
        {
            /*
              # error pp-tokensopt new-line
            */
            ctx->n_warnings++;
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//error
            struct token_list r6 = pp_tokens_opt(ctx, input_list, level);
            preprocessor_diagnostic(C_ERROR_PREPROCESSOR_C_ERROR_DIRECTIVE, ctx, input_list->head, "#error");
            token_list_append_list(&r, &r6);
            token_list_destroy(&r6);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);


        }
        else if (strcmp(input_list->head->lexeme, "warning") == 0)
        {
            /*
              # warning pp-tokensopt new-line
            */
            ctx->n_warnings++;

            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//warning

            struct token_list r6 = pp_tokens_opt(ctx, input_list, level);
            preprocessor_diagnostic(W_NONE, ctx, input_list->head, "#warning");
            token_list_append_list(&r, &r6);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
            token_list_destroy(&r6);
        }
        else if (strcmp(input_list->head->lexeme, "pragma") == 0)
        {
            /*
              # pragma pp-tokensopt new-line
            */
            /*
               #pragma will survive and compiler will handle as
               pragma declaration
            */
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//pragma

            if (r.tail)
            {
                r.tail->type = TK_PRAGMA;
                r.tail->flags |= TK_FLAG_FINAL;
            }
            skip_blanks_level(ctx, &r, input_list, level);

            if (input_list->head == NULL)
            {
                pre_unexpected_end_of_file(r.tail, ctx);
                throw;
            }

            if (input_list->head->type == TK_IDENTIFIER)
            {
                if (strcmp(input_list->head->lexeme, "CAKE") == 0)
                {
                    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
                    if (r.tail)
                    {
                        r.tail->flags |= TK_FLAG_FINAL;
                    }
                    skip_blanks_level(ctx, &r, input_list, level);
                }

                if (input_list->head == NULL)
                {
                    pre_unexpected_end_of_file(r.tail, ctx);
                    throw;
                }

                if (strcmp(input_list->head->lexeme, "once") == 0)
                {
                    pragma_once_add(ctx, input_list->head->token_origin->lexeme);
                    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//pragma
                    if (r.tail)
                    {
                        r.tail->flags |= TK_FLAG_FINAL;
                    }
                }
                else if (strcmp(input_list->head->lexeme, "dir") == 0)
                {
                    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//pragma
                    skip_blanks_level(ctx, &r, input_list, level);

                    if (input_list->head == NULL)
                    {
                        pre_unexpected_end_of_file(r.tail, ctx);
                        throw;
                    }

                    if (input_list->head->type != TK_STRING_LITERAL)
                    {
                        preprocessor_diagnostic(C_ERROR_UNEXPECTED, ctx, input_list->head, "expected string");
                        throw;
                    }

                    char path[200] = { 0 };
                    strncpy(path, input_list->head->lexeme + 1, strlen(input_list->head->lexeme) - 2);
                    include_dir_add(&ctx->include_dir, path);
                    match_token_level(&r, input_list, TK_STRING_LITERAL, level, ctx);//pragma
                    if (r.tail)
                    {
                        r.tail->flags |= TK_FLAG_FINAL;
                    }
                }
                else if (strcmp(input_list->head->lexeme, "nullchecks") == 0)
                {
                    assert(false);
                    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//nullchecks
                    assert(r.tail != NULL);
                    r.tail->flags |= TK_FLAG_FINAL;

                    skip_blanks_level(ctx, &r, input_list, level);
                    ctx->options.null_checks_enabled = true;
                }

                if (input_list->head == NULL)
                {
                    pre_unexpected_end_of_file(r.tail, ctx);
                    throw;
                }

                if (strcmp(input_list->head->lexeme, "diagnostic") == 0)
                {
                    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//diagnostic
                    assert(r.tail != NULL);
                    r.tail->flags |= TK_FLAG_FINAL;

                    skip_blanks_level(ctx, &r, input_list, level);

                    if (input_list->head == NULL)
                    {
                        pre_unexpected_end_of_file(r.tail, ctx);
                        throw;
                    }

                    if (strcmp(input_list->head->lexeme, "push") == 0)
                    {
                        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//diagnostic
                        assert(r.tail != NULL);
                        r.tail->flags |= TK_FLAG_FINAL;

                        //#pragma GCC diagnostic push
                        if (ctx->options.diagnostic_stack.top_index <
                            sizeof(ctx->options.diagnostic_stack) / sizeof(ctx->options.diagnostic_stack.stack[0]))
                        {
                            ctx->options.diagnostic_stack.top_index++;

                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] =
                                ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index - 1];
                        }
                    }
                    else if (strcmp(input_list->head->lexeme, "pop") == 0)
                    {
                        //#pragma GCC diagnostic pop
                        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//pop
                        assert(r.tail != NULL);
                        r.tail->flags |= TK_FLAG_FINAL;
                        if (ctx->options.diagnostic_stack.top_index > 0)
                        {
                            ctx->options.diagnostic_stack.top_index--;
                        }
                    }
                    else if (strcmp(input_list->head->lexeme, "warning") == 0)
                    {
                        //#pragma CAKE diagnostic warning "-Wenum-compare"

                        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//warning
                        assert(r.tail != NULL);
                        r.tail->flags |= TK_FLAG_FINAL;
                        skip_blanks_level(ctx, &r, input_list, level);

                        if (input_list->head && input_list->head->type == TK_STRING_LITERAL)
                        {
                            match_token_level(&r, input_list, TK_STRING_LITERAL, level, ctx);//""
                            assert(r.tail != NULL);
                            r.tail->flags |= TK_FLAG_FINAL;

                            unsigned long long  w = get_warning_bit_mask(input_list->head->lexeme + 1 + 2);
                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings |= w;
                        }
                    }
                    else if (strcmp(input_list->head->lexeme, "ignore") == 0)
                    {
                        //#pragma CAKE diagnostic ignore "-Wenum-compare"

                        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//ignore
                        assert(r.tail != NULL);
                        r.tail->flags |= TK_FLAG_FINAL;

                        skip_blanks_level(ctx, &r, input_list, level);

                        if (input_list->head && input_list->head->type == TK_STRING_LITERAL)
                        {
                            unsigned long long w = get_warning_bit_mask(input_list->head->lexeme + 1 + 2);
                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;
                        }
                    }
                }
            }

            struct token_list r7 = pp_tokens_opt(ctx, input_list, level);
            token_list_append_list(&r, &r7);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
            assert(r.tail != NULL);
            r.tail->type = TK_PRAGMA_END;
            r.tail->flags |= TK_FLAG_FINAL;
            token_list_destroy(&r7);
        }
        else if (input_list->head->type == TK_NEWLINE)
        {
            skip_blanks_level(ctx, &r, input_list, level);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
        }
        else
        {
            //handled by the caller
            preprocessor_diagnostic(C_ERROR_UNEXPECTED_TOKEN,
                ctx,
                input_list->head,
                "unexpected\n");
            throw;
        }
    }
    catch
    {
    }

    return r;
}


static struct token_list non_directive(struct preprocessor_ctx* ctx, struct token_list* input_list, int level)
{
    /*
      non-directive:
      pp-tokens new-line
     */
    struct token_list r = pp_tokens_opt(ctx, input_list, level);
    skip_blanks_level(ctx, &r, input_list, level);
    match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
    return r;
}

static struct macro_argument_list collect_macro_arguments(struct preprocessor_ctx* ctx,
    struct macro* macro,
    struct token_list* input_list, int level)
{

    struct macro_argument_list macro_argument_list = { 0 };

    try
    {
        if (input_list->head == NULL)
        {
            throw;
        }

        assert(input_list->head->type == TK_IDENTIFIER);//macro name
        const struct token* const macro_name_token = input_list->head;

        match_token_level(&macro_argument_list.tokens, input_list, TK_IDENTIFIER, level, ctx); //MACRO NAME

        if (!macro->is_function)
        {
            //This function is also called for non function like macros.
            //In this case we return empty
            return macro_argument_list;
        }


        int count = 1;

        //skip spaces after macro name
        skip_blanks(ctx, &macro_argument_list.tokens, input_list);

        //macro is a function
        match_token_level(&macro_argument_list.tokens, input_list, '(', level, ctx);

        //skip spaces after (
        skip_blanks(ctx, &macro_argument_list.tokens, input_list);

        if (input_list->head == NULL)
        {
            pre_unexpected_end_of_file(macro_argument_list.tokens.tail, ctx);
            throw;
        }

        if (input_list->head->type == ')')
        {
            /*
               empty argument list
            */

            if (macro->parameters != NULL)
            {
                struct macro_argument* _Owner _Opt  p_argument = calloc(1, sizeof(struct macro_argument));
                if (p_argument == NULL)
                {
                    throw;
                }
                struct macro_parameter* p_current_parameter = macro->parameters;
                p_argument->macro_parameter = p_current_parameter;
                argument_list_add(&macro_argument_list, p_argument);
            }
            match_token_level(&macro_argument_list.tokens, input_list, ')', level, ctx);
            return macro_argument_list;
        }

        if (macro->parameters == NULL)
        {
            //we have a non empty argument list, calling a macro without parameters
            preprocessor_diagnostic(C_ERROR_TOO_MANY_ARGUMENTS_TO_FUNCTION_LIKE_MACRO, ctx, macro_name_token, "too many arguments provided to function-like macro invocation\n");
            throw;
        }

        struct macro_parameter* p_current_parameter = macro->parameters;
        struct macro_argument* _Owner _Opt p_argument = calloc(1, sizeof(struct macro_argument));
        if (p_argument == NULL)
        {
            throw;
        }

        p_argument->macro_parameter = p_current_parameter;
        //collect next arguments...
        while (input_list->head != NULL)
        {
            if (input_list->head->type == '(')
            {
                count++;
                token_list_clone_and_add(&p_argument->tokens, input_list->head);
                match_token_level(&macro_argument_list.tokens, input_list, '(', level, ctx);
            }
            else if (input_list->head->type == ')')
            {
                count--;
                if (count == 0)
                {
                    match_token_level(&macro_argument_list.tokens, input_list, ')', level, ctx);
                    argument_list_add(&macro_argument_list, p_argument);
                    p_argument = NULL; //MOVED

                    if (p_current_parameter->next != NULL)
                    {
                        p_current_parameter = p_current_parameter->next;
                        if (strcmp(p_current_parameter->name, "__VA_ARGS__") == 0)
                        {
                            //we add this argument as being empty
                            p_argument = calloc(1, sizeof(struct macro_argument));
                            if (p_argument == NULL)
                            {
                                throw;
                            }

                            p_argument->macro_parameter = p_current_parameter;
                            argument_list_add(&macro_argument_list, p_argument);
                            p_argument = NULL; //MOVED
                        }
                        else
                        {
                            preprocessor_diagnostic(C_ERROR_TOO_FEW_ARGUMENTS_TO_FUNCTION_LIKE_MACRO, ctx, macro_name_token, "too few arguments provided to function-like macro invocation\n");
                            throw;
                        }
                    }

                    break;
                }
                else
                {
                    token_list_clone_and_add(&p_argument->tokens, input_list->head);
                    match_token_level(&macro_argument_list.tokens, input_list, ')', level, ctx);
                }
            }
            else if (count == 1 && input_list->head->type == ',')
            {
                if (strcmp(p_current_parameter->name, "__VA_ARGS__") == 0)
                {
                    token_list_clone_and_add(&p_argument->tokens, input_list->head);
                    match_token_level(&macro_argument_list.tokens, input_list, ',', level, ctx);
                }
                else //if (count == 1)
                {
                    match_token_level(&macro_argument_list.tokens, input_list, ',', level, ctx);
                    argument_list_add(&macro_argument_list, p_argument);
                    p_argument = NULL; /*MOVED*/

                    p_argument = calloc(1, sizeof(struct macro_argument));
                    if (p_argument == NULL)
                    {
                        throw;
                    }

                    if (p_current_parameter->next == NULL)
                    {
                        preprocessor_diagnostic(C_ERROR_TOO_MANY_ARGUMENTS_TO_FUNCTION_LIKE_MACRO, ctx, macro_argument_list.tokens.tail, "too many arguments provided to function-like macro invocation\n");
                        macro_argument_delete(p_argument);
                        p_argument = NULL; //DELETED
                        throw;
                    }

                    p_current_parameter = p_current_parameter->next;

                    p_argument->macro_parameter = p_current_parameter;
                }
            }
            else
            {
                token_list_clone_and_add(&p_argument->tokens, input_list->head);
                prematch_level(&macro_argument_list.tokens, input_list, level);
                //token_list_add(&list, token_list_pop_front(input_list));
            }
        }

        assert(p_argument == NULL);
    }
    catch
    {
    }

    return macro_argument_list;
}

struct token_list expand_macro(struct preprocessor_ctx* ctx, struct macro_expanded* _Opt p_list, struct macro* macro, struct macro_argument_list* arguments, int level, const struct token* origin);
struct token_list replacement_list_reexamination(struct preprocessor_ctx* ctx, struct macro_expanded* p_list, struct token_list* oldlist, int level, const struct token* origin);


struct token_list macro_copy_replacement_list(struct preprocessor_ctx* ctx, struct macro* macro, const struct token* origin);

/*#define hash_hash # ## #
#define mkstr(a) # a
#define in_between(a) mkstr(a)
#define join(c, d) in_between(c hash_hash d)

hash_hash

join(x, y)
*/
static struct token_list concatenate(struct preprocessor_ctx* ctx, struct token_list* input_list)
{
    //printf("input="); print_list(input_list);

    struct token_list  r = { 0 };
    try
    {
        //todo juntar tokens mesmo objet macro
        //struct token* p_previousNonBlank = 0;
        while (input_list->head)
        {
            //printf("r="); print_list(&r);
            //printf("input="); print_list(input_list);

            //#def macro
            //assert(!(input_list->head->flags & TK_FLAG_HAS_NEWLINE_BEFORE));
            if (input_list->head->type == '##')
            {
                if (r.tail == NULL)
                {
                    preprocessor_diagnostic(C_ERROR_PREPROCESSOR_MISSING_MACRO_ARGUMENT, ctx, input_list->head, "missing macro argument (should be checked before)");
                    break;
                }
                /*
                * arranca ## do input (sem adicionar)
                */
                token_list_pop_front(input_list);

                struct osstream ss = { 0 };

                /*
                *  Faz uma string com o fim r + começo do input (## ja foi removido)
                */
                if (r.tail->lexeme[0] != '\0')
                    ss_fprintf(&ss, "%s", r.tail->lexeme);

                if (input_list->head && input_list->head->lexeme[0] != '\0')
                    ss_fprintf(&ss, "%s", input_list->head->lexeme);


                //copiar o level para gerar um novo igual
                int level = input_list->head ? input_list->head->level : 0;

                /*
                * Já paga do input o token usado na concatenacao
                */
                token_list_pop_front(input_list);

                /*
                * Faz um novo token com a string montada
                */
                struct tokenizer_ctx tctx = { 0 };
                struct token_list newlist = { 0 };

                if (ss.c_str != NULL)
                {
                    newlist = tokenizer(&tctx, ss.c_str, NULL, level, TK_FLAG_NONE);
                }

                if (newlist.head)
                {
                    newlist.head->flags = r.tail->flags;
                }
                else
                {
                    struct token* _Owner _Opt p_new_token = calloc(1, sizeof * p_new_token);
                    if (p_new_token == NULL)
                    {
                        ss_close(&ss);
                        throw;
                    }
                    char* _Owner _Opt temp = strdup("");
                    if (temp == NULL)
                    {
                        ss_close(&ss);
                        token_delete(p_new_token);
                        throw;
                    }
                    p_new_token->lexeme = temp;
                    p_new_token->type = TK_PLACEMARKER;
                    token_list_add(&newlist, p_new_token);
                    assert(newlist.head != NULL);
                    newlist.head->flags = r.tail->flags;
                }
                /*
                * Arranca o anterior do r que foi usado para formar string
                */
                token_list_pop_back(&r);

                /*adiciona novo token no fim do r*/
                token_list_append_list(&r, &newlist);

                ss_close(&ss);

                token_list_destroy(&newlist);

                if (input_list->head == NULL)
                    break;
            }
            else
            {
                prematch(&r, input_list);
            }
        }
    }
    catch
    {
    }

    return r;
}

/*
  check if the argument list that corresponds to a trailing ...
  of the parameter list is present and has a non-empty substitution.
*/
static bool has_argument_list_empty_substitution(struct preprocessor_ctx* ctx,
    struct macro_expanded* p_list,
    struct macro_argument_list* p_macro_argument_list,
    const struct token* origin)
{
    if (p_macro_argument_list->head == NULL)
        return true;

    struct macro_argument* _Opt p_va_args_argument =
        find_macro_argument_by_name(p_macro_argument_list, "__VA_ARGS__");

    if (p_va_args_argument)
    {
        if (p_va_args_argument->tokens.head == NULL)
            return true;

        struct token_list argumentlist = copy_argument_list(p_va_args_argument);

        struct token_list r4 = replacement_list_reexamination(ctx, p_list, &argumentlist, 0, origin);
        const bool results_in_empty_substituition = (r4.head == NULL || r4.head->type == TK_PLACEMARKER);
        token_list_destroy(&r4);

        token_list_destroy(&argumentlist);

        return results_in_empty_substituition;
    }

    return false;
}

static struct token_list replace_macro_arguments(struct preprocessor_ctx* ctx, struct macro_expanded* p_list, struct token_list* input_list, struct macro_argument_list* arguments, const struct token* origin)
{
    struct token_list r = { 0 };

    try
    {
        /*clear previous usage*/
        struct macro_argument* _Owner _Opt p = arguments->head;
        while (p)
        {
            struct macro_argument* _Owner _Opt next = p->next;
            if (p->macro_parameter)
            {
                p->macro_parameter->already_expanded = false;
                token_list_clear(&p->macro_parameter->expanded_list);
            }
            p = next;
        }

        while (input_list->head)
        {
            assert(!(input_list->head->flags & TK_FLAG_HAS_NEWLINE_BEFORE));
            assert(!token_is_blank(input_list->head));
            assert(r.tail == NULL || !token_is_blank(r.tail));
            struct macro_argument* _Opt p_argument = NULL;
            if (input_list->head->type == TK_IDENTIFIER)
            {
                if (strcmp(input_list->head->lexeme, "__VA_OPT__") == 0)
                {
                    token_list_pop_front(input_list); //pop __VA_OPT__
                    token_list_pop_front(input_list); //pop (
                    int parenteses_count = 1;         //we already have one

                    const bool discard_va_opt =
                        has_argument_list_empty_substitution(ctx, p_list, arguments, origin);

                    if (discard_va_opt)
                    {
                        //discard all tokens __VA_OPT__(...)
                        while (input_list->head)
                        {
                            if (input_list->head->type == '(') parenteses_count++;
                            else if (input_list->head->type == ')') parenteses_count--;
                            token_list_pop_front(input_list);
                            if (parenteses_count == 0)
                                break;
                        }
                    }
                    else
                    {
                        // Search and remove the last balanced ')'
                        struct token* _Opt p_token = input_list->head;
                        for (; p_token; p_token = p_token->next)
                        {
                            if (p_token->type == '(') parenteses_count++;
                            else if (p_token->type == ')') parenteses_count--;

                            if (parenteses_count == 0)
                                break;
                        }
                        token_list_remove(input_list, p_token, p_token);
                    }
                    continue;
                }

                p_argument = find_macro_argument_by_name(arguments, input_list->head->lexeme);
            }

            if (p_argument)
            {
                if (r.tail != NULL && r.tail->type == '#')
                {

                    /*
                      deleta nome parametro da lista
                      antes copia flags dele
                    */

                    const enum token_flags flags = r.tail->flags;
                    token_list_pop_front(input_list);

                    //deleta tambem # do fim
                    while (token_is_blank(r.tail))
                    {
                        token_list_pop_back(&r);
                    }
                    token_list_pop_back(&r);

                    ///----------------------------
                    //transforma tudo em string e coloca no resultado
                    struct token_list argumentlist = copy_argument_list(p_argument);
                    char* _Owner _Opt s = token_list_join_tokens(&argumentlist, true);
                    if (s == NULL)
                    {
                        token_list_destroy(&argumentlist);
                        preprocessor_diagnostic(C_ERROR_UNEXPECTED, ctx, input_list->head, "unexpected");
                        throw;
                    }
                    struct token* _Owner _Opt p_new_token = calloc(1, sizeof * p_new_token);

                    if (p_new_token == NULL)
                    {
                        free(s);
                        token_list_destroy(&argumentlist);
                        throw;
                    }

                    p_new_token->lexeme = s;
                    p_new_token->type = TK_STRING_LITERAL;
                    p_new_token->flags = flags;
                    token_list_add(&r, p_new_token);
                    token_list_destroy(&argumentlist);
                    continue;
                }
                else if (r.tail != NULL && r.tail->type == '##')
                {
                    //estou parametro e anterior era ##
                    token_list_pop_front(input_list);
                    struct token_list argumentlist = copy_argument_list(p_argument);
                    token_list_append_list(&r, &argumentlist);
                    token_list_destroy(&argumentlist);
                }
                else if (input_list->head->next && input_list->head->next->type == '##')
                {
                    //estou no parametro e o da frente eh ##
                    int flags = input_list->head->flags;
                    //tira nome parametro a lista
                    token_list_pop_front(input_list);
                    //passa tudo p resultado
                    struct token_list argumentlist = copy_argument_list(p_argument);
                    if (argumentlist.head != NULL)
                    {
                        argumentlist.head->flags = flags;
                    }
                    token_list_append_list(&r, &argumentlist);
                    // ja passa o ## tambem
                    prematch(&r, input_list);
                    token_list_destroy(&argumentlist);
                }
                else
                {
                    const int flags = input_list->head->flags;

                    //remove nome parametro do input
                    token_list_pop_front(input_list);

                    if (p_argument->macro_parameter == NULL)
                    {
                        throw;
                    }

                    if (!p_argument->macro_parameter->already_expanded)
                    {
                        /*
                          https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3457.htm#number-of-expansions
                          For each such parameter this expansion is performed exactly once,
                          and then preprocessing tokens naming the parameter are each replaced
                          with the resulting token list.
                        */
                        struct token_list copy_list = copy_argument_list(p_argument);
                        struct token_list r4 = replacement_list_reexamination(ctx, p_list, &copy_list, 0, origin);
                        token_list_swap(&p_argument->macro_parameter->expanded_list, &r4);
                        token_list_destroy(&r4);
                        p_argument->macro_parameter->already_expanded = true;
                    }

                    //Use the previous expansion
                    struct token_list copy_list = copy_argument_list_tokens(&p_argument->macro_parameter->expanded_list);
                    if (copy_list.head)
                    {
                        //fix flags
                        copy_list.head->flags = flags;
                    }
                    token_list_append_list(&r, &copy_list);
                    token_list_destroy(&copy_list);
                    if (ctx->n_errors > 0)
                    {
                        throw;
                    }
                }
            }
            else
            {
                prematch(&r, input_list);
            }
        }
    }
    catch
    {
    }

    return r;
}

struct token_list concatenate(struct preprocessor_ctx* ctx, struct token_list* input_list);

static bool macro_already_expanded(struct macro_expanded* _Opt p_list, const char* name)
{
    struct macro_expanded* _Opt p_item = p_list;
    while (p_item)
    {
        if (strcmp(name, p_item->name) == 0)
        {
            return true;
        }
        p_item = p_item->p_previous;
    }
    return false;
}

struct token_list replacement_list_reexamination(struct preprocessor_ctx* ctx,
    struct macro_expanded* p_list,
    struct token_list* oldlist,
    int level,
    const struct token* origin)
{
    struct token_list r = { 0 };
    try
    {
        //replacement_list_reexamination
        /*
        For both object-like and function-like macro invocations, before the replacement list is reexamined
        for more macro names to replace, each instance of a ## preprocessing token in the replacement list
        (not from an argument) is deleted and the preceding preprocessing token is concatenated with the
        following preprocessing token.
        */
        struct token_list new_list = concatenate(ctx, oldlist);
        while (new_list.head != NULL)
        {
            //OBS: #def macro have newlinew
            //assert(!(new_list.head->flags & TK_FLAG_HAS_NEWLINE_BEFORE));
            // assert(!token_is_blank(new_list.head));

            struct macro* _Opt macro = NULL;
            if (new_list.head->type == TK_IDENTIFIER)
            {
                macro = find_macro(ctx, new_list.head->lexeme);
                if (macro &&
                    macro->is_function &&
                    !preprocessor_token_ahead_is(new_list.head, '('))
                {
                    macro = NULL;
                }

                if (macro && macro_already_expanded(p_list, new_list.head->lexeme))
                {
                    new_list.head->type = TK_IDENTIFIER_RECURSIVE_MACRO;
                    macro = NULL;
                }


                if (ctx->conditional_inclusion)
                {
                    /*
                        When we are expanding in conditional inclusion the defined macro or defined (macro)
                        is not expanded and is considered later
                    */
                    if (r.tail &&
                        r.tail->type == TK_IDENTIFIER &&
                        strcmp(r.tail->lexeme, "defined") == 0)
                    {
                        macro = NULL;
                    }
                    else if (r.tail &&
                        r.tail->type == '(')
                    {
                        struct token* _Opt previous = r.tail->prev;
                        if (previous != NULL &&
                            previous->type == TK_IDENTIFIER &&
                            strcmp(previous->lexeme, "defined") == 0)
                        {
                            macro = NULL;
                        }
                    }
                }

            }
            if (macro)
            {
                int flags = new_list.head->flags;
                struct macro_argument_list arguments = collect_macro_arguments(ctx, macro, &new_list, level);
                if (ctx->n_errors > 0)
                {
                    macro_argument_list_destroy(&arguments);
                    token_list_destroy(&new_list);
                    throw;
                }


                struct token_list r3 = expand_macro(ctx, p_list, macro, &arguments, level, origin);
                if (ctx->n_errors > 0)
                {
                    token_list_destroy(&new_list);
                    token_list_destroy(&r3);
                    macro_argument_list_destroy(&arguments);
                    throw;
                }

                if (r3.head)
                {
                    r3.head->flags = flags;
                }
                token_list_append_list_at_beginning(&new_list, &r3);
                macro_argument_list_destroy(&arguments);
                token_list_destroy(&r3);
            }
            else
            {
                /*
                 This is a good place to set the level and macro flags
                 because there is always a macro rescan at the end
                */
                new_list.head->level = level;
                new_list.head->flags |= TK_FLAG_MACRO_EXPANDED;

                //OBS: #def macro have newlinew
                //assert(!(new_list.head->flags & TK_FLAG_HAS_NEWLINE_BEFORE));
                prematch(&r, &new_list); //it wasn't macro
            }
        }
    }
    catch
    {
    }

    return r;
}

/*
Performs the comparison ignoring the continuation of the line
TODO do a general review where strcmp is used in lexeme
and replace it with this one.
*/
int lexeme_cmp(const char* s1, const char* s2)
{
    while (*s1 && *s2)
    {

        while ((s1[0] == '\\' && s1[1] == '\n'))
        {
            s1++;
            s1++;
        }


        while (s2[0] == '\\' && s2[1] == '\n')
        {
            s2++;
            s2++;
        }

        if (*s1 != *s2)
            break;

        s1++;
        s2++;
    }

    while ((s1[0] == '\\' && s1[1] == '\n'))
    {
        s1++;
        s1++;
    }


    while (s2[0] == '\\' && s2[1] == '\n')
    {
        s2++;
        s2++;
    }

    return *(const unsigned char*)s1 - *(const unsigned char*)s2;
}

void remove_line_continuation(char* s)
{
    char* pread = s;
    char* pwrite = s;
    while (*pread)
    {
        if (pread[0] == '\\' &&
              (pread[1] == '\n' ||
                  (pread[1] == '\r' && pread[2] == '\n'))
            )
        {
            if (pread[1] == '\r' && pread[2] == '\n')
            {
                pread++;
                pread++;
                pread++;
            }
            else
            {
                pread++;
                pread++;
            }

        }
        else
        {
            *pwrite = *pread;
            pread++;
            pwrite++;
        }
    }
    *pwrite = *pread;
}

struct token_list  copy_replacement_list_core(struct preprocessor_ctx* ctx,
    const struct token_list* list,
    bool new_line_is_space)
{
    //Makes a copy of the tokens by trimming the beginning and end 
    //any space in comments etc. becomes a single space

    struct token_list r = { 0 };
    struct token* _Opt current = list->head;

    //get off all initial whites
    if (!new_line_is_space)
    {
        while (current && token_is_blank(current))
        {
            current = current->next;
        }
    }
    else
    {
        while (current && (token_is_blank(current) || current->type == TK_NEWLINE))
        {
            current = current->next;
        }
    }

    //remove space flag before if present
    bool is_first = true;

    for (; current;)
    {
        if (!new_line_is_space)
        {
            if (current && token_is_blank(current))
            {
                if (current == list->tail)
                    break;

                current = current->next;
                continue;
            }
        }
        else
        {
            if (current && (token_is_blank(current) || current->type == TK_NEWLINE))
            {
                if (current == list->tail)
                    break;

                current = current->next;
                continue;
            }
        }
        struct token* token_added = token_list_clone_and_add(&r, current);


        if (!ctx->options.preprocess_def_macro && token_added->type == TK_PREPROCESSOR_LINE)
        {
            token_added->type = '#';
            free(token_added->lexeme);
            token_added->lexeme = strdup("#");
        }

        if (token_added->flags & TK_FLAG_HAS_NEWLINE_BEFORE)
        {
            token_added->flags = token_added->flags & ~TK_FLAG_HAS_NEWLINE_BEFORE;
            token_added->flags |= TK_FLAG_HAS_SPACE_BEFORE;
        }
        if (is_first)
        {
            token_added->flags = token_added->flags & ~TK_FLAG_HAS_SPACE_BEFORE;
            token_added->flags = token_added->flags & ~TK_FLAG_HAS_NEWLINE_BEFORE;
            is_first = false;
        }
        remove_line_continuation(token_added->lexeme);

        if (current == list->tail)
            break;
        current = current->next;

    }
    return r;
}

struct token_list  copy_replacement_list(struct preprocessor_ctx* ctx,
    const struct token_list* list)
{
    return copy_replacement_list_core(ctx, list, !ctx->options.preprocess_def_macro);
}

struct token_list macro_copy_replacement_list(struct preprocessor_ctx* ctx, struct macro* macro, const struct token* origin)
{
    /*dynamic content macros*/
    if (strcmp(macro->name, "__LINE__") == 0)
    {
        struct tokenizer_ctx tctx = { 0 };
        char line[50] = { 0 };

        assert(origin != NULL);
        snprintf(line, sizeof line, "%d", origin->line);

        struct token_list r = tokenizer(&tctx, line, "", 0, TK_FLAG_NONE);

        token_list_pop_front(&r);

        if (r.head != NULL)
        {
            r.head->flags = 0;
        }
        return r;
    }
    else if (strcmp(macro->name, "__FILE__") == 0)
    {
        char buffer[300] = { 0 };
        if (stringify(origin->token_origin->lexeme, sizeof buffer, buffer) < 0)
        {
            //ops TODO
        }

        struct tokenizer_ctx tctx = { 0 };
        struct token_list r = tokenizer(&tctx, buffer, "", 0, TK_FLAG_NONE);
        token_list_pop_front(&r);
        if (r.head)
        {
            r.head->flags = 0;
        }
        return r;
    }
    else if (strcmp(macro->name, "__COUNTER__") == 0)
    {
        char line[50] = { 0 };
        snprintf(line, sizeof line, "%d", ctx->count_macro_value);
        ctx->count_macro_value++;

        struct tokenizer_ctx tctx = { 0 };
        struct token_list r = tokenizer(&tctx, line, "", 0, TK_FLAG_NONE);
        token_list_pop_front(&r);

        if (r.head != NULL)
        {
            r.head->flags = 0;
        }
        return r;
    }

    return copy_replacement_list(ctx, &macro->replacement_list);
}

void print_literal2(const char* s);


struct token_list expand_macro(struct preprocessor_ctx* ctx,
    struct macro_expanded* _Opt p_list_of_macro_expanded_opt,
    struct macro* macro,
    struct macro_argument_list* arguments,
    int level,
    const struct token* origin)
{
    macro->usage++;

    struct token_list r = { 0 };
    try
    {
        assert(!macro_already_expanded(p_list_of_macro_expanded_opt, macro->name));
        _Opt struct macro_expanded macro_expanded = { 0 };
        macro_expanded.name = macro->name;
        macro_expanded.p_previous = p_list_of_macro_expanded_opt;
        if (macro->is_function)
        {
            struct token_list copy = macro_copy_replacement_list(ctx, macro, origin);
            struct token_list copy2 = replace_macro_arguments(ctx, &macro_expanded, &copy, arguments, origin);
            struct token_list r2 = replacement_list_reexamination(ctx, &macro_expanded, &copy2, level, origin);

            token_list_append_list(&r, &r2);

            token_list_destroy(&copy);
            token_list_destroy(&copy2);
            token_list_destroy(&r2);

            if (ctx->n_errors > 0) throw;
        }
        else
        {
            struct token_list copy = macro_copy_replacement_list(ctx, macro, origin);
            struct token_list r3 = replacement_list_reexamination(ctx, &macro_expanded, &copy, level, origin);
            if (ctx->n_errors > 0)
            {
                token_list_destroy(&copy);
                token_list_destroy(&r3);
                throw;
            }

            token_list_append_list(&r, &r3);
            token_list_destroy(&copy);
            token_list_destroy(&r3);
        }

        if (ctx->n_errors > 0) throw;

        if (ctx->options.preprocess_def_macro && macro->def_macro)
        {
            struct token_list r0 = { 0 };
            token_list_append_list(&r0, &r);

            struct token_list list2 = preprocessor(ctx, &r0, level + 1);
            struct tokenizer_ctx tctx = { 0 };
            const char* _Opt _Owner result = print_preprocessed_to_string2(list2.head);

            token_list_clear(&r);
            r = tokenizer(&tctx, result, "", 0, TK_FLAG_MACRO_EXPANDED);
            struct token_list list3 = copy_replacement_list_core(ctx, &r, true);
            token_list_swap(&list3, &r);
            free((void*)result);
            token_list_destroy(&list2);
            token_list_destroy(&list3);
        }

    }
    catch
    {
    }

    //printf("result=");
    //print_tokens(r.head);
    return r;
}
void print_token(const struct token* p_token);

static struct token_list text_line(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    /*
          text-line:
          pp-tokens_opt new-line
    */
    struct token_list r = { 0 };

    try
    {
        while (input_list->head &&
            input_list->head->type != TK_PREPROCESSOR_LINE)
        {
            struct macro* _Opt macro = NULL;
            struct token* _Opt start_token = input_list->head;
            const struct token* _Opt origin = NULL;

            if (is_active && input_list->head->type == TK_IDENTIFIER)
            {
                origin = input_list->head;
                macro = find_macro(ctx, input_list->head->lexeme);
                if (macro &&
                    macro->is_function &&
                    !preprocessor_token_ahead_is(input_list->head, '('))
                {
                    macro = NULL;
                }

                if (ctx->conditional_inclusion)
                {
                    /*
                     Quando estamos expandindo em condinonal inclusion o defined macro ou defined (macro)
                     não é expandido e é considerado depois
                    */

                    if (r.tail &&
                        r.tail->type == TK_IDENTIFIER &&
                        strcmp(r.tail->lexeme, "defined") == 0)
                    {
                        macro = NULL;
                    }
                    else if (r.tail &&
                        r.tail->type == '(')
                    {
                        struct token* _Opt previous = r.tail->prev;
                        if (previous != NULL &&
                            previous->type == TK_IDENTIFIER &&
                            strcmp(previous->lexeme, "defined") == 0)
                        {
                            macro = NULL;
                        }
                    }
                }
            }
            if (macro)
            {
                // "Tetris" effect
                // #define f(a) a
                // #define F g
                // F(1)
                //quero deixar F(g) na saida.
                //e toda parte de dentro escondida no caso  1
                //F(1)`a` acho que vou imprimir desta forma ou so fundo diferente
                //
                enum token_flags flags = input_list->head->flags;
                struct macro_argument_list arguments = collect_macro_arguments(ctx, macro, input_list, level);
                if (ctx->n_errors > 0)
                {
                    macro_argument_list_destroy(&arguments);
                    throw;
                }


                struct token_list start_macro = expand_macro(ctx, NULL, macro, &arguments, level, origin);
                if (start_macro.head)
                {
                    start_macro.head->flags |= flags;
                }


                //seta nos tokens expandidos da onde eles vieram
                token_list_set_file(&start_macro, start_token->token_origin, start_token->line, start_token->col);

                token_list_append_list_at_beginning(input_list, &start_macro);

                if (ctx->flags & PREPROCESSOR_CTX_FLAGS_ONLY_FINAL)
                {
                }
                else
                {
                    if (level == 0 || INCLUDE_ALL)
                        token_list_append_list(&r, &arguments.tokens);
                }

                //print_tokens(r.head);
                while (macro)
                {
                    macro = NULL;
                    if (input_list->head && input_list->head->type == TK_IDENTIFIER)
                    {
                        macro = find_macro(ctx, input_list->head->lexeme);
                        if (macro && macro->is_function &&
                            !preprocessor_token_ahead_is(input_list->head, '('))
                        {
                            macro = NULL;
                        }
                        if (macro)
                        {
                            // printf("tetris\n");
                            int flags2 = input_list->head->flags;
                            struct macro_argument_list arguments2 = collect_macro_arguments(ctx, macro, input_list, level);
                            if (ctx->n_errors > 0)
                            {
                                macro_argument_list_destroy(&arguments2);
                                macro_argument_list_destroy(&arguments);
                                token_list_destroy(&start_macro);
                                throw;
                            }

                            if (ctx->flags & PREPROCESSOR_CTX_FLAGS_ONLY_FINAL)
                            {
                            }
                            else
                            {
                                if (level == 0 || INCLUDE_ALL)
                                {
                                    token_list_append_list(&r, &arguments2.tokens);
                                }
                            }


                            struct token_list r3 = expand_macro(ctx, NULL, macro, &arguments2, level, origin);
                            if (ctx->n_errors > 0)
                            {
                                macro_argument_list_destroy(&arguments2);
                                token_list_destroy(&r3);
                                macro_argument_list_destroy(&arguments);
                                token_list_destroy(&start_macro);
                                throw;
                            }

                            //seta nos tokens expandidos da onde eles vieram
                            token_list_set_file(&r3, start_token->token_origin, start_token->line, start_token->col);

                            if (r3.head)
                            {
                                r3.head->flags = flags2;
                            }
                            token_list_append_list_at_beginning(input_list, &r3);
                            macro_argument_list_destroy(&arguments2);
                            token_list_destroy(&r3);
                        }
                    }
                }

                macro_argument_list_destroy(&arguments);
                token_list_destroy(&start_macro);

                continue;
                //exit tetris...
                //entao tudo foi expandido desde a primeiroa
            }
            else
            {
                if (input_list->head->flags & TK_FLAG_LINE_CONTINUATION &&
                    !(input_list->head->flags & TK_FLAG_MACRO_EXPANDED)
                    )
                {
                    /*
                       The only place were line-continuation are really necessary is
                       inside preprocessor directives.
                       Here we are inside text-line so we can send a info that
                       here is optional.
                    */
                    if (input_list->head->type == TK_STRING_LITERAL)
                    {
                        preprocessor_diagnostic(W_NOTE, ctx, input_list->head, "you can use \"adjacent\" \"strings\"");
                    }
                    else if (input_list->head->type == TK_LINE_COMMENT)
                        preprocessor_diagnostic(W_COMMENT, ctx, input_list->head, "multi-line //comment");
                    else
                        preprocessor_diagnostic(W_LINE_SLICING, ctx, input_list->head, "unnecessary line-slicing");
                }

                bool blanks = token_is_blank(input_list->head) || input_list->head->type == TK_NEWLINE;
                bool is_final = is_active && !is_never_final(input_list->head->type);

                if (ctx->flags & PREPROCESSOR_CTX_FLAGS_ONLY_FINAL)
                {
                    if (is_final)
                    {
                        prematch(&r, input_list);
                        assert(r.tail != NULL);
                        r.tail->flags |= TK_FLAG_FINAL;
                    }
                    else
                    {
                        token_list_pop_front(input_list);//todo deletar
                    }
                }
                else
                {
                    if (blanks)
                    {
                        if (level == 0 || INCLUDE_ALL)
                        {
                            prematch(&r, input_list);
                        }
                        else
                            token_list_pop_front(input_list);//todo deletar
                    }
                    else
                    {
                        if (level == 0 || INCLUDE_ALL)
                        {
                            prematch(&r, input_list);
                            if (is_final)
                            {
                                assert(r.tail != NULL);
                                r.tail->flags |= TK_FLAG_FINAL;
                            }
                        }
                        else
                        {
                            if (is_final)
                            {
                                prematch(&r, input_list);
                                assert(r.tail != NULL);
                                r.tail->flags |= TK_FLAG_FINAL;
                            }
                            else
                            {
                                token_list_pop_front(input_list);//todo deletar
                            }
                        }
                    }
                }


            }
        }
    }
    catch
    {
    }

    return r;
}

struct token_list group_part(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    /*
    group-part:
     if-section
     control-line
     text-line
     # non-directive
    */

    assert(input_list->head != NULL);

    if (input_list->head->type == TK_PREPROCESSOR_LINE)
    {
        if (preprocessor_token_ahead_is_identifier(input_list->head, "if") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "ifdef") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "ifndef"))
        {
            return if_section(ctx, input_list, is_active, level);
        }
        else if (preprocessor_token_ahead_is_identifier(input_list->head, "def"))
        {
            //C2Y
            return def_section(ctx, input_list, is_active, level);
        }
        else if (preprocessor_token_ahead_is_identifier(input_list->head, "include") ||
        preprocessor_token_ahead_is_identifier(input_list->head, "include_next") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "embed") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "define") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "undef") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "warning") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "line") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "error") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "pragma") ||
            preprocessor_token_ahead_is(input_list->head, TK_NEWLINE))
        {
            return control_line(ctx, input_list, is_active, level);
        }
        else
        {
            if (is_active)
            {
                struct token* _Opt p_token = preprocessor_look_ahead_core(input_list->head);
                const char* directive_name = p_token ? p_token->lexeme : "";
                /*
                   13 The execution of a non-directive preprocessing directive results in undefined behavior.
                */
                preprocessor_diagnostic(C_ERROR_INVALID_PREPROCESSING_DIRECTIVE,
                    ctx,
                    input_list->head,
                    "invalid preprocessor directive '#%s'\n", directive_name);
            }
            //here I will consume the # inside to make it symmetrical
            return non_directive(ctx, input_list, level);
        }
    }
    return text_line(ctx, input_list, is_active, level);
}


struct token_list preprocessor(struct preprocessor_ctx* ctx, struct token_list* input_list, int level)
{
    struct token_list r = { 0 };
    if (input_list->head == NULL)
    {
        return r;
    }

    if (input_list->head->type == TK_BEGIN_OF_FILE)
    {
        prematch_level(&r, input_list, 1); //sempre coloca
    }

    struct token_list g = group_opt(ctx, input_list, true /*active*/, level);
    token_list_append_list(&r, &g);
    token_list_destroy(&g);
    return r;
}


static void mark_macros_as_used(struct hash_map* map)
{
    /*
     *  Objetivo era alertar macros nao usadas...
     */

    if (map->table != NULL)
    {
        for (int i = 0; i < map->capacity; i++)
        {
            struct map_entry* _Opt pentry = map->table[i];

            while (pentry != NULL)
            {
                assert(pentry->data.p_macro != NULL);
                struct macro* macro = pentry->data.p_macro;
                macro->usage = 1;
                pentry = pentry->next;
            }
        }
    }
}

void check_unused_macros(const struct hash_map* map)
{
    /*
     *  Objetivo era alertar macros nao usadas...
     */

    if (map->table != NULL)
    {
        for (int i = 0; i < map->capacity; i++)
        {
            struct map_entry* _Opt pentry = map->table[i];

            while (pentry != NULL)
            {
                assert(pentry->data.p_macro != NULL);

                struct macro* macro = pentry->data.p_macro;
                if (macro->usage == 0)
                {
                    //TODO adicionar conceito meu codigo , codigo de outros nao vou colocar erro
                    printf("%s not used\n", macro->name);
                }
                pentry = pentry->next;
            }
        }
    }
}

int include_config_header(struct preprocessor_ctx* ctx, const char* file_name)
{
    char local_cakeconfig_path[MAX_PATH] = { 0 };
    snprintf(local_cakeconfig_path, sizeof local_cakeconfig_path, "%s", file_name);
    dirname(local_cakeconfig_path);

    snprintf(local_cakeconfig_path, sizeof local_cakeconfig_path, "%s" CAKE_CFG_FNAME, local_cakeconfig_path);

    char* _Owner _Opt str = read_file(local_cakeconfig_path, true);

    if (str && ctx->options.show_includes)
    {
        printf(".%s\n", local_cakeconfig_path);
    }

    while (str == NULL)
    {
        dirname(local_cakeconfig_path);
        dirname(local_cakeconfig_path);
        if (local_cakeconfig_path[0] == '\0')
            break;
        str = read_file(local_cakeconfig_path, true);
        if (str && ctx->options.show_includes)
        {
            printf(".%s\n", local_cakeconfig_path);
        }
    }

    if (str == NULL)
    {
        //Search cakeconfig at cake executable dir

        char executable_path[MAX_PATH - sizeof(CAKE_CFG_FNAME)] = { 0 };
        get_self_path(executable_path, sizeof(executable_path));
        dirname(executable_path);
        char root_cakeconfig_path[MAX_PATH] = { 0 };
        snprintf(root_cakeconfig_path, sizeof root_cakeconfig_path, "%s" CAKE_CFG_FNAME, executable_path);
        str = read_file(root_cakeconfig_path, true);
        if (str && ctx->options.show_includes)
        {
            printf(".%s\n", root_cakeconfig_path);
        }
    }

    if (str == NULL)
    {
        if (ctx->options.show_includes)
        {
            printf(".(cakeconfig.h not found)\n");
        }
        //"No such file or directory";
        return  ENOENT;
    }

    const enum diagnostic_id w =
        ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings;

    struct tokenizer_ctx tctx = { 0 };
    struct token_list l = tokenizer(&tctx, str, "standard macros inclusion", 0, TK_FLAG_NONE);
    struct token_list l10 = preprocessor(ctx, &l, 0);
    mark_macros_as_used(&ctx->macros);
    token_list_destroy(&l);
    free(str);
    token_list_destroy(&l10);

    /*restore*/
    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings = w;

    return  0;
}

static bool is_builtin_macro(const char* name)
{
    if (strcmp(name, "__FILE__") == 0)
        return true;

    if (strcmp(name, "__CAKE__") == 0)
        return true;

    return false;
}

void add_standard_macros(struct preprocessor_ctx* ctx)
{
    /*
      This command prints all macros used by gcc
      echo | gcc -dM -E -
    */
    const struct diagnostic w =
        ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index];

    /*we dont want warnings here*/
    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] =
        (struct diagnostic){ 0 };

    static char mon[][4] = {
        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    };

    time_t now = time(NULL);
    struct tm* tm = localtime(&now);

    struct tokenizer_ctx tctx = { 0 };


    char datastr[100] = { 0 };
    snprintf(datastr, sizeof datastr, "#define __DATE__ \"%s %2d %d\"\n", mon[tm->tm_mon], tm->tm_mday, tm->tm_year + 1900);
    struct token_list l1 = tokenizer(&tctx, datastr, "__DATE__ macro inclusion", 0, TK_FLAG_NONE);
    struct token_list tl1 = preprocessor(ctx, &l1, 0);

    token_list_destroy(&tl1);
    token_list_destroy(&l1);

    char timestr[100] = { 0 };
    snprintf(timestr, sizeof timestr, "#define __TIME__ \"%02d:%02d:%02d\"\n", tm->tm_hour, tm->tm_min, tm->tm_sec);
    struct token_list l2 = tokenizer(&tctx, timestr, "__TIME__ macro inclusion", 0, TK_FLAG_NONE);
    struct token_list tl2 = preprocessor(ctx, &l2, 0);

    token_list_destroy(&tl2);
    token_list_destroy(&l2);


    /*
      Some macros are dynamic like __LINE__ they are replaced  at
      macro_copy_replacement_list but they need to be registered here.
    */

    const char* pre_defined_macros_text =
        "#define __CAKE__ 202311L\n"
        "#define __STDC_VERSION__ 202311L\n"
        "#define __FILE__ \"__FILE__\"\n"
        "#define __LINE__ 0\n"
        "#define __COUNTER__ 0\n"
        "#define _CONSOLE\n"
        "#define __STDC_OWNERSHIP__ 1\n" /*cake extension*/
        //"#define __STDC_HOSTED__ " TOSTRING(__STDC_HOSTED__) "\n" /*breaks linux*/
        "#define __STDC_NO_ATOMICS__ " TOSTRING(__STDC_NO_ATOMICS__) "\n"
        "#define __STDC_NO_COMPLEX__  " TOSTRING(__STDC_NO_COMPLEX__) "\n"
        "#define __STDC_NO_THREADS__   " TOSTRING(__STDC_NO_THREADS__) "\n"
        "#define __STDC_NO_VLA__    " TOSTRING(__STDC_NO_VLA__) "\n"
        //"#define __STDC__    " TOSTRING(__STDC__) "\n"



#ifdef __EMSCRIPTEN__
        //include dir on emscripten
        "#pragma dir \"c:/\"\n"
#endif

#ifdef _WIN32

        //see
        //https://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros?_View=msvc-170
        "#define _WIN32 " TOSTRING(_WIN32) "\n"


#ifdef _WIN64
        "#define _WIN64 " TOSTRING(_WIN64) "\n"
#endif

        "#define _INTEGRAL_MAX_BITS " TOSTRING(_INTEGRAL_MAX_BITS) "\n" /*Use of __int64 should be conditional on the predefined macro _INTEGRAL_MAX_BITS*/

        "#define _MSC_VER " TOSTRING(_MSC_VER) "\n"
        "#define _M_IX86 "  TOSTRING(_M_IX86) "\n"
        "#define __pragma(a)\n"
        ;

#endif

#ifdef __linux__

    //https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html
        /*some gcc stuff need to parse linux headers*/
    "#define __linux__\n"
        //see
        //https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html                
        "#define __x86_64__ " TOSTRING(__x86_64__) "\n"
        "#define __CHAR_BIT__ " TOSTRING(__CHAR_BIT__) "\n"
        "#define __SIZE_TYPE__ " TOSTRING(__SIZE_TYPE__) "\n"
        "#define __PTRDIFF_TYPE__ " TOSTRING(__PTRDIFF_TYPE__) "\n"
        "#define __WCHAR_TYPE__ " TOSTRING(__WCHAR_TYPE__) "\n"
        "#define __WINT_TYPE__ " TOSTRING(__WINT_TYPE__) "\n"
        "#define __INTMAX_TYPE__ " TOSTRING(__INTMAX_TYPE__) "\n"
        "#define __UINTMAX_TYPE__ " TOSTRING(__UINTMAX_TYPE__) "\n"
        "#define __SIG_ATOMIC_TYPE__ " TOSTRING(__SIG_ATOMIC_TYPE__) "\n"
        "#define __INT8_TYPE__ " TOSTRING(__INT8_TYPE__) "\n"
        "#define __INT16_TYPE__ " TOSTRING(__INT16_TYPE__) "\n"
        "#define __INT32_TYPE__ " TOSTRING(__INT32_TYPE__) "\n"
        "#define __INT64_TYPE__ " TOSTRING(__INT64_TYPE__) "\n"
        "#define __UINT8_TYPE__ " TOSTRING(__UINT8_TYPE__) "\n"
        "#define __UINT16_TYPE__ " TOSTRING(__UINT16_TYPE__) "\n"
        "#define __UINT32_TYPE__ " TOSTRING(__UINT32_TYPE__) "\n"
        "#define __UINT64_TYPE__ " TOSTRING(__UINT64_TYPE__) "\n"
        "#define __INT_LEAST8_TYPE__ " TOSTRING(__INT_LEAST8_TYPE__) "\n"
        "#define __INT_LEAST16_TYPE__ " TOSTRING(__INT_LEAST16_TYPE__) "\n"
        "#define __INT_LEAST32_TYPE__ " TOSTRING(__INT_LEAST32_TYPE__) "\n"
        "#define __INT_LEAST64_TYPE__ " TOSTRING(__INT_LEAST64_TYPE__) "\n"
        "#define __UINT_LEAST8_TYPE__ " TOSTRING(__UINT_LEAST8_TYPE__) "\n"
        "#define __UINT_LEAST16_TYPE__ " TOSTRING(__UINT_LEAST16_TYPE__) "\n"
        "#define __UINT_LEAST32_TYPE__ " TOSTRING(__UINT_LEAST32_TYPE__) "\n"
        "#define __UINT_LEAST64_TYPE__ " TOSTRING(__UINT_LEAST64_TYPE__) "\n"
        "#define __INT_FAST8_TYPE__ " TOSTRING(__INT_FAST8_TYPE__) "\n"
        "#define __INT_FAST16_TYPE__ " TOSTRING(__INT_FAST16_TYPE__) "\n"
        "#define __INT_FAST32_TYPE__ " TOSTRING(__INT_FAST32_TYPE__) "\n"
        "#define __INT_FAST64_TYPE__ " TOSTRING(__INT_FAST64_TYPE__) "\n"
        "#define __UINT_FAST8_TYPE__ " TOSTRING(__UINT_FAST8_TYPE__) "\n"
        "#define __UINT_FAST16_TYPE__ " TOSTRING(__UINT_FAST16_TYPE__) "\n"
        "#define __UINT_FAST32_TYPE__ " TOSTRING(__UINT_FAST32_TYPE__) "\n"
        "#define __UINT_FAST64_TYPE__ " TOSTRING(__UINT_FAST64_TYPE__) "\n"
        "#define __INTPTR_TYPE__ " TOSTRING(__INTPTR_TYPE__) "\n"
        "#define __UINTPTR_TYPE__ " TOSTRING(__UINTPTR_TYPE__) "\n"

        "#define __DBL_MAX__ " TOSTRING(__DBL_MAX__) "\n"
        "#define __DBL_MIN__ " TOSTRING(__DBL_MIN__) "\n"
        "#define __FLT_RADIX__ " TOSTRING(__FLT_RADIX__) "\n"
        "#define __FLT_EPSILON__ " TOSTRING(__FLT_EPSILON__) "\n"
        "#define __DBL_EPSILON__ " TOSTRING(__DBL_EPSILON__) "\n"
        "#define __LDBL_EPSILON__ " TOSTRING(__LDBL_EPSILON__) "\n"
        "#define __DBL_DECIMAL_DIG__ " TOSTRING(__DBL_DECIMAL_DIG__) "\n"
        "#define __FLT_EVAL_METHOD__ " TOSTRING(__FLT_EVAL_METHOD__) "\n"
        "#define __FLT_RADIX__ " TOSTRING(__FLT_RADIX__) "\n"

        // gcc -dM -E

        "#define __DBL_MAX_EXP__ " TOSTRING(__DBL_MAX_EXP__) "\n"
        "#define __DECIMAL_DIG__ " TOSTRING(__DECIMAL_DIG__) "\n"
        "#define __FLT_DECIMAL_DIG__ " TOSTRING(__FLT_DECIMAL_DIG__) "\n"


        "#define __FLT_MIN_10_EXP__ " TOSTRING(__FLT_MIN_10_EXP__) "\n"
        "#define __FLT_MIN__ " TOSTRING(__FLT_MIN__) "\n"
        "#define __FLT_MAX__ " TOSTRING(__FLT_MAX__) "\n"
        "#define __FLT_EPSILON__ " TOSTRING(__FLT_EPSILON__) "\n"
        "#define __FLT_DIG__ " TOSTRING(__FLT_DIG__) "\n"
        "#define __FLT_MANT_DIG__ " TOSTRING(__FLT_MANT_DIG__) "\n"
        "#define __FLT_MIN_EXP__ " TOSTRING(__FLT_MIN_EXP__) "\n"
        "#define __FLT_MAX_10_EXP__ " TOSTRING(__FLT_MAX_10_EXP__) "\n"
        "#define __FLT_ROUNDS__ " TOSTRING(__FLT_ROUNDS__) "\n"
        "#define __FLT_EVAL_METHOD__ " TOSTRING(__FLT_EVAL_METHOD__) "\n"
        "#define __FLT_HAS_SUBNORM__ " TOSTRING(__FLT_HAS_SUBNORM__) "\n"

        "#define __FLT_MAX_EXP__ " TOSTRING(__FLT_MAX_EXP__) "\n"
        "#define __FLT_HAS_DENORM__ " TOSTRING(__FLT_HAS_DENORM__) "\n"


        "#define __SCHAR_MAX__ " TOSTRING(__SCHAR_MAX__) "\n"
        "#define __WCHAR_MAX__ " TOSTRING(__WCHAR_MAX__) "\n"
        "#define __SHRT_MAX__ " TOSTRING(__SHRT_MAX__) "\n"
        "#define __INT_MAX__ " TOSTRING(__INT_MAX__) "\n"
        "#define __LONG_MAX__ " TOSTRING(__LONG_MAX__) "\n"
        "#define __LONG_LONG_MAX__ " TOSTRING(__LONG_LONG_MAX__) "\n"
        "#define __WINT_MAX__ " TOSTRING(__WINT_MAX__) "\n"
        "#define __SIZE_MAX__ " TOSTRING(__SIZE_MAX__) "\n"
        "#define __PTRDIFF_MAX__ " TOSTRING(__PTRDIFF_MAX__) "\n"
        "#define __INTMAX_MAX__ " TOSTRING(__INTMAX_MAX__) "\n"
        "#define __UINTMAX_MAX__ " TOSTRING(__UINTMAX_MAX__) "\n"
        "#define __SIG_ATOMIC_MAX__ " TOSTRING(__SIG_ATOMIC_MAX__) "\n"
        "#define __INT8_MAX__ " TOSTRING(__INT8_MAX__) "\n"
        "#define __INT16_MAX__ " TOSTRING(__INT16_MAX__) "\n"
        "#define __INT32_MAX__ " TOSTRING(__INT32_MAX__) "\n"
        "#define __INT64_MAX__ " TOSTRING(__INT64_MAX__) "\n"
        "#define __UINT8_MAX__ " TOSTRING(__UINT8_MAX__) "\n"
        "#define __UINT16_MAX__ " TOSTRING(__UINT16_MAX__) "\n"
        "#define __UINT32_MAX__ " TOSTRING(__UINT32_MAX__) "\n"
        "#define __UINT64_MAX__ " TOSTRING(__UINT64_MAX__) "\n"
        "#define __INT_LEAST8_MAX__ " TOSTRING(__INT_LEAST8_MAX__) "\n"
        "#define __INT_LEAST16_MAX__ " TOSTRING(__INT_LEAST16_MAX__) "\n"
        "#define __INT_LEAST32_MAX__ " TOSTRING(__INT_LEAST32_MAX__) "\n"
        "#define __INT_LEAST64_MAX__ " TOSTRING(__INT_LEAST64_MAX__) "\n"
        "#define __UINT_LEAST8_MAX__ " TOSTRING(__UINT_LEAST8_MAX__) "\n"
        "#define __UINT_LEAST16_MAX__ " TOSTRING(__UINT_LEAST16_MAX__) "\n"
        "#define __UINT_LEAST32_MAX__ " TOSTRING(__UINT_LEAST32_MAX__) "\n"
        "#define __UINT_LEAST64_MAX__ " TOSTRING(__UINT_LEAST64_MAX__) "\n"
        "#define __INT_FAST8_MAX__ " TOSTRING(__INT_FAST8_MAX__) "\n"
        "#define __INT_FAST16_MAX__ " TOSTRING(__INT_FAST16_MAX__) "\n"
        "#define __INT_FAST32_MAX__ " TOSTRING(__INT_FAST32_MAX__) "\n"
        "#define __INT_FAST64_MAX__ " TOSTRING(__INT_FAST64_MAX__) "\n"
        "#define __UINT_FAST8_MAX__ " TOSTRING(__UINT_FAST8_MAX__) "\n"
        "#define __UINT_FAST16_MAX__ " TOSTRING(__UINT_FAST16_MAX__) "\n"
        "#define __UINT_FAST32_MAX__ " TOSTRING(__UINT_FAST32_MAX__) "\n"
        "#define __UINT_FAST64_MAX__ " TOSTRING(__UINT_FAST64_MAX__) "\n"
        "#define __INTPTR_MAX__ " TOSTRING(__INTPTR_MAX__) "\n"
        "#define __UINTPTR_MAX__ " TOSTRING(__UINTPTR_MAX__) "\n"
        "#define __WCHAR_MIN__ " TOSTRING(__WCHAR_MIN__) "\n"
        "#define __WINT_MIN__ " TOSTRING(__WINT_MIN__) "\n"
        "#define __SIG_ATOMIC_MIN__ " TOSTRING(__SIG_ATOMIC_MIN__) "\n"

        "#define __INT8_C " TOSTRING(__SIG_ATOMIC_MIN__) "\n"
        "#define __INT16_C " TOSTRING(__INT16_C) "\n"
        "#define __INT32_C " TOSTRING(__INT32_C) "\n"
        "#define __INT64_C " TOSTRING(__INT64_C) "\n"
        "#define __UINT8_C " TOSTRING(__UINT8_C) "\n"
        "#define __UINT16_C " TOSTRING(__UINT16_C) "\n"
        "#define __UINT32_C " TOSTRING(__UINT32_C) "\n"
        "#define __UINT64_C " TOSTRING(__UINT64_C) "\n"
        "#define __INTMAX_C " TOSTRING(__INTMAX_C) "\n"
        "#define __UINTMAX_C " TOSTRING(__UINTMAX_C) "\n"

        "#define __SCHAR_WIDTH__ " TOSTRING(__SCHAR_WIDTH__) "\n"
        "#define __SHRT_WIDTH__ " TOSTRING(__SHRT_WIDTH__) "\n"
        "#define __INT_WIDTH__ " TOSTRING(__INT_WIDTH__) "\n"
        "#define __LONG_WIDTH__ " TOSTRING(__LONG_WIDTH__) "\n"
        "#define __LONG_LONG_WIDTH__ " TOSTRING(__LONG_LONG_WIDTH__) "\n"
        "#define __PTRDIFF_WIDTH__ " TOSTRING(__PTRDIFF_WIDTH__) "\n"
        "#define __SIG_ATOMIC_WIDTH__ " TOSTRING(__SIG_ATOMIC_WIDTH__) "\n"
        "#define __SIZE_WIDTH__ " TOSTRING(__SIZE_WIDTH__) "\n"
        "#define __WCHAR_WIDTH__ " TOSTRING(__WCHAR_WIDTH__) "\n"
        "#define __WINT_WIDTH__ " TOSTRING(__WINT_WIDTH__) "\n"
        "#define __INT_LEAST8_WIDTH__ " TOSTRING(__INT_LEAST8_WIDTH__) "\n"
        "#define __INT_LEAST16_WIDTH__ " TOSTRING(__INT_LEAST16_WIDTH__) "\n"
        "#define __INT_LEAST32_WIDTH__ " TOSTRING(__INT_LEAST32_WIDTH__) "\n"
        "#define __INT_LEAST64_WIDTH__ " TOSTRING(__INT_LEAST64_WIDTH__) "\n"
        "#define __INT_FAST8_WIDTH__ " TOSTRING(__INT_FAST8_WIDTH__) "\n"
        "#define __INT_FAST16_WIDTH__ " TOSTRING(__INT_FAST16_WIDTH__) "\n"
        "#define __INT_FAST32_WIDTH__ " TOSTRING(__INT_FAST32_WIDTH__) "\n"
        "#define __INT_FAST64_WIDTH__ " TOSTRING(__INT_FAST64_WIDTH__) "\n"
        "#define __INTPTR_WIDTH__ " TOSTRING(__INTPTR_WIDTH__) "\n"
        "#define __INTMAX_WIDTH__ " TOSTRING(__INTMAX_WIDTH__) "\n"


        "#define __SIZEOF_INT__ " TOSTRING(__SIZEOF_INT__) "\n"
        "#define __SIZEOF_LONG__ " TOSTRING(__SIZEOF_LONG__) "\n"
        "#define __SIZEOF_LONG_LONG__ " TOSTRING(__SIZEOF_LONG_LONG__) "\n"
        "#define __SIZEOF_SHORT__ " TOSTRING(__SIZEOF_SHORT__) "\n"
        "#define __SIZEOF_POINTER__ " TOSTRING(__SIZEOF_POINTER__) "\n"
        "#define __SIZEOF_FLOAT__ " TOSTRING(__SIZEOF_FLOAT__) "\n"
        "#define __SIZEOF_DOUBLE__ " TOSTRING(__SIZEOF_DOUBLE__) "\n"
        "#define __SIZEOF_LONG_DOUBLE__ " TOSTRING(__SIZEOF_LONG_DOUBLE__) "\n"
        "#define __SIZEOF_SIZE_T__ " TOSTRING(__SIZEOF_SIZE_T__) "\n"
        "#define __SIZEOF_WCHAR_T__ " TOSTRING(__SIZEOF_WCHAR_T__) "\n"
        "#define __SIZEOF_WINT_T__ " TOSTRING(__SIZEOF_WINT_T__) "\n"
        "#define __SIZEOF_PTRDIFF_T__ " TOSTRING(__SIZEOF_PTRDIFF_T__) "\n"
#endif
        "\n";

    struct token_list l = tokenizer(&tctx, pre_defined_macros_text, "standard macros inclusion", 0, TK_FLAG_NONE);
    struct token_list l10 = preprocessor(ctx, &l, 0);

    //nao quer ver warning de nao usado nestas macros padrao
    mark_macros_as_used(&ctx->macros);
    token_list_destroy(&l);
    token_list_destroy(&l10);

    /*restore*/
    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] = w;
}




const char* get_token_name(enum token_type tk)
{
    switch (tk)
    {
    case TK_NONE: return "TK_NONE";
    case TK_NEWLINE: return "TK_NEWLINE";
    case TK_WHITE_SPACE: return "TK_WHITE_SPACE";
    case TK_EXCLAMATION_MARK: return "TK_EXCLAMATION_MARK";
    case TK_QUOTATION_MARK: return "TK_QUOTATION_MARK";
    case TK_NUMBER_SIGN: return "TK_NUMBER_SIGN";
    case TK_DOLLAR_SIGN: return "TK_DOLLAR_SIGN";
    case TK_PERCENT_SIGN: return "TK_PERCENT_SIGN";
    case TK_AMPERSAND: return "TK_AMPERSAND";
    case TK_APOSTROPHE: return "TK_APOSTROPHE";
    case TK_LEFT_PARENTHESIS: return "TK_LEFT_PARENTHESIS";
    case TK_RIGHT_PARENTHESIS: return "TK_RIGHT_PARENTHESIS";
    case TK_ASTERISK: return "TK_ASTERISK";
    case TK_PLUS_SIGN: return "TK_PLUS_SIGN";
    case TK_COMMA: return "TK_COMMA";
    case TK_HYPHEN_MINUS: return "TK_HYPHEN_MINUS";
    case TK_FULL_STOP: return "TK_FULL_STOP";
    case TK_SOLIDUS: return "TK_SOLIDUS";
    case TK_COLON: return "TK_COLON";
    case TK_SEMICOLON: return "TK_SEMICOLON";
    case TK_LESS_THAN_SIGN: return "TK_LESS_THAN_SIGN";
    case TK_EQUALS_SIGN: return "TK_EQUALS_SIGN";
    case TK_GREATER_THAN_SIGN: return "TK_GREATER_THAN_SIGN";
    case TK_QUESTION_MARK: return "TK_QUESTION_MARK";
    case TK_COMMERCIAL_AT: return "TK_COMMERCIAL_AT";
    case TK_LEFT_SQUARE_BRACKET: return "TK_LEFT_SQUARE_BRACKET";
    case TK_REVERSE_SOLIDUS: return "TK_REVERSE_SOLIDUS";
    case TK_RIGHT_SQUARE_BRACKET: return "TK_RIGHT_SQUARE_BRACKET";
    case TK_CIRCUMFLEX_ACCENT: return "TK_CIRCUMFLEX_ACCENT";
    case TK_FLOW_LINE: return "TK_FLOW_LINE";
    case TK_GRAVE_ACCENT: return "TK_GRAVE_ACCENT";
    case TK_LEFT_CURLY_BRACKET: return "TK_LEFT_CURLY_BRACKET";
    case TK_VERTICAL_LINE: return "TK_VERTICAL_LINE";
    case TK_RIGHT_CURLY_BRACKET: return "TK_RIGHT_CURLY_BRACKET";
    case TK_TILDE: return "TK_TILDE";
    case TK_PREPROCESSOR_LINE: return "TK_PREPROCESSOR_LINE";
    case TK_PRAGMA: return "TK_PRAGMA";
    case TK_STRING_LITERAL: return "TK_STRING_LITERAL";
    case TK_CHAR_CONSTANT: return "TK_CHAR_CONSTANT";
    case TK_LINE_COMMENT: return "TK_LINE_COMMENT";
    case TK_COMMENT: return "TK_COMMENT";
    case TK_PPNUMBER: return "TK_PPNUMBER";

    case TK_KEYWORD_GCC__ATTRIBUTE:return "TK_KEYWORD_GCC__ATTRIBUTE";
    case TK_KEYWORD_GCC__BUILTIN_VA_LIST:return "TK_KEYWORD_GCC__BUILTIN_VA_LIST";
    case TK_KEYWORD_MSVC__PTR32:return "TK_KEYWORD_MSVC__PTR32";
    case TK_KEYWORD_MSVC__PTR64:return "TK_KEYWORD_MSVC__PTR64";

    case ANY_OTHER_PP_TOKEN: return "ANY_OTHER_PP_TOKEN"; //@ por ex

        /*PPNUMBER sao convertidos para constantes antes do parse*/
    case TK_COMPILER_DECIMAL_CONSTANT: return "TK_COMPILER_DECIMAL_CONSTANT";
    case TK_COMPILER_OCTAL_CONSTANT: return "TK_COMPILER_OCTAL_CONSTANT";
    case TK_COMPILER_HEXADECIMAL_CONSTANT: return "TK_COMPILER_HEXADECIMAL_CONSTANT";
    case TK_COMPILER_BINARY_CONSTANT: return "TK_COMPILER_BINARY_CONSTANT";
    case TK_COMPILER_DECIMAL_FLOATING_CONSTANT: return "TK_COMPILER_DECIMAL_FLOATING_CONSTANT";
    case TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT: return "TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT";


    case TK_PLACEMARKER: return "TK_PLACEMARKER";

    case TK_BLANKS: return "TK_BLANKS";
    case TK_PLUSPLUS: return "TK_PLUSPLUS";
    case TK_MINUSMINUS: return "TK_MINUSMINUS";
    case TK_ARROW: return "TK_ARROW";
    case TK_SHIFTLEFT: return "TK_SHIFTLEFT";
    case TK_SHIFTRIGHT: return "TK_SHIFTRIGHT";
    case TK_LOGICAL_OPERATOR_OR: return "TK_LOGICAL_OPERATOR_OR";
    case TK_LOGICAL_OPERATOR_AND: return "TK_LOGICAL_OPERATOR_AND";

    case TK_MACRO_CONCATENATE_OPERATOR: return "TK_MACRO_CONCATENATE_OPERATOR";

    case TK_IDENTIFIER: return "TK_IDENTIFIER";
    case TK_IDENTIFIER_RECURSIVE_MACRO: return "TK_IDENTIFIER_RECURSIVE_MACRO"; /*usado para evitar recursao expansao macro*/

    case TK_BEGIN_OF_FILE: return "TK_BEGIN_OF_FILE";

        //C23 keywords
    case TK_KEYWORD_AUTO: return "TK_KEYWORD_AUTO";
    case TK_KEYWORD_BREAK: return "TK_KEYWORD_BREAK";
    case TK_KEYWORD_CASE: return "TK_KEYWORD_CASE";
    case TK_KEYWORD_CONSTEXPR: return "TK_KEYWORD_CONSTEXPR";
    case TK_KEYWORD_CHAR: return "TK_KEYWORD_CHAR";
    case TK_KEYWORD_CONST: return "TK_KEYWORD_CONST";
    case TK_KEYWORD_CONTINUE: return "TK_KEYWORD_CONTINUE";
    case TK_KEYWORD_CAKE_CATCH: return "TK_KEYWORD_CAKE_CATCH"; /*extension*/
    case TK_KEYWORD_DEFAULT: return "TK_KEYWORD_DEFAULT";
    case TK_KEYWORD_DO: return "TK_KEYWORD_DO";
    case TK_KEYWORD_DEFER: return "TK_KEYWORD_DEFER"; /*extension*/
    case TK_KEYWORD_DOUBLE: return "TK_KEYWORD_DOUBLE";
    case TK_KEYWORD_ELSE: return "TK_KEYWORD_ELSE";
    case TK_KEYWORD_ENUM: return "TK_KEYWORD_ENUM";
    case TK_KEYWORD_EXTERN: return "TK_KEYWORD_EXTERN";
    case TK_KEYWORD_FLOAT: return "TK_KEYWORD_FLOAT";
    case TK_KEYWORD_FOR: return "TK_KEYWORD_FOR";
    case TK_KEYWORD_GOTO: return "TK_KEYWORD_GOTO";
    case TK_KEYWORD_IF: return "TK_KEYWORD_IF";
    case TK_KEYWORD_INLINE: return "TK_KEYWORD_INLINE";
    case TK_KEYWORD_INT: return "TK_KEYWORD_INT";
    case TK_KEYWORD_LONG: return "TK_KEYWORD_LONG";
    case TK_KEYWORD_MSVC__INT8: return "TK_KEYWORD_MSVC__INT8";
    case TK_KEYWORD_MSVC__INT16: return "TK_KEYWORD_MSVC__INT16";
    case TK_KEYWORD_MSVC__INT32: return "TK_KEYWORD_MSVC__INT32";
    case TK_KEYWORD_MSVC__INT64: return "TK_KEYWORD_MSVC__INT64";


    case TK_KEYWORD_REGISTER: return "TK_KEYWORD_REGISTER";
    case TK_KEYWORD_RESTRICT: return "TK_KEYWORD_RESTRICT";
    case TK_KEYWORD_RETURN: return "TK_KEYWORD_RETURN";
    case TK_KEYWORD_SHORT: return "TK_KEYWORD_SHORT";
    case TK_KEYWORD_SIGNED: return "TK_KEYWORD_SIGNED";
    case TK_KEYWORD_SIZEOF: return "TK_KEYWORD_SIZEOF";

    case TK_KEYWORD_STATIC: return "TK_KEYWORD_STATIC";
    case TK_KEYWORD_STRUCT: return "TK_KEYWORD_STRUCT";
    case TK_KEYWORD_SWITCH: return "TK_KEYWORD_SWITCH";
    case TK_KEYWORD_TYPEDEF: return "TK_KEYWORD_TYPEDEF";
    case TK_KEYWORD_CAKE_TRY: return "TK_KEYWORD_CAKE_TRY"; /*extension*/
    case TK_KEYWORD_CAKE_THROW: return "TK_KEYWORD_CAKE_THROW"; /*extension*/
    case TK_KEYWORD_UNION: return "TK_KEYWORD_UNION";
    case TK_KEYWORD_UNSIGNED: return "TK_KEYWORD_UNSIGNED";
    case TK_KEYWORD_VOID: return "TK_KEYWORD_VOID";
    case TK_KEYWORD_VOLATILE: return "TK_KEYWORD_VOLATILE";
    case TK_KEYWORD_WHILE: return "TK_KEYWORD_WHILE";

    case TK_KEYWORD__ALIGNAS: return "TK_KEYWORD__ALIGNAS";
    case TK_KEYWORD__ALIGNOF: return "TK_KEYWORD__ALIGNOF";
    case TK_KEYWORD__ATOMIC: return "TK_KEYWORD__ATOMIC";

        //#ifdef _WIN32
    case TK_KEYWORD_MSVC__FASTCALL: return "TK_KEYWORD_MSVC__FASTCALL";
    case TK_KEYWORD_MSVC__STDCALL:return "TK_KEYWORD_MSVC__STDCALL";
    case TK_KEYWORD_MSVC__CDECL:return "TK_KEYWORD_MSVC__CDECL";
    case TK_KEYWORD_MSVC__DECLSPEC:return "TK_KEYWORD_MSVC__DECLSPEC";
        //#endif
    case TK_KEYWORD__ASM: return "TK_KEYWORD__ASM";
        //end microsoft
    case TK_KEYWORD__BOOL: return "TK_KEYWORD__BOOL";
    case TK_KEYWORD__COMPLEX: return "TK_KEYWORD__COMPLEX";
    case TK_KEYWORD__DECIMAL128: return "TK_KEYWORD__DECIMAL128";
    case TK_KEYWORD__DECIMAL32: return "TK_KEYWORD__DECIMAL32";
    case TK_KEYWORD__DECIMAL64: return "TK_KEYWORD__DECIMAL64";
    case TK_KEYWORD__GENERIC: return "TK_KEYWORD__GENERIC";
    case TK_KEYWORD__IMAGINARY: return "TK_KEYWORD__IMAGINARY";
    case TK_KEYWORD__NORETURN: return "TK_KEYWORD__NORETURN";
    case TK_KEYWORD__STATIC_ASSERT: return "TK_KEYWORD__STATIC_ASSERT";
    case TK_KEYWORD_ASSERT: return "TK_KEYWORD_ASSERT"; /*extension*/
    case TK_KEYWORD__THREAD_LOCAL: return "TK_KEYWORD__THREAD_LOCAL";

    case TK_KEYWORD_TYPEOF: return "TK_KEYWORD_TYPEOF"; /*C23*/

    case TK_KEYWORD_TRUE: return "TK_KEYWORD_TRUE";  /*C23*/
    case TK_KEYWORD_FALSE: return "TK_KEYWORD_FALSE";  /*C23*/
    case TK_KEYWORD_NULLPTR: return "TK_KEYWORD_NULLPTR";  /*C23*/
    case TK_KEYWORD_TYPEOF_UNQUAL: return "TK_KEYWORD_TYPEOF_UNQUAL"; /*C23*/
    case TK_KEYWORD__BITINT: return "TK_KEYWORD__BITINT";  /*C23*/



        /*cake extension*/
    case TK_KEYWORD_CAKE_OWNER: return "TK_KEYWORD_CAKE_OWNER";
    case TK_KEYWORD__CTOR: return "TK_KEYWORD__OUT";
    case TK_KEYWORD__DTOR: return "TK_KEYWORD__OBJ_OWNER";
    case TK_KEYWORD_CAKE_VIEW: return "TK_KEYWORD_CAKE_VIEW";
    case TK_KEYWORD_CAKE_OPT: return "TK_KEYWORD_CAKE_OPT";


        /*extension compile time functions*/
    case TK_KEYWORD_CAKE_STATIC_DEBUG: return "TK_KEYWORD_CAKE_STATIC_DEBUG"; /*extension*/
    case TK_KEYWORD_CAKE_STATIC_DEBUG_EX: return "TK_KEYWORD_CAKE_STATIC_DEBUG_EX"; /*extension*/
    case TK_KEYWORD_STATIC_STATE: return "TK_KEYWORD_STATIC_STATE"; /*extension*/
    case TK_KEYWORD_STATIC_SET: return "TK_KEYWORD_STATIC_SET"; /*extension*/

        /*https://en.cppreference.com/w/cpp/header/type_traits*/

    case TK_KEYWORD_IS_POINTER: return "TK_KEYWORD_IS_POINTER";
    case TK_KEYWORD_IS_LVALUE: return "TK_KEYWORD_IS_LVALUE";
    case TK_KEYWORD_IS_CONST: return "TK_KEYWORD_IS_CONST";
    case TK_KEYWORD_IS_OWNER: return "TK_KEYWORD_IS_OWNER";
    case TK_KEYWORD_IS_ARRAY: return "TK_KEYWORD_IS_ARRAY";
    case TK_KEYWORD_IS_FUNCTION: return "TK_KEYWORD_IS_FUNCTION";
    case TK_KEYWORD_IS_SCALAR: return "TK_KEYWORD_IS_SCALAR";
    case TK_KEYWORD_IS_ARITHMETIC: return "TK_KEYWORD_IS_ARITHMETIC";
    case TK_KEYWORD_IS_FLOATING_POINT: return "TK_KEYWORD_IS_FLOATING_POINT";
    case TK_KEYWORD_IS_INTEGRAL: return "TK_KEYWORD_IS_INTEGRAL";
    case TK_PRAGMA_END: return "TK_PRAGMA_END";
    case TK_KEYWORD__COUNTOF: return "TK_KEYWORD__COUNTOF";
    case TK_PLUS_ASSIGN: return "TK_PLUS_ASSIGN";
    case TK_MINUS_ASSIGN: return "TK_MINUS_ASSIGN";
    case TK_MULTI_ASSIGN: return "TK_MULTI_ASSIGN";
    case TK_DIV_ASSIGN: return "TK_DIV_ASSIGN";
    case TK_MOD_ASSIGN: return "TK_MOD_ASSIGN";
    case TK_SHIFT_LEFT_ASSIGN: return "TK_SHIFT_LEFT_ASSIGN";
    case TK_SHIFT_RIGHT_ASSIGN: return "TK_SHIFT_RIGHT_ASSIGN";
    case TK_AND_ASSIGN: return "TK_AND_ASSIGN";
    case TK_OR_ASSIGN: return "TK_OR_ASSIGN";
    case TK_NOT_ASSIGN: return "TK_NOT_ASSIGN";

    case TK_KEYWORD_GCC__BUILTIN_VA_END: return "TK_KEYWORD_GCC__BUILTIN_VA_END";
    case TK_KEYWORD_GCC__BUILTIN_VA_ARG: return "TK_KEYWORD_GCC__BUILTIN_VA_ARG";
    case TK_KEYWORD_GCC__BUILTIN_C23_VA_START: return "TK_KEYWORD_GCC__BUILTIN_C23_VA_START";
    case TK_KEYWORD_GCC__BUILTIN_VA_COPY: return "TK_KEYWORD_GCC__BUILTIN_VA_COPY";
    case TK_KEYWORD_GCC__BUILTIN_OFFSETOF: return "TK_KEYWORD_GCC__BUILTIN_OFFSETOF";

    }
    return "TK_X_MISSING_NAME";
};


int stringify(const char* input, int n, char output[])
{
    int count = 0;
    if (count < n)
        output[count++] = '"';

    const char* p = input;
    while (*p)
    {
        if (*p == '\"' ||
            *p == '\\')
        {
            if (count < n)
                output[count++] = '\\';

            if (count < n)
                output[count++] = *p;
            p++;
        }
        else
        {
            if (count < n)
                output[count++] = *p;
            p++;
        }
    }

    if (count < n)
        output[count++] = '"';
    if (count < n)
        output[count++] = 0;

    if (count >= n)
        return -count;

    return count;
}


void print_literal(const char* _Opt s)
{
    if (s == NULL)
    {
        printf("\"");
        printf("\"");
        return;
    }
    printf("\"");
    while (*s)
    {
        switch (*s)
        {
        case '\n':
            printf("\\n");
            break;
        default:
            printf("%c", *s);
        }
        s++;
    }
    printf("\"");
}


const char* _Owner _Opt get_code_as_we_see_plus_macros(const struct token_list* list)
{
    struct osstream ss = { 0 };
    struct token* _Opt current = list->head;
    while (current)
    {
        if (current->level == 0 &&
            current->type != TK_BEGIN_OF_FILE)
        {
            if (current->flags & TK_FLAG_MACRO_EXPANDED)
                ss_fprintf(&ss, LIGHTCYAN);
            else
                ss_fprintf(&ss, WHITE);
            ss_fprintf(&ss, "%s", current->lexeme);
            ss_fprintf(&ss, RESET);
        }
        current = current->next;
    }

    const char* _Owner _Opt cstr = ss.c_str;
    ss.c_str = NULL; /*MOVED*/

    ss_close(&ss);

    return cstr;
}

/*useful to debug visit.c*/
void print_code_as_we_see(const struct token_list* list, bool remove_comments)
{
    if (list->head == NULL || list->tail == NULL)
    {
        return;
    }

    struct token* _Opt current = list->head;
    while (current && current != list->tail->next)
    {
        if (current->level == 0 &&
            !(current->flags & TK_FLAG_MACRO_EXPANDED) &&
            !(current->flags & TK_C_BACKEND_FLAG_HIDE) &&
            current->type != TK_BEGIN_OF_FILE)
        {
            if ((current->flags & TK_FLAG_HAS_SPACE_BEFORE) &&
                (current->prev != NULL && current->prev->type != TK_BLANKS))
            {
                //if an expanded macro is shown it does not have spaces so we insert
                printf(" ");
            }

            if (remove_comments)
            {
                if (current->type == TK_LINE_COMMENT)
                    printf("\n");
                else if (current->type == TK_COMMENT)
                    printf(" ");
                else
                    printf("%s", current->lexeme);
            }
            else
            {
                printf("%s", current->lexeme);
            }
        }
        current = current->next;
    }
}
const char* _Owner _Opt get_code_as_we_see(const struct token_list* list, bool remove_comments)
{
    if (list->head == NULL || list->tail == NULL)
        return NULL;

    struct osstream ss = { 0 };
    struct token* _Opt current = list->head;
    while (current && current != list->tail->next)
    {
        if (current->level == 0 &&
            !(current->flags & TK_FLAG_MACRO_EXPANDED) &&
            !(current->flags & TK_C_BACKEND_FLAG_HIDE) &&
            current->type != TK_BEGIN_OF_FILE)
        {
            if ((current->flags & TK_FLAG_HAS_SPACE_BEFORE) &&
                (current->prev != NULL && current->prev->type != TK_BLANKS))
            {
                //if an expanded macro is shown it has no spaces so we insert
                ss_fprintf(&ss, " ");
            }

            if (remove_comments)
            {
                if (current->type == TK_LINE_COMMENT)
                    ss_fprintf(&ss, "\n");
                else if (current->type == TK_COMMENT)
                    ss_fprintf(&ss, " ");
                else
                    ss_fprintf(&ss, "%s", current->lexeme);
            }
            else
            {
                ss_fprintf(&ss, "%s", current->lexeme);
            }
        }
        current = current->next;
    }

    const char* _Owner _Opt cstr = ss.c_str;
    ss.c_str = NULL; /*MOVED*/

    ss_close(&ss);

    return cstr;
}


const char* _Owner _Opt get_code_as_compiler_see(const struct token_list* list)
{
    if (list->head == NULL || list->tail == NULL)
    {
        return NULL;
    }

    struct osstream ss = { 0 };


    struct token* _Opt current = list->head;
    while (current && current != list->tail->next)
    {
        if (!(current->flags & TK_C_BACKEND_FLAG_HIDE) &&
            current->type != TK_BEGIN_OF_FILE &&
            (current->flags & TK_FLAG_FINAL))
        {
            if (current->flags & TK_FLAG_HAS_SPACE_BEFORE)
                ss_fprintf(&ss, " ");

            if (current->flags & TK_FLAG_HAS_NEWLINE_BEFORE)
                ss_fprintf(&ss, "\n");

            if (current->type == TK_LINE_COMMENT)
                ss_fprintf(&ss, "\n");
            else if (current->type == TK_COMMENT)
                ss_fprintf(&ss, " ");
            else
                ss_fprintf(&ss, "%s", current->lexeme);
        }
        current = current->next;
    }

    return ss.c_str;
}

const char* _Owner _Opt print_preprocessed_to_string2(const struct token* _Opt p_token)
{
    /*
      * At level > 0 (i.e. inside the includes)
      * This function prints the tokens as the compiler sees them
      * and inserts a space or line break to represent
      * the separation between tokens.

      * At level 0 (main file) it prints spaces, comments
      * etc. and inserts spaces in the macro expansion.
  */

    if (p_token == NULL)
        return strdup("(null)");

    struct osstream ss = { 0 };
    const struct token* _Opt current = p_token;
    while (current)
    {

        //We ignored the line continuation and it can appear anywhere in the lexemes. 
        //instead of removing it, you could just skip it when printing
        remove_line_continuation(current->lexeme);

        if (current->flags & TK_FLAG_FINAL)
        {
            if (current->level > 0)
            {
                //at the include levels we may be ignoring all
                //the spaces. in this case it is necessary to include them so as not to add the tokens
                if ((current->flags & TK_FLAG_HAS_NEWLINE_BEFORE))
                    ss_fprintf(&ss, "\n");
                else if ((current->flags & TK_FLAG_HAS_SPACE_BEFORE))
                    ss_fprintf(&ss, " ");
            }
            else
            {
                /*
                 at level 0 we print the spaces.. however in the case of macros
                 it is necessary to put a space because it does not exist.
                */
                if (current->flags & TK_FLAG_MACRO_EXPANDED)
                {
                    if ((current->flags & TK_FLAG_HAS_SPACE_BEFORE))
                        ss_fprintf(&ss, " ");
                }
            }

            if (current->lexeme[0] != '\0')
            {
                ss_fprintf(&ss, "%s", current->lexeme);
            }

            current = current->next;
        }
        else
        {
            if (current->level == 0)
            {
                if (current->type == TK_BLANKS ||
                    current->type == TK_NEWLINE)
                {
                    ss_fprintf(&ss, "%s", current->lexeme);
                }
            }

            current = current->next;
        }
    }

    return ss.c_str;
}

const char* _Owner _Opt print_preprocessed_to_string(const struct token* p_token)
{
    /*
    * Esta funcao imprime os tokens como o compilador ve
    * e insere um espaco ou quebra de linha para poder representar
    * a separacao entre os tokens.
    */

    struct osstream ss = { 0 };
    const struct token* _Opt current = p_token;

    /*
    * Ignora tudo o que é espaço no início
    */
    while (!(current->flags & TK_FLAG_FINAL) ||
        current->type == TK_BLANKS ||
        current->type == TK_COMMENT ||
        current->type == TK_LINE_COMMENT ||
        current->type == TK_NEWLINE ||
        current->type == TK_PREPROCESSOR_LINE)
    {
        current = current->next;
        if (current == NULL)
            return ss.c_str; /*MOVED*/
    }

    bool first = true;
    while (current)
    {
        assert(current->token_origin != NULL);
        if (current->flags & TK_FLAG_FINAL)
        {
            if (!first && current->flags & TK_FLAG_HAS_NEWLINE_BEFORE)
                ss_fprintf(&ss, "\n");
            else if (!first && current->flags & TK_FLAG_HAS_SPACE_BEFORE)
                ss_fprintf(&ss, " ");
            if (current->lexeme[0] != '\0')
                ss_fprintf(&ss, "%s", current->lexeme);
            first = false;
            current = current->next;
        }
        else
        {
            current = current->next;
        }
    }

    return ss.c_str; /*MOVED*/
}

void print_preprocessed(const struct token* p_token)
{
    const char* _Owner _Opt s = print_preprocessed_to_string(p_token);
    if (s)
    {
        printf("%s", s);
        free((void* _Owner)s);
    }
}

static bool is_screaming_case(const char* text)
{

    bool screaming_case = false;

    while (*text)
    {
        if ((*text >= 'A' && *text <= 'Z') ||
            (*text >= '0' && *text <= '9') ||
            (*text == '_'))
        {
            //ok
            screaming_case = true;
        }
        else
            return false;
        text++;
    }

    return screaming_case;
}

void print_all_macros(const struct preprocessor_ctx* prectx)
{
    for (int i = 0; i < prectx->macros.capacity; i++)
    {
        struct map_entry* _Opt entry = prectx->macros.table[i];
        if (entry == NULL) continue;
        assert(entry->data.p_macro != NULL);

        struct macro* macro = entry->data.p_macro;
        printf("#define %s", macro->name);
        if (macro->is_function)
        {
            printf("(");

            struct macro_parameter* _Opt parameter = macro->parameters;
            while (parameter)
            {
                printf("%s", parameter->name);
                if (parameter->next)
                    printf(",");
                parameter = parameter->next;
            }
            printf(")");
        }
        printf(" ");

        struct token* _Opt token = macro->replacement_list.head;
        while (token)
        {
            printf("%s", token->lexeme);

            if (token == macro->replacement_list.tail)
                break;

            token = token->next;
        }
        printf("\n");
    }
}
void naming_convention_macro(struct preprocessor_ctx* ctx, struct token* token)
{
    if (!is_screaming_case(token->lexeme))
    {
        preprocessor_diagnostic(W_NOTE, ctx, token, "use SCREAMING_CASE for macros");
    }

}


#ifdef TEST


//#pragma once

extern int g_unit_test_error_count;
extern int g_unit_test_success_count;
static void assert_func(int condition, const char* func, const char* file, int line, const char* message)
{
    if (!condition)
    {
        const char* pos = file;
        const char* p = file;
        while (*p)
        {
            if (*p == '/' || *p == '\\')
                pos = p;
            p++;
        }
        
        if (*pos == '/' || *pos == '\\')
            pos++;

        g_unit_test_error_count++;
        printf("\x1b[97m" "%s:%d:0:" "\x1b[91m" " test failed:" "\x1b[0m" " function '%s'\n", pos, line, func);
        
        char buffer[20] = { 0 };
        int n = snprintf(buffer, sizeof buffer, "%d", line);        
        printf(" %s |", buffer);
        printf("    assert(%s);\n", message);
        printf(" %*s |\n", n, " ");
    }
    else
    {
        g_unit_test_success_count++;
        //printf("\x1b[97m" "%s:%d:0" "\x1b[92m" " OK" "\x1b[0m" " at '%s'\n", file, line, func);        
    }
}

#undef assert
#define assert(expression) assert_func(expression, __func__, __FILE__, __LINE__, #expression)




void print_asserts(struct token* p_token)
{
    struct token* current = p_token;
    printf("struct { const char* lexeme; enum token_type token; int is_active; int is_final; } result[] = { \n");
    while (current)
    {
        printf("{ %-20s, %d, ", get_token_name(current->type), (current->flags & TK_FLAG_FINAL));
        print_literal(current->lexeme);
        printf("},\n");
        current = current->next;
    }
    printf("}\n");
}

void show_all(struct token* p_token)
{
    struct token* current = p_token;
    while (current)
    {
        if (current->flags & TK_FLAG_FINAL)
        {
            if (current->level == 0)
                printf(WHITE);
            else
                printf(BROWN);
        }
        else
        {
            if (current->level == 0)
                printf(LIGHTGRAY);
            else
                printf(BLACK);
        }
        printf("%s", current->lexeme);
        printf(RESET);
        current = current->next;
    }
}

void print_preprocessed_to_file(struct token* p_token, const char* filename)
{
    FILE* f = fopen(filename, "r");
    if (f)
    {
        const char* s = print_preprocessed_to_string(p_token);
        if (s)
        {
            fprintf(f, "%s", s);
            free((void* _Owner)s);
        }
        fclose(f);
    }
}

void show_visible(struct token* p_token)
{
    printf(WHITE "visible used   / " LIGHTGRAY "visible ignored\n" RESET);
    struct token* current = p_token;
    while (current)
    {
        if (current->level == 0)
        {
            if (current->flags & TK_FLAG_FINAL)
                printf(WHITE);
            else
                printf(LIGHTGRAY);
        }
        else
        {
            if (current->level == 0)
                printf(BLACK);
            else
                printf(BLACK);
        }
        printf("%s", current->lexeme);
        printf(RESET);
        current = current->next;
    }
}

void show_visible_and_invisible(struct token* p_token)
{
    printf(LIGHTGREEN "visible used   / " LIGHTGRAY "visible ignored\n" RESET);
    printf(LIGHTBLUE  "invisible used / " BROWN     "invisible ignored\n" RESET);
    struct token* current = p_token;
    while (current)
    {
        if (current->level == 0)
        {
            if (current->flags & TK_FLAG_FINAL)
                printf(LIGHTGREEN);
            else
                printf(LIGHTGRAY);
        }
        else
        {
            if (current->flags & TK_FLAG_FINAL)
                printf(LIGHTBLUE);
            else
                printf(BROWN);
        }
        printf("%s", current->lexeme);
        printf(RESET);
        current = current->next;
    }
}

int test_preprossessor_input_output(const char* input, const char* output)
{
    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);

    struct preprocessor_ctx ctx = { 0 };

    struct token_list r = preprocessor(&ctx, &list, 0);
    const char* s = print_preprocessed_to_string(r.head);
    if (strcmp(s, output) != 0)
    {
        printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
        printf("expected\n%s", output);
        printf("HAS\n%s", s);
        printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
        print_tokens(r.head);
        printf("TEST 0 FAILED\n");
        return 1;
    }
    free((void* _Owner)s);
    return 0;
}

char* normalize_line_end(char* input)
{
    if (input == NULL)
        return NULL;
    char* pWrite = input;
    const char* p = input;
    while (*p)
    {
        if (p[0] == '\r' && p[1] == '\n')
        {
            *pWrite = '\n';
            p++;
            p++;
            pWrite++;
        }
        else
        {
            *pWrite = *p;
            p++;
            pWrite++;
        }
    }
    *pWrite = 0;
    return input;
}


int test_preprocessor_in_out(const char* input, const char* output)
{
    int res = 0;

    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);

    struct preprocessor_ctx ctx = { 0 };

    struct token_list r = preprocessor(&ctx, &list, 0);
    const char* result = print_preprocessed_to_string(r.head);
    if (result == NULL)
    {
        result = strdup("");
    }

    if (strcmp(result, output) != 0)
    {
        /*
        printf("FAILED\n");
        printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
        printf("assert\n");
        printf("%s`", output);
        printf("\nGOT\n");
        printf("%s`", result);
        printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
        print_tokens(r.head);

        */
        res = 1;
    }

    free(result);

    return res;
}

int test_preprocessor_in_out_using_file(const char* fileName)
{
    int res = 0;
    const char* input = normalize_line_end(read_file(fileName, true));
    char* output = 0;
    if (input)
    {
        char* pos = strstr(input, "\n---");
        if (pos)
        {
            *pos = 0;
            //anda ate sair ---
            pos++;
            while (*pos != '\n')
            {
                pos++;
            }
            pos++; //skip \n
            output = pos;
            /*optional*/
            pos = strstr(output, "\n---");
            if (pos)
                *pos = 0;
        }
        res = test_preprocessor_in_out(input, output);
        free((void* _Owner)input);
    }
    return res;
}

void test_lexeme_cmp()
{
    assert(lexeme_cmp("a", "\\\na") == 0);
    assert(lexeme_cmp("a", "a\\\n") == 0);
    assert(lexeme_cmp("\\\na", "a") == 0);
    assert(lexeme_cmp("a\\\n", "a") == 0);
    assert(lexeme_cmp("a\\\nb", "ab") == 0);
    assert(lexeme_cmp("define", "define") == 0);
    assert(lexeme_cmp("de\\\nfine", "define") == 0);
}

void token_list_pop_front_test()
{

    struct token_list list = { 0 };
    token_list_pop_front(&list);
    struct tokenizer_ctx tctx = { 0 };
    list = tokenizer(&tctx, "a", NULL, 0, TK_FLAG_NONE);
    token_list_pop_front(&list);

    list = tokenizer(&tctx, "a,", NULL, 0, TK_FLAG_NONE);
    token_list_pop_front(&list);

    list = tokenizer(&tctx, "a,b", NULL, 0, TK_FLAG_NONE);
    token_list_pop_front(&list);
}

void token_list_pop_back_test()
{

    struct token_list list = { 0 };
    token_list_pop_back(&list);

    /*pop back quando so tem 1*/
    token_list_clear(&list);
    struct tokenizer_ctx tctx = { 0 };
    list = tokenizer(&tctx, "a", NULL, 0, TK_FLAG_NONE);
    token_list_pop_back(&list);
    assert(list.head == NULL && list.tail == NULL);


    /*
    * pop bacl com 2
    */

    token_list_clear(&list);
    list = tokenizer(&tctx, "a,", NULL, 0, TK_FLAG_NONE);
    token_list_pop_back(&list);

    assert(strcmp(list.head->lexeme, "a") == 0);

    assert(list.head != NULL &&
        list.head->prev == NULL &&
        list.head->next == NULL &&
        list.tail->prev == NULL &&
        list.tail->next == NULL &&
        list.tail == list.head);

    /*
    * pop back com 3
    */

    list = tokenizer(&tctx, "a,b", NULL, 0, TK_FLAG_NONE);
    token_list_pop_back(&list);
    assert(strcmp(list.head->lexeme, "a") == 0);
    assert(strcmp(list.head->next->lexeme, ",") == 0);
    assert(strcmp(list.tail->lexeme, ",") == 0);
    assert(strcmp(list.tail->prev->lexeme, "a") == 0);
    assert(list.head->prev == NULL);
    assert(list.tail->next == NULL);
}

int token_list_append_list_test()
{

    struct tokenizer_ctx tctx = { 0 };
    struct token_list source = { 0 };
    struct token_list dest = tokenizer(&tctx, "a", NULL, 0, TK_FLAG_NONE);
    token_list_append_list(&dest, &source);
    assert(strcmp(dest.head->lexeme, "a") == 0);


    token_list_clear(&source);
    token_list_clear(&dest);


    dest = tokenizer(&tctx, "a", NULL, 0, TK_FLAG_NONE);
    token_list_append_list(&dest, &source);

    assert(strcmp(dest.head->lexeme, "a") == 0);

    token_list_clear(&source);
    token_list_clear(&dest);
    source = tokenizer(&tctx, "a,", NULL, 0, TK_FLAG_NONE);
    dest = tokenizer(&tctx, "1", NULL, 0, TK_FLAG_NONE);
    token_list_append_list(&dest, &source);
    assert(strcmp(dest.head->lexeme, "1") == 0);
    assert(strcmp(dest.tail->lexeme, ",") == 0);
    assert(dest.tail->next == NULL);
    assert(dest.head->next->next == dest.tail);
    assert(dest.tail->prev->prev == dest.head);

    return 0;
}

void test_collect()
{
    const char* input =
        "#define F(A, B) A ## B\n"
        "F(a \n, b)";

    const char* output =
        "ab"
        ;


    assert(test_preprocessor_in_out(input, output) == 0);

}


void test_va_opt_0()
{
    const char* input =
        "#define F(...)  f(0 __VA_OPT__(,) __VA_ARGS__)\n"
        "F(a, b, c)";
    const char* output =
        "f(0, a, b, c)";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_opt_1()
{
    const char* input =
        "#define F(...)  f(0 __VA_OPT__(,) __VA_ARGS__)\n"
        "F()";
    const char* output =
        "f(0)";
    assert(test_preprocessor_in_out(input, output) == 0);
}


void test_va_opt_2()
{
    const char* input =
        "#define empty(...) (__VA_OPT__(!)1)\n"
        "empty()";
    const char* output =
        "(1)";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_opt_3()
{
    const char* input =
        "#define empty(...) (__VA_OPT__(!)1)\n"
        "empty(1)";
    const char* output =
        "(!1)";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_opt_4()
{
    const char* input =
        "#define LPAREN() (\n"
        "#define G(Q) 42\n"
        "#define F(R, X, ...) __VA_OPT__(G R X) )\n"
        "int x = F(LPAREN(), 0, <:-);\n"
        ;
    const char* output =
        "int x = 42;";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_opt_5()
{
    const char* input =
        "#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)\n"
        "#define EMPTY\n"
        "F(EMPTY)"
        ;
    const char* output =
        "f(0)";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_opt_6()
{
    const char* input =
        "#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)\n"
        "G(a)"
        ;

    const char* output =
        "f(0, a)";

    assert(test_preprocessor_in_out(input, output) == 0);
}
void test_va_opt_7()
{
    const char* input =
        "#define H4(X, ...) __VA_OPT__(a X ## X) ## b\n"
        "H4(, 1)"
        ;

    const char* output =
        "a b";

    assert(test_preprocessor_in_out(input, output) == 0);
}

void concatenation_problem()
{
    const char* input =
        "#define H4(X, ...) a X ## X ## b\n"
        "H4()"
        ;

    const char* output =
        "a b";

    assert(test_preprocessor_in_out(input, output) == 0);
}


void test_va_opt_G2()
{
    const char* input =
        "#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)\n"
        "G(a, )"
        ;

    const char* output =
        "f(0, a)";

    assert(test_preprocessor_in_out(input, output) == 0);
}


void test_va_opt()
{
    const char* input =
        "#define F(...)  f(0 __VA_OPT__(,) __VA_ARGS__)\n"
        "#define EMPTY\n"
        "F(EMPTY)";
    const char* output =
        "f(0)";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_empty_va_args()
{
    const char* input = "#define M(a, ...) a, __VA_ARGS__\n"
        "M(1)\n";
    const char* output =
        "1,";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_args_single()
{
    const char* input =
        "#define F(...) __VA_ARGS__\n"
        "F(1, 2)";
    const char* output =
        "1, 2";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_args_extra_args()
{
    const char* input =
        "#define F(a, ...) a __VA_ARGS__\n"
        "F(0, 1, 2)";
    const char* output =
        "0 1, 2";
    assert(test_preprocessor_in_out(input, output) == 0);
}


void test_empty_va_args_empty()
{
    const char* input =
        "#define F(...) a __VA_ARGS__\n"
        "F()";
    const char* output =
        "a";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_defined()
{
    const char* input =
        "#if defined X || defined (X)\n"
        "A\n"
        "#else\n"
        "B\n"
        "#endif\n";
    const char* output =
        "B";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void testline()
{
    const char* input =
        "#define M \\\n"
        "        a\\\n"
        "        b\n"
        "M";
    const char* output =
        "a b";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void ifelse()
{
    const char* input =
        "#if 1\n"
        "A\n"
        "#else\n"
        "B\n"
        "#endif\n";
    const char* output =
        "A";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void T1()
{
    const char* input =
        "#define f(a) f(x * (a))\n"
        "f(2 * (0, 1))";
    const char* output =
        "f(x * (2 * (0, 1)))";
    //se f tivesse 2 parametros
    //error: too few arguments provided to function-like macro invocation
    //se f nao tivesse nenhum ou menus
    //too many arguments provided to function-like macro invocation
    assert(test_preprocessor_in_out(input, output) == 0);
}

int EXAMPLE5()
{
    /*
    //EXAMPLE 5 To illustrate the rules for placemarker preprocessing tokens, the sequence

    //const char* input =
    //"#define t(x,y,z) x ## y ## z\n"
    //"int j[] = {t(+1,2,3), t(,4,5), t(6,,7), t(8,9,),t(10,,), t(,11,), t(,,12), t(,,) };";

    //const char* output =
      //  "int j[] = {+123, 45, 67, 89,10, 11, 12, };";

    const char* input =
        "#define t(x,y,z) x ## y ## z\n"
        "t(+1,2,3)";

    const char* output =
        "int j[] = {+123, 45, 67, 89,10, 11, 12, };";

    //se f tivesse 2 parametros
    //error: too few arguments provided to function-like macro invocation

    //se f nao tivesse nenhum ou menus
    //too many arguments provided to function-like macro invocation
    //test_preprocessor_in_out(input, output);
    */
    return 0;
}

void recursivetest1()
{
    //acho que este vai sero caso que precisa do hidden set.
    const char* input =
        "#define x 2\n"
        "#define f(a) f(x * (a))\n"
        "#define z z[0]\n"
        "f(f(z))";
    //resultado gcc da
    //const char* output =
    //  "f(2 * (f(2 * (z[0]))))";
    const char* output =
        "f(2 * (f(z[0])))";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void rectest()
{
    const char* input =
        "#define x 2\n"
        "#define f(a) f(x * (a))\n"
        "#define g f\n"
        "#define z z[0]\n"
        "f(y + 1) + f(f(z)) % t(t(g)(0) + t)(1);";
    //GCC
    //const char* output =
    //  "f(2 * (y + 1)) + f(2 * (f(2 * (z[0])))) % t(t(f)(0) + t)(1);";
    const char* output =
        "f(2 * (y + 1)) + f(2 * (f(z[0]))) % t(t(f)(0) + t)(1);";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void emptycall()
{
    const char* input =
        "#define F(x) x\n"
        "F()"
        ;
    const char* output =
        ""
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}

void semiempty()
{
    const char* input =
        "#define F(x,y) x ## y\n"
        "F(1,)"
        ;
    const char* output =
        "1"
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}

void calling_one_arg_with_empty_arg()
{
    const char* input =
        "#define F(a) # a\n"
        "F()"
        ;
    const char* output =
        "\"\""
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}


void test_argument_with_parentesis()
{
    const char* input =
        "#define F(a, b) a ## b\n"
        "F((1, 2, 3),4)"
        ;
    const char* output =
        "(1, 2, 3)4"
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}

void two_empty_arguments()
{
    const char* input =
        "#define F(a, b) a ## b\n"
        "F(,)\n"
        ;
    const char* output =
        ""
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}

void simple_object_macro()
{
    const char* input = "#define B b\n"
        "#define M a B\n"
        "M\n"
        "c\n";
    const char* output =
        "a b\n"
        "c";
    assert(test_preprocessor_in_out(input, output) == 0);
}


void test_one_file()
{
    assert(test_preprocessor_in_out_using_file("tests/pre_debug.c") == 0);
}

void test2()
{
    const char* input =
        "#define F(a, b) 1 a ## b 4\n"
        "F(  2  ,  3 )"
        ;
    const char* output =
        "1 23 4"
        ;

    assert(test_preprocessor_in_out(input, output) == 0);
}


void test3()
{
#if 0
    const char* input =
        "#define F(a, b) 1 a ## 3 4\n"
        "F(  2   )"
        ;
    const char* output =
        "1 23 4"
        ;
#endif
    //este erro falta parametro b
    //too few arguments provided to function - like macro invocation
    //test_preprocessor_in_out(input, output);
}


void tetris()
{
    const char* input =
        "#define D(a) a\n"
        "#define C(a) a\n"
        "#define F(a) a\n"
        "#define M F\n"
        "M(F)(C)(D)e"
        ;
    const char* output =
        "De"
        ;
    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);

    struct preprocessor_ctx ctx = { 0 };

    struct token_list r = preprocessor(&ctx, &list, 0);

    assert(test_preprocessor_in_out(input, output) == 0);
}

void recursive_macro_expansion()
{
    const char* input =
        "#define A 3 4 B\n"
        "#define B 1 2 A\n"
        "B";
    const char* output =
        "1 2 3 4 B"
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}

void empty_and_no_args()
{
    const char* input =
        "#define F() 1\n"
        "F()";
    const char* output =
        "1"
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}

void empty_and_args()
{
    const char* input =
        "#define F() 1\n"
        "F(1)";
    const char* output =
        "1"
        ;
    int code = test_preprocessor_in_out(input, output);
    assert(code != 0);
}

void test4()
{
    const char* input =
        "#define F(a, b) 1 2 ## a 4\n"
        "F(  3   )"
        ;
    const char* output =
        "1 23 4"
        ;


    int code = test_preprocessor_in_out(input, output);

    //esperado um erro (falta mensagem)
    //too few arguments provided to function-like macro invocation F (3)
    //engracado msc eh warning  warning C4003: not enough actual parameters for macro 'F'
    assert(code != 0);
}

void test_string()
{
    const char* input =
        "#define M(a, b) a # b\n"
        "M(A, \"B\")"
        ;
    const char* output =
        "A \"\\\"B\\\"\""
        ;


    test_preprocessor_in_out(input, output);
}

void test6()
{
    /*

    #define Y
    #define X defined (Y)

    #if X
    #warning !
    #endif
    */
}

void testerror()
{
    /*
    const char* input =
        "#define F(a) #b\n"
        "F(1)\n"
        ;
    const char* output =
        ""
        ;
    //tem que dar error
    test_preprocessor_in_out(input, output);
    */
}

int test_preprocessor_expression(const char* expr, long long expected)
{

    struct preprocessor_ctx ctx = { 0 };

    struct token_list r = { 0 };
    struct tokenizer_ctx tctx = { 0 };
    struct token_list input = tokenizer(&tctx, expr, "", 0, TK_FLAG_NONE);

    long long result = preprocessor_constant_expression(&ctx, &r, &input, 0);
    return result == expected ? 0 : 1;
}

int test_expression()
{

    //TODO preprocessador eh sempre long long.. signed passadno maior
    //deve dar erro

    if (test_preprocessor_expression("true", true) != 0)
        return __LINE__;

    if (test_preprocessor_expression("false", false) != 0)
        return __LINE__;


    if (test_preprocessor_expression("'A'", 'A') != 0)
        return __LINE__;

    if (test_preprocessor_expression("'ab'", 'ab') != 0)
        return __LINE__;

    if (test_preprocessor_expression("1+2", 1 + 2) != 0)
        return __LINE__;

    if (test_preprocessor_expression("1 + 2 * 3 / 2 ^ 2 & 4 | 3 % 6 >> 2 << 5 - 4 + !7",
        1 + 2 * 3 / 2 ^ 2 & 4 | 3 % 6 >> 2 << 5 - 4 + !7) != 0)
        return __LINE__;

    if (test_preprocessor_expression("1ull + 2l * 3ll",
        1ull + 2l * 3ll) != 0)
        return __LINE__;


    return 0;
}

int test_concatenation_o()
{
    const char* input =
        "# define F(t1, t2, t3) *i_##t1##_j k\n"
        "F(A, B, C)\n";

    const char* output =
        "*i_A_j k"
        ;


    return test_preprocessor_in_out(input, output);
}

int test_concatenation()
{
    const char* input =
        "#define F(t1, t2, t3) i##j##k\n"
        "F(A, B, C)\n";

    const char* output =
        "ijk"
        ;


    return test_preprocessor_in_out(input, output);


}

void bad_test()
{
    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, "0xfe-BAD(3)", "source", 0, TK_FLAG_NONE);

    const char* input = "#define BAD(x) ((x) & 0xff)\n"
        "0xfe-BAD(3);";
    const char* output =
        "0xfe-BAD(3);"
        ;

    test_preprocessor_in_out(input, output);
}
/*
#define A0
#define B0
#define A1(x) x B##x(
#define B1(x) x A##x(
A1(1)1)1)1)1)0))
*/
int test_spaces()
{
    const char* input =
        "#define throw A B\n"
        "throw\n"
        ;
    const char* output =
        "A B"
        ;


    return test_preprocessor_in_out(input, output);
}

int test_stringfy()
{
    const char* input =
        "#define M(T) #T\n"
        "M(unsigned   int)\n"
        ;
    const char* output =
        "\"unsigned int\""
        ;


    return test_preprocessor_in_out(input, output);

}


int test_tokens()
{
    const char* input =
        "L\"s1\" u8\"s2\""
        ;

    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "", 0, TK_FLAG_NONE);

    if (list.head->next->type != TK_STRING_LITERAL)
    {
        return __LINE__;
    }

    if (list.head->next->next->next->type != TK_STRING_LITERAL)
    {
        return __LINE__;
    }

    return tctx.n_errors;
}

int test_predefined_macros()
{
    const char* input =
        "__LINE__ __FILE__"
        ;
    const char* output =
        "1 \"source\""
        ;

    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);

    struct preprocessor_ctx prectx = { 0 };
    prectx.macros.capacity = 5000;
    add_standard_macros(&prectx);
    struct token_list list2 = preprocessor(&prectx, &list, 0);


    const char* result = print_preprocessed_to_string(list2.head);
    if (result == NULL)
    {
        result = strdup("");
    }
    if (strcmp(result, output) != 0)
    {

    }


    return 0;
}

int test_utf8()
{

    const char* input =
        "u8\"maçã\"";

    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);
    if (strcmp(list.head->next->lexeme, u8"u8\"maçã\"") != 0)
        return __LINE__;
    token_list_destroy(&list);
    return 0;
}

int test_counter()
{
    //https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3457.htm#number-of-expansions

    const char* input =
        "#define X(Z) Z Z\n"
        "X(__COUNTER__)\n";

    const char* output =
        "0 0"
        ;

    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);

    struct preprocessor_ctx prectx = { 0 };
    prectx.macros.capacity = 5000;
    add_standard_macros(&prectx);
    struct token_list list2 = preprocessor(&prectx, &list, 0);

    const char* result = print_preprocessed_to_string(list2.head);
    if (result == NULL)
    {
        result = strdup("");
    }

    assert(test_preprocessor_in_out(result, output) == 0);

    return 0;
}

int bug_test()
{
    const char* input =
        "#define M(b) a #b \n"
        "M(1)\n";

    const char* output =
        "a \"1\""
        ;


    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);



    assert(test_preprocessor_in_out(input, output) == 0);

    return 0;
}
int test_line_continuation()
{


    const char* input =
        "#define A B \\\n"
        "C\n"
        "A";

    const char* output =
        "1 \"source\""
        ;


    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "", 0, TK_FLAG_NONE);

    struct preprocessor_ctx prectx = { 0 };
    prectx.macros.capacity = 5000;

    struct token_list list2 = preprocessor(&prectx, &list, 0);

    const char* result = print_preprocessed_to_string(list2.head);
    if (result == NULL)
    {
        result = strdup("");
    }
    if (strcmp(result, output) != 0)
    {
    }


    return 0;
}

int stringify_test()
{
    char buffer[200];
    int n = stringify("\"ab\\c\"", sizeof buffer, buffer);
    assert(n == sizeof(STRINGIFY("\"ab\\c\"")));
    const char* r = STRINGIFY("\"ab\\c\"");

    assert(strcmp(buffer, r) == 0);
    return 0;

}

void recursive_macro_expr()
{

    const char* input =
        "#define A A\n"
        "#if A == 0\n"
        "1\n"
        "#endif";

    const char* output =
        "1"
        ;

    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);

    assert(test_preprocessor_in_out(input, output) == 0);

}

#endif


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

#pragma safety enable


void ss_swap(_View struct osstream* a, _View struct osstream* b)
{
    _View struct osstream r = *a;
    *a = *b;
    *b = r;
}

void ss_clear(struct osstream* stream)
{
    if (stream->c_str)
        stream->c_str[0] = '\0';
    stream->size = 0;
}


void ss_close(_Dtor struct osstream* stream)
{
    free(stream->c_str);
}

static int reserve(struct osstream* stream, int size)
{
    int errorcode = 0;
    if (size > stream->capacity)
    {
        void* _Owner _Opt pnew = realloc(stream->c_str, (size + 1) * sizeof(char));
        if (pnew)
        {
            static_set(stream->c_str, "moved");
            stream->c_str = pnew;
            stream->capacity = size;
            stream->c_str[size] = 0;
        }
        else
        {
            errno = ENOMEM;
            errorcode = 1;
        }
    }
    return errorcode;
}

int ss_vafprintf(struct osstream* stream, const char* fmt, va_list args)
{
    assert(fmt != 0);
    int size = 0;

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"



    va_list tmpa = { 0 };

    va_copy(tmpa, args);

    size = vsnprintf(stream->c_str + stream->size, stream->capacity - stream->size, fmt, tmpa);

    va_end(tmpa);

#pragma CAKE diagnostic pop

    if (size < 0)
    {
        return -1;
    }

    if (reserve(stream, stream->size + size) != 0)
    {
        return -1;
    }

    size = vsprintf(stream->c_str + stream->size, fmt, args);
    if (size > 0)
    {
        stream->size += size;
    }
    return size;
}

/*
* Returns the character written. For fputc, a return value of EOF indicates an error
*/
int ss_putc(char ch, struct osstream* stream)
{
    if (reserve(stream, stream->size + 1) != 0)
    {
        return EOF;
    }
    stream->c_str[stream->size] = ch;
    stream->size++;

    return ch;
}

int ss_fprintf(struct osstream* stream, const char* fmt, ...)
{
#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"

    va_list args = { 0 };
    va_start(args, fmt);
    int size = ss_vafprintf(stream, fmt, args);
    va_end(args);

#pragma CAKE diagnostic pop

    return size;
}



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

#pragma safety enable



#include <wchar.h>


#ifdef _WIN32
#endif


#if defined _MSC_VER && !defined __POCC__
#endif


#ifdef __POCC__
#define stat _stat
#endif

#ifdef _WIN32
#pragma comment (lib, "Rpcrt4.lib")

#else


#include <uuid/uuid.h>
/*
caso nao tenha este arquivos apt-get install uuid-dev
*/
#endif



bool path_is_normalized(const char* path)
{
#ifdef _WINDOWS_
    for (const char* p = path; *p; p++)
    {
        int before = *p;
        int after = tolower(*p);

        if (before != after)
            return false;

        if (after == '\\')
        {
            return false;
        }
    }
    return true;
#else
    return true;
#endif
}

void path_normalize(char* path)
{
#ifdef _WINDOWS_
    for (char* p = path; *p; p++)
    {
        *p = (char)tolower(*p);
        if (*p == '\\')
        {
            *p = '/';
        }
    }
#else

#endif
}

bool path_is_absolute(const char* path)
{
#ifdef _WINDOWS_
    const char ch = (char)tolower(path[0]);
    if (ch >= 'a' && ch <= 'z')
    {
        /*  c:/ or c:\ */
        if (path[1] == ':' && (path[2] == '\\' || path[2] == '/'))
            return true;
    }

    if (path[0] == '\\' && path[1] == '\\')
    {
        // //server
        return true;
    }
#else
    return path[0] == '/';
#endif

    return false;
}

bool path_is_relative(const char* path)
{
    return !path_is_absolute(path);
}


#ifdef _WIN32

#ifdef __CAKE__
#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wstyle"
#endif

struct TAGDIR
{
    void* handle;
    struct dirent dirent;
};

#ifdef __CAKE__
#pragma CAKE diagnostic pop
#endif

DIR* _Owner _Opt opendir(const char* name)
{
    assert(name != 0);
    WIN32_FIND_DATAA fdfile = { 0 };

    char path[MAX_PATH] = { 0 };
    strcat(path, name);
    strcat(path, "\\*.*");

    HANDLE handle = FindFirstFileA(path, &fdfile);

    if (handle != INVALID_HANDLE_VALUE)
    {
        _Opt DIR* _Owner _Opt p = calloc(1, sizeof * p);
        if (p)
        {
            p->handle = handle;
            return p;
        }
        else
        {
            /*calloc sets errno to ENOMEM if a memory allocation fails */
            FindClose(handle);
        }
    }
    else
    {
        errno = windows_error_to_posix(GetLastError());
    }

    return NULL;
}

int closedir(DIR* _Owner dirp)
{
    FindClose(dirp->handle);
    free(dirp);
    return 0;
}

struct dirent* _Opt readdir(DIR* dirp)
{
    WIN32_FIND_DATAA fdfile = { 0 };
    BOOL b = FindNextFileA(dirp->handle, &fdfile);
    if (b)
    {
        /*clear*/
        memset(&dirp->dirent, 0, sizeof(dirp->dirent));

        if (fdfile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            dirp->dirent.d_type |= DT_DIR;
        }

        /*worst case trunks the string*/
        strncpy(dirp->dirent.d_name,
            fdfile.cFileName,
            sizeof(dirp->dirent.d_name) - 1);

        return &dirp->dirent;
    }
    else
    {
        errno = windows_error_to_posix(GetLastError());
    }
    return NULL;
}

/*
* realpath
   If there is no error, realpath() returns a pointer to the
       resolved_path.

       Otherwise, it returns NULL, the contents of the array
       resolved_path are undefined, and errno is set to indicate the
       error.
*/
char* _Opt realpath(const char* restrict path, char* restrict resolved_path)
{
    /*
    * _fullpath
    * Each of these functions returns a pointer to a buffer
      containing the absolute path name (absPath). If there's an
      error (for example, if the value passed in relPath includes a drive
      letter that isn't valid or can't be found, or if the length of the
      created absolute path name (absPath) is greater than maxLength), the function returns NULL.
    */
#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wflow-not-null"
    char* _Opt p = _fullpath(resolved_path, path, MAX_PATH);
    if (p)
    {
        char* p2 = resolved_path;
        while (*p2)
        {
            if (*p2 == '\\')
                *p2 = '/';
            p2++;
        }
    }
#pragma CAKE diagnostic pop

    return p;
}

#endif //_WINDOWS_

int copy_file(const char* pathfrom, const char* pathto)
{

    FILE* _Owner _Opt fd_from = fopen(pathfrom, "rb");
    if (fd_from == NULL)
        return -1;

    FILE* _Owner _Opt fd_to = fopen(pathto, "wb");
    if (fd_to == NULL)
    {
        fclose(fd_from);
        return -1;
    }

    char buf[4096] = { 0 };
    size_t nread;
    while (nread = fread(buf, sizeof(char), sizeof buf, fd_from), nread > 0) //lint !e668  (warning -- possibly passing null pointer to function 'fread(void *, size_t, size_t, FILE *)', arg. no. 4)
    {
        char* out_ptr = buf;
        size_t nwritten;

        do
        {
            nwritten = fwrite(out_ptr, sizeof(char), nread, fd_to);//lint !e668

            nread -= nwritten;
            out_ptr += nwritten;
        } while (nread > 0);
    }

    if (nread == 0)
    {
        fclose(fd_to);
        fclose(fd_from);

        /* Success! */
        return 0;
    }

    fclose(fd_to);
    fclose(fd_from);

    return -1;
}

int copy_folder(const char* from, const char* to)
{
#if !defined __EMSCRIPTEN__
    int errcode = mkdir(to, 0700);
    if (errcode != 0)
    {
        return errcode;
    }

    DIR* _Owner _Opt dir = opendir(from);

    if (dir == NULL)
    {
        return errno;
    }

    struct dirent* _Opt dp;
    while ((dp = readdir(dir)) != NULL)
    {
        if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
        {
            /* skip self and parent */
            continue;
        }

        char fromlocal[MAX_PATH] = { 0 };
        snprintf(fromlocal, MAX_PATH, "%s/%s", from, dp->d_name);

        char tolocal[MAX_PATH] = { 0 };
        snprintf(tolocal, MAX_PATH, "%s/%s", to, dp->d_name);

        if (dp->d_type & DT_DIR)
        {
            errcode = copy_folder(fromlocal, tolocal);
        }
        else
        {
            errcode = copy_file(fromlocal, tolocal);
        }

        if (errcode != 0)
            break;
    }

    closedir(dir);
    return errcode;
#else
    return -1;
#endif
}

#ifdef _WIN32
int get_self_path(char* buffer, int maxsize)
{

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"

    DWORD r = GetModuleFileNameA(NULL, buffer, maxsize);

#pragma CAKE diagnostic pop

    return r;
}

#else

int get_self_path(char* buffer, int maxsize)
{

    memset(buffer, 0, maxsize); // readlink does not null terminate!
    if (readlink("/proc/self/exe", buffer, maxsize) == -1)
    {
        //perror("readlink");
        return 1;
    }
    else
    {
        //printf("%s\n", dest);
    }
    return 0;

}

#endif




#if !defined __EMSCRIPTEN__

/* Find the last occurrence of c1 or c2 in s. */
char* _Opt strrchr_ex(const char* s, int c1, int c2)
{
    const char* _Opt last = NULL;
    const char* p = s;
    while (*p)
    {
        if (*p == c1 || *p == c2)
        {
            last = p;
        }
        p++;
    }
    return (char*)last;
}

char* basename(const char* filename)
{
    char* _Opt p = strrchr_ex(filename, '/', '\\'); //added \ to windows path
    return p ? p + 1 : (char*)filename;
}

char* dirname(char* path)
{
    int last = -1;
    for (int i = 0; path[i]; i++)
    {
        if (path[i] == '\\' || path[i] == '/')
            last = i;
    }

    if (last != -1)
    {
        path[last] = 0;
    }
    else
    {
        path[0] = 0;
    }
    return path;
}
#endif

#ifndef MOCKFILES

char* _Owner _Opt read_file(const char* const path, bool append_newline)
{
    char* _Owner _Opt data = NULL;
    FILE* _Owner _Opt file = NULL;
    struct stat info = { 0 };

    if (stat(path, &info) != 0)
        return NULL;

    int mem_size_bytes = sizeof(char) * info.st_size + 1 /* \0 */ + 1 /*newline*/;
    
    if (mem_size_bytes < 4)
    {
        //we always read 3 chars even if file is small
        mem_size_bytes = 4; //BOM + /0
    }

    data = malloc(mem_size_bytes);
    if (data == NULL)
        return NULL;

    file = fopen(path, "r");
    if (file == NULL)
    {
        free(data);
        return NULL;
    }

    /* first we read 3 bytes */
    size_t bytes_read = fread(data, 1, 3, file);

    if (bytes_read < 3)
    {
        /* we have less than 3 bytes - no BOM */

        data[bytes_read] = '\0';
        if (feof(file))
        {
            fclose(file);
            return data;
        }

        free(data);
        fclose(file);

        return NULL;
    }

    size_t bytes_read_part2 = 0;

    /* check byte order mark (BOM) */
    if ((unsigned char)data[0] == (unsigned char)0xEF &&
        (unsigned char)data[1] == (unsigned char)0xBB &&
        (unsigned char)data[2] == (unsigned char)0xBF)
    {
        /* in this case we skip this BOM, reading again*/
        bytes_read_part2 = fread(&data[0], 1, info.st_size - 3, file);
    }
    else
    {
        bytes_read_part2 = fread(&data[3], 1, info.st_size - 3, file);
        bytes_read_part2 = bytes_read_part2 + 3;
    }

    data[bytes_read_part2] = 0;
    if (append_newline && data[bytes_read_part2 - 1] != '\n')
    {
        /*
        A source file that is not empty shall end in a new-line character, which shall not 
        be immediately preceded by a backslash character before any such splicing takes place.
        */
        data[bytes_read_part2] = '\n';

        //we already allocated an extra char for this
        assert(bytes_read_part2+1 < mem_size_bytes);
        data[bytes_read_part2+1] = '\0'; 
    }

    fclose(file);
    return data;
}

#else

/*
   used in web build
   embeded standard headers from .\include\
   the tool embed creates the .include version of each file
   in .\include\
*/

static const char file_assert_h[] = {



47,42,13,10,32,42,32,32,84,104,105,115,32,102,105,108,101,32,105,115,32,112,97,114,116
,32,111,102,32,99,97,107,101,32,99,111,109,112,105,108,101,114,13,10,32,42,32,32,104,116
,116,112,115,58,47,47,103,105,116,104,117,98,46,99,111,109,47,116,104,114,97,100,97,109,115
,47,99,97,107,101,13,10,42,47,32,13,10,13,10,35,105,102,100,101,102,32,78,68,69,66
,85,71,13,10,35,100,101,102,105,110,101,32,97,115,115,101,114,116,40,46,46,46,41,32,40
,40,118,111,105,100,41,48,41,13,10,35,101,108,115,101,13,10,35,100,101,102,105,110,101,32
,97,115,115,101,114,116,40,46,46,46,41,32,97,115,115,101,114,116,40,95,95,86,65,95,65
,82,71,83,95,95,41,13,10,35,101,110,100,105,102,13,10
};

static const char file_stdio_h[] = {



47,42,13,10,32,42,32,32,84,104,105,115,32,102,105,108,101,32,105,115,32,112,97,114,116
,32,111,102,32,99,97,107,101,32,99,111,109,112,105,108,101,114,13,10,32,42,32,32,104,116
,116,112,115,58,47,47,103,105,116,104,117,98,46,99,111,109,47,116,104,114,97,100,97,109,115
,47,99,97,107,101,13,10,42,47,13,10,13,10,35,112,114,97,103,109,97,32,111,110,99,101
,13,10,35,100,101,102,105,110,101,32,95,73,79,70,66,70,32,48,120,48,48,48,48,13,10
,35,100,101,102,105,110,101,32,95,73,79,76,66,70,32,48,120,48,48,52,48,13,10,35,100
,101,102,105,110,101,32,95,73,79,78,66,70,32,48,120,48,48,48,52,13,10,13,10,35,100
,101,102,105,110,101,32,66,85,70,83,73,90,32,32,53,49,50,13,10,13,10,35,100,101,102
,105,110,101,32,69,79,70,32,32,32,32,40,45,49,41,13,10,13,10,35,100,101,102,105,110
,101,32,70,73,76,69,78,65,77,69,95,77,65,88,32,32,32,32,50,54,48,13,10,35,100
,101,102,105,110,101,32,70,79,80,69,78,95,77,65,88,32,32,32,32,32,32,32,50,48,13
,10,13,10,35,100,101,102,105,110,101,32,76,95,116,109,112,110,97,109,32,32,32,50,54,48
,32,47,47,32,95,77,65,88,95,80,65,84,72,13,10,13,10,47,42,32,83,101,101,107,32
,109,101,116,104,111,100,32,99,111,110,115,116,97,110,116,115,32,42,47,13,10,13,10,35,100
,101,102,105,110,101,32,83,69,69,75,95,67,85,82,32,32,32,32,49,13,10,35,100,101,102
,105,110,101,32,83,69,69,75,95,69,78,68,32,32,32,32,50,13,10,35,100,101,102,105,110
,101,32,83,69,69,75,95,83,69,84,32,32,32,32,48,13,10,13,10,13,10,35,100,101,102
,105,110,101,32,84,77,80,95,77,65,88,32,32,32,32,32,32,32,32,32,50,49,52,55,52
,56,51,54,52,55,13,10,13,10,13,10,13,10,116,121,112,101,100,101,102,32,108,111,110,103
,32,108,111,110,103,32,102,112,111,115,95,116,59,13,10,116,121,112,101,100,101,102,32,105,110
,116,32,70,73,76,69,59,13,10,13,10,101,120,116,101,114,110,32,70,73,76,69,42,32,115
,116,100,105,110,59,13,10,101,120,116,101,114,110,32,70,73,76,69,42,32,115,116,100,111,117
,116,59,13,10,101,120,116,101,114,110,32,70,73,76,69,42,32,115,116,100,101,114,114,59,13
,10,13,10,116,121,112,101,100,101,102,32,117,110,115,105,103,110,101,100,32,108,111,110,103,32
,115,105,122,101,95,116,59,13,10,116,121,112,101,100,101,102,32,118,111,105,100,42,32,118,97
,95,108,105,115,116,59,13,10,105,110,116,32,114,101,109,111,118,101,40,99,111,110,115,116,32
,99,104,97,114,42,32,102,105,108,101,110,97,109,101,41,59,13,10,105,110,116,32,114,101,110
,97,109,101,40,99,111,110,115,116,32,99,104,97,114,42,32,111,108,100,44,32,99,111,110,115
,116,32,99,104,97,114,42,32,110,101,119,115,41,59,13,10,70,73,76,69,42,32,95,79,112
,116,32,116,109,112,102,105,108,101,40,118,111,105,100,41,59,13,10,99,104,97,114,42,32,116
,109,112,110,97,109,40,99,104,97,114,42,32,115,41,59,13,10,35,105,102,32,100,101,102,105
,110,101,100,40,95,95,83,84,68,67,95,79,87,78,69,82,83,72,73,80,95,95,41,32,13
,10,105,110,116,32,102,99,108,111,115,101,40,70,73,76,69,42,32,95,79,119,110,101,114,32
,115,116,114,101,97,109,41,59,13,10,35,101,108,115,101,13,10,105,110,116,32,102,99,108,111
,115,101,40,70,73,76,69,42,32,115,116,114,101,97,109,41,59,13,10,35,101,110,100,105,102
,13,10,105,110,116,32,102,102,108,117,115,104,40,70,73,76,69,42,32,115,116,114,101,97,109
,41,59,13,10,35,105,102,32,100,101,102,105,110,101,100,40,95,95,83,84,68,67,95,79,87
,78,69,82,83,72,73,80,95,95,41,32,13,10,70,73,76,69,42,32,95,79,119,110,101,114
,32,95,79,112,116,32,102,111,112,101,110,40,99,111,110,115,116,32,99,104,97,114,42,32,114
,101,115,116,114,105,99,116,32,102,105,108,101,110,97,109,101,44,32,99,111,110,115,116,32,99
,104,97,114,42,32,114,101,115,116,114,105,99,116,32,109,111,100,101,41,59,13,10,70,73,76
,69,42,32,95,79,119,110,101,114,32,95,79,112,116,32,102,114,101,111,112,101,110,40,99,111
,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32,102,105,108,101,110,97
,109,101,44,32,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32
,109,111,100,101,44,32,70,73,76,69,42,32,114,101,115,116,114,105,99,116,32,115,116,114,101
,97,109,41,59,13,10,35,101,108,115,101,13,10,70,73,76,69,42,32,102,111,112,101,110,40
,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32,102,105,108,101
,110,97,109,101,44,32,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99
,116,32,109,111,100,101,41,59,13,10,70,73,76,69,42,32,102,114,101,111,112,101,110,40,99
,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32,102,105,108,101,110
,97,109,101,44,32,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116
,32,109,111,100,101,44,32,70,73,76,69,42,32,114,101,115,116,114,105,99,116,32,115,116,114
,101,97,109,41,59,13,10,35,101,110,100,105,102,13,10,118,111,105,100,32,115,101,116,98,117
,102,40,70,73,76,69,42,32,114,101,115,116,114,105,99,116,32,115,116,114,101,97,109,44,32
,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32,98,117,102,41,59,13,10,105,110,116
,32,115,101,116,118,98,117,102,40,70,73,76,69,42,32,114,101,115,116,114,105,99,116,32,115
,116,114,101,97,109,44,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32,98,117,102
,44,32,105,110,116,32,109,111,100,101,44,32,115,105,122,101,95,116,32,115,105,122,101,41,59
,13,10,105,110,116,32,102,112,114,105,110,116,102,40,70,73,76,69,42,32,114,101,115,116,114
,105,99,116,32,115,116,114,101,97,109,44,32,99,111,110,115,116,32,99,104,97,114,42,32,114
,101,115,116,114,105,99,116,32,102,111,114,109,97,116,44,32,46,46,46,41,59,13,10,105,110
,116,32,102,115,99,97,110,102,40,70,73,76,69,42,32,114,101,115,116,114,105,99,116,32,115
,116,114,101,97,109,44,32,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105
,99,116,32,102,111,114,109,97,116,44,32,46,46,46,41,59,13,10,105,110,116,32,112,114,105
,110,116,102,40,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32
,102,111,114,109,97,116,44,32,46,46,46,41,59,13,10,105,110,116,32,115,99,97,110,102,40
,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32,102,111,114,109
,97,116,44,32,46,46,46,41,59,13,10,105,110,116,32,115,110,112,114,105,110,116,102,40,99
,104,97,114,42,32,114,101,115,116,114,105,99,116,32,115,44,32,115,105,122,101,95,116,32,110
,44,32,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32,102,111
,114,109,97,116,44,32,46,46,46,41,59,13,10,105,110,116,32,115,112,114,105,110,116,102,40
,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32,115,44,32,99,111,110,115,116,32,99
,104,97,114,42,32,114,101,115,116,114,105,99,116,32,102,111,114,109,97,116,44,32,46,46,46
,41,59,13,10,105,110,116,32,115,115,99,97,110,102,40,99,111,110,115,116,32,99,104,97,114
,42,32,114,101,115,116,114,105,99,116,32,115,44,32,99,111,110,115,116,32,99,104,97,114,42
,32,114,101,115,116,114,105,99,116,32,102,111,114,109,97,116,44,32,46,46,46,41,59,13,10
,105,110,116,32,118,102,112,114,105,110,116,102,40,70,73,76,69,42,32,114,101,115,116,114,105
,99,116,32,115,116,114,101,97,109,44,32,99,111,110,115,116,32,99,104,97,114,42,32,114,101
,115,116,114,105,99,116,32,102,111,114,109,97,116,44,32,118,97,95,108,105,115,116,32,97,114
,103,41,59,13,10,105,110,116,32,118,102,115,99,97,110,102,40,70,73,76,69,42,32,114,101
,115,116,114,105,99,116,32,115,116,114,101,97,109,44,32,99,111,110,115,116,32,99,104,97,114
,42,32,114,101,115,116,114,105,99,116,32,102,111,114,109,97,116,44,32,118,97,95,108,105,115
,116,32,97,114,103,41,59,13,10,105,110,116,32,118,112,114,105,110,116,102,40,99,111,110,115
,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32,102,111,114,109,97,116,44,32
,118,97,95,108,105,115,116,32,97,114,103,41,59,13,10,105,110,116,32,118,115,99,97,110,102
,40,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32,102,111,114
,109,97,116,44,32,118,97,95,108,105,115,116,32,97,114,103,41,59,13,10,105,110,116,32,112
,117,116,115,40,99,111,110,115,116,32,99,104,97,114,42,32,115,116,114,41,59,13,10,105,110
,116,32,102,112,117,116,115,40,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114
,105,99,116,32,115,44,32,70,73,76,69,42,32,114,101,115,116,114,105,99,116,32,115,116,114
,101,97,109,41,59,13,10,105,110,116,32,103,101,116,99,40,70,73,76,69,42,32,115,116,114
,101,97,109,41,59,13,10,105,110,116,32,103,101,116,99,104,97,114,40,118,111,105,100,41,59
,13,10,105,110,116,32,112,117,116,99,40,105,110,116,32,99,44,32,70,73,76,69,42,32,115
,116,114,101,97,109,41,59,13,10,105,110,116,32,112,117,116,99,104,97,114,40,105,110,116,32
,99,41,59,13,10,105,110,116,32,112,117,116,115,40,99,111,110,115,116,32,99,104,97,114,42
,32,115,41,59,13,10,105,110,116,32,117,110,103,101,116,99,40,105,110,116,32,99,44,32,70
,73,76,69,42,32,115,116,114,101,97,109,41,59,13,10,105,110,116,32,102,103,101,116,99,40
,70,73,76,69,42,32,115,116,114,101,97,109,41,59,13,10,115,105,122,101,95,116,32,102,114
,101,97,100,40,118,111,105,100,42,32,114,101,115,116,114,105,99,116,32,112,116,114,44,32,115
,105,122,101,95,116,32,115,105,122,101,44,32,115,105,122,101,95,116,32,110,109,101,109,98,44
,32,70,73,76,69,42,32,114,101,115,116,114,105,99,116,32,115,116,114,101,97,109,41,59,13
,10,115,105,122,101,95,116,32,102,119,114,105,116,101,40,99,111,110,115,116,32,118,111,105,100
,42,32,114,101,115,116,114,105,99,116,32,112,116,114,44,32,115,105,122,101,95,116,32,115,105
,122,101,44,32,115,105,122,101,95,116,32,110,109,101,109,98,44,32,70,73,76,69,42,32,114
,101,115,116,114,105,99,116,32,115,116,114,101,97,109,41,59,13,10,105,110,116,32,102,103,101
,116,112,111,115,40,70,73,76,69,42,32,114,101,115,116,114,105,99,116,32,115,116,114,101,97
,109,44,32,102,112,111,115,95,116,42,32,114,101,115,116,114,105,99,116,32,112,111,115,41,59
,13,10,105,110,116,32,102,115,101,101,107,40,70,73,76,69,42,32,115,116,114,101,97,109,44
,32,108,111,110,103,32,105,110,116,32,111,102,102,115,101,116,44,32,105,110,116,32,119,104,101
,110,99,101,41,59,13,10,105,110,116,32,102,115,101,116,112,111,115,40,70,73,76,69,42,32
,115,116,114,101,97,109,44,32,99,111,110,115,116,32,102,112,111,115,95,116,42,32,112,111,115
,41,59,13,10,108,111,110,103,32,105,110,116,32,102,116,101,108,108,40,70,73,76,69,42,32
,115,116,114,101,97,109,41,59,13,10,118,111,105,100,32,114,101,119,105,110,100,40,70,73,76
,69,42,32,115,116,114,101,97,109,41,59,13,10,118,111,105,100,32,99,108,101,97,114,101,114
,114,40,70,73,76,69,42,32,115,116,114,101,97,109,41,59,13,10,105,110,116,32,102,101,111
,102,40,70,73,76,69,42,32,115,116,114,101,97,109,41,59,13,10,105,110,116,32,102,101,114
,114,111,114,40,70,73,76,69,42,32,115,116,114,101,97,109,41,59,13,10,118,111,105,100,32
,112,101,114,114,111,114,40,99,111,110,115,116,32,99,104,97,114,42,32,115,41,59,13,10,13
,10,13,10,13,10,35,105,102,110,100,101,102,32,78,85,76,76,13,10,35,100,101,102,105,110
,101,32,78,85,76,76,32,40,40,118,111,105,100,42,41,48,41,13,10,35,101,110,100,105,102
,13,10
};

static const char file_errno_h[] = {



47,42,13,10,32,42,32,32,84,104,105,115,32,102,105,108,101,32,105,115,32,112,97,114,116
,32,111,102,32,99,97,107,101,32,99,111,109,112,105,108,101,114,13,10,32,42,32,32,104,116
,116,112,115,58,47,47,103,105,116,104,117,98,46,99,111,109,47,116,104,114,97,100,97,109,115
,47,99,97,107,101,13,10,42,47,13,10,13,10,35,112,114,97,103,109,97,32,111,110,99,101
,13,10,13,10,105,110,116,42,32,95,101,114,114,110,111,40,118,111,105,100,41,59,13,10,35
,100,101,102,105,110,101,32,101,114,114,110,111,32,40,42,95,101,114,114,110,111,40,41,41,13
,10,32,13,10,13,10,35,100,101,102,105,110,101,32,69,80,69,82,77,32,32,32,32,32,32
,32,32,32,32,32,49,13,10,35,100,101,102,105,110,101,32,69,78,79,69,78,84,32,32,32
,32,32,32,32,32,32,32,50,13,10,35,100,101,102,105,110,101,32,69,83,82,67,72,32,32
,32,32,32,32,32,32,32,32,32,51,13,10,35,100,101,102,105,110,101,32,69,73,78,84,82
,32,32,32,32,32,32,32,32,32,32,32,52,13,10,35,100,101,102,105,110,101,32,69,73,79
,32,32,32,32,32,32,32,32,32,32,32,32,32,53,13,10,35,100,101,102,105,110,101,32,69
,78,88,73,79,32,32,32,32,32,32,32,32,32,32,32,54,13,10,35,100,101,102,105,110,101
,32,69,50,66,73,71,32,32,32,32,32,32,32,32,32,32,32,55,13,10,35,100,101,102,105
,110,101,32,69,78,79,69,88,69,67,32,32,32,32,32,32,32,32,32,56,13,10,35,100,101
,102,105,110,101,32,69,66,65,68,70,32,32,32,32,32,32,32,32,32,32,32,57,13,10,35
,100,101,102,105,110,101,32,69,67,72,73,76,68,32,32,32,32,32,32,32,32,32,32,49,48
,13,10,35,100,101,102,105,110,101,32,69,65,71,65,73,78,32,32,32,32,32,32,32,32,32
,32,49,49,13,10,35,100,101,102,105,110,101,32,69,78,79,77,69,77,32,32,32,32,32,32
,32,32,32,32,49,50,13,10,35,100,101,102,105,110,101,32,69,65,67,67,69,83,32,32,32
,32,32,32,32,32,32,32,49,51,13,10,35,100,101,102,105,110,101,32,69,70,65,85,76,84
,32,32,32,32,32,32,32,32,32,32,49,52,13,10,35,100,101,102,105,110,101,32,69,66,85
,83,89,32,32,32,32,32,32,32,32,32,32,32,49,54,13,10,35,100,101,102,105,110,101,32
,69,69,88,73,83,84,32,32,32,32,32,32,32,32,32,32,49,55,13,10,35,100,101,102,105
,110,101,32,69,88,68,69,86,32,32,32,32,32,32,32,32,32,32,32,49,56,13,10,35,100
,101,102,105,110,101,32,69,78,79,68,69,86,32,32,32,32,32,32,32,32,32,32,49,57,13
,10,35,100,101,102,105,110,101,32,69,78,79,84,68,73,82,32,32,32,32,32,32,32,32,32
,50,48,13,10,35,100,101,102,105,110,101,32,69,73,83,68,73,82,32,32,32,32,32,32,32
,32,32,32,50,49,13,10,35,100,101,102,105,110,101,32,69,78,70,73,76,69,32,32,32,32
,32,32,32,32,32,32,50,51,13,10,35,100,101,102,105,110,101,32,69,77,70,73,76,69,32
,32,32,32,32,32,32,32,32,32,50,52,13,10,35,100,101,102,105,110,101,32,69,78,79,84
,84,89,32,32,32,32,32,32,32,32,32,32,50,53,13,10,35,100,101,102,105,110,101,32,69
,70,66,73,71,32,32,32,32,32,32,32,32,32,32,32,50,55,13,10,35,100,101,102,105,110
,101,32,69,78,79,83,80,67,32,32,32,32,32,32,32,32,32,32,50,56,13,10,35,100,101
,102,105,110,101,32,69,83,80,73,80,69,32,32,32,32,32,32,32,32,32,32,50,57,13,10
,35,100,101,102,105,110,101,32,69,82,79,70,83,32,32,32,32,32,32,32,32,32,32,32,51
,48,13,10,35,100,101,102,105,110,101,32,69,77,76,73,78,75,32,32,32,32,32,32,32,32
,32,32,51,49,13,10,35,100,101,102,105,110,101,32,69,80,73,80,69,32,32,32,32,32,32
,32,32,32,32,32,51,50,13,10,35,100,101,102,105,110,101,32,69,68,79,77,32,32,32,32
,32,32,32,32,32,32,32,32,51,51,13,10,35,100,101,102,105,110,101,32,69,68,69,65,68
,76,75,32,32,32,32,32,32,32,32,32,51,54,13,10,35,100,101,102,105,110,101,32,69,78
,65,77,69,84,79,79,76,79,78,71,32,32,32,32,51,56,13,10,35,100,101,102,105,110,101
,32,69,78,79,76,67,75,32,32,32,32,32,32,32,32,32,32,51,57,13,10,35,100,101,102
,105,110,101,32,69,78,79,83,89,83,32,32,32,32,32,32,32,32,32,32,52,48,13,10,35
,100,101,102,105,110,101,32,69,78,79,84,69,77,80,84,89,32,32,32,32,32,32,32,52,49
,13,10,13,10,13,10,47,47,32,83,117,112,112,111,114,116,32,69,68,69,65,68,76,79,67
,75,32,102,111,114,32,99,111,109,112,97,116,105,98,105,108,105,116,121,32,119,105,116,104,32
,111,108,100,101,114,32,77,105,99,114,111,115,111,102,116,32,67,32,118,101,114,115,105,111,110
,115,13,10,35,100,101,102,105,110,101,32,69,68,69,65,68,76,79,67,75,32,32,32,32,32
,32,32,69,68,69,65,68,76,75,13,10,13,10,35,100,101,102,105,110,101,32,69,65,68,68
,82,73,78,85,83,69,32,32,32,32,32,32,49,48,48,13,10,35,100,101,102,105,110,101,32
,69,65,68,68,82,78,79,84,65,86,65,73,76,32,32,32,49,48,49,13,10,35,100,101,102
,105,110,101,32,69,65,70,78,79,83,85,80,80,79,82,84,32,32,32,32,49,48,50,13,10
,35,100,101,102,105,110,101,32,69,65,76,82,69,65,68,89,32,32,32,32,32,32,32,32,49
,48,51,13,10,35,100,101,102,105,110,101,32,69,66,65,68,77,83,71,32,32,32,32,32,32
,32,32,32,49,48,52,13,10,35,100,101,102,105,110,101,32,69,67,65,78,67,69,76,69,68
,32,32,32,32,32,32,32,49,48,53,13,10,35,100,101,102,105,110,101,32,69,67,79,78,78
,65,66,79,82,84,69,68,32,32,32,32,49,48,54,13,10,35,100,101,102,105,110,101,32,69
,67,79,78,78,82,69,70,85,83,69,68,32,32,32,32,49,48,55,13,10,35,100,101,102,105
,110,101,32,69,67,79,78,78,82,69,83,69,84,32,32,32,32,32,32,49,48,56,13,10,35
,100,101,102,105,110,101,32,69,68,69,83,84,65,68,68,82,82,69,81,32,32,32,32,49,48
,57,13,10,35,100,101,102,105,110,101,32,69,72,79,83,84,85,78,82,69,65,67,72,32,32
,32,32,49,49,48,13,10,35,100,101,102,105,110,101,32,69,73,68,82,77,32,32,32,32,32
,32,32,32,32,32,32,49,49,49,13,10,35,100,101,102,105,110,101,32,69,73,78,80,82,79
,71,82,69,83,83,32,32,32,32,32,49,49,50,13,10,35,100,101,102,105,110,101,32,69,73
,83,67,79,78,78,32,32,32,32,32,32,32,32,32,49,49,51,13,10,35,100,101,102,105,110
,101,32,69,76,79,79,80,32,32,32,32,32,32,32,32,32,32,32,49,49,52,13,10,35,100
,101,102,105,110,101,32,69,77,83,71,83,73,90,69,32,32,32,32,32,32,32,32,49,49,53
,13,10,35,100,101,102,105,110,101,32,69,78,69,84,68,79,87,78,32,32,32,32,32,32,32
,32,49,49,54,13,10,35,100,101,102,105,110,101,32,69,78,69,84,82,69,83,69,84,32,32
,32,32,32,32,32,49,49,55,13,10,35,100,101,102,105,110,101,32,69,78,69,84,85,78,82
,69,65,67,72,32,32,32,32,32,49,49,56,13,10,35,100,101,102,105,110,101,32,69,78,79
,66,85,70,83,32,32,32,32,32,32,32,32,32,49,49,57,13,10,35,100,101,102,105,110,101
,32,69,78,79,68,65,84,65,32,32,32,32,32,32,32,32,32,49,50,48,13,10,35,100,101
,102,105,110,101,32,69,78,79,76,73,78,75,32,32,32,32,32,32,32,32,32,49,50,49,13
,10,35,100,101,102,105,110,101,32,69,78,79,77,83,71,32,32,32,32,32,32,32,32,32,32
,49,50,50,13,10,35,100,101,102,105,110,101,32,69,78,79,80,82,79,84,79,79,80,84,32
,32,32,32,32,49,50,51,13,10,35,100,101,102,105,110,101,32,69,78,79,83,82,32,32,32
,32,32,32,32,32,32,32,32,49,50,52,13,10,35,100,101,102,105,110,101,32,69,78,79,83
,84,82,32,32,32,32,32,32,32,32,32,32,49,50,53,13,10,35,100,101,102,105,110,101,32
,69,78,79,84,67,79,78,78,32,32,32,32,32,32,32,32,49,50,54,13,10,35,100,101,102
,105,110,101,32,69,78,79,84,82,69,67,79,86,69,82,65,66,76,69,32,49,50,55,13,10
,35,100,101,102,105,110,101,32,69,78,79,84,83,79,67,75,32,32,32,32,32,32,32,32,49
,50,56,13,10,35,100,101,102,105,110,101,32,69,78,79,84,83,85,80,32,32,32,32,32,32
,32,32,32,49,50,57,13,10,35,100,101,102,105,110,101,32,69,79,80,78,79,84,83,85,80
,80,32,32,32,32,32,32,49,51,48,13,10,35,100,101,102,105,110,101,32,69,79,84,72,69
,82,32,32,32,32,32,32,32,32,32,32,49,51,49,13,10,35,100,101,102,105,110,101,32,69
,79,86,69,82,70,76,79,87,32,32,32,32,32,32,32,49,51,50,13,10,35,100,101,102,105
,110,101,32,69,79,87,78,69,82,68,69,65,68,32,32,32,32,32,32,49,51,51,13,10,35
,100,101,102,105,110,101,32,69,80,82,79,84,79,32,32,32,32,32,32,32,32,32,32,49,51
,52,13,10,35,100,101,102,105,110,101,32,69,80,82,79,84,79,78,79,83,85,80,80,79,82
,84,32,49,51,53,13,10,35,100,101,102,105,110,101,32,69,80,82,79,84,79,84,89,80,69
,32,32,32,32,32,32,49,51,54,13,10,35,100,101,102,105,110,101,32,69,84,73,77,69,32
,32,32,32,32,32,32,32,32,32,32,49,51,55,13,10,35,100,101,102,105,110,101,32,69,84
,73,77,69,68,79,85,84,32,32,32,32,32,32,32,49,51,56,13,10,35,100,101,102,105,110
,101,32,69,84,88,84,66,83,89,32,32,32,32,32,32,32,32,32,49,51,57,13,10,35,100
,101,102,105,110,101,32,69,87,79,85,76,68,66,76,79,67,75,32,32,32,32,32,49,52,48
,13,10,13,10
};

static const char file_string_h[] = {



32,13,10,116,121,112,101,100,101,102,32,105,110,116,32,101,114,114,110,111,95,116,59,13,10
,116,121,112,101,100,101,102,32,117,110,115,105,103,110,101,100,32,108,111,110,103,32,115,105,122
,101,95,116,59,13,10,116,121,112,101,100,101,102,32,117,110,115,105,103,110,101,100,32,108,111
,110,103,32,114,115,105,122,101,95,116,59,13,10,116,121,112,101,100,101,102,32,105,110,116,32
,119,99,104,97,114,95,116,59,13,10,118,111,105,100,42,32,109,101,109,99,104,114,40,118,111
,105,100,32,99,111,110,115,116,42,32,95,66,117,102,44,32,105,110,116,32,95,86,97,108,44
,32,115,105,122,101,95,116,32,95,77,97,120,67,111,117,110,116,41,59,13,10,105,110,116,32
,109,101,109,99,109,112,40,118,111,105,100,32,99,111,110,115,116,42,32,95,66,117,102,49,44
,32,118,111,105,100,32,99,111,110,115,116,42,32,95,66,117,102,50,44,32,115,105,122,101,95
,116,32,95,83,105,122,101,41,59,13,10,118,111,105,100,42,32,109,101,109,99,112,121,40,118
,111,105,100,42,32,95,68,115,116,44,32,118,111,105,100,32,99,111,110,115,116,42,32,95,83
,114,99,44,32,115,105,122,101,95,116,32,95,83,105,122,101,41,59,13,10,118,111,105,100,42
,32,109,101,109,109,111,118,101,40,118,111,105,100,42,32,95,68,115,116,44,32,118,111,105,100
,32,99,111,110,115,116,42,32,95,83,114,99,44,32,115,105,122,101,95,116,32,95,83,105,122
,101,41,59,13,10,118,111,105,100,42,32,109,101,109,115,101,116,40,118,111,105,100,42,32,95
,68,115,116,44,32,105,110,116,32,95,86,97,108,44,32,115,105,122,101,95,116,32,95,83,105
,122,101,41,59,13,10,99,104,97,114,42,32,115,116,114,99,104,114,40,99,104,97,114,32,99
,111,110,115,116,42,32,95,83,116,114,44,32,105,110,116,32,95,86,97,108,41,59,13,10,99
,104,97,114,32,42,115,116,114,99,112,121,40,95,67,116,111,114,32,99,104,97,114,32,42,114
,101,115,116,114,105,99,116,32,100,101,115,116,44,32,99,111,110,115,116,32,99,104,97,114,32
,42,114,101,115,116,114,105,99,116,32,115,114,99,32,41,59,13,10,99,104,97,114,42,32,115
,116,114,114,99,104,114,40,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,44,32
,105,110,116,32,95,67,104,41,59,13,10,99,104,97,114,42,32,115,116,114,115,116,114,40,99
,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,44,32,99,104,97,114,32,99,111,110
,115,116,42,32,95,83,117,98,83,116,114,41,59,13,10,119,99,104,97,114,95,116,42,32,119
,99,115,99,104,114,40,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,116,114
,44,32,119,99,104,97,114,95,116,32,95,67,104,41,59,13,10,119,99,104,97,114,95,116,42
,32,119,99,115,114,99,104,114,40,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95
,83,116,114,44,32,119,99,104,97,114,95,116,32,95,67,104,41,59,13,10,119,99,104,97,114
,95,116,42,32,119,99,115,115,116,114,40,119,99,104,97,114,95,116,32,99,111,110,115,116,42
,32,95,83,116,114,44,32,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,117
,98,83,116,114,41,59,13,10,115,116,97,116,105,99,32,105,110,108,105,110,101,32,101,114,114
,110,111,95,116,32,109,101,109,99,112,121,95,115,40,118,111,105,100,42,32,99,111,110,115,116
,32,95,68,101,115,116,105,110,97,116,105,111,110,44,32,114,115,105,122,101,95,116,32,99,111
,110,115,116,32,95,68,101,115,116,105,110,97,116,105,111,110,83,105,122,101,44,32,118,111,105
,100,32,99,111,110,115,116,42,32,99,111,110,115,116,32,95,83,111,117,114,99,101,44,32,114
,115,105,122,101,95,116,32,99,111,110,115,116,32,95,83,111,117,114,99,101,83,105,122,101,41
,59,13,10,115,116,97,116,105,99,32,105,110,108,105,110,101,32,101,114,114,110,111,95,116,32
,109,101,109,109,111,118,101,95,115,40,118,111,105,100,42,32,99,111,110,115,116,32,95,68,101
,115,116,105,110,97,116,105,111,110,44,32,114,115,105,122,101,95,116,32,99,111,110,115,116,32
,95,68,101,115,116,105,110,97,116,105,111,110,83,105,122,101,44,32,118,111,105,100,32,99,111
,110,115,116,42,32,99,111,110,115,116,32,95,83,111,117,114,99,101,44,32,114,115,105,122,101
,95,116,32,99,111,110,115,116,32,95,83,111,117,114,99,101,83,105,122,101,41,59,13,10,105
,110,116,32,95,109,101,109,105,99,109,112,40,118,111,105,100,32,99,111,110,115,116,42,32,95
,66,117,102,49,44,32,118,111,105,100,32,99,111,110,115,116,42,32,95,66,117,102,50,44,32
,115,105,122,101,95,116,32,95,83,105,122,101,41,59,13,10,118,111,105,100,42,32,109,101,109
,99,99,112,121,40,118,111,105,100,42,32,95,68,115,116,44,32,118,111,105,100,32,99,111,110
,115,116,42,32,95,83,114,99,44,32,105,110,116,32,95,86,97,108,44,32,115,105,122,101,95
,116,32,95,83,105,122,101,41,59,13,10,105,110,116,32,109,101,109,105,99,109,112,40,118,111
,105,100,32,99,111,110,115,116,42,32,95,66,117,102,49,44,32,118,111,105,100,32,99,111,110
,115,116,42,32,95,66,117,102,50,44,32,115,105,122,101,95,116,32,95,83,105,122,101,41,59
,13,10,101,114,114,110,111,95,116,32,119,99,115,99,97,116,95,115,40,119,99,104,97,114,95
,116,42,32,95,68,101,115,116,105,110,97,116,105,111,110,44,32,114,115,105,122,101,95,116,32
,95,83,105,122,101,73,110,87,111,114,100,115,44,32,119,99,104,97,114,95,116,32,99,111,110
,115,116,42,32,95,83,111,117,114,99,101,41,59,13,10,101,114,114,110,111,95,116,32,119,99
,115,99,112,121,95,115,40,119,99,104,97,114,95,116,42,32,95,68,101,115,116,105,110,97,116
,105,111,110,44,32,114,115,105,122,101,95,116,32,95,83,105,122,101,73,110,87,111,114,100,115
,44,32,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,111,117,114,99,101,41
,59,13,10,101,114,114,110,111,95,116,32,119,99,115,110,99,97,116,95,115,40,119,99,104,97
,114,95,116,42,32,95,68,101,115,116,105,110,97,116,105,111,110,44,32,114,115,105,122,101,95
,116,32,95,83,105,122,101,73,110,87,111,114,100,115,44,32,119,99,104,97,114,95,116,32,99
,111,110,115,116,42,32,95,83,111,117,114,99,101,44,32,114,115,105,122,101,95,116,32,95,77
,97,120,67,111,117,110,116,41,59,13,10,101,114,114,110,111,95,116,32,119,99,115,110,99,112
,121,95,115,40,119,99,104,97,114,95,116,42,32,95,68,101,115,116,105,110,97,116,105,111,110
,44,32,114,115,105,122,101,95,116,32,95,83,105,122,101,73,110,87,111,114,100,115,44,32,119
,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,111,117,114,99,101,44,32,114,115
,105,122,101,95,116,32,95,77,97,120,67,111,117,110,116,41,59,13,10,119,99,104,97,114,95
,116,42,32,119,99,115,116,111,107,95,115,40,119,99,104,97,114,95,116,42,32,95,83,116,114
,105,110,103,44,32,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,68,101,108,105
,109,105,116,101,114,44,32,119,99,104,97,114,95,116,42,42,32,95,67,111,110,116,101,120,116
,41,59,13,10,119,99,104,97,114,95,116,42,32,95,119,99,115,100,117,112,40,119,99,104,97
,114,95,116,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103,41,59,13,10,119,99,104
,97,114,95,116,42,32,119,99,115,99,97,116,40,119,99,104,97,114,95,116,42,32,95,68,101
,115,116,105,110,97,116,105,111,110,44,32,119,99,104,97,114,95,116,32,99,111,110,115,116,42
,32,95,83,111,117,114,99,101,41,59,32,105,110,116,32,119,99,115,99,109,112,40,119,99,104
,97,114,95,116,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103,49,44,32,119,99,104
,97,114,95,116,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103,50,41,59,13,10,119
,99,104,97,114,95,116,42,32,119,99,115,99,112,121,40,119,99,104,97,114,95,116,42,32,95
,68,101,115,116,105,110,97,116,105,111,110,44,32,119,99,104,97,114,95,116,32,99,111,110,115
,116,42,32,95,83,111,117,114,99,101,41,59,32,115,105,122,101,95,116,32,119,99,115,99,115
,112,110,40,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103
,44,32,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,67,111,110,116,114,111,108
,41,59,13,10,115,105,122,101,95,116,32,119,99,115,108,101,110,40,119,99,104,97,114,95,116
,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103,41,59,13,10,115,105,122,101,95,116
,32,119,99,115,110,108,101,110,40,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95
,83,111,117,114,99,101,44,32,115,105,122,101,95,116,32,95,77,97,120,67,111,117,110,116,41
,59,13,10,115,116,97,116,105,99,32,105,110,108,105,110,101,32,115,105,122,101,95,116,32,119
,99,115,110,108,101,110,95,115,40,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95
,83,111,117,114,99,101,44,32,115,105,122,101,95,116,32,95,77,97,120,67,111,117,110,116,41
,59,13,10,119,99,104,97,114,95,116,42,32,119,99,115,110,99,97,116,40,119,99,104,97,114
,95,116,42,32,95,68,101,115,116,105,110,97,116,105,111,110,44,32,119,99,104,97,114,95,116
,32,99,111,110,115,116,42,32,95,83,111,117,114,99,101,44,32,115,105,122,101,95,116,32,95
,67,111,117,110,116,41,59,13,10,105,110,116,32,119,99,115,110,99,109,112,40,119,99,104,97
,114,95,116,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103,49,44,32,119,99,104,97
,114,95,116,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103,50,44,32,115,105,122,101
,95,116,32,95,77,97,120,67,111,117,110,116,41,59,13,10,119,99,104,97,114,95,116,42,32
,119,99,115,110,99,112,121,40,119,99,104,97,114,95,116,42,32,95,68,101,115,116,105,110,97
,116,105,111,110,44,32,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,111,117
,114,99,101,44,32,115,105,122,101,95,116,32,95,67,111,117,110,116,41,59,13,10,119,99,104
,97,114,95,116,42,32,119,99,115,112,98,114,107,40,119,99,104,97,114,95,116,32,99,111,110
,115,116,42,32,95,83,116,114,105,110,103,44,32,119,99,104,97,114,95,116,32,99,111,110,115
,116,42,32,95,67,111,110,116,114,111,108,41,59,13,10,115,105,122,101,95,116,32,119,99,115
,115,112,110,40,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,116,114,105,110
,103,44,32,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,67,111,110,116,114,111
,108,41,59,13,10,119,99,104,97,114,95,116,42,32,119,99,115,116,111,107,40,119,99,104,97
,114,95,116,42,32,95,83,116,114,105,110,103,44,32,119,99,104,97,114,95,116,32,99,111,110
,115,116,42,32,95,68,101,108,105,109,105,116,101,114,44,32,119,99,104,97,114,95,116,42,42
,32,95,67,111,110,116,101,120,116,41,59,13,10,115,105,122,101,95,116,32,119,99,115,120,102
,114,109,40,119,99,104,97,114,95,116,42,32,95,68,101,115,116,105,110,97,116,105,111,110,44
,32,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,111,117,114,99,101,44,32
,115,105,122,101,95,116,32,95,77,97,120,67,111,117,110,116,41,59,13,10,105,110,116,32,119
,99,115,99,111,108,108,40,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,116
,114,105,110,103,49,44,32,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,116
,114,105,110,103,50,41,59,13,10,119,99,104,97,114,95,116,42,32,119,99,115,100,117,112,40
,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103,41,59,13
,10,105,110,116,32,119,99,115,105,99,109,112,40,119,99,104,97,114,95,116,32,99,111,110,115
,116,42,32,95,83,116,114,105,110,103,49,44,32,119,99,104,97,114,95,116,32,99,111,110,115
,116,42,32,95,83,116,114,105,110,103,50,41,59,13,10,105,110,116,32,119,99,115,110,105,99
,109,112,40,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103
,49,44,32,119,99,104,97,114,95,116,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103
,50,44,32,115,105,122,101,95,116,32,95,77,97,120,67,111,117,110,116,41,59,13,10,119,99
,104,97,114,95,116,42,32,119,99,115,110,115,101,116,40,119,99,104,97,114,95,116,42,32,95
,83,116,114,105,110,103,44,32,119,99,104,97,114,95,116,32,95,86,97,108,117,101,44,32,115
,105,122,101,95,116,32,95,77,97,120,67,111,117,110,116,41,59,13,10,119,99,104,97,114,95
,116,42,32,119,99,115,114,101,118,40,119,99,104,97,114,95,116,42,32,95,83,116,114,105,110
,103,41,59,13,10,119,99,104,97,114,95,116,42,32,119,99,115,115,101,116,40,119,99,104,97
,114,95,116,42,32,95,83,116,114,105,110,103,44,32,119,99,104,97,114,95,116,32,95,86,97
,108,117,101,41,59,13,10,119,99,104,97,114,95,116,42,32,119,99,115,108,119,114,40,119,99
,104,97,114,95,116,42,32,95,83,116,114,105,110,103,41,59,32,119,99,104,97,114,95,116,42
,32,119,99,115,117,112,114,40,119,99,104,97,114,95,116,42,32,95,83,116,114,105,110,103,41
,59,13,10,105,110,116,32,119,99,115,105,99,111,108,108,40,119,99,104,97,114,95,116,32,99
,111,110,115,116,42,32,95,83,116,114,105,110,103,49,44,32,119,99,104,97,114,95,116,32,99
,111,110,115,116,42,32,95,83,116,114,105,110,103,50,41,59,13,10,99,104,97,114,42,32,115
,116,114,116,111,107,95,115,40,99,104,97,114,42,32,95,83,116,114,105,110,103,44,32,99,104
,97,114,32,99,111,110,115,116,42,32,95,68,101,108,105,109,105,116,101,114,44,32,99,104,97
,114,42,42,32,95,67,111,110,116,101,120,116,41,59,13,10,118,111,105,100,42,32,95,109,101
,109,99,99,112,121,40,118,111,105,100,42,32,95,68,115,116,44,32,118,111,105,100,32,99,111
,110,115,116,42,32,95,83,114,99,44,32,105,110,116,32,95,86,97,108,44,32,115,105,122,101
,95,116,32,95,77,97,120,67,111,117,110,116,41,59,13,10,99,104,97,114,42,32,115,116,114
,99,97,116,40,99,104,97,114,42,32,95,68,101,115,116,105,110,97,116,105,111,110,44,32,99
,104,97,114,32,99,111,110,115,116,42,32,95,83,111,117,114,99,101,41,59,13,10,105,110,116
,32,115,116,114,99,109,112,40,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,49
,44,32,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,50,41,59,13,10,105,110
,116,32,115,116,114,99,111,108,108,40,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116
,114,105,110,103,49,44,32,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,105,110
,103,50,41,59,13,10,99,104,97,114,42,32,115,116,114,101,114,114,111,114,40,105,110,116,32
,95,69,114,114,111,114,77,101,115,115,97,103,101,41,59,13,10,115,105,122,101,95,116,32,115
,116,114,108,101,110,40,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,41,59,13
,10,99,104,97,114,42,32,115,116,114,110,99,97,116,40,99,104,97,114,42,32,95,68,101,115
,116,105,110,97,116,105,111,110,44,32,99,104,97,114,32,99,111,110,115,116,42,32,95,83,111
,117,114,99,101,44,32,115,105,122,101,95,116,32,95,67,111,117,110,116,41,59,13,10,105,110
,116,32,115,116,114,110,99,109,112,40,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116
,114,49,44,32,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,50,44,32,115,105
,122,101,95,116,32,95,77,97,120,67,111,117,110,116,41,59,13,10,99,104,97,114,42,32,115
,116,114,110,99,112,121,40,99,104,97,114,42,32,95,68,101,115,116,105,110,97,116,105,111,110
,44,32,99,104,97,114,32,99,111,110,115,116,42,32,95,83,111,117,114,99,101,44,32,115,105
,122,101,95,116,32,95,67,111,117,110,116,41,59,13,10,115,105,122,101,95,116,32,115,116,114
,110,108,101,110,40,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103,44
,32,115,105,122,101,95,116,32,95,77,97,120,67,111,117,110,116,41,59,13,10,115,116,97,116
,105,99,32,105,110,108,105,110,101,32,115,105,122,101,95,116,32,115,116,114,110,108,101,110,95
,115,40,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103,44,32,115,105
,122,101,95,116,32,95,77,97,120,67,111,117,110,116,41,59,13,10,99,104,97,114,42,32,115
,116,114,112,98,114,107,40,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,44,32
,99,104,97,114,32,99,111,110,115,116,42,32,95,67,111,110,116,114,111,108,41,59,13,10,115
,105,122,101,95,116,32,115,116,114,115,112,110,40,99,104,97,114,32,99,111,110,115,116,42,32
,95,83,116,114,44,32,99,104,97,114,32,99,111,110,115,116,42,32,95,67,111,110,116,114,111
,108,41,59,13,10,99,104,97,114,42,32,115,116,114,116,111,107,40,99,104,97,114,42,32,95
,83,116,114,105,110,103,44,32,99,104,97,114,32,99,111,110,115,116,42,32,95,68,101,108,105
,109,105,116,101,114,41,59,13,10,13,10,35,105,102,32,100,101,102,105,110,101,100,40,95,95
,83,84,68,67,95,79,87,78,69,82,83,72,73,80,95,95,41,32,13,10,99,104,97,114,42
,32,95,79,119,110,101,114,32,95,79,112,116,32,115,116,114,100,117,112,40,99,104,97,114,32
,99,111,110,115,116,42,32,95,83,116,114,105,110,103,41,59,13,10,35,101,108,115,101,13,10
,99,104,97,114,42,32,115,116,114,100,117,112,40,99,104,97,114,32,99,111,110,115,116,42,32
,95,83,116,114,105,110,103,41,59,13,10,35,101,110,100,105,102,13,10,13,10,105,110,116,32
,115,116,114,99,109,112,105,40,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,105
,110,103,49,44,32,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103,50
,41,59,13,10,105,110,116,32,115,116,114,105,99,109,112,40,99,104,97,114,32,99,111,110,115
,116,42,32,95,83,116,114,105,110,103,49,44,32,99,104,97,114,32,99,111,110,115,116,42,32
,95,83,116,114,105,110,103,50,41,59,13,10,99,104,97,114,42,32,115,116,114,108,119,114,40
,99,104,97,114,42,32,95,83,116,114,105,110,103,41,59,13,10,105,110,116,32,115,116,114,110
,105,99,109,112,40,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103,49
,44,32,99,104,97,114,32,99,111,110,115,116,42,32,95,83,116,114,105,110,103,50,44,32,115
,105,122,101,95,116,32,95,77,97,120,67,111,117,110,116,41,59,13,10,99,104,97,114,42,32
,115,116,114,110,115,101,116,40,99,104,97,114,42,32,95,83,116,114,105,110,103,44,32,105,110
,116,32,95,86,97,108,117,101,44,32,115,105,122,101,95,116,32,95,77,97,120,67,111,117,110
,116,41,59,13,10,99,104,97,114,42,32,115,116,114,114,101,118,40,99,104,97,114,42,32,95
,83,116,114,105,110,103,41,59,13,10,99,104,97,114,42,32,115,116,114,115,101,116,40,99,104
,97,114,42,32,95,83,116,114,105,110,103,44,32,105,110,116,32,95,86,97,108,117,101,41,59
,32,99,104,97,114,42,32,115,116,114,117,112,114,40,99,104,97,114,42,32,95,83,116,114,105
,110,103,41,59
};

static const char file_math_h[] = {



47,42,13,10,32,42,32,32,84,104,105,115,32,102,105,108,101,32,105,115,32,112,97,114,116
,32,111,102,32,99,97,107,101,32,99,111,109,112,105,108,101,114,13,10,32,42,32,32,104,116
,116,112,115,58,47,47,103,105,116,104,117,98,46,99,111,109,47,116,104,114,97,100,97,109,115
,47,99,97,107,101,13,10,42,47,13,10,13,10,35,112,114,97,103,109,97,32,111,110,99,101
,13,10,13,10,100,111,117,98,108,101,32,97,99,111,115,40,100,111,117,98,108,101,32,95,95
,120,41,59,13,10,100,111,117,98,108,101,32,97,115,105,110,40,100,111,117,98,108,101,32,95
,95,120,41,59,13,10,100,111,117,98,108,101,32,97,116,97,110,40,100,111,117,98,108,101,32
,95,95,120,41,59,13,10,100,111,117,98,108,101,32,97,116,97,110,50,40,100,111,117,98,108
,101,32,95,95,121,44,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98
,108,101,32,99,111,115,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98
,108,101,32,115,105,110,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98
,108,101,32,116,97,110,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98
,108,101,32,99,111,115,104,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117
,98,108,101,32,115,105,110,104,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111
,117,98,108,101,32,116,97,110,104,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100
,111,117,98,108,101,32,97,99,111,115,104,40,100,111,117,98,108,101,32,95,95,120,41,59,13
,10,100,111,117,98,108,101,32,97,115,105,110,104,40,100,111,117,98,108,101,32,95,95,120,41
,59,13,10,100,111,117,98,108,101,32,97,116,97,110,104,40,100,111,117,98,108,101,32,95,95
,120,41,59,13,10,100,111,117,98,108,101,32,101,120,112,40,100,111,117,98,108,101,32,95,95
,120,41,59,13,10,100,111,117,98,108,101,32,102,114,101,120,112,40,100,111,117,98,108,101,32
,95,95,120,44,32,105,110,116,42,32,95,95,101,120,112,111,110,101,110,116,41,59,13,10,100
,111,117,98,108,101,32,108,100,101,120,112,40,100,111,117,98,108,101,32,95,95,120,44,32,105
,110,116,32,95,95,101,120,112,111,110,101,110,116,41,59,13,10,100,111,117,98,108,101,32,108
,111,103,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98,108,101,32,108
,111,103,49,48,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98,108,101
,32,109,111,100,102,40,100,111,117,98,108,101,32,95,95,120,44,32,100,111,117,98,108,101,42
,32,95,95,105,112,116,114,41,59,13,10,100,111,117,98,108,101,32,101,120,112,109,49,40,100
,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98,108,101,32,108,111,103,49,112
,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98,108,101,32,108,111,103
,98,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98,108,101,32,101,120
,112,50,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98,108,101,32,108
,111,103,50,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98,108,101,32
,112,111,119,40,100,111,117,98,108,101,32,95,95,120,44,32,100,111,117,98,108,101,32,95,95
,121,41,59,13,10,100,111,117,98,108,101,32,115,113,114,116,40,100,111,117,98,108,101,32,95
,95,120,41,59,13,10,100,111,117,98,108,101,32,104,121,112,111,116,40,100,111,117,98,108,101
,32,95,95,120,44,32,100,111,117,98,108,101,32,95,95,121,41,59,13,10,100,111,117,98,108
,101,32,99,98,114,116,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98
,108,101,32,99,101,105,108,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117
,98,108,101,32,102,97,98,115,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111
,117,98,108,101,32,102,108,111,111,114,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10
,100,111,117,98,108,101,32,102,109,111,100,40,100,111,117,98,108,101,32,95,95,120,44,32,100
,111,117,98,108,101,32,95,95,121,41,59,13,10,105,110,116,32,105,115,105,110,102,40,100,111
,117,98,108,101,32,95,95,118,97,108,117,101,41,59,13,10,105,110,116,32,102,105,110,105,116
,101,40,100,111,117,98,108,101,32,95,95,118,97,108,117,101,41,59,13,10,100,111,117,98,108
,101,32,100,114,101,109,40,100,111,117,98,108,101,32,95,95,120,44,32,100,111,117,98,108,101
,32,95,95,121,41,59,13,10,100,111,117,98,108,101,32,115,105,103,110,105,102,105,99,97,110
,100,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111,117,98,108,101,32,99,111
,112,121,115,105,103,110,40,100,111,117,98,108,101,32,95,95,120,44,32,100,111,117,98,108,101
,32,95,95,121,41,59,13,10,100,111,117,98,108,101,32,110,97,110,40,99,111,110,115,116,32
,99,104,97,114,42,32,95,95,116,97,103,98,41,59,13,10,105,110,116,32,105,115,110,97,110
,40,100,111,117,98,108,101,32,95,95,118,97,108,117,101,41,59,13,10,100,111,117,98,108,101
,32,106,48,40,100,111,117,98,108,101,41,59,13,10,100,111,117,98,108,101,32,106,49,40,100
,111,117,98,108,101,41,59,13,10,100,111,117,98,108,101,32,106,110,40,105,110,116,44,32,100
,111,117,98,108,101,41,59,13,10,100,111,117,98,108,101,32,121,48,40,100,111,117,98,108,101
,41,59,13,10,100,111,117,98,108,101,32,121,49,40,100,111,117,98,108,101,41,59,13,10,100
,111,117,98,108,101,32,121,110,40,105,110,116,44,32,100,111,117,98,108,101,41,59,13,10,100
,111,117,98,108,101,32,101,114,102,40,100,111,117,98,108,101,41,59,13,10,100,111,117,98,108
,101,32,101,114,102,99,40,100,111,117,98,108,101,41,59,13,10,100,111,117,98,108,101,32,108
,103,97,109,109,97,40,100,111,117,98,108,101,41,59,13,10,100,111,117,98,108,101,32,116,103
,97,109,109,97,40,100,111,117,98,108,101,41,59,13,10,100,111,117,98,108,101,32,103,97,109
,109,97,40,100,111,117,98,108,101,41,59,13,10,100,111,117,98,108,101,32,108,103,97,109,109
,97,95,114,40,100,111,117,98,108,101,44,32,105,110,116,42,32,95,95,115,105,103,110,103,97
,109,112,41,59,13,10,100,111,117,98,108,101,32,114,105,110,116,40,100,111,117,98,108,101,32
,95,95,120,41,59,13,10,100,111,117,98,108,101,32,110,101,120,116,97,102,116,101,114,40,100
,111,117,98,108,101,32,95,95,120,44,32,100,111,117,98,108,101,32,95,95,121,41,59,13,10
,100,111,117,98,108,101,32,110,101,120,116,116,111,119,97,114,100,40,100,111,117,98,108,101,32
,95,95,120,44,32,108,111,110,103,32,100,111,117,98,108,101,32,95,95,121,41,59,13,10,100
,111,117,98,108,101,32,114,101,109,97,105,110,100,101,114,40,100,111,117,98,108,101,32,95,95
,120,44,32,100,111,117,98,108,101,32,95,95,121,41,59,13,10,100,111,117,98,108,101,32,115
,99,97,108,98,110,40,100,111,117,98,108,101,32,95,95,120,44,32,105,110,116,32,95,95,110
,41,59,13,10,105,110,116,32,105,108,111,103,98,40,100,111,117,98,108,101,32,95,95,120,41
,59,13,10,100,111,117,98,108,101,32,115,99,97,108,98,108,110,40,100,111,117,98,108,101,32
,95,95,120,44,32,108,111,110,103,32,105,110,116,32,95,95,110,41,59,13,10,100,111,117,98
,108,101,32,110,101,97,114,98,121,105,110,116,40,100,111,117,98,108,101,32,95,95,120,41,59
,13,10,100,111,117,98,108,101,32,114,111,117,110,100,40,100,111,117,98,108,101,32,95,95,120
,41,59,13,10,100,111,117,98,108,101,32,116,114,117,110,99,40,100,111,117,98,108,101,32,95
,95,120,41,59,13,10,100,111,117,98,108,101,32,114,101,109,113,117,111,40,100,111,117,98,108
,101,32,95,95,120,44,32,100,111,117,98,108,101,32,95,95,121,44,32,105,110,116,42,32,95
,95,113,117,111,41,59,13,10,108,111,110,103,32,105,110,116,32,108,114,105,110,116,40,100,111
,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,108,111,110,103,32,105,110,116
,32,108,108,114,111,117,110,100,40,100,111,117,98,108,101,32,95,95,120,41,59,13,10,100,111
,117,98,108,101,32,102,100,105,109,40,100,111,117,98,108,101,32,95,95,120,44,32,100,111,117
,98,108,101,32,95,95,121,41,59,13,10,100,111,117,98,108,101,32,102,109,97,120,40,100,111
,117,98,108,101,32,95,95,120,44,32,100,111,117,98,108,101,32,95,95,121,41,59,13,10,100
,111,117,98,108,101,32,102,109,105,110,40,100,111,117,98,108,101,32,95,95,120,44,32,100,111
,117,98,108,101,32,95,95,121,41,59,13,10,100,111,117,98,108,101,32,102,109,97,40,100,111
,117,98,108,101,32,95,95,120,44,32,100,111,117,98,108,101,32,95,95,121,44,32,100,111,117
,98,108,101,32,95,95,122,41,59,13,10,100,111,117,98,108,101,32,115,99,97,108,98,40,100
,111,117,98,108,101,32,95,95,120,44,32,100,111,117,98,108,101,32,95,95,110,41,59,13,10
,102,108,111,97,116,32,97,99,111,115,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10
,102,108,111,97,116,32,97,115,105,110,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10
,102,108,111,97,116,32,97,116,97,110,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10
,102,108,111,97,116,32,97,116,97,110,50,102,40,102,108,111,97,116,32,95,95,121,44,32,102
,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,99,111,115,102,40,102,108
,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,115,105,110,102,40,102,108,111
,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,116,97,110,102,40,102,108,111,97
,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,99,111,115,104,102,40,102,108,111,97
,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,115,105,110,104,102,40,102,108,111,97
,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,116,97,110,104,102,40,102,108,111,97
,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,97,99,111,115,104,102,40,102,108,111
,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,97,115,105,110,104,102,40,102,108
,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,97,116,97,110,104,102,40,102
,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,101,120,112,102,40,102,108
,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,102,114,101,120,112,102,40,102
,108,111,97,116,32,95,95,120,44,32,105,110,116,42,32,95,95,101,120,112,111,110,101,110,116
,41,59,13,10,102,108,111,97,116,32,108,100,101,120,112,102,40,102,108,111,97,116,32,95,95
,120,44,32,105,110,116,32,95,95,101,120,112,111,110,101,110,116,41,59,13,10,102,108,111,97
,116,32,108,111,103,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116
,32,108,111,103,49,48,102,40,102,108,111,97,116,32,95,95,120,41,59,32,102,108,111,97,116
,32,95,95,108,111,103,49,48,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10,102,108
,111,97,116,32,109,111,100,102,102,40,102,108,111,97,116,32,95,95,120,44,32,102,108,111,97
,116,42,32,95,95,105,112,116,114,41,59,13,10,102,108,111,97,116,32,101,120,112,109,49,102
,40,102,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,108,111,103,49,112
,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,108,111,103,98
,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,101,120,112,50
,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,108,111,103,50
,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,112,111,119,102
,40,102,108,111,97,116,32,95,95,120,44,32,102,108,111,97,116,32,95,95,121,41,59,13,10
,102,108,111,97,116,32,115,113,114,116,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10
,102,108,111,97,116,32,104,121,112,111,116,102,40,102,108,111,97,116,32,95,95,120,44,32,102
,108,111,97,116,32,95,95,121,41,59,13,10,102,108,111,97,116,32,99,98,114,116,102,40,102
,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,99,101,105,108,102,40,102
,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,102,97,98,115,102,40,102
,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,102,108,111,111,114,102,40
,102,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,102,109,111,100,102,40
,102,108,111,97,116,32,95,95,120,44,32,102,108,111,97,116,32,95,95,121,41,59,13,10,105
,110,116,32,105,115,105,110,102,102,40,102,108,111,97,116,32,95,95,118,97,108,117,101,41,59
,13,10,105,110,116,32,102,105,110,105,116,101,102,40,102,108,111,97,116,32,95,95,118,97,108
,117,101,41,59,13,10,102,108,111,97,116,32,100,114,101,109,102,40,102,108,111,97,116,32,95
,95,120,44,32,102,108,111,97,116,32,95,95,121,41,59,13,10,102,108,111,97,116,32,115,105
,103,110,105,102,105,99,97,110,100,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10,102
,108,111,97,116,32,99,111,112,121,115,105,103,110,102,40,102,108,111,97,116,32,95,95,120,44
,32,102,108,111,97,116,32,95,95,121,41,59,13,10,102,108,111,97,116,32,110,97,110,102,40
,99,111,110,115,116,32,99,104,97,114,42,32,95,95,116,97,103,98,41,59,13,10,105,110,116
,32,105,115,110,97,110,102,40,102,108,111,97,116,32,95,95,118,97,108,117,101,41,59,13,10
,102,108,111,97,116,32,106,48,102,40,102,108,111,97,116,41,59,13,10,102,108,111,97,116,32
,106,49,102,40,102,108,111,97,116,41,59,13,10,102,108,111,97,116,32,106,110,102,40,105,110
,116,44,32,102,108,111,97,116,41,59,13,10,102,108,111,97,116,32,121,48,102,40,102,108,111
,97,116,41,59,13,10,102,108,111,97,116,32,121,49,102,40,102,108,111,97,116,41,59,13,10
,102,108,111,97,116,32,121,110,102,40,105,110,116,44,32,102,108,111,97,116,41,59,13,10,102
,108,111,97,116,32,101,114,102,102,40,102,108,111,97,116,41,59,13,10,102,108,111,97,116,32
,101,114,102,99,102,40,102,108,111,97,116,41,59,13,10,102,108,111,97,116,32,108,103,97,109
,109,97,102,40,102,108,111,97,116,41,59,13,10,102,108,111,97,116,32,116,103,97,109,109,97
,102,40,102,108,111,97,116,41,59,13,10,102,108,111,97,116,32,103,97,109,109,97,102,40,102
,108,111,97,116,41,59,13,10,102,108,111,97,116,32,108,103,97,109,109,97,102,95,114,40,102
,108,111,97,116,44,32,105,110,116,42,32,95,95,115,105,103,110,103,97,109,112,41,59,13,10
,102,108,111,97,116,32,114,105,110,116,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10
,102,108,111,97,116,32,110,101,120,116,97,102,116,101,114,102,40,102,108,111,97,116,32,95,95
,120,44,32,102,108,111,97,116,32,95,95,121,41,59,13,10,102,108,111,97,116,32,110,101,120
,116,116,111,119,97,114,100,102,40,102,108,111,97,116,32,95,95,120,44,32,108,111,110,103,32
,100,111,117,98,108,101,32,95,95,121,41,59,13,10,102,108,111,97,116,32,114,101,109,97,105
,110,100,101,114,102,40,102,108,111,97,116,32,95,95,120,44,32,102,108,111,97,116,32,95,95
,121,41,59,13,10,102,108,111,97,116,32,115,99,97,108,98,110,102,40,102,108,111,97,116,32
,95,95,120,44,32,105,110,116,32,95,95,110,41,59,13,10,105,110,116,32,105,108,111,103,98
,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,115,99,97,108
,98,108,110,102,40,102,108,111,97,116,32,95,95,120,44,32,108,111,110,103,32,105,110,116,32
,95,95,110,41,59,13,10,102,108,111,97,116,32,110,101,97,114,98,121,105,110,116,102,40,102
,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,114,111,117,110,100,102,40
,102,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,116,114,117,110,99,102
,40,102,108,111,97,116,32,95,95,120,41,59,13,10,102,108,111,97,116,32,114,101,109,113,117
,111,102,40,102,108,111,97,116,32,95,95,120,44,32,102,108,111,97,116,32,95,95,121,44,32
,105,110,116,42,32,95,95,113,117,111,41,59,13,10,108,111,110,103,32,105,110,116,32,108,114
,105,110,116,102,40,102,108,111,97,116,32,95,95,120,41,59,13,10,108,111,110,103,32,108,111
,110,103,32,105,110,116,32,108,108,114,111,117,110,100,102,40,102,108,111,97,116,32,95,95,120
,41,59,13,10,102,108,111,97,116,32,102,100,105,109,102,40,102,108,111,97,116,32,95,95,120
,44,32,102,108,111,97,116,32,95,95,121,41,59,13,10,102,108,111,97,116,32,102,109,97,120
,102,40,102,108,111,97,116,32,95,95,120,44,32,102,108,111,97,116,32,95,95,121,41,59,13
,10,102,108,111,97,116,32,102,109,105,110,102,40,102,108,111,97,116,32,95,95,120,44,32,102
,108,111,97,116,32,95,95,121,41,59,13,10,102,108,111,97,116,32,102,109,97,102,40,102,108
,111,97,116,32,95,95,120,44,32,102,108,111,97,116,32,95,95,121,44,32,102,108,111,97,116
,32,95,95,122,41,59,13,10,102,108,111,97,116,32,115,99,97,108,98,102,40,102,108,111,97
,116,32,95,95,120,44,32,102,108,111,97,116,32,95,95,110,41,59,13,10,108,111,110,103,32
,100,111,117,98,108,101,32,97,99,111,115,108,40,108,111,110,103,32,100,111,117,98,108,101,32
,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,97,115,105,110,108,40
,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100
,111,117,98,108,101,32,97,116,97,110,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95
,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,97,116,97,110,50,108,40
,108,111,110,103,32,100,111,117,98,108,101,32,95,95,121,44,32,108,111,110,103,32,100,111,117
,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,99,111
,115,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110
,103,32,100,111,117,98,108,101,32,115,105,110,108,40,108,111,110,103,32,100,111,117,98,108,101
,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,116,97,110,108,40
,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100
,111,117,98,108,101,32,99,111,115,104,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95
,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,115,105,110,104,108,40,108
,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111
,117,98,108,101,32,116,97,110,104,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95
,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,97,99,111,115,104,108,40,108
,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111
,117,98,108,101,32,97,115,105,110,104,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95
,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,97,116,97,110,104,108,40
,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100
,111,117,98,108,101,32,101,120,112,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95
,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,102,114,101,120,112,108,40,108
,111,110,103,32,100,111,117,98,108,101,32,95,95,120,44,32,105,110,116,42,32,95,95,101,120
,112,111,110,101,110,116,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,108,100,101
,120,112,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,44,32,105,110,116,32
,95,95,101,120,112,111,110,101,110,116,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101
,32,108,111,103,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10
,108,111,110,103,32,100,111,117,98,108,101,32,108,111,103,49,48,108,40,108,111,110,103,32,100
,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32
,109,111,100,102,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,44,32,108,111
,110,103,32,100,111,117,98,108,101,42,32,95,95,105,112,116,114,41,59,13,10,108,111,110,103
,32,100,111,117,98,108,101,32,101,120,112,109,49,108,40,108,111,110,103,32,100,111,117,98,108
,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,108,111,103,49
,112,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110
,103,32,100,111,117,98,108,101,32,108,111,103,98,108,40,108,111,110,103,32,100,111,117,98,108
,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,101,120,112,50
,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103
,32,100,111,117,98,108,101,32,108,111,103,50,108,40,108,111,110,103,32,100,111,117,98,108,101
,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,112,111,119,108,40
,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,44,32,108,111,110,103,32,100,111,117
,98,108,101,32,95,95,121,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,115,113
,114,116,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111
,110,103,32,100,111,117,98,108,101,32,104,121,112,111,116,108,40,108,111,110,103,32,100,111,117
,98,108,101,32,95,95,120,44,32,108,111,110,103,32,100,111,117,98,108,101,32,95,95,121,41
,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,99,98,114,116,108,40,108,111,110,103
,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108
,101,32,99,101,105,108,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59
,13,10,108,111,110,103,32,100,111,117,98,108,101,32,102,97,98,115,108,40,108,111,110,103,32
,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101
,32,102,108,111,111,114,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59
,13,10,108,111,110,103,32,100,111,117,98,108,101,32,102,109,111,100,108,40,108,111,110,103,32
,100,111,117,98,108,101,32,95,95,120,44,32,108,111,110,103,32,100,111,117,98,108,101,32,95
,95,121,41,59,13,10,105,110,116,32,105,115,105,110,102,108,40,108,111,110,103,32,100,111,117
,98,108,101,32,95,95,118,97,108,117,101,41,59,13,10,105,110,116,32,102,105,110,105,116,101
,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,118,97,108,117,101,41,59,13,10
,108,111,110,103,32,100,111,117,98,108,101,32,100,114,101,109,108,40,108,111,110,103,32,100,111
,117,98,108,101,32,95,95,120,44,32,108,111,110,103,32,100,111,117,98,108,101,32,95,95,121
,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,115,105,103,110,105,102,105,99,97
,110,100,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111
,110,103,32,100,111,117,98,108,101,32,99,111,112,121,115,105,103,110,108,40,108,111,110,103,32
,100,111,117,98,108,101,32,95,95,120,44,32,108,111,110,103,32,100,111,117,98,108,101,32,95
,95,121,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,110,97,110,108,40,99,111
,110,115,116,32,99,104,97,114,42,32,95,95,116,97,103,98,41,59,13,10,105,110,116,32,105
,115,110,97,110,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,118,97,108,117,101
,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,106,48,108,40,108,111,110,103,32
,100,111,117,98,108,101,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,106,49,108
,40,108,111,110,103,32,100,111,117,98,108,101,41,59,13,10,108,111,110,103,32,100,111,117,98
,108,101,32,106,110,108,40,105,110,116,44,32,108,111,110,103,32,100,111,117,98,108,101,41,59
,13,10,108,111,110,103,32,100,111,117,98,108,101,32,121,48,108,40,108,111,110,103,32,100,111
,117,98,108,101,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,121,49,108,40,108
,111,110,103,32,100,111,117,98,108,101,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101
,32,121,110,108,40,105,110,116,44,32,108,111,110,103,32,100,111,117,98,108,101,41,59,13,10
,108,111,110,103,32,100,111,117,98,108,101,32,101,114,102,108,40,108,111,110,103,32,100,111,117
,98,108,101,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,101,114,102,99,108,40
,108,111,110,103,32,100,111,117,98,108,101,41,59,13,10,108,111,110,103,32,100,111,117,98,108
,101,32,108,103,97,109,109,97,108,40,108,111,110,103,32,100,111,117,98,108,101,41,59,13,10
,108,111,110,103,32,100,111,117,98,108,101,32,116,103,97,109,109,97,108,40,108,111,110,103,32
,100,111,117,98,108,101,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,103,97,109
,109,97,108,40,108,111,110,103,32,100,111,117,98,108,101,41,59,13,10,108,111,110,103,32,100
,111,117,98,108,101,32,108,103,97,109,109,97,108,95,114,40,108,111,110,103,32,100,111,117,98
,108,101,44,32,105,110,116,42,32,95,95,115,105,103,110,103,97,109,112,41,59,13,10,108,111
,110,103,32,100,111,117,98,108,101,32,114,105,110,116,108,40,108,111,110,103,32,100,111,117,98
,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,110,101,120
,116,97,102,116,101,114,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,44,32
,108,111,110,103,32,100,111,117,98,108,101,32,95,95,121,41,59,13,10,108,111,110,103,32,100
,111,117,98,108,101,32,110,101,120,116,116,111,119,97,114,100,108,40,108,111,110,103,32,100,111
,117,98,108,101,32,95,95,120,44,32,108,111,110,103,32,100,111,117,98,108,101,32,95,95,121
,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,114,101,109,97,105,110,100,101,114
,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,44,32,108,111,110,103,32,100
,111,117,98,108,101,32,95,95,121,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32
,115,99,97,108,98,110,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,44,32
,105,110,116,32,95,95,110,41,59,13,10,105,110,116,32,105,108,111,103,98,108,40,108,111,110
,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98
,108,101,32,115,99,97,108,98,108,110,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95
,95,120,44,32,108,111,110,103,32,105,110,116,32,95,95,110,41,59,13,10,108,111,110,103,32
,100,111,117,98,108,101,32,110,101,97,114,98,121,105,110,116,108,40,108,111,110,103,32,100,111
,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,114
,111,117,110,100,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10
,108,111,110,103,32,100,111,117,98,108,101,32,116,114,117,110,99,108,40,108,111,110,103,32,100
,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32
,114,101,109,113,117,111,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,44,32
,108,111,110,103,32,100,111,117,98,108,101,32,95,95,121,44,32,105,110,116,42,32,95,95,113
,117,111,41,59,13,10,108,111,110,103,32,105,110,116,32,108,114,105,110,116,108,40,108,111,110
,103,32,100,111,117,98,108,101,32,95,95,120,41,59,13,10,108,111,110,103,32,108,111,110,103
,32,105,110,116,32,108,108,114,111,117,110,100,108,40,108,111,110,103,32,100,111,117,98,108,101
,32,95,95,120,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,102,100,105,109,108
,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,44,32,108,111,110,103,32,100,111
,117,98,108,101,32,95,95,121,41,59,13,10,108,111,110,103,32,100,111,117,98,108,101,32,102
,109,97,120,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,44,32,108,111,110
,103,32,100,111,117,98,108,101,32,95,95,121,41,59,13,10,108,111,110,103,32,100,111,117,98
,108,101,32,102,109,105,110,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,44
,32,108,111,110,103,32,100,111,117,98,108,101,32,95,95,121,41,59,13,10,108,111,110,103,32
,100,111,117,98,108,101,32,102,109,97,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95
,95,120,44,32,108,111,110,103,32,100,111,117,98,108,101,32,95,95,121,44,32,108,111,110,103
,32,100,111,117,98,108,101,32,95,95,122,41,59,13,10,108,111,110,103,32,100,111,117,98,108
,101,32,115,99,97,108,98,108,40,108,111,110,103,32,100,111,117,98,108,101,32,95,95,120,44
,32,108,111,110,103,32,100,111,117,98,108,101,32,95,95,110,41,59,13,10
};

static const char file_stdlib_h[] = {



47,42,13,10,32,42,32,32,84,104,105,115,32,102,105,108,101,32,105,115,32,112,97,114,116
,32,111,102,32,99,97,107,101,32,99,111,109,112,105,108,101,114,13,10,32,42,32,32,104,116
,116,112,115,58,47,47,103,105,116,104,117,98,46,99,111,109,47,116,104,114,97,100,97,109,115
,47,99,97,107,101,13,10,42,47,13,10,13,10,116,121,112,101,100,101,102,32,108,111,110,103
,32,108,111,110,103,32,102,112,111,115,95,116,59,13,10,116,121,112,101,100,101,102,32,117,110
,115,105,103,110,101,100,32,108,111,110,103,32,115,105,122,101,95,116,59,13,10,13,10,35,100
,101,102,105,110,101,32,69,88,73,84,95,83,85,67,67,69,83,83,32,48,13,10,35,100,101
,102,105,110,101,32,69,88,73,84,95,70,65,73,76,85,82,69,32,49,13,10,35,100,101,102
,105,110,101,32,78,85,76,76,32,40,40,118,111,105,100,42,41,48,41,13,10,13,10,116,121
,112,101,100,101,102,32,105,110,116,32,119,99,104,97,114,95,116,59,13,10,91,91,110,111,100
,105,115,99,97,114,100,93,93,32,100,111,117,98,108,101,32,97,116,111,102,40,99,111,110,115
,116,32,99,104,97,114,42,32,110,112,116,114,41,59,13,10,91,91,110,111,100,105,115,99,97
,114,100,93,93,32,105,110,116,32,97,116,111,105,40,99,111,110,115,116,32,99,104,97,114,42
,32,110,112,116,114,41,59,13,10,91,91,110,111,100,105,115,99,97,114,100,93,93,32,108,111
,110,103,32,105,110,116,32,97,116,111,108,40,99,111,110,115,116,32,99,104,97,114,42,32,110
,112,116,114,41,59,13,10,91,91,110,111,100,105,115,99,97,114,100,93,93,32,108,111,110,103
,32,108,111,110,103,32,105,110,116,32,97,116,111,108,108,40,99,111,110,115,116,32,99,104,97
,114,42,32,110,112,116,114,41,59,13,10,100,111,117,98,108,101,32,115,116,114,116,111,100,40
,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32,110,112,116,114
,44,32,99,104,97,114,42,42,32,114,101,115,116,114,105,99,116,32,101,110,100,112,116,114,41
,59,13,10,102,108,111,97,116,32,115,116,114,116,111,102,40,99,111,110,115,116,32,99,104,97
,114,42,32,114,101,115,116,114,105,99,116,32,110,112,116,114,44,32,99,104,97,114,42,42,32
,114,101,115,116,114,105,99,116,32,101,110,100,112,116,114,41,59,13,10,108,111,110,103,32,100
,111,117,98,108,101,32,115,116,114,116,111,108,100,40,99,111,110,115,116,32,99,104,97,114,42
,32,114,101,115,116,114,105,99,116,32,110,112,116,114,44,32,99,104,97,114,42,42,32,114,101
,115,116,114,105,99,116,32,101,110,100,112,116,114,41,59,13,10,108,111,110,103,32,105,110,116
,32,115,116,114,116,111,108,40,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114
,105,99,116,32,110,112,116,114,44,32,99,104,97,114,42,42,32,114,101,115,116,114,105,99,116
,32,101,110,100,112,116,114,44,32,105,110,116,32,98,97,115,101,41,59,13,10,108,111,110,103
,32,108,111,110,103,32,105,110,116,32,115,116,114,116,111,108,108,40,99,111,110,115,116,32,99
,104,97,114,42,32,114,101,115,116,114,105,99,116,32,110,112,116,114,44,32,99,104,97,114,42
,42,32,114,101,115,116,114,105,99,116,32,101,110,100,112,116,114,44,32,105,110,116,32,98,97
,115,101,41,59,13,10,117,110,115,105,103,110,101,100,32,108,111,110,103,32,105,110,116,32,115
,116,114,116,111,117,108,40,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105
,99,116,32,110,112,116,114,44,32,99,104,97,114,42,42,32,114,101,115,116,114,105,99,116,32
,101,110,100,112,116,114,44,32,105,110,116,32,98,97,115,101,41,59,13,10,117,110,115,105,103
,110,101,100,32,108,111,110,103,32,108,111,110,103,32,105,110,116,32,115,116,114,116,111,117,108
,108,40,99,111,110,115,116,32,99,104,97,114,42,32,114,101,115,116,114,105,99,116,32,110,112
,116,114,44,32,99,104,97,114,42,42,32,114,101,115,116,114,105,99,116,32,101,110,100,112,116
,114,44,32,105,110,116,32,98,97,115,101,41,59,13,10,105,110,116,32,114,97,110,100,40,118
,111,105,100,41,59,13,10,118,111,105,100,32,115,114,97,110,100,40,117,110,115,105,103,110,101
,100,32,105,110,116,32,115,101,101,100,41,59,13,10,118,111,105,100,42,32,97,108,105,103,110
,101,100,95,97,108,108,111,99,40,115,105,122,101,95,116,32,97,108,105,103,110,109,101,110,116
,44,32,115,105,122,101,95,116,32,115,105,122,101,41,59,13,10,13,10,35,105,102,32,100,101
,102,105,110,101,100,40,95,95,83,84,68,67,95,79,87,78,69,82,83,72,73,80,95,95,41
,32,13,10,91,91,110,111,100,105,115,99,97,114,100,93,93,32,118,111,105,100,42,32,95,79
,119,110,101,114,32,95,79,112,116,32,99,97,108,108,111,99,40,115,105,122,101,95,116,32,110
,109,101,109,98,44,32,115,105,122,101,95,116,32,115,105,122,101,41,59,13,10,118,111,105,100
,32,102,114,101,101,40,118,111,105,100,42,32,95,79,119,110,101,114,32,95,79,112,116,32,112
,116,114,41,59,13,10,91,91,110,111,100,105,115,99,97,114,100,93,93,32,118,111,105,100,42
,32,95,79,119,110,101,114,32,95,79,112,116,32,109,97,108,108,111,99,40,115,105,122,101,95
,116,32,115,105,122,101,41,59,13,10,91,91,110,111,100,105,115,99,97,114,100,93,93,32,118
,111,105,100,42,32,95,79,119,110,101,114,32,95,79,112,116,32,114,101,97,108,108,111,99,40
,118,111,105,100,42,32,95,79,112,116,32,112,116,114,44,32,115,105,122,101,95,116,32,115,105
,122,101,41,59,13,10,35,101,108,115,101,13,10,91,91,110,111,100,105,115,99,97,114,100,93
,93,32,118,111,105,100,42,32,99,97,108,108,111,99,40,115,105,122,101,95,116,32,110,109,101
,109,98,44,32,115,105,122,101,95,116,32,115,105,122,101,41,59,13,10,118,111,105,100,32,102
,114,101,101,40,118,111,105,100,42,32,112,116,114,41,59,13,10,91,91,110,111,100,105,115,99
,97,114,100,93,93,32,118,111,105,100,42,32,109,97,108,108,111,99,40,115,105,122,101,95,116
,32,115,105,122,101,41,59,13,10,91,91,110,111,100,105,115,99,97,114,100,93,93,32,118,111
,105,100,42,32,114,101,97,108,108,111,99,40,118,111,105,100,42,32,112,116,114,44,32,115,105
,122,101,95,116,32,115,105,122,101,41,59,13,10,35,101,110,100,105,102,13,10,13,10,91,91
,110,111,114,101,116,117,114,110,93,93,32,118,111,105,100,32,97,98,111,114,116,40,118,111,105
,100,41,59,13,10,105,110,116,32,97,116,101,120,105,116,40,118,111,105,100,32,40,42,102,117
,110,99,41,40,118,111,105,100,41,41,59,13,10,105,110,116,32,97,116,95,113,117,105,99,107
,95,101,120,105,116,40,118,111,105,100,32,40,42,102,117,110,99,41,40,118,111,105,100,41,41
,59,13,10,91,91,110,111,114,101,116,117,114,110,93,93,32,118,111,105,100,32,101,120,105,116
,40,105,110,116,32,115,116,97,116,117,115,41,59,13,10,91,91,110,111,114,101,116,117,114,110
,93,93,32,118,111,105,100,32,95,69,120,105,116,40,105,110,116,32,115,116,97,116,117,115,41
,59,13,10,99,104,97,114,42,32,103,101,116,101,110,118,40,99,111,110,115,116,32,99,104,97
,114,42,32,110,97,109,101,41,59,13,10,91,91,110,111,114,101,116,117,114,110,93,93,32,118
,111,105,100,32,113,117,105,99,107,95,101,120,105,116,40,105,110,116,32,115,116,97,116,117,115
,41,59,13,10,105,110,116,32,115,121,115,116,101,109,40,99,111,110,115,116,32,99,104,97,114
,42,32,115,116,114,105,110,103,41,59,13,10
};

static const char file_stddef_h[] = {



47,42,13,10,32,42,32,32,84,104,105,115,32,102,105,108,101,32,105,115,32,112,97,114,116
,32,111,102,32,99,97,107,101,32,99,111,109,112,105,108,101,114,13,10,32,42,32,32,104,116
,116,112,115,58,47,47,103,105,116,104,117,98,46,99,111,109,47,116,104,114,97,100,97,109,115
,47,99,97,107,101,13,10,42,47,13,10,13,10,35,100,101,102,105,110,101,32,117,110,114,101
,97,99,104,97,98,108,101,40,41,32,100,111,32,123,125,32,119,104,105,108,101,40,48,41,32
,13,10,116,121,112,101,100,101,102,32,108,111,110,103,32,105,110,116,32,112,116,114,100,105,102
,102,95,116,59,13,10,116,121,112,101,100,101,102,32,117,110,115,105,103,110,101,100,32,108,111
,110,103,32,115,105,122,101,95,116,59,13,10,116,121,112,101,100,101,102,32,105,110,116,32,119
,99,104,97,114,95,116,59,13,10,116,121,112,101,100,101,102,32,115,116,114,117,99,116,32,123
,13,10,32,32,108,111,110,103,32,108,111,110,103,32,95,95,109,97,120,95,97,108,105,103,110
,95,108,108,59,13,10,32,32,108,111,110,103,32,100,111,117,98,108,101,32,95,95,109,97,120
,95,97,108,105,103,110,95,108,100,59,13,10,125,32,109,97,120,95,97,108,105,103,110,95,116
,59,13,10,13,10,116,121,112,101,100,101,102,32,116,121,112,101,111,102,40,110,117,108,108,112
,116,114,41,32,110,117,108,108,112,116,114,95,116,59,13,10,13,10
};

static const char file_limits_h[] = {
    #include "include\limits.h.include"
};

static const char file_locale_h[] = {



47,42,13,10,32,42,32,32,84,104,105,115,32,102,105,108,101,32,105,115,32,112,97,114,116
,32,111,102,32,99,97,107,101,32,99,111,109,112,105,108,101,114,13,10,32,42,32,32,104,116
,116,112,115,58,47,47,103,105,116,104,117,98,46,99,111,109,47,116,104,114,97,100,97,109,115
,47,99,97,107,101,13,10,42,47,13,10,13,10,35,112,114,97,103,109,97,32,111,110,99,101
,13,10,116,121,112,101,100,101,102,32,105,110,116,32,119,99,104,97,114,95,116,59,13,10,47
,47,32,76,111,99,97,108,101,32,99,97,116,101,103,111,114,105,101,115,13,10,35,100,101,102
,105,110,101,32,76,67,95,65,76,76,32,32,32,32,32,32,32,32,32,32,48,13,10,35,100
,101,102,105,110,101,32,76,67,95,67,79,76,76,65,84,69,32,32,32,32,32,32,49,13,10
,35,100,101,102,105,110,101,32,76,67,95,67,84,89,80,69,32,32,32,32,32,32,32,32,50
,13,10,35,100,101,102,105,110,101,32,76,67,95,77,79,78,69,84,65,82,89,32,32,32,32
,32,51,13,10,35,100,101,102,105,110,101,32,76,67,95,78,85,77,69,82,73,67,32,32,32
,32,32,32,52,13,10,35,100,101,102,105,110,101,32,76,67,95,84,73,77,69,32,32,32,32
,32,32,32,32,32,53,13,10,13,10,35,100,101,102,105,110,101,32,76,67,95,77,73,78,32
,32,32,32,32,32,32,32,32,32,76,67,95,65,76,76,13,10,35,100,101,102,105,110,101,32
,76,67,95,77,65,88,32,32,32,32,32,32,32,32,32,32,76,67,95,84,73,77,69,13,10
,13,10,47,47,32,76,111,99,97,108,101,32,99,111,110,118,101,110,116,105,111,110,32,115,116
,114,117,99,116,117,114,101,13,10,115,116,114,117,99,116,32,108,99,111,110,118,13,10,123,13
,10,32,32,32,32,99,104,97,114,42,32,100,101,99,105,109,97,108,95,112,111,105,110,116,59
,13,10,32,32,32,32,99,104,97,114,42,32,116,104,111,117,115,97,110,100,115,95,115,101,112
,59,13,10,32,32,32,32,99,104,97,114,42,32,103,114,111,117,112,105,110,103,59,13,10,32
,32,32,32,99,104,97,114,42,32,105,110,116,95,99,117,114,114,95,115,121,109,98,111,108,59
,13,10,32,32,32,32,99,104,97,114,42,32,99,117,114,114,101,110,99,121,95,115,121,109,98
,111,108,59,13,10,32,32,32,32,99,104,97,114,42,32,109,111,110,95,100,101,99,105,109,97
,108,95,112,111,105,110,116,59,13,10,32,32,32,32,99,104,97,114,42,32,109,111,110,95,116
,104,111,117,115,97,110,100,115,95,115,101,112,59,13,10,32,32,32,32,99,104,97,114,42,32
,109,111,110,95,103,114,111,117,112,105,110,103,59,13,10,32,32,32,32,99,104,97,114,42,32
,112,111,115,105,116,105,118,101,95,115,105,103,110,59,13,10,32,32,32,32,99,104,97,114,42
,32,110,101,103,97,116,105,118,101,95,115,105,103,110,59,13,10,32,32,32,32,99,104,97,114
,32,32,32,32,32,105,110,116,95,102,114,97,99,95,100,105,103,105,116,115,59,13,10,32,32
,32,32,99,104,97,114,32,32,32,32,32,102,114,97,99,95,100,105,103,105,116,115,59,13,10
,32,32,32,32,99,104,97,114,32,32,32,32,32,112,95,99,115,95,112,114,101,99,101,100,101
,115,59,13,10,32,32,32,32,99,104,97,114,32,32,32,32,32,112,95,115,101,112,95,98,121
,95,115,112,97,99,101,59,13,10,32,32,32,32,99,104,97,114,32,32,32,32,32,110,95,99
,115,95,112,114,101,99,101,100,101,115,59,13,10,32,32,32,32,99,104,97,114,32,32,32,32
,32,110,95,115,101,112,95,98,121,95,115,112,97,99,101,59,13,10,32,32,32,32,99,104,97
,114,32,32,32,32,32,112,95,115,105,103,110,95,112,111,115,110,59,13,10,32,32,32,32,99
,104,97,114,32,32,32,32,32,110,95,115,105,103,110,95,112,111,115,110,59,13,10,32,32,32
,32,119,99,104,97,114,95,116,42,32,95,87,95,100,101,99,105,109,97,108,95,112,111,105,110
,116,59,13,10,32,32,32,32,119,99,104,97,114,95,116,42,32,95,87,95,116,104,111,117,115
,97,110,100,115,95,115,101,112,59,13,10,32,32,32,32,119,99,104,97,114,95,116,42,32,95
,87,95,105,110,116,95,99,117,114,114,95,115,121,109,98,111,108,59,13,10,32,32,32,32,119
,99,104,97,114,95,116,42,32,95,87,95,99,117,114,114,101,110,99,121,95,115,121,109,98,111
,108,59,13,10,32,32,32,32,119,99,104,97,114,95,116,42,32,95,87,95,109,111,110,95,100
,101,99,105,109,97,108,95,112,111,105,110,116,59,13,10,32,32,32,32,119,99,104,97,114,95
,116,42,32,95,87,95,109,111,110,95,116,104,111,117,115,97,110,100,115,95,115,101,112,59,13
,10,32,32,32,32,119,99,104,97,114,95,116,42,32,95,87,95,112,111,115,105,116,105,118,101
,95,115,105,103,110,59,13,10,32,32,32,32,119,99,104,97,114,95,116,42,32,95,87,95,110
,101,103,97,116,105,118,101,95,115,105,103,110,59,13,10,125,59,13,10,13,10,115,116,114,117
,99,116,32,116,109,59,13,10,13,10,99,104,97,114,42,32,115,101,116,108,111,99,97,108,101
,40,13,10,32,32,32,32,105,110,116,32,32,32,32,32,32,32,32,32,95,67,97,116,101,103
,111,114,121,44,13,10,32,32,32,32,99,104,97,114,32,99,111,110,115,116,42,32,95,76,111
,99,97,108,101,13,10,41,59,13,10,13,10,115,116,114,117,99,116,32,108,99,111,110,118,42
,32,108,111,99,97,108,101,99,111,110,118,40,118,111,105,100,41,59,13,10
};

const char file_wchar_h[] = {
  #include "include\wchar.h.include"
};

char* _Owner read_file(const char* path, bool append_newline)
{
    if (strcmp(path, "c:/stdio.h") == 0)
        return strdup(file_stdio_h);
    else if (strcmp(path, "c:/stdlib.h") == 0)
        return strdup(file_stdlib_h);
    else if (strcmp(path, "c:/stddef.h") == 0)
        return strdup(file_stddef_h);
    else if (strcmp(path, "c:/math.h") == 0)
        return strdup(file_math_h);
    else if (strcmp(path, "c:/errno.h") == 0)
        return strdup(file_errno_h);
    else if (strcmp(path, "c:/string.h") == 0)
        return strdup(file_string_h);
    else if (strcmp(path, "c:/assert.h") == 0)
        return strdup(file_assert_h);
    else if (strcmp(path, "c:/limits.h") == 0)
        return strdup(file_limits_h);
    else if (strcmp(path, "c:/locale.h") == 0)
        return strdup(file_locale_h);
    else if (strcmp(path, "c:/wchar.h") == 0)
        return strdup(file_wchar_h);

    return NULL;
}
#endif




/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable


#if defined(_WIN32) || defined(_WIN64)
#  define PLATFORM_NAME "windows"
#elif defined(__APPLE__) && defined(__MACH__)
#  define PLATFORM_NAME "apple"
#elif defined(__linux__)
#  define PLATFORM_NAME "linux"
#elif defined(__EMSCRIPTEN__)
#  define PLATFORM_NAME "emscripten"
#else
#error add new platform 
#endif



#if defined(__clang__)
#define COMPILER_NAME "clang"

#elif defined(__GNUC__) && !defined(__TINYC__) && !defined(__HLC__)
#define COMPILER_NAME "gcc"
#elif defined(_MSC_VER) && !defined(__TINYC__) && !defined(__HLC__)
#define COMPILER_NAME "msvc"
#elif defined(__INTEL_COMPILER)
#define COMPILER_NAME "intel"
#elif defined(__TINYC__)
#define COMPILER_NAME "tcc"
#elif defined(__HLC__)
#define COMPILER_NAME "hlc"
#else
#error add new compiler 
#endif


#if defined(__x86_64__) || defined(_M_X64)
#  define ARCH_NAME "X86_64"
#elif defined(__i386__) || defined(_M_IX86)
#  define ARCH_NAME "X86"

#elif defined(__aarch64__) || defined(_M_ARM64)
#  define ARCH_NAME "ARM64"
#elif defined(__arm__) || defined(_M_ARM)
#  define ARCH_NAME "ARM"
#elif defined(__wasm32__)
#  define ARCH_NAME "wasm32"
#elif defined(__wasm64__)
#  define ARCH_NAME "wasm64"
#elif defined(__wasm__)
#  define ARCH_NAME "wasm"
#else
#error add new architeture
#endif


const char* target_to_string(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:
        return PLATFORM_NAME " " COMPILER_NAME  " " ARCH_NAME " (default)";

    case TARGET_X86_X64_GCC:
        return "X86_X64_GCC";
    case TARGET_X86_MSVC:
        return "X86_MSVC";
    case TARGET_X64_MSVC:
        return "X64_MSVC";
    }
    return "";
}

bool is_diagnostic_note(enum diagnostic_id id)
{
    if (id == W_NOTE ||
        id == W_LOCATION)
    {
        return true;
    }

    return false;
}

bool is_diagnostic_warning(enum diagnostic_id id)
{
    return id > W_NOTE && id <= C_ERROR_INVALID_QUALIFIER_FOR_POINTER;
}

bool is_diagnostic_error(enum diagnostic_id id)
{
    return id >= C_ERROR_INVALID_QUALIFIER_FOR_POINTER;
}

bool is_diagnostic_configurable(enum diagnostic_id id)
{
    //We have 0-63 configurable (bit set)
    //configurable diagnostic also have names. Other have numbers only    
    return id >= 0 && id < W_LOCATION;
}

int diagnostic_stack_push_empty(struct diagnostic_stack* diagnostic_stack)
{
    int index = diagnostic_stack->top_index;
    diagnostic_stack->top_index++;
    diagnostic_stack->stack[diagnostic_stack->top_index].warnings = 0;
    diagnostic_stack->stack[diagnostic_stack->top_index].errors = 0;
    diagnostic_stack->stack[diagnostic_stack->top_index].notes = 0;
    return index;
}

void diagnostic_stack_pop(struct diagnostic_stack* diagnostic_stack)
{
    if (diagnostic_stack->top_index > 0)
    {
        diagnostic_stack->top_index--;
    }
    else
    {
        assert(false);
    }
}


struct diagnostic default_diagnostic = {
      .warnings = (~0ULL) & ~(
        NULLABLE_DISABLE_REMOVED_WARNINGS |
        (1ULL << W_NOTE) |
        (1ULL << W_STYLE) |
        (1ULL << W_UNUSED_PARAMETER) |
        (1ULL << W_UNUSED_VARIABLE))
};

static struct w {
    enum diagnostic_id w;
    const char* name;
}
s_warnings[] = {
    {W_UNUSED_VARIABLE, "unused-variable"},
    {W_UNUSED_FUNCTION, "unused-function"},
    {W_DEPRECATED, "deprecated"},
    {W_ENUN_CONVERSION,"enum-conversion"},

    {W_ADDRESS, "address"},
    {W_UNUSED_PARAMETER, "unused-parameter"},
    {W_DECLARATOR_HIDE, "hide-declarator"},
    {W_TYPEOF_ARRAY_PARAMETER, "typeof-parameter"},
    {W_ATTRIBUTES, "attributes"},
    {W_UNUSED_VALUE, "unused-value"},
    {W_STYLE, "style"},
    {W_COMMENT,"comment"},
    {W_LINE_SLICING,"line-slicing"},
    {W_SWITCH, "switch"},
    {W_UNSUAL_NULL_POINTER_CONSTANT, "unusual-null"},

    {W_DISCARDED_QUALIFIERS, "discarded-qualifiers"},
    {W_UNINITIALZED, "uninitialized"},
    {W_RETURN_LOCAL_ADDR, "return-local-addr"},
    {W_DIVIZION_BY_ZERO,"div-by-zero"},
    {W_CONSTANT_VALUE, "constant-value"},
    {W_SIZEOF_ARRAY_ARGUMENT, "sizeof-array-argument"},

    {W_STRING_SLICED,"string-slicing"},
    {W_DECLARATOR_STATE,"declarator-state"},
    {W_OWNERSHIP_MISSING_OWNER_QUALIFIER, "missing-owner-qualifier"},
    {W_OWNERSHIP_NOT_OWNER,"not-owner"},
    {W_OWNERSHIP_USING_TEMPORARY_OWNER,"temp-owner"},
    {W_OWNERSHIP_MOVE_ASSIGNMENT_OF_NON_OWNER, "non-owner-move"},
    {W_OWNERSHIP_NON_OWNER_TO_OWNER_ASSIGN, "non-owner-to-owner-move"},
    {W_OWNERSHIP_DISCARDING_OWNER, "discard-owner"},

    {W_OWNERSHIP_NON_OWNER_MOVE, "non-owner-move"},
    {W_FLOW_DIVIZION_BY_ZERO, "flow-div-by-zero"},

    /////////////////////////////////////////////////////////////////////////
    {W_FLOW_NON_NULL, "flow-not-null"},
    {W_FLOW_MISSING_DTOR, "missing-destructor"},
    {W_FLOW_MOVED, "using-moved-object"},
    {W_FLOW_UNINITIALIZED, "analyzer-maybe-uninitialized"},
    {W_FLOW_NULL_DEREFERENCE, "analyzer-null-dereference"}, // -fanalyzer
    {W_FLOW_MAYBE_NULL_TO_NON_OPT_ARG, "analyzer-non-opt-arg"},
    {W_FLOW_LIFETIME_ENDED, "lifetime-ended"},
    {W_FLOW_NULLABLE_TO_NON_NULLABLE, "nullable-to-non-nullable"},

    /////////////////////////////////////////////////////////////////////
    {W_MUST_USE_ADDRESSOF, "must-use-address-of"},
    {W_PASSING_NULL_AS_ARRAY, "null-as-array"},
    {W_INCOMPATIBLE_ENUN_TYPES, "incompatible-enum"},
    {W_MULTICHAR_ERROR, "multi-char"},
    {W_ARRAY_INDIRECTION,"array-indirection"},
    {W_OUT_OF_BOUNDS, "out-of-bounds"},
    {W_ASSIGNMENT_OF_ARRAY_PARAMETER, "array-parameter-assignment"},
    {W_CONDITIONAL_IS_CONSTANT,"conditional-constant"},

    {W_CONST_NOT_INITIALIZED, "const-init"},
    {W_NULL_CONVERTION, "null-conversion"},
    {W_IMPLICITLY_UNSIGNED_LITERAL, "implicitly-unsigned-literal"},
    {W_INTEGER_OVERFLOW, "overflow"},
    {W_ARRAY_SIZE, "array-size"},
    {W_EMPTY_STATEMENT, "empty-statement"},
    {W_ERROR_INCOMPATIBLE_TYPES, "incompatible-types"},
    {W_UNUSED_LABEL, "unused-label"}
};

void diagnostic_remove(struct diagnostic* d, enum diagnostic_id w)
{
    if (!is_diagnostic_configurable(w))
        return; //ops

    if ((d->errors & (1ULL << w)) != 0)
        d->errors &= ~(1ULL << w);

    if ((d->warnings & (1ULL << w)) != 0)
        d->warnings &= ~(1ULL << w);

    if ((d->notes & (1ULL << w)) != 0)
        d->notes &= ~(1ULL << w);
}

int get_diagnostic_type(struct diagnostic* d, enum diagnostic_id w)
{
    if (is_diagnostic_configurable(w))
    {
        if ((d->errors & (1ULL << w)) != 0)
            return 3;

        if ((d->warnings & (1ULL << w)) != 0)
            return 2;

        if ((d->notes & (1ULL << w)) != 0)
            return 1;
    }


    if (is_diagnostic_note(w))
        return 1;

    if (is_diagnostic_warning(w))
        return 2;

    if (is_diagnostic_error(w))
        return 3;

    return 3; //errors
}

int get_diagnostic_phase(enum diagnostic_id w)
{
    switch (w)
    {
        //TODO should be everything that starts with FLOW
    case W_FLOW_MISSING_DTOR:
    case W_FLOW_UNINITIALIZED:
    case W_FLOW_MOVED:
    case W_FLOW_NULL_DEREFERENCE:
    case W_FLOW_MAYBE_NULL_TO_NON_OPT_ARG:
    case W_FLOW_NON_NULL:
    case W_FLOW_LIFETIME_ENDED:
    case W_FLOW_DIVIZION_BY_ZERO:

        return 2; /*returns 2 if it flow analysis*/
    default:
        break;
    }
    return 0;
}


enum diagnostic_id  get_warning(const char* wname)
{
    if (!(wname[0] == '-' || wname[0] == 'E'))
    {
        return 0;
    }

    if (wname[0] == '-' && wname[1] == 'W')
    {
        for (int j = 0; j < sizeof(s_warnings) / sizeof(s_warnings[0]); j++)
        {
            if (strncmp(s_warnings[j].name, wname + 2, strlen(s_warnings[j].name)) == 0)
            {
                return s_warnings[j].w;
            }
        }
    }
    else if (wname[1] == 'E')
    {
        int ec = atoi(wname + 2);
        return ec;

    }
    return 0;
}

unsigned long long  get_warning_bit_mask(const char* wname)
{
    const bool disable_warning = wname[2] == 'n' && wname[3] == 'o';
    const char* final_name = disable_warning ? wname + 5 : wname + 2;
    assert(wname[0] == '-');
    for (int j = 0; j < sizeof(s_warnings) / sizeof(s_warnings[0]); j++)
    {

        if (strncmp(s_warnings[j].name, final_name, strlen(s_warnings[j].name)) == 0)
        {
            return (1ULL << ((unsigned long long)s_warnings[j].w));
        }
    }
    return 0;
}

int get_warning_name(enum diagnostic_id w, int n, char buffer[/*n*/])
{
    if (is_diagnostic_configurable(w))
    {
        //TODO because s_warnings is _Ctor of order ....
        //this is a linear seatch instead of just index! TODOD
        for (int j = 0; j < sizeof(s_warnings) / sizeof(s_warnings[0]); j++)
        {
            if (s_warnings[j].w == w)
            {
                snprintf(buffer, n, "-W%s", s_warnings[j].name);
                return 0;
            }
        }
    }
    else
    {
        snprintf(buffer, n, "E%d", w);
    }

    return 0;//"";
}

int fill_options(struct options* options,
    int argc,
    const char** argv)
{

    /*
       default at this moment is same as -Wall
    */
    options->diagnostic_stack.stack[0] = default_diagnostic;

    options->diagnostic_stack.stack[0].warnings &= ~(1ULL << W_STYLE);
    //&~items;


    /*first loop used to collect options*/
    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] != '-')
            continue;

        if (argv[i][1] == 'I' ||
            argv[i][1] == 'D')
        {
            /*
              Valid, but handled with preprocessor
            */
            continue;
        }

        if (strcmp(argv[i], "-no-output") == 0)
        {
            options->no_output = true;
            continue;
        }

        if (strcmp(argv[i], "-const-literal") == 0)
        {
            options->const_literal = true;
            continue;
        }

        if (strcmp(argv[i], "-o") == 0)
        {
            if (i + 1 < argc)
            {
                strcpy(options->output, argv[i + 1]);
                i++;
            }
            else
            {
                //ops
            }
            continue;
        }

        if (strcmp(argv[i], "-sarif-path") == 0)
        {
            if (i + 1 < argc)
            {
                strcpy(options->sarifpath, argv[i + 1]);
                i++;
            }
            else
            {
                //ops
            }
            continue;
        }

        if (strcmp(argv[i], "-H") == 0)
        {
            options->show_includes = true;
            continue;
        }

        if (strcmp(argv[i], "-E") == 0)
        {
            options->preprocess_only = true;
            continue;
        }

        if (strcmp(argv[i], "-preprocess-def-macro") == 0)
        {
            options->preprocess_def_macro = true;
            continue;
        }

        if (strcmp(argv[i], "-sarif") == 0)
        {
            options->sarif_output = true;
            continue;
        }

        if (strcmp(argv[i], "-fanalyzer") == 0)
        {
            options->flow_analysis = true;
            continue;
        }

        if (strcmp(argv[i], "-nullchecks") == 0)
        {
            options->null_checks_enabled = true;
            continue;
        }

        if (strcmp(argv[i], "-debug") == 0)
        {
            options->do_static_debug = true;
            if (i + 1 < argc)
            {
                i++;
                options->static_debug_lines = atoi(argv[i]);
            }
            else
            {
                //ops
            }
            continue;
        }

        if (strcmp(argv[i], "-ownership=enable") == 0)
        {
            options->ownership_enabled = true;
            continue;
        }

        if (strcmp(argv[i], "-ownership=disable") == 0)
        {
            options->ownership_enabled = false;
            continue;
        }

        if (strcmp(argv[i], "-test-mode") == 0)
        {
            options->test_mode = true;
            continue;
        }

        if (strcmp(argv[i], "-msvc-output") == 0 ||
            strcmp(argv[i], "-fdiagnostics-format=msvc") == 0) //same as clang
        {
            options->visual_studio_ouput_format = true;
            continue;
        }


        //
        if (strcmp(argv[i], "-style=cake") == 0)
        {
            options->style = STYLE_CAKE;
            continue;
        }

        if (strcmp(argv[i], "-style=gnu") == 0)
        {
            options->style = STYLE_GNU;
            continue;
        }

        if (strcmp(argv[i], "-style=microsoft") == 0)
        {
            options->style = STYLE_GNU;
            continue;
        }

        if (strcmp(argv[i], "-nullable=disable") == 0)
        {
            options->null_checks_enabled = false;
            unsigned long long w = NULLABLE_DISABLE_REMOVED_WARNINGS;
            options->diagnostic_stack.stack[0].warnings &= ~w;
            continue;
        }

        if (strcmp(argv[i], "-nullable=enabled") == 0)
        {
            options->null_checks_enabled = true;
            continue;
        }

        if (strcmp(argv[i], "-autoconfig") == 0 ||
            strcmp(argv[i], "-auto-config") == 0)
        {
            options->auto_config = true;
            continue;
        }

        if (strstr(argv[i], "-target") != NULL)
        {
            if (strcmp(argv[i], "-target=x86_x64_gcc") == 0)
            {
                options->target = TARGET_X86_X64_GCC;
                continue;
            }

            if (strcmp(argv[i], "-target=x64_msvc") == 0)
            {
                options->target = TARGET_X64_MSVC;
                continue;
            }

            if (strcmp(argv[i], "-target=x86_msvc") == 0)
            {
                options->target = TARGET_X86_MSVC;
                continue;
            }

            printf("invalid target. Options are: x86_x64_gcc / x64_msvc / x86_msvc");
        }


        if (strcmp(argv[i], "-std=c2x") == 0 ||
            strcmp(argv[i], "-std=c23") == 0)
        {
            options->input = LANGUAGE_C23;
            continue;
        }
        if (strcmp(argv[i], "-std=cxx") == 0)
        {
            options->input = LANGUAGE_CAK;
            continue;
        }

        //warnings
        if (argv[i][1] == 'W')
        {
            if (strcmp(argv[i], "-Wall") == 0)
            {
                options->diagnostic_stack.stack[0].warnings = ~0ULL;
                continue;
            }
            const bool disable_warning = (argv[i][2] == 'n' && argv[i][3] == 'o');

            unsigned long long w = get_warning_bit_mask(argv[i]);

            if (w == 0)
            {
                printf("unknown warning '%s'", argv[i]);
                return 1;
            }


            if (disable_warning)
            {
                options->diagnostic_stack.stack[0].warnings &= ~w;
            }
            else
            {
                if (w == W_STYLE)
                    options->diagnostic_stack.stack[0].warnings |= w;
                else
                    options->diagnostic_stack.stack[0].notes |= w;
            }
            continue;
        }

        if (strcmp(argv[i], "-dump-tokens") == 0)
        {
            options->dump_tokens = true;
            continue;
        }

        if (strcmp(argv[i], "-dump-pp-tokens") == 0)
        {
            options->dump_pptokens = true;
            continue;
        }

        if (strcmp(argv[i], "-disable-assert") == 0)
        {
            options->disable_assert = true;
            continue;
        }

        printf("unknown option '%s'", argv[i]);
        return 1;
    }
    return 0;
}


void print_help()
{
#define CAKE LIGHTCYAN "cake " RESET 

    const char* options =
        LIGHTGREEN "Usage :" RESET CAKE LIGHTBLUE "[OPTIONS] source1.c source2.c ...\n" RESET
        "\n"
        LIGHTGREEN "Samples:\n" RESET
        "\n"
        WHITE "    " CAKE " source.c\n" RESET
        "    Compiles source.c and outputs /out/source.c\n"
        "\n"
        WHITE "    " CAKE " file.c -o file.cc && cl file.cc\n" RESET
        "    Compiles file.c and outputs file.cc then use cl to compile file.cc\n"
        "\n"
        WHITE "    " CAKE " file.c -direct-compilation -o file.cc && cl file.cc\n" RESET
        "    Compiles file.c and outputs file.cc for direct compilation then use cl to compile file.cc\n"
        "\n"
        LIGHTGREEN "Options:\n" RESET
        "\n"
        LIGHTCYAN "  -I                   " RESET " Adds a directory to the list of directories searched for include files \n"
        "                        (On windows, if you run cake at the visual studio command prompt cake \n"
        "                        uses the same include files used by msvc )\n"
        "\n"
        LIGHTCYAN "  -auto-config           " RESET "Generates cakeconfig.h with include directories\n"
        "\n"
        LIGHTCYAN "  -no-output            " RESET "Cake will not generate output\n"
        "\n"
        LIGHTCYAN "  -D                    " RESET "Defines a preprocessing symbol for a source file \n"
        "\n"
        LIGHTCYAN "  -E                    " RESET "Copies preprocessor output to standard output \n"
        "\n"
        LIGHTCYAN "  -o name.c             " RESET "Defines the output name when compiling one file\n"
        "\n"
        LIGHTCYAN "  -std=standard         " RESET "Assume that the input sources are for standard (c89, c99, c11, c2x, cxx) \n"
        "                        (not implemented yet, input is considered C23)                    \n"
        "\n"
        LIGHTCYAN "  -no-discard           " RESET "Makes [[nodiscard]] default implicitly \n"
        "\n"
        LIGHTCYAN "  -Wname -Wno-name      " RESET "Enables or disable warning\n"
        "\n"
        LIGHTCYAN "  -fanalyzer            " RESET "Runs flow analysis -  required for ownership\n"
        "\n"
        LIGHTCYAN "  -sarif                " RESET "Generates sarif files\n"
        "\n"
        LIGHTCYAN "  -H                    " RESET "Print the name of each header file used\n"
        "\n"
        LIGHTCYAN "  -sarif-path           " RESET "Set sarif output dir\n"
        "\n"
        LIGHTCYAN "  -msvc-output          " RESET "Output is compatible with visual studio\n"
        "\n"
        LIGHTCYAN "  -dump-tokens          " RESET "Output tokens before preprocessor\n"
        "\n"
        LIGHTCYAN "  -dump-pp-tokens       " RESET "Output tokens after preprocessor\n"
        "\n"
        LIGHTCYAN "  -disable-assert       " RESET "disables built-in assert\n"
        "\n"
        LIGHTCYAN "  -const-literal        " RESET "literal string becomes const\n"
        "\n"
        LIGHTCYAN "  -preprocess-def-macro " RESET "preprocess def macros after expansion\n"

        "More details at http://thradams.com/cake/manual.html\n"
        ;

    printf("%s", options);
}

#ifdef TEST

void test_get_warning_name()
{
    char dbg_name[100];
    get_warning_name(W_FLOW_MISSING_DTOR, sizeof dbg_name, dbg_name);
    assert(strcmp(dbg_name, "-Wmissing-destructor") == 0);

    unsigned long long  flags = get_warning_bit_mask(dbg_name);
    assert(flags == (1ULL << W_FLOW_MISSING_DTOR));


    get_warning_name(W_STYLE, sizeof dbg_name, dbg_name);
    assert(strcmp(dbg_name, "-Wstyle") == 0);

    unsigned long long  flags2 = get_warning_bit_mask(dbg_name);
    assert(flags2 == (1ULL << W_STYLE));
}

#endif


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable




/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
 *
 *  struct object is used to compute the compile time expressions (including constexpr)
 *
*/

//#pragma once



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once


struct parser_ctx;



enum type_category
{
    TYPE_CATEGORY_ITSELF,
    TYPE_CATEGORY_FUNCTION,
    TYPE_CATEGORY_ARRAY,
    TYPE_CATEGORY_POINTER,
};

enum attribute_flags
{
    STD_ATTRIBUTE_NONE = 0,
    STD_ATTRIBUTE_DEPRECATED = 1 << 0,
    STD_ATTRIBUTE_FALLTHROUGH = 1 << 1,
    STD_ATTRIBUTE_MAYBE_UNUSED = 1 << 2,
    STD_ATTRIBUTE_NODISCARD = 1 << 3,
    STD_ATTRIBUTE_NORETURN = 1 << 4,
    STD_ATTRIBUTE_UNSEQUENCED = 1 << 5,
    STD_ATTRIBUTE_REPRODUCIBLE = 1 << 6,

    //TODO decide attribute or not
    CAKE_ATTRIBUTE_CTOR = 1 << 7,
    CAKE_ATTRIBUTE_DTOR = 1 << 8,

    /*
     1 == 2 results in int in C
     lets add extra flag here
     not sure what is the best place to put in
     type specifier my generate some error
    */
    CAKE_HIDDEN_ATTRIBUTE_LIKE_BOOL = 1 << 25,
    // 'a'
    CAKE_HIDDEN_ATTRIBUTE_INT_LIKE_CHAR = 1 << 26,

    /*
       Storing calling convention on attributes to consuming less memory
    */
    CAKE_ATTRIBUTE_FASTCALL = 1 << 27,
    CAKE_ATTRIBUTE_STDCALL = 1 << 28,
    CAKE_ATTRIBUTE_CDECL = 1 << 29

};

enum type_specifier_flags
{
    TYPE_SPECIFIER_NONE = 0,
    TYPE_SPECIFIER_VOID = 1 << 0,
    TYPE_SPECIFIER_CHAR = 1 << 1,
    TYPE_SPECIFIER_SHORT = 1 << 2,
    TYPE_SPECIFIER_INT = 1 << 3,
    TYPE_SPECIFIER_LONG = 1 << 4,

    TYPE_SPECIFIER_FLOAT = 1 << 5,
    TYPE_SPECIFIER_DOUBLE = 1 << 6,
    TYPE_SPECIFIER_SIGNED = 1 << 7,
    TYPE_SPECIFIER_UNSIGNED = 1 << 8,
    TYPE_SPECIFIER_BOOL = 1 << 9,
    TYPE_SPECIFIER_COMPLEX = 1 << 10,
    TYPE_SPECIFIER_DECIMAL32 = 1 << 11,
    TYPE_SPECIFIER_DECIMAL64 = 1 << 12,
    TYPE_SPECIFIER_DECIMAL128 = 1 << 13,
    TYPE_SPECIFIER_ATOMIC = 1 << 14,
    TYPE_SPECIFIER_STRUCT_OR_UNION = 1 << 15,
    TYPE_SPECIFIER_ENUM = 1 << 16,
    TYPE_SPECIFIER_TYPEDEF = 1 << 17,


    TYPE_SPECIFIER_INT8 = 1 << 18,
    TYPE_SPECIFIER_INT16 = 1 << 19,
    TYPE_SPECIFIER_INT32 = 1 << 20,
    TYPE_SPECIFIER_INT64 = 1 << 21,

    TYPE_SPECIFIER_LONG_LONG = 1 << 22,

    TYPE_SPECIFIER_TYPEOF = 1 << 23,

    TYPE_SPECIFIER_NULLPTR_T = 1 << 24,

    TYPE_SPECIFIER_GCC__BUILTIN_VA_LIST = 1 << 25
};



enum type_specifier_flags get_wchar_type_specifier(enum target target);
enum type_specifier_flags get_size_t_specifier(enum target target);


enum type_qualifier_flags
{
    TYPE_QUALIFIER_NONE,
    TYPE_QUALIFIER_CONST = 1 << 0,
    TYPE_QUALIFIER_RESTRICT = 1 << 1,
    TYPE_QUALIFIER_VOLATILE = 1 << 2,
    TYPE_QUALIFIER__ATOMIC = 1 << 3,



    /*ownership extensions*/
    TYPE_QUALIFIER_OWNER = 1 << 4,
    TYPE_QUALIFIER_VIEW = 1 << 5,
    TYPE_QUALIFIER_OPT = 1 << 6,

    /*function contract*/
    TYPE_QUALIFIER_DTOR = 1 << 7,
    TYPE_QUALIFIER_CTOR = 1 << 8,

    TYPE_QUALIFIER_MSVC_PTR32 = 1 << 9,
    TYPE_QUALIFIER_MSVC_PTR64 = 1 << 10,

};

enum storage_class_specifier_flags
{
    STORAGE_SPECIFIER_NONE = 0,
    STORAGE_SPECIFIER_TYPEDEF = 1 << 0,
    STORAGE_SPECIFIER_EXTERN = 1 << 1,
    STORAGE_SPECIFIER_STATIC = 1 << 2,
    STORAGE_SPECIFIER_THREAD_LOCAL = 1 << 3,
    STORAGE_SPECIFIER_AUTO = 1 << 4,
    STORAGE_SPECIFIER_REGISTER = 1 << 5,
    STORAGE_SPECIFIER_CONSTEXPR = 1 << 6,

    /*extra flag just to annotate this*/
    STORAGE_SPECIFIER_CONSTEXPR_STATIC = 1 << 7,

    /*it is a function parameter*/
    STORAGE_SPECIFIER_PARAMETER = 1 << 11,
    STORAGE_SPECIFIER_BLOCK_SCOPE = 1 << 12,

    STORAGE_SPECIFIER_FUNCTION_RETURN = 1 << 13,
    STORAGE_SPECIFIER_FUNCTION_RETURN_NODISCARD = 1 << 14,
};

bool is_automatic_variable(enum storage_class_specifier_flags f);
enum function_specifier_flags
{
    FUNCTION_SPECIFIER_NONE = 0,
    FUNCTION_SPECIFIER_INLINE = 1 << 0,
    FUNCTION_SPECIFIER_NORETURN = 1 << 1,
};

enum alignment_specifier_flags
{
    ALIGNMENT_SPECIFIER_NONE = 0,
    ALIGNMENT_SPECIFIER_8_FLAGS = 1 << 0,
    ALIGNMENT_SPECIFIER_16_FLAGS = 1 << 1,
    ALIGNMENT_SPECIFIER_32_FLAGS = 1 << 2,
    ALIGNMENT_SPECIFIER_64_FLAGS = 1 << 3,
    ALIGNMENT_SPECIFIER_128_FLAGS = 1 << 4,
};

enum msvc_declspec_flags
{
    //https://learn.microsoft.com/en-us/cpp/cpp/declspec?view=msvc-170
    MSVC_DECLSPEC_NONE = 0,
    MSVC_DECLSPEC_ALIGN_8_FLAG = 1 << 1, //( NUMBER )
    MSVC_DECLSPEC_ALIGN_16_FLAG = 1 << 2, //( NUMBER )
    MSVC_DECLSPEC_ALIGN_32_FLAG = 1 << 3, //( NUMBER )
    MSVC_DECLSPEC_ALIGN_64_FLAG = 1 << 4, //( NUMBER )

    MSVC_DECLSPEC_ALLOCATE_FLAG = 1 << 5, //(" SEGNAME ")
    MSVC_DECLSPEC_ALLOCATOR_FLAG = 1 << 6, //
    MSVC_DECLSPEC_APPDOMAIN_FLAG = 1 << 7, //
    MSVC_DECLSPEC_CODE_SEG_FLAG = 1 << 8, //(" SEGNAME ")
    MSVC_DECLSPEC_DEPRECATED_FLAG = 1 << 9, //
    MSVC_DECLSPEC_DLLIMPORT_FLAG = 1 << 10, //
    MSVC_DECLSPEC_DLLEXPORT_FLAG = 1 << 11, //
    MSVC_DECLSPEC_EMPTY_BASES_FLAG = 1 << 12, //
    MSVC_DECLSPEC_HYBRID_PATCHABLE_FLAG = 1 << 13, //
    MSVC_DECLSPEC_JITINTRINSIC_FLAG = 1 << 14, //
    MSVC_DECLSPEC_NAKED_FLAG = 1 << 15, //
    MSVC_DECLSPEC_NOALIAS_FLAG = 1 << 16, //
    MSVC_DECLSPEC_NOINLINE_FLAG = 1 << 17, //
    MSVC_DECLSPEC_NORETURN_FLAG = 1 << 18, //
    MSVC_DECLSPEC_NOTHROW_FLAG = 1 << 19, //
    MSVC_DECLSPEC_NOVTABLE_FLAG = 1 << 20, //
    MSVC_DECLSPEC_NO_SANITIZE_ADDRESS_FLAG = 1 << 21, //
    MSVC_DECLSPEC_PROCESS_FLAG = 1 << 22, //
    MSVC_DECLSPEC_PROPERTY_FLAG = 1 << 23, //( { GET=GET-FUNC-NAME | ,PUT=PUT-FUNC-NAME } )
    MSVC_DECLSPEC_RESTRICT_FLAG = 1 << 24, //
    MSVC_DECLSPEC_SAFEBUFFERS_FLAG = 1 << 25, //
    MSVC_DECLSPEC_SELECTANY_FLAG = 1 << 26, //
    MSVC_DECLSPEC_SPECTRE_FLAG = 1 << 27, //(NOMITIGATION)
    MSVC_DECLSPEC_THREAD_FLAG = 1 << 28, //
    MSVC_DECLSPEC_UUID_FLAG = 1 << 29, //(" COMOBJECTGUID ")
};

struct declarator;
struct type;

enum assigment_type
{
    ASSIGMENT_TYPE_RETURN,    // T f() { return b; }
    ASSIGMENT_TYPE_PARAMETER, // void f(T a); f(b);
    ASSIGMENT_TYPE_OBJECTS,   // a = b
    ASSIGMENT_TYPE_INIT,   // T a = b
};


struct type_list
{
    struct type* _Owner _Opt head;
    struct type* _Opt tail;
};

void type_list_destroy(_Dtor struct type_list* p_type_list);
void type_list_push_back(struct type_list* books, struct type* _Owner new_book);
void type_list_push_front(struct type_list* books, struct type* _Owner new_book);


struct param;

struct param_list
{
    bool is_var_args;
    bool is_void;
    struct param* _Owner _Opt head;
    struct param* _Opt tail;
};

void param_list_destroy(_Dtor struct param_list* p);
void param_list_add(struct param_list* p, struct param* _Owner p_item);

struct type
{
    enum type_category category;

    enum attribute_flags  attributes_flags;
    enum msvc_declspec_flags msvc_declspec_flags;
    enum alignment_specifier_flags alignment_specifier_flags;
    enum type_specifier_flags type_specifier_flags;
    enum type_qualifier_flags type_qualifier_flags;
    enum storage_class_specifier_flags storage_class_specifier_flags;

    const char* _Owner _Opt name_opt;

    struct struct_or_union_specifier* _Opt struct_or_union_specifier;
    const struct enum_specifier* _Opt enum_specifier;

    //Expression used as array size. Can be constant or not constant (VLA)
    const struct expression* _Opt array_num_elements_expression;

    size_t num_of_elements;
    bool has_static_array_size;

    /*
      address_of is true when the type is created by address of operator.
      This is used to create _Dtor pointer.
    */
    bool address_of;

    struct param_list params;
    struct type* _Owner _Opt next;
};

const struct param_list* _Opt type_get_func_or_func_ptr_params(const struct type* p_type);

struct param
{
    struct type type;
    struct param* _Owner _Opt next;
};

void print_type(struct osstream* ss, const  struct type* type, enum target target);
void print_type_no_names(struct osstream* ss, const struct type* p_type, enum target target);

void print_item(struct osstream* ss, bool* first, const char* item);
struct type type_dup(const struct type* p_type);
void type_set(struct type* a, const struct type* b);
void type_destroy(_Opt _Dtor struct type* p_type);

struct type type_common(const struct type* p_type1, const struct type* p_type2, enum target target);
struct type get_array_item_type(const struct type* p_type);
struct type type_remove_pointer(const struct type* p_type);

bool type_is_essential_bool(const struct type* p_type);
bool type_is_essential_char(const struct type* p_type);

bool type_is_enum(const struct type* p_type);
bool type_is_array(const struct type* p_type);

bool type_is_ctor(const struct type* p_type);
bool type_is_const(const struct type* p_type);
bool type_is_constexpr(const struct type* p_type);
bool type_is_const_or_constexpr(const struct type* p_type);
bool type_is_opt(const struct type* p_type, bool nullable_enabled);
bool type_is_view(const struct type* p_type);

bool type_is_owner(const struct type* p_type);
bool type_is_pointed_dtor(const struct type* p_type);
bool type_is_owner_or_pointer_to_dtor(const struct type* p_type);

bool type_is_pointer_to_const(const struct type* p_type);
bool type_is_pointer(const struct type* p_type);
bool type_is_pointer_to_out(const struct type* p_type);

bool type_is_nullptr_t(const struct type* p_type);
bool type_is_void_ptr(const struct type* p_type);
bool type_is_integer(const struct type* p_type);
bool type_is_char(const struct type* p_type);
bool type_is_array_of_char(const struct type* p_type);
bool type_is_unsigned_integer(const struct type* p_type);
bool type_is_signed_integer(const struct type* p_type);
bool type_is_floating_point(const struct type* p_type);
int type_get_integer_rank(const struct type* p_type1);

bool type_is_arithmetic(const struct type* p_type);

bool type_is_struct_or_union(const struct type* p_type);
bool type_is_union(const struct type* p_type);

bool type_is_void(const struct type* p_type);
bool type_is_function_or_function_pointer(const struct type* p_type);
bool type_is_function(const struct type* p_type);
bool type_is_nodiscard(const struct type* p_type);

bool type_is_deprecated(const struct type* p_type);
bool type_is_maybe_unused(const struct type* p_type);
bool type_is_pointer_or_array(const struct type* p_type);
bool type_is_same(const struct type* a, const struct type* b, bool compare_qualifiers);
bool type_is_compatible(const struct type* a, const struct type* b);
bool type_is_scalar(const struct type* p_type);
bool type_has_attribute(const struct type* p_type, enum attribute_flags attributes);
bool type_is_bool(const struct type* p_type);
bool type_is_decimal128(const struct type* p_type);
bool type_is_decimal64(const struct type* p_type);
bool type_is_decimal32(const struct type* p_type);
bool type_is_long_double(const struct type* p_type);
bool type_is_double(const struct type* p_type);
bool type_is_float(const struct type* p_type);
bool type_is_int(const struct type* p_type);
bool type_is_unsigned_int(const struct type* p_type);
bool type_is_empty(const struct type* p_type);

bool type_is_vla(const struct type* p_type);

struct type type_get_enum_type(const struct type* p_type);

struct argument_expression;
void check_argument_and_parameter(struct parser_ctx* ctx,
    struct argument_expression* current_argument,
    struct type* paramer_type,
    int param_num);

struct type type_convert_to(const struct type* p_type, enum language_version target);
struct type type_lvalue_conversion(const struct type* p_type, bool nullchecks_enabled);
void type_remove_qualifiers(struct type* p_type);
void type_add_const(struct type* p_type);
void type_swap(struct type* a, struct type* b);
void type_clear(struct type* a);
void type_integer_promotion(struct type* a);


struct type type_remove_pointer(const struct type* p_type);
struct type get_array_item_type(const struct type* p_type);

struct type type_param_array_to_pointer(const struct type* p_type, bool null_checks_enabled);

struct type type_make_literal_string(int size, enum type_specifier_flags chartype, enum type_qualifier_flags qualifiers, enum target target);
struct type type_make_int();
struct type type_make_int_bool_like();
struct type type_make_size_t(enum target target);
struct type type_make_long_double();
struct type type_make_double();
struct type type_make_float();


struct type type_make_enumerator(const struct enum_specifier* enum_specifier);
struct type make_void_type();
struct type make_void_ptr_type();
struct type make_size_t_type(enum target target);
struct type make_with_type_specifier_flags(enum type_specifier_flags f);


struct type get_function_return_type(const struct type* p_type);
bool function_returns_void(const struct type* p_type);


enum sizeof_error
{
    ESIZEOF_NONE = 0,
    ESIZEOF_OVERLOW,
    ESIZEOF_VLA,
    ESIZEOF_INCOMPLETE,
    ESIZEOF_FUNCTION
};

enum sizeof_error type_get_sizeof(const struct type* p_type, size_t* size, enum target target);
enum sizeof_error type_get_offsetof(const struct type* p_type, const char* member, size_t* size, enum target target);

size_t type_get_alignof(const struct type* p_type, enum target target);

struct type type_add_pointer(const struct type* p_type, bool null_checks_enabled);
void type_print(const struct type* a, enum target target);
void type_println(const struct type* a, enum target target);

enum type_category type_get_category(const struct type* p_type);
void print_type_qualifier_specifiers(struct osstream* ss, const struct type* type, enum target target);

void type_visit_to_mark_anonymous(struct type* p_type);

void type_set_qualifiers_using_declarator(struct type* p_type, struct declarator* pdeclarator);
void type_merge_qualifiers_using_declarator(struct type* p_type, struct declarator* pdeclarator);

void print_type_declarator(struct osstream* ss, const struct type* p_type, enum target target);
void type_remove_names(struct type* p_type);
const struct type* type_get_specifer_part(const struct type* p_type);
void print_msvc_declspec(struct osstream* ss, bool* first, enum msvc_declspec_flags  msvc_declspec_flags);

struct parser_ctx;

enum object_value_type 
{

    TYPE_SIGNED_INT,
    TYPE_UNSIGNED_INT,

    TYPE_BOOL,

    TYPE_SIGNED_CHAR,
    TYPE_UNSIGNED_CHAR,

    TYPE_SIGNED_SHORT,
    TYPE_UNSIGNED_SHORT,

    TYPE_SIGNED_LONG,
    TYPE_UNSIGNED_LONG,

    TYPE_SIGNED_LONG_LONG,
    TYPE_UNSIGNED_LONG_LONG,

    TYPE_FLOAT,
    TYPE_DOUBLE,
    TYPE_LONG_DOUBLE,
    
    TYPE_VOID_PTR,
    TYPE_VOID_PTR_REF,
};

enum object_value_state
{    
    CONSTANT_VALUE_STATE_UNINITIALIZED,        
    CONSTANT_VALUE_STATE_ANY,
    CONSTANT_VALUE_STATE_CONSTANT,
    //flow analysis
    CONSTANT_VALUE_NOT_EQUAL,
    CONSTANT_VALUE_EQUAL,
};

struct object
{    
    enum object_value_state state;
    enum object_value_type value_type;
    struct type type; //TODO to be removed

    const char* _Opt _Owner debug_name; //TODO we can remove this passing tthe type to print function

    union {
        _Bool bool_value;

        signed char signed_char_value;
        unsigned char unsigned_char_value;

        signed short signed_short_value;
        unsigned short unsigned_short_value;

        signed int signed_int_value;
        unsigned int unsigned_int_value;

        signed long signed_long_value;
        unsigned long unsigned_long_value;

        signed long long signed_long_long_value;
        unsigned long long unsigned_long_long_value;

        float float_value;
        double double_value;
        long double long_double_value;            

        void * _Opt void_pointer;
    } value;
    struct object* _Opt parent; //to be removed
    struct expression * _Opt p_init_expression;
    
    struct object* _Opt _Owner members;
    struct object* _Opt _Owner next;
};

void object_swap(struct object* a, struct object* b);
void object_print_value_debug(const struct object* a);
void object_destroy(_Opt _Dtor struct object* p);
void object_delete(struct object* _Opt _Owner p);
bool object_has_constant_value(const struct object* a);
void object_to_string(const struct object* a, char buffer[], int sz);


//Make constant value
struct object            object_make_wchar_t(wchar_t value);
struct object             object_make_size_t(size_t value);
struct object               object_make_bool(bool value);
struct object            object_make_nullptr();
struct object        object_make_signed_char(signed char value);
struct object      object_make_unsigned_char(unsigned char value);
struct object       object_make_signed_short(signed short value);
struct object     object_make_unsigned_short(unsigned short value);
struct object         object_make_signed_int(signed int value);
struct object       object_make_unsigned_int(unsigned int value);

struct object        object_make_signed_long(signed long value);
struct object      object_make_unsigned_long(unsigned long value);
struct object   object_make_signed_long_long(signed long long value);
struct object object_make_unsigned_long_long(unsigned long long value);
struct object              object_make_float(float value);
struct object             object_make_double(double value);
struct object        object_make_long_double(long double value);
struct object        object_make_reference(struct object* object);
struct object        object_make_pointer(struct object* object);
struct object        object_make_null_pointer();


//dynamic cast
void object_set_signed_int(struct object* a, long long value);
void object_set_unsigned_int(struct object* a, unsigned long long value);

struct object object_cast(enum object_value_type e, const struct object* a);
enum object_value_type  type_specifier_to_object_type(const enum type_specifier_flags type_specifier_flags);

errno_t object_increment_value(struct object* a);

//static cast
signed char object_to_signed_char(const struct object* a);
unsigned char object_to_unsigned_char(const struct object* a);
signed short object_to_signed_short(const struct object* a);
unsigned short object_to_unsigned_short(const struct object* a);
signed int object_to_signed_int(const struct object* a);
unsigned int object_to_unsigned_int(const struct object* a);
signed long object_to_signed_long(const struct object* a);
unsigned long object_to_unsigned_long(const struct object* a);
signed long long object_to_signed_long_long(const struct object* a);
unsigned long long object_to_unsigned_long_long(const struct object* a);
float object_to_float(const struct object* a);
double object_to_double(const struct object* a);
long double object_to_long_double(const struct object* a);
bool object_to_bool(const struct object* a);

int object_to_str(const struct object* a, int n, char str[/*n*/]);

int object_greater_than_or_equal(const struct object* a, const struct object* b);
int object_smaller_than_or_equal(const struct object* a, const struct object* b);
int object_equal(const struct object* a, const struct object* b);
int object_not_equal(const struct object* a, const struct object* b);
struct object object_add(const struct object* a, const struct object* b);
struct object object_sub(const struct object* a, const struct object* b);


//Overflow checks
bool unsigned_long_long_sub(_Ctor unsigned long long* result, unsigned long long a, unsigned long long b);
bool unsigned_long_long_mul(_Ctor unsigned long long* result, unsigned long long a, unsigned long long b);
bool unsigned_long_long_add(_Ctor unsigned long long* result, unsigned long long a, unsigned long long b);
bool signed_long_long_sub(_Ctor signed long long* result, signed long long a, signed long long b);
bool signed_long_long_add(_Ctor signed long long* result, signed long long a, signed long long b);
bool signed_long_long_mul(_Ctor signed long long* result, signed long long a, signed long long b);

void object_default_initialization(struct object* p_object, bool is_constant);

struct object* _Opt object_get_member(struct object* p_object, int index);

int make_object_with_name(const struct type* p_type, struct object* obj, const char* name);
int make_object(const struct type* p_type, struct object* obj);
struct object object_dup(const struct object* src);

bool object_is_reference(const struct object* p_object);
bool object_is_derived(const struct object* p_object);
bool object_is_signed(const struct object* p_object);
void object_set_any(struct object* p_object);

const struct object* object_get_referenced(const struct object* p_object);

NODISCARD
int object_set(
    struct parser_ctx* ctx, 
    struct object* to,
    struct expression* _Opt init_expression, 
    const struct object* from, 
    bool is_constant,
    bool requires_constant_initialization);

struct type;

enum object_value_type type_to_object_type(const struct type* type);

void object_print_to_debug(const struct object* object, enum target target);

struct object* object_extend_array_to_index(const struct type* p_type, struct object* a, size_t n, bool is_constant);
struct object* object_get_non_const_referenced(struct object* p_object);



struct objects 
{
    struct object** _Opt items;
    int size;
    int capacity;
};

void objects_destroy(struct objects* arr);
int objects_push(struct objects* arr, struct object* obj); // returns 0 on success, ENOMEM on alloc fail




#include <limits.h>


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once


struct parser_ctx;

enum expression_type
{
    EXPRESSION_TYPE_INVALID, 

    PRIMARY_EXPRESSION_ENUMERATOR,
    PRIMARY_EXPRESSION_DECLARATOR,    
    PRIMARY_EXPRESSION_STRING_LITERAL,
    PRIMARY_EXPRESSION__FUNC__, /*predefined identifier __func__ */
    PRIMARY_EXPRESSION_CHAR_LITERAL,
    PRIMARY_EXPRESSION_PREDEFINED_CONSTANT, /*true false*/
    PRIMARY_EXPRESSION_GENERIC,
    PRIMARY_EXPRESSION_NUMBER,
    PRIMARY_EXPRESSION_PARENTESIS,

    POSTFIX_EXPRESSION_FUNCTION_LITERAL,
    POSTFIX_EXPRESSION_COMPOUND_LITERAL,

    POSTFIX_FUNCTION_CALL, // ( ) 
    POSTFIX_ARRAY, // [ ]
    POSTFIX_DOT, // .
    POSTFIX_ARROW, // .
    POSTFIX_INCREMENT,
    POSTFIX_DECREMENT,


    UNARY_EXPRESSION_SIZEOF_EXPRESSION,
    UNARY_EXPRESSION_SIZEOF_TYPE,
    UNARY_EXPRESSION_COUNTOF,
    
    UNARY_EXPRESSION_GCC__BUILTIN_VA_START,
    UNARY_EXPRESSION_GCC__BUILTIN_VA_END,    
    UNARY_EXPRESSION_GCC__BUILTIN_VA_COPY,
    UNARY_EXPRESSION_GCC__BUILTIN_VA_ARG,
    UNARY_EXPRESSION_GCC__BUILTIN_OFFSETOF,


    UNARY_EXPRESSION_TRAITS,
    UNARY_EXPRESSION_IS_SAME,
    UNARY_DECLARATOR_ATTRIBUTE_EXPR,
    UNARY_EXPRESSION_ALIGNOF_TYPE,
    UNARY_EXPRESSION_ALIGNOF_EXPRESSION,
    UNARY_EXPRESSION_ASSERT,
    UNARY_EXPRESSION_CONSTEVAL,

    UNARY_EXPRESSION_INCREMENT,
    UNARY_EXPRESSION_DECREMENT,

    UNARY_EXPRESSION_NOT,
    UNARY_EXPRESSION_BITNOT,
    UNARY_EXPRESSION_NEG,
    UNARY_EXPRESSION_PLUS,
    UNARY_EXPRESSION_CONTENT,
    UNARY_EXPRESSION_ADDRESSOF,

    CAST_EXPRESSION,

    MULTIPLICATIVE_EXPRESSION_MULT,
    MULTIPLICATIVE_EXPRESSION_DIV,
    MULTIPLICATIVE_EXPRESSION_MOD,

    ADDITIVE_EXPRESSION_PLUS,
    ADDITIVE_EXPRESSION_MINUS,

    SHIFT_EXPRESSION_RIGHT,
    SHIFT_EXPRESSION_LEFT,

    RELATIONAL_EXPRESSION_BIGGER_THAN,
    RELATIONAL_EXPRESSION_LESS_THAN,
    RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN,
    RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN,

    EQUALITY_EXPRESSION_EQUAL,
    EQUALITY_EXPRESSION_NOT_EQUAL,

    AND_EXPRESSION,
    EXCLUSIVE_OR_EXPRESSION,
    INCLUSIVE_OR_EXPRESSION,

    LOGICAL_OR_EXPRESSION,  //||
    LOGICAL_AND_EXPRESSION, //&&
    
    ASSIGNMENT_EXPRESSION_ASSIGN,
    ASSIGNMENT_EXPRESSION_PLUS_ASSIGN,
    ASSIGNMENT_EXPRESSION_MINUS_ASSIGN,
    ASSIGNMENT_EXPRESSION_MULTI_ASSIGN,
    ASSIGNMENT_EXPRESSION_DIV_ASSIGN,
    ASSIGNMENT_EXPRESSION_MOD_ASSIGN,
    ASSIGNMENT_EXPRESSION_SHIFT_LEFT_ASSIGN,
    ASSIGNMENT_EXPRESSION_SHIFT_RIGHT_ASSIGN,
    ASSIGNMENT_EXPRESSION_AND_ASSIGN,
    ASSIGNMENT_EXPRESSION_OR_ASSIGN,
    ASSIGNMENT_EXPRESSION_NOT_ASSIGN,
                       

    EXPRESSION_EXPRESSION,

    CONDITIONAL_EXPRESSION,
};

struct argument_expression_list
{
    /*
     argument-expression-list:
        assignment-expression
        argument-expression-list , assignment-expression
    */
    struct argument_expression* _Owner _Opt head;
    struct argument_expression* _Opt tail;
};

void argument_expression_list_destroy(_Dtor struct argument_expression_list* p);
void argument_expression_list_push(struct argument_expression_list* list, struct argument_expression* _Owner p);

struct generic_association
{
    /*
     generic-association:
       type-name : assignment-expression
       "default" : assignment-expression
    */

    struct type type;
    struct type_name* _Owner _Opt p_type_name;
    struct expression* _Owner expression;

    struct token* first_token;
    struct token* last_token;

    struct generic_association* _Owner _Opt next;
};

void generic_association_delete(struct generic_association* _Owner _Opt p);

struct generic_assoc_list
{
    struct generic_association* _Owner _Opt head;
    struct generic_association* _Opt tail;
};

void generic_assoc_list_add(struct generic_assoc_list* p, struct generic_association* _Owner item);
void generic_assoc_list_destroy(_Dtor struct generic_assoc_list* p);

struct generic_selection
{
    /*
      generic-selection:
        "_Generic" ( assignment-expression , generic-assoc-list )
    */


    /*
      Extension
      generic-selection:
        "_Generic" ( generic-argument, generic-assoc-list )

        generic-argument:
          assignment-expression
          type-name
    */


    struct expression* _Owner _Opt expression;
    struct type_name* _Owner _Opt type_name;
    /*
    * Points to the matching expression
    */
    struct expression* _Opt p_view_selected_expression;

    struct generic_assoc_list generic_assoc_list;
    struct token* first_token;
    struct token* last_token;
};

void generic_selection_delete(struct generic_selection* _Owner _Opt p);

struct expression
{
    enum expression_type expression_type;
    struct type type;

    struct object object;

    struct type_name* _Owner _Opt type_name;

    struct braced_initializer* _Owner _Opt braced_initializer;
    struct compound_statement* _Owner _Opt compound_statement; //function literal (lambda)
    struct generic_selection* _Owner _Opt generic_selection; //_Generic

    struct token* first_token;
    struct token* last_token;
    
    //TODO https://gcc.gnu.org/onlinedocs/gcc/Offsetof.html#Offsetof
    struct token* offsetof_member_designator;

    /*if expression is an identifier it points to its declaration*/
    struct declarator* _Opt declarator;
    struct init_declarator* _Opt p_init_declarator;

    int member_index; //used in post_fix .

    /*se for POSTFIX_FUNCTION_CALL post*/
    struct argument_expression_list argument_expression_list; //este node eh uma  chamada de funcao

    struct expression* _Owner _Opt condition_expr;
    struct expression* _Owner _Opt left;
    struct expression* _Owner _Opt right;

    bool is_assignment_expression;
};

//built-in semantics
bool expression_is_malloc(const struct expression* p);
bool expression_is_calloc(const struct expression* p);

void expression_delete(struct expression* _Owner _Opt p);

struct expression* _Owner _Opt assignment_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt constant_expression(struct parser_ctx* ctx, bool show_error_if_not_constant);
bool expression_is_subjected_to_lvalue_conversion(const struct expression*);

bool expression_get_variables(const struct expression* expr, int n, struct object* variables[/*n*/]);

bool expression_is_lvalue(const struct expression* expr);

bool expression_is_one(const struct expression* expression);
bool expression_is_zero(const struct expression* expression);
bool expression_is_null_pointer_constant(const struct expression* expression);
void expression_evaluate_equal_not_equal(const struct expression* left,
    const struct expression* right,
    struct expression* result,
    int op,
    bool disabled);

void check_diferent_enuns(struct parser_ctx* ctx,
                          const struct token* operator_token,
                          const struct expression* left,
                          const struct expression* right,
                          const char* message);

void check_assigment(struct parser_ctx* ctx,
    const struct type* left_type,
    const struct expression* right,
    enum assigment_type assigment_type);

void check_comparison(struct parser_ctx* ctx,
    struct expression* p_a_expression,
    struct expression* p_b_expression,
    const struct token* op_token);

struct object expression_eval(struct expression* p_expression);



//EXPERIMENTAL CONTRACTS
#define EXPERIMENTAL_CONTRACTS 1


struct scope
{
    int scope_level;
    struct hash_map tags;
    struct hash_map variables;

    struct scope* _Opt next;
    struct scope* _Opt previous;
};

void scope_destroy(_Dtor struct scope* p);

struct scope_list
{
    struct scope* _Opt head;
    struct scope* _Opt tail;
};
void scope_list_push(struct scope_list* list, struct scope* s);
void scope_list_pop(struct scope_list* list);

struct report
{
    int no_files;
    double cpu_time_used_sec;
    int error_count;
    int warnings_count;
    int info_count;

    bool test_mode;
    int test_failed;
    int test_succeeded;

    /*
     Warnings are removed (-test-mode) on demand at next line,
     but we can have more than one warning at same line then we need this array
    */
    enum diagnostic_id last_diagnostics_ids[2];

    //this error is expected in test-mode
    //it is used when the error aborts parsing
    enum diagnostic_id fatal_error_expected;

    /*
      direct commands like -autoconfig doesnt use report
    */
    bool ignore_this_report;
};

struct label_list_item
{
    struct token* p_last_usage;
    struct token* p_defined;
    struct label_list_item* next;
};

struct label_list
{
    struct label_list_item* _Opt _Owner head;
    struct label_list_item* _Opt tail;
};

struct label_list_item* _Opt label_list_find(struct label_list* list, const char* label_name);
void label_list_push(struct label_list* list, struct label_list_item* _Owner pitem);
void label_list_clear(struct label_list* list);


struct parser_ctx
{
    struct options options;

    /*
      file scope -> function params -> function -> inner scope
    */
    struct scope_list scopes;

    /*
    * Points to the function we're in. Or null in file scope.
    */
    struct declarator* _Opt p_current_function_opt;

    /*
    * Points to the scope where the current function is. (used in local functions)
    */
    struct scope* _Opt p_current_function_scope_opt;


    /*
    *  Used to track non-used labels or used and not defined labels
    */
    struct label_list label_list;

    /*
    * Points to the try-block we're in. Or null.
    */
    const struct try_statement* _Opt p_current_try_statement_opt;

    const struct defer_statement* _Opt p_current_defer_statement_opt;

    /*
    * Points to the selection_statement we're in. Or null.
    */
    const struct selection_statement* _Opt p_current_selection_statement;


    FILE* _Owner _Opt sarif_file;
    unsigned int sarif_entries;

    _View struct token_list input_list;
    struct token* _Opt current;
    struct token* _Opt previous;
    /*
       Expression inside sizeof etc.. are not evaluated
    */
    bool evaluation_is_disabled;

    bool inside_generic_association;

    int label_id; /*generates unique ids for labels*/

    struct report* p_report;

};

///////////////////////////////////////////////////////

void parser_ctx_destroy(_Opt _Dtor struct parser_ctx* ctx);


struct token* _Opt parser_look_ahead(const struct parser_ctx* ctx);
void unexpected_end_of_file(struct parser_ctx* ctx);
void parser_match(struct parser_ctx* ctx);
NODISCARD
int parser_match_tk(struct parser_ctx* ctx, enum token_type type);

struct token* _Opt previous_parser_token(const struct token* token);
struct declarator* _Opt find_declarator(const struct parser_ctx* ctx, const char* lexeme, struct scope** _Opt ppscope_opt);
struct enumerator* _Opt find_enumerator(const struct parser_ctx* ctx, const char* lexeme, struct scope** _Opt ppscope_opt);
struct map_entry* _Opt find_variables(const struct parser_ctx* ctx, const char* lexeme, struct scope* _Opt* _Opt ppscope_opt);

struct struct_or_union_specifier* _Opt find_struct_or_union_specifier(const struct parser_ctx* ctx, const char* lexeme);

void print_scope(struct scope_list* e);

/*
  This is the function called by the web version.
*/
char* _Opt _Owner CompileText(const char* options, const char* content);

_Bool compiler_diagnostic(enum diagnostic_id w,
    const struct parser_ctx* ctx,
    const struct token* _Opt p_token,
    const struct marker* _Opt p_marker,
    const char* fmt, ...);

int compile(int argc, const char** argv, struct report* error);

void print_type_qualifier_flags(struct osstream* ss, bool* first, enum type_qualifier_flags e_type_qualifier_flags);
bool print_type_alignment_flags(struct osstream* ss, bool* first, enum alignment_specifier_flags flags, enum target target);
bool print_type_specifier_flags(struct osstream* ss, bool* first, enum type_specifier_flags e_type_specifier_flags);


struct expression_ctx;

struct declaration_specifier
{
    /*
       declaration-specifier:
         storage-class-specifier
         type-specifier-qualifier
         function-specifier
    */
    struct storage_class_specifier* _Owner _Opt storage_class_specifier;

    struct type_specifier_qualifier* _Owner _Opt type_specifier_qualifier;

    struct function_specifier* _Owner _Opt function_specifier;
    struct alignment_specifier* _Owner _Opt alignment_specifier;

    struct declaration_specifier* _Owner _Opt next;
};

struct declaration_specifier* _Owner _Opt declaration_specifier(struct parser_ctx* ctx);
void declaration_specifier_delete(struct declaration_specifier* _Owner _Opt p);

struct declaration_specifiers
{
    /*
     declaration-specifiers:
       declaration-specifier attribute-specifier-sequence _Opt
       declaration-specifier declaration-specifiers
    */

    /*cumulative flags*/
    enum attribute_flags  attributes_flags;
    enum msvc_declspec_flags msvc_declspec_flags;
    enum type_specifier_flags type_specifier_flags;
    enum type_qualifier_flags type_qualifier_flags;
    enum storage_class_specifier_flags storage_class_specifier_flags;
    enum function_specifier_flags function_specifier_flags;
    
    enum alignment_specifier_flags alignment_specifier_flags;
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;

    /*shortcuts*/
    struct struct_or_union_specifier* _Opt struct_or_union_specifier;
    struct enum_specifier* _Opt enum_specifier;
    struct declarator* _Opt typedef_declarator;
    struct typeof_specifier* _Opt typeof_specifier;

    struct token* first_token; /*not _Owner*/
    struct token* last_token; /*not _Owner*/

    struct declaration_specifier* _Owner _Opt head;
    struct declaration_specifier* _Opt tail;
};

void print_declaration_specifiers(struct osstream* ss, struct declaration_specifiers* p);
struct declaration_specifiers* _Owner _Opt declaration_specifiers(struct parser_ctx* ctx, enum storage_class_specifier_flags default_storage_flag);
void declaration_specifiers_delete(struct declaration_specifiers* _Owner _Opt p);
void declaration_specifiers_add(struct declaration_specifiers* p, struct declaration_specifier* _Owner item);

struct static_assert_declaration
{
    /*
     static_assert-declaration:
       "static_assert" ( constant-expression , string-literal ) ;
       "static_assert" ( constant-expression ) ;
    */

    /*
      I am keeping the name static_assert_declaration but better is

      static_declaration:
       static_assert_declaration
       static_debug_declaration

      extension:
      "static_debug" ( constant-expression ) ;
      "static_set" ( constant-expression , string-literal) ;
    */

    struct token* first_token;
    struct token* last_token;
    struct expression* _Owner constant_expression;
    struct token* _Opt string_literal_opt;
};
struct static_assert_declaration* _Owner static_assert_declaration(struct parser_ctx* ctx);
void static_assert_declaration_delete(struct static_assert_declaration* _Owner _Opt p);

/*
  extension, pragma survives the preprocessor and become
  a pragma_declaration that can be used on the AST visit
*/

struct pragma_declaration {
    struct token* first_token;
    struct token* last_token;
};

struct pragma_declaration* _Owner pragma_declaration(struct parser_ctx* ctx);
void pragma_declaration_delete(struct pragma_declaration* _Owner _Opt p);

void execute_pragma(struct parser_ctx* ctx, struct pragma_declaration* p_pragma, bool on_flow_analysis);

struct attribute_specifier_sequence
{
    /*
     attribute-specifier-sequence:
       attribute-specifier-sequence _Opt attribute-specifier
    */

    struct token* first_token;
    struct token* last_token;
    enum msvc_declspec_flags msvc_declspec_flags;
    enum attribute_flags  attributes_flags;
    struct attribute_specifier* _Owner _Opt head;
    struct attribute_specifier* _Opt tail;
};
struct attribute_specifier_sequence* _Owner _Opt attribute_specifier_sequence_opt(struct parser_ctx* ctx);
void attribute_specifier_sequence_delete(struct attribute_specifier_sequence* _Owner _Opt p);
void attribute_specifier_sequence_add(struct attribute_specifier_sequence* list, struct attribute_specifier* _Owner p_item);

struct attribute_specifier
{
    /*
     attribute-specifier:
        [ [ attribute-list ] ]
    */
    struct token* first_token;
    struct token* last_token;
    struct attribute_list* _Owner attribute_list;
    struct attribute_specifier* _Owner _Opt  next;
};

struct attribute_specifier* _Owner _Opt attribute_specifier(struct parser_ctx* ctx);
void attribute_specifier_delete(struct attribute_specifier* _Owner _Opt p);

struct attribute* _Owner _Opt attribute(struct parser_ctx* ctx);


struct storage_class_specifier
{
    /*
     storage-class-specifier:
      "auto"
      "constexpr"
      "extern"
      "register"
      "static"
      "thread_local"
      "typedef"
    */
    enum storage_class_specifier_flags flags;
    struct token* token;
};

struct storage_class_specifier* _Owner _Opt storage_class_specifier(struct parser_ctx* ctx);
void storage_class_specifier_delete(struct storage_class_specifier* _Owner _Opt p);

struct function_specifier
{
    /*
     function-specifier:
       inline
       _Noreturn
    */
    enum function_specifier_flags flags;
    struct token* token;
};
struct function_specifier* _Owner _Opt  function_specifier(struct parser_ctx* ctx);
void function_specifier_delete(struct function_specifier* _Owner _Opt  p);

struct typeof_specifier_argument
{
    /*
     typeof-specifier-argument:
       expression
       type-name
    */
    struct expression* _Owner _Opt expression;
    struct type_name* _Owner _Opt type_name;
};

void typeof_specifier_argument_delete(struct typeof_specifier_argument* _Owner _Opt p);

struct typeof_specifier
{
    /*
     typeof-specifier:
       "typeof" ( typeof-specifier-argument )
    */
    struct token* first_token;
    struct token* last_token;
    struct typeof_specifier_argument* _Owner typeof_specifier_argument;
    struct type type;
};

void typeof_specifier_delete(struct typeof_specifier* _Owner _Opt p);


struct type_specifier
{
    /*
     type-specifier:
        "void"
        "char"
        "short"
        "int"
        "long"
        "float"
        "double"
        "signed"
        "unsigned"
        "_BitInt" ( constant-expression )
        "bool"
        "_Complex"
        "_Decimal32"
        "_Decimal64"
        "_Decimal128"
        atomic-type-specifier
        struct-or-union-specifier
        enum-specifier
        typedef-name
        typeof-specifier
    */
    enum type_specifier_flags flags;
    struct token* token;
    struct struct_or_union_specifier* _Owner _Opt struct_or_union_specifier;
    struct typeof_specifier* _Owner _Opt  typeof_specifier;
    struct enum_specifier* _Owner _Opt enum_specifier;    
    struct declarator* _Opt typedef_declarator;
    struct atomic_type_specifier* _Owner _Opt  atomic_type_specifier;
};

struct type_specifier* _Owner _Opt type_specifier(struct parser_ctx* ctx);
void type_specifier_delete(struct type_specifier* _Owner _Opt p);

struct init_declarator_list
{
    /*
     init-declarator-list:
       init-declarator
       init-declarator-list , init-declarator
    */
    struct init_declarator* _Owner _Opt head;
    struct init_declarator* _Opt tail;
};

struct init_declarator_list init_declarator_list(struct parser_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers);

void init_declarator_list_destroy(_Dtor struct init_declarator_list* p);
void init_declarator_list_add(struct init_declarator_list* list, struct init_declarator* _Owner p_item);

struct defer_list_item;

struct defer_list
{
    struct defer_list_item* _Opt _Owner head;
    struct defer_list_item* _Opt tail;
};


struct declaration
{
    /*
      declaration:
        declaration-specifiers init-declarator-list _Opt ;
        attribute-specifier-sequence declaration-specifiers init-declarator-list ;
        static_assert-declaration
        attribute-declaration
    */
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;

    struct static_assert_declaration* _Owner _Opt static_assert_declaration;
    struct pragma_declaration* _Owner _Opt pragma_declaration;


    struct declaration_specifiers* _Owner _Opt  declaration_specifiers;
    struct init_declarator_list init_declarator_list;

    struct compound_statement* _Owner _Opt  function_body;
    struct defer_list defer_list; //arguments

    struct declarator* _Opt  contract_declarator;

    struct token* first_token;
    struct token* last_token;

    struct declaration* _Owner _Opt next;
};

void declaration_delete(struct declaration* _Owner _Opt p);
struct declaration* _Owner _Opt external_declaration(struct parser_ctx* ctx);

struct simple_declaration
{
    /*
    This is an extension to support C++ 17 if with initialization

    simple-declaration:
      declaration-specifiers init-declarator-list _Opt ;
      attribute-specifier-sequence declaration-specifiers init-declarator-list ;
    */
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;
    struct declaration_specifiers* _Owner p_declaration_specifiers;
    struct init_declarator_list init_declarator_list;
    struct token* first_token;
    struct token* last_token;
};

void simple_declaration_delete(struct simple_declaration* _Owner _Opt p);

struct simple_declaration* _Owner _Opt simple_declaration(struct parser_ctx* ctx,
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt,
    bool ignore_semicolon);

struct condition
{
    /*
      This is an extension to support C++ 17 if with initialization

      condition :
       expression
       attribute-specifier-seq opt decl-specifier-seq declarator initializer
    */
    struct expression* _Owner _Opt expression;
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;
    struct declaration_specifiers* _Owner _Opt p_declaration_specifiers;

    /*
      OBS:
      We must use p_init_declarator because it is kept on the scope
      as init_declarator when we are trying to parse init-statement or condition that
      are very similar
    */
    struct init_declarator* _Owner _Opt p_init_declarator;

    struct token* first_token;
    struct token* last_token;
};

void condition_delete(struct condition* _Owner _Opt p);
struct condition* _Owner _Opt condition(struct parser_ctx* ctx);

struct init_statement
{
    /*
        This is an extension to support C++ 17 if with initialization

        init-statement :
          expression-statement
          simple-declaration
    */
    struct expression_statement* _Owner _Opt p_expression_statement;
    struct simple_declaration* _Owner _Opt p_simple_declaration;
};

void init_statement_delete(struct init_statement* _Owner _Opt p);
struct init_statement* _Owner _Opt init_statement(struct parser_ctx* ctx, bool ignore_semicolon);

struct atomic_type_specifier
{
    /*
      atomic-type-specifier:
        "_Atomic" ( type-name )
    */
    struct token* token;
    struct type_name* _Owner type_name;
};

struct atomic_type_specifier* _Owner _Opt atomic_type_specifier(struct parser_ctx* ctx);
void atomic_type_specifier_delete(struct atomic_type_specifier* _Owner _Opt  p);

struct enumerator_list
{
    /*
     enumerator-list:
       enumerator
       enumerator-list , enumerator
    */
    struct enumerator* _Owner _Opt head;
    struct enumerator* _Opt tail;
};

struct enumerator_list enumerator_list(struct parser_ctx* ctx,
    const struct enum_specifier* p_enum_specifier
);

void enumerator_list_destroy(_Dtor struct enumerator_list* p_enum_specifier);
void enumerator_list_add(struct enumerator_list* list, struct enumerator* _Owner p_item);

struct enum_specifier
{
    /*
     enum-type-specifier:
       : specifier-qualifier-lis

     enum-specifier:
       "enum" attribute-specifier-sequence opt identifier opt enum-type-specifier opt  { enumerator-list }
       "enum" attribute-specifier-sequence opt identifier opt enum-type-specifier opt  { enumerator-list , }
       "enum" identifier enum-type-specifier opt
    */

    /*
       If has_shared_ownership is
        - true,  both AST and some map are sharing the ownership
        - false, only AST OR and some map have the ownership
    */
    bool has_shared_ownership;

    struct attribute_specifier_sequence* _Owner _Opt attribute_specifier_sequence_opt;
    struct specifier_qualifier_list* _Owner _Opt specifier_qualifier_list;

    char tag_name[200];

    struct enumerator_list enumerator_list;

    struct token* _Opt tag_token;
    struct token* first_token;
    /*points to the complete enum (can be self pointed)*/
    struct enum_specifier* _Opt p_complete_enum_specifier;
};

bool enum_specifier_has_fixed_underlying_type(const struct enum_specifier*);
struct enum_specifier* _Owner _Opt enum_specifier(struct parser_ctx*);

struct enum_specifier* _Owner enum_specifier_add_ref(struct enum_specifier* p);
void enum_specifier_delete(struct enum_specifier* _Owner _Opt p);
const struct enum_specifier* _Opt get_complete_enum_specifier(const struct enum_specifier* p_enum_specifier);
enum type_specifier_flags get_enum_type_specifier_flags(const struct enum_specifier* p_enum_specifier);

const struct enumerator* _Opt find_enumerator_by_value(const struct enum_specifier* p_enum_specifier, const struct object* object);

struct member_declaration_list
{
    /*
     member-declaration-list:
       member-declaration
       member-declaration-list member-declaration
    */

    struct token* first_token; /*TODO ? necessary*/
    struct token* last_token;
    struct member_declaration* _Owner _Opt head;
    struct member_declaration* _Opt tail;
};

struct member_declaration_list member_declaration_list(struct parser_ctx* ctx, struct struct_or_union_specifier*);
void member_declaration_list_destroy(_Opt _Dtor struct member_declaration_list* p);
void member_declaration_list_add(struct member_declaration_list* list, struct member_declaration* _Owner p_item);

struct member_declarator* _Opt find_member_declarator(struct member_declaration_list* list, const char* name, int* p_member_index);

struct struct_or_union_specifier
{
    /*
       If has_shared_ownership is
        - true,  both AST and some map are sharing the ownership
        - false, only AST OR and some map have the ownership
    */
    bool has_shared_ownership;

    struct attribute_specifier_sequence* _Owner _Opt attribute_specifier_sequence_opt;
    struct member_declaration_list member_declaration_list;

    struct token* first_token;
    struct token* last_token;

    bool is_owner;

    /*
    *Token that has a strut tag
    */
    struct token* _Opt tagtoken;

    char tag_name[200];
    /*geramos um tag name para anomimas, mas colocamos banonymousTag para true*/
    bool has_anonymous_tag;
    /*it was asked to show struct tag created for anonymous*/
    bool show_anonymous_tag;

    int scope_level; /*nivel escopo 0 global*/
    int visit_moved; /*nivel escopo 0 global*/

    /*
    * This points to the first struct_or_union_specifier that will have it´s
    * complete_struct_or_union_specifier_indirection pointing to the complete
    * struct_or_union_specifier.
    */
    struct struct_or_union_specifier* _Opt complete_struct_or_union_specifier_indirection;
};

struct struct_or_union_specifier* _Owner _Opt struct_or_union_specifier(struct parser_ctx* ctx);
struct struct_or_union_specifier* _Owner struct_or_union_specifier_add_ref(struct struct_or_union_specifier* p);
bool struct_or_union_specifier_is_union(const struct struct_or_union_specifier* p);
void struct_or_union_specifier_delete(struct struct_or_union_specifier* _Owner _Opt  p);

bool struct_or_union_specifier_is_complete(struct struct_or_union_specifier* p_struct_or_union_specifier);
struct struct_or_union_specifier* _Opt get_complete_struct_or_union_specifier(const struct struct_or_union_specifier* p_struct_or_union_specifier);

struct init_declarator
{
    /*
     init-declarator:
        declarator
        declarator = initializer
    */

    /*
       If has_shared_ownership is
        - true,  both AST and some map are sharing the ownership
        - false, only AST OR and some map have the ownership
    */
    bool has_shared_ownership;

    struct declarator* _Owner p_declarator;
    struct initializer* _Owner _Opt initializer;
    struct init_declarator* _Owner _Opt next;
};


struct init_declarator* _Owner init_declarator_add_ref(struct init_declarator* p);
void init_declarator_delete(struct init_declarator* _Owner _Opt p);
struct init_declarator* _Owner _Opt init_declarator(struct parser_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers
);

struct initializer
{
    /*
     initializer:
       assignment-expression
       braced-initializer
    */
    struct token* first_token;
    struct braced_initializer* _Owner _Opt braced_initializer;
    struct expression* _Owner _Opt assignment_expression;
};

struct initializer* _Owner _Opt initializer(struct parser_ctx* ctx);
void initializer_delete(struct initializer* _Owner _Opt  p);

struct declarator
{
    /*
      declarator:
        pointer _Opt direct-declarator
    */

    /*
       If has_shared_ownership is
        - true,  both AST and Map are sharing the ownership
        - false, only AST OR Map have the ownership
    */
    bool has_shared_ownership;
    struct token* _Opt first_token_opt;
    struct token* _Opt last_token_opt;

    struct pointer* _Owner _Opt pointer;
    struct direct_declarator* _Owner _Opt direct_declarator;

    struct declaration_specifiers* _Opt declaration_specifiers;
    const struct specifier_qualifier_list* _Opt specifier_qualifier_list;

    struct token* _Opt name_opt; //shortcut , null for abstract declarator

    struct compound_statement* _Opt function_body;
    
    /*
        points to someone that has the function_body or 
        to someone that points to someone that has the function_body        
    */
    struct declarator* _Opt p_complete_declarator;

    int num_uses; /*used to show not used warnings*/

    struct object object;

    /*user by flow analysis*/
    struct flow_object* _Opt p_flow_object;

    struct expression* _Opt _Owner p_expression_true;
    struct expression* _Opt _Owner p_expression_false;

    /*Used to check contracts*/
    struct expression* _Opt p_alias_of_expression;

    /*
       TODO it is duplicated with object
       final declarator type (after auto, typeof etc)
    */
    struct type type;
};

const struct declarator* _Opt declarator_get_function_definition(const struct declarator* p);
enum type_specifier_flags declarator_get_type_specifier_flags(const struct declarator* p);

struct declarator;
void print_declarator(struct osstream* ss, struct declarator* declarator, bool is_abstract);

struct declarator* _Owner _Opt declarator(struct parser_ctx* ctx,
    const struct specifier_qualifier_list* _Opt specifier_qualifier_list,
    struct declaration_specifiers* _Opt declaration_specifiers,
    bool abstract_acceptable,
    struct token** _Opt pptokenname);

struct declarator* _Owner declarator_add_ref(struct declarator* p);
void declarator_delete(struct declarator* _Owner _Opt  p);

struct array_declarator
{
    /*
     array-declarator:
        direct-declarator [ type-qualifier-list opt assignment-expression opt ]
        direct-declarator [ "static" type-qualifier-list opt assignment-expression ]
        direct-declarator [ type-qualifier-list "static" assignment-expression ]
        direct-declarator [ type-qualifier-list opt * ]
    */
    struct direct_declarator* _Owner _Opt direct_declarator;
    struct expression* _Owner _Opt  assignment_expression;
    struct expression* _Owner _Opt expression;
    struct type_qualifier_list* _Owner _Opt type_qualifier_list_opt;

    struct token* token;
    struct token* _Opt static_token_opt;
};

void array_declarator_delete(struct array_declarator* _Owner _Opt p);

/*
  Return a value > 0 if it has constant size
*/
size_t  array_declarator_get_size(const struct array_declarator* p_array_declarator);

struct function_declarator
{
    /*
     function-declarator:
       direct-declarator ( parameter-type-list _Opt )
    */
    struct direct_declarator* _Owner _Opt direct_declarator;
    struct scope parameters_scope;// used for scope parameters
    struct parameter_type_list* _Owner _Opt parameter_type_list_opt;
};

void function_declarator_delete(struct function_declarator* _Owner _Opt p);

struct direct_declarator
{
    /*
     direct-declarator:
        identifier attribute-specifier-sequence opt
        ( declarator )
        array-declarator attribute-specifier-sequence opt
        function-declarator attribute-specifier-sequence opt
    */
    struct token* _Opt name_opt;
    struct token* _Opt p_calling_convention;
    struct declarator* _Owner _Opt declarator;
    struct array_declarator* _Owner _Opt array_declarator;
    struct function_declarator* _Owner _Opt function_declarator;
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;
};

void direct_declarator_delete(struct direct_declarator* _Owner _Opt p);

struct direct_declarator* _Owner _Opt direct_declarator(struct parser_ctx* ctx,
    const struct specifier_qualifier_list* _Opt specifier_qualifier_list,
    struct declaration_specifiers* _Opt declaration_specifiers,
    bool abstract_acceptable,
    struct token** _Opt pptoken_name
);

struct parameter_type_list
{
    /*
    parameter-type-list:
        parameter-list
        parameter-list , ...
        ...
    */
    bool is_var_args; /*(...)*/
    bool is_void;/*(void)*/
    struct parameter_list* _Owner _Opt parameter_list;
};

struct parameter_type_list* _Owner _Opt parameter_type_list(struct parser_ctx* ctx);
void parameter_type_list_delete(struct parameter_type_list* _Owner _Opt  p);

struct pointer
{
    /*
     pointer:
        * attribute-specifier-sequence opt type-qualifier-list opt
        * attribute-specifier-sequence opt type-qualifier-list opt pointer
    */
    struct attribute_specifier_sequence* _Owner _Opt  attribute_specifier_sequence_opt;
    struct type_qualifier_list* _Owner _Opt type_qualifier_list_opt;

    /*
      typedef int (__fastcall *pf)();
    */
    struct token* _Opt calling_convention;

    struct pointer* _Owner _Opt pointer;
};

struct pointer* _Owner _Opt  pointer_opt(struct parser_ctx* ctx);
void pointer_delete(struct pointer* _Owner _Opt p);

struct parameter_list
{
    /*
     parameter-list:
        parameter-declaration
        parameter-list , parameter-declaration
    */
    struct parameter_declaration* _Owner _Opt head;
    struct parameter_declaration* _Opt tail;
};

struct parameter_list* _Owner _Opt  parameter_list(struct parser_ctx* ctx);
void parameter_list_delete(struct parameter_list* _Owner _Opt  p);
void parameter_list_add(struct parameter_list* list, struct parameter_declaration* _Owner p_item);

struct parameter_declaration
{
    /*
     parameter-declaration:
      attribute-specifier-sequence opt declaration-specifiers declarator
      attribute-specifier-sequence opt declaration-specifiers abstract-declarator opt
    */
    struct attribute_specifier_sequence* _Owner _Opt  attribute_specifier_sequence_opt;

    struct declaration_specifiers* _Owner declaration_specifiers;
    struct declarator* _Owner _Opt  declarator;
    struct parameter_declaration* _Owner _Opt next;
};

struct parameter_declaration* _Owner _Opt parameter_declaration(struct parser_ctx* ctx);
void parameter_declaration_delete(struct parameter_declaration* _Owner _Opt  p);


struct type_name
{
    /*
     type-name:
       specifier-qualifier-list abstract-declarator opt
    */

    struct token* first_token;
    struct token* last_token;
    struct specifier_qualifier_list* _Owner specifier_qualifier_list;
    struct declarator* _Owner abstract_declarator; //TODO OPT
    struct type type;
};

struct type_name* _Owner _Opt type_name(struct parser_ctx* ctx);
void type_name_delete(struct type_name* _Owner _Opt p);
void print_type_name(struct osstream* ss, struct type_name* p);

struct argument_expression
{
    struct expression* _Owner expression;
    struct argument_expression* _Owner _Opt next;
    bool set_unkown; //used in flow analysis need to be removed..
};

void argument_expression_delete(struct argument_expression* _Owner _Opt  p);

struct braced_initializer
{
    /*
      { }
      { initializer-list }
      { initializer-list , }
    */

    struct token* first_token;
    struct token* last_token;
    struct initializer_list* _Owner _Opt initializer_list;
};

struct braced_initializer* _Owner _Opt braced_initializer(struct parser_ctx* ctx);
void braced_initializer_delete(struct braced_initializer* _Owner _Opt p);

struct type_specifier_qualifier
{
    /*
     type-specifier-qualifier:
       type-specifier
       type-qualifier
       alignment-specifier
    */

    struct type_specifier* _Owner _Opt type_specifier;
    struct type_qualifier* _Owner _Opt type_qualifier;
    struct alignment_specifier* _Owner _Opt alignment_specifier;

    struct type_specifier_qualifier* _Owner _Opt next;
};
struct type_specifier_qualifier* _Owner _Opt type_specifier_qualifier(struct parser_ctx* ctx);
void type_specifier_qualifier_delete(struct type_specifier_qualifier* _Owner _Opt  p);

struct specifier_qualifier_list
{
    /*
      specifier-qualifier-list:
        type-specifier-qualifier attribute-specifier-sequence _Opt
        type-specifier-qualifier specifier-qualifier-list
    */

    /*cumulative flags*/
    enum type_specifier_flags type_specifier_flags;
    enum type_qualifier_flags type_qualifier_flags;
    enum alignment_specifier_flags alignment_specifier_flags;


    /*shortcuts*/
    struct struct_or_union_specifier* _Opt struct_or_union_specifier;
    struct enum_specifier* _Opt enum_specifier;
    struct typeof_specifier* _Opt typeof_specifier;
    struct declarator* _Opt typedef_declarator;

    struct type_specifier_qualifier* _Owner _Opt head;
    struct type_specifier_qualifier* _Opt tail;
    struct token* first_token;
    struct token* last_token;

    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence;

};

struct specifier_qualifier_list* _Owner _Opt specifier_qualifier_list(struct parser_ctx* ctx);
void specifier_qualifier_list_delete(struct specifier_qualifier_list* _Owner _Opt p);
void specifier_qualifier_list_add(struct specifier_qualifier_list* list, struct type_specifier_qualifier* _Owner p_item);

void print_specifier_qualifier_list(struct osstream* ss, bool* first, struct specifier_qualifier_list* p_specifier_qualifier_list);

struct alignment_specifier
{
    /*
     alignment-specifier:
       "alignas" ( type-name )
       "alignas" ( constant-expression )
    */
    enum alignment_specifier_flags flags;
    struct type_name* _Owner _Opt type_name;
    struct expression* _Owner _Opt constant_expression;
    struct token* token;
};

struct alignment_specifier* _Owner _Opt alignment_specifier(struct parser_ctx* ctx);
void alignment_specifier_delete(struct alignment_specifier* _Owner _Opt p);

struct type_qualifier
{
    /*
     type-qualifier:
       "const"
       "restrict"
       "volatile"
       "_Atomic"
    */
    enum type_qualifier_flags flags;
    struct token* token;

    /*
      Next is used when inside struct type_qualifier_list
      Not used when inside struct type_specifier_qualifier
    */
    struct type_qualifier* _Owner _Opt next;
};

struct type_qualifier* _Owner _Opt type_qualifier(struct parser_ctx* ctx);
void type_qualifier_delete(struct type_qualifier* _Owner _Opt p);

struct member_declaration
{
    /*
     member-declaration:
       attribute-specifier-sequence opt specifier-qualifier-list member-declarator-list opt ;
       static_assert-declaration
    */
    struct specifier_qualifier_list* _Owner _Opt specifier_qualifier_list;
    struct member_declarator_list* _Owner _Opt member_declarator_list_opt;

    struct static_assert_declaration* _Owner _Opt static_assert_declaration;
    struct pragma_declaration* _Owner _Opt pragma_declaration;

    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;
    struct member_declaration* _Owner _Opt next;

};

struct member_declaration* _Owner _Opt member_declaration(struct parser_ctx* ctx,
    struct struct_or_union_specifier*);
void member_declaration_delete(struct member_declaration* _Owner _Opt p);

struct member_declarator
{
    /*
     member-declarator:
       declarator
       declarator opt : constant-expression
    */

    struct declarator* _Owner _Opt declarator;
    struct expression* _Owner _Opt constant_expression;
    struct member_declarator* _Owner _Opt next;
};
void member_declarator_delete(struct member_declarator* _Owner _Opt p);

struct member_declarator_list
{
    /*
     member-declarator-list:
        member-declarator
        member-declarator-list , member-declarator
    */

    struct member_declarator* _Owner _Opt head;
    struct member_declarator* _Opt tail;
};

struct member_declarator* _Opt find_member_declarator_by_index(struct member_declaration_list* list, int member_index);

struct member_declarator_list* _Owner _Opt member_declarator_list(struct parser_ctx* ctx,
    struct struct_or_union_specifier*, /*not const*/
    const struct specifier_qualifier_list* specifier_qualifier_list
);
void member_declarator_list_delete(struct member_declarator_list* _Owner _Opt p);
void member_declarator_list_add(struct member_declarator_list* list, struct member_declarator* _Owner p_item);

struct block_item_list
{
    /*
     block-item-list:
       block-item
       block-item-list block-item
    */
    struct block_item* _Owner _Opt head;
    struct block_item* _Opt tail;
};

struct block_item_list block_item_list(struct parser_ctx* ctx, bool* error);
void block_item_list_destroy(_Dtor struct block_item_list* p);
void block_item_list_add(struct block_item_list* list, struct block_item* _Owner p_item);


struct compound_statement
{
    /*
     compound-statement:
       { block-item-list _Opt }
    */
    struct token* first_token; /*{*/
    struct token* last_token; /*}*/

    struct block_item_list block_item_list;

    //flow analysis flags
    struct diagnostic diagnostic_flags;

    struct defer_list defer_list;
};
struct compound_statement* _Owner _Opt compound_statement(struct parser_ctx* ctx);
void compound_statement_delete(struct compound_statement* _Owner _Opt p);

struct defer_statement
{
    /*
     defer-statement: (extension)
       "defer" secondary-block
    */
    struct token* first_token;
    struct token* last_token;
    struct secondary_block* _Owner secondary_block;
};

void defer_statement_delete(struct defer_statement* _Owner _Opt p);

struct defer_list_item
{
    struct declarator* _Opt declarator;
    struct defer_statement* _Opt defer_statement;
    struct defer_list_item* _Opt _Owner next;
};



void defer_list_add(struct defer_list* list, struct defer_list_item* _Owner p_item);
void defer_list_destroy(_Dtor struct defer_list* p);

struct try_statement
{
    /*
      try-statement: (extension)
       "try" secondary-block
       "try" secondary-block "catch" secondary-block
    */
    struct secondary_block* _Owner secondary_block;
    struct secondary_block* _Owner _Opt catch_secondary_block_opt;
    struct token* first_token; /*try*/
    struct token* last_token;
    struct token* _Opt catch_token_opt; /*catch*/

    int catch_label_id;
};

struct try_statement* _Owner _Opt try_statement(struct parser_ctx* ctx);
void try_statement_delete(struct try_statement* _Owner _Opt p);

struct case_label_list
{
    /*
       it is not the owner. The owner is the label statement
    */
    struct label* _Opt head;
    struct label* _Opt tail;
};

void case_label_list_push(struct case_label_list* list, struct label* pnew);
struct label* _Opt case_label_list_find(const struct case_label_list* list, const struct object* object);
struct label* _Opt case_label_list_find_default(const struct case_label_list* list);
struct label* _Opt case_label_list_find_range(const struct case_label_list* list, const struct object* begin, const struct object* end);

struct selection_statement
{
    /*
      selection-statement:
        "if" ( expression ) secondary-block
        "if" ( expression ) secondary-block "else" secondary-block
        "switch" ( expression ) secondary-block
    */

    //TODO rename
    /*C2Y
      selection-statement:
         if ( selection-header ) secondary-block
         if ( selection-header ) secondary-block else secondary-block
         switch ( selection-header ) secondary-block

     selection-header:
       expression
       declaration expression
       simple-declaration


     simple-declaration:
        attribute-specifier-sequenceopt declaration-specifiers declarator = initializer
    */

    struct init_statement* _Owner _Opt p_init_statement;
    struct condition* _Owner _Opt _Opt condition;

    struct secondary_block* _Owner secondary_block;
    struct secondary_block* _Owner _Opt else_secondary_block_opt;

    struct token* open_parentesis_token;
    struct token* close_parentesis_token;

    //case labels inside the switch
    struct case_label_list label_list;

    struct token* first_token;
    struct token* last_token;
    struct token* _Opt else_token_opt;
    struct defer_list defer_list;

    int label_id;
};

struct selection_statement* _Owner _Opt selection_statement(struct parser_ctx* ctx);
void selection_statement_delete(struct selection_statement* _Owner _Opt  p);

struct iteration_statement
{
    /*
      iteration-statement:
        "while" ( expression ) secondary-block
        "do" secondary-block "while" ( expression ) ;
        "for" ( expression _Opt ; expression _Opt ; expression _Opt ) secondary-block
        "for" ( declaration expression _Opt ; expression _Opt ) secondary-block
    */

    struct token* first_token;
    struct token* second_token; /*do {} while*/

    struct secondary_block* _Owner secondary_block;

    struct expression* _Owner _Opt expression1;
    struct expression* _Owner _Opt expression2;
    struct expression* _Owner _Opt expression0;
    struct declaration* _Owner _Opt declaration;
    struct defer_list defer_list;
};

struct iteration_statement* _Owner _Opt iteration_statement(struct parser_ctx* ctx);
void iteration_statement_delete(struct iteration_statement* _Owner _Opt p);

struct jump_statement
{
    /*
     jump-statement:
       "goto" identifier ;
       "continue" ;
       "break" ;
       "return" expression _Opt ;
    */

    struct token* _Opt label;
    struct token* first_token;
    struct token* last_token;
    struct expression* _Owner _Opt expression_opt;

    int label_id;
    struct defer_list defer_list;
};

struct jump_statement* _Owner _Opt jump_statement(struct parser_ctx* ctx);
void jump_statement_delete(struct jump_statement* _Owner _Opt p);

struct expression_statement
{
    /*
     expression-statement:
       expression _Opt;
       attribute-specifier-sequence expression ;
    */

    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;
    struct expression* _Owner _Opt expression_opt;
};

struct expression_statement* _Owner _Opt expression_statement(struct parser_ctx* ctx, bool ignore_semicolon);
void expression_statement_delete(struct expression_statement* _Owner _Opt  p);

struct block_item
{
    /*
     block-item:
      declaration
      unlabeled-statement
      label
    */
    struct token* first_token; //?necessary
    struct declaration* _Owner _Opt declaration;
    struct unlabeled_statement* _Owner _Opt unlabeled_statement;
    struct label* _Owner _Opt label;

    struct block_item* _Owner _Opt next;
};

struct block_item* _Owner _Opt block_item(struct parser_ctx* ctx);
void block_item_delete(struct block_item* _Owner _Opt p);

struct compound_statement* _Owner _Opt function_body(struct parser_ctx* ctx);

struct designator
{
    /*
     designator:
       [ constant-expression ]
       . identifier
    */
    struct expression* _Owner _Opt constant_expression_opt;
    struct token* token;
    struct designator* _Owner _Opt next;
};

struct designator* _Owner _Opt designator(struct parser_ctx* ctx);
void designator_delete(struct designator* _Owner _Opt p);

struct initializer_list_item
{
    //A small grammar rewrite    
    /*
      initializer-list:
        designation opt initializer
        initializer-list , designation opt initializer
    */

    /*
      initializer-list-item:
        designation opt initializer

      initializer-list:
        initializer-list-item
        initializer-list , initializer-list-item
     */

    struct designation* _Opt _Owner designation;
    struct initializer* _Owner initializer;
    struct initializer_list_item* _Opt _Owner next;
};

void initializer_list_item_delete(struct initializer_list_item* _Owner _Opt p);

struct initializer_list
{
    /*
      initializer-list:
        designation opt initializer
        initializer-list , designation opt initializer
    */
    struct token* first_token;
    struct initializer_list_item* _Owner _Opt head;
    struct initializer_list_item* _Opt tail;
    int size;
};

struct initializer_list* _Owner _Opt initializer_list(struct parser_ctx* ctx);
void initializer_list_delete(struct initializer_list* _Owner _Opt p);
void initializer_list_add(struct initializer_list* list, struct initializer_list_item* _Owner p_item);

struct primary_block
{
    /*
       primary-block:
         compound-statement
         selection-statement
         iteration-statement
         defer-statement (extension)
         try-statement (extension)
    */

    struct compound_statement* _Owner _Opt compound_statement;
    struct selection_statement* _Owner _Opt selection_statement;
    struct iteration_statement* _Owner _Opt iteration_statement;
    struct defer_statement* _Owner _Opt defer_statement;
    struct try_statement* _Owner _Opt try_statement;
};

void primary_block_delete(struct primary_block* _Owner _Opt p);

struct secondary_block
{
    /*
     secondary-block:
       statement
    */
    struct token* first_token;
    struct token* last_token;
    struct statement* _Owner statement;
};

void secondary_block_delete(struct secondary_block* _Owner _Opt p);
bool secondary_block_ends_with_jump(struct secondary_block* _Opt p_secondary_block);

struct unlabeled_statement
{
    /*
      unlabeled-statement:
        expression-statement
        attribute-specifier-sequence opt primary-block
        attribute-specifier-sequence opt jump-statement
     */

    struct expression_statement* _Owner _Opt expression_statement;
    struct primary_block* _Owner _Opt primary_block;
    struct jump_statement* _Owner _Opt jump_statement;
};

struct unlabeled_statement* _Owner _Opt unlabeled_statement(struct parser_ctx* ctx);
void unlabeled_statement_delete(struct unlabeled_statement* _Owner _Opt p);

struct labeled_statement
{
    /*
     label statement:
       label statement
    */
    struct label* _Owner label;
    struct statement* _Owner statement;
};

struct labeled_statement* _Owner _Opt labeled_statement(struct parser_ctx* ctx);
void labeled_statement_delete(struct labeled_statement* _Owner _Opt p);

struct statement
{
    /*
     statement:
       labeled-statement
       unlabeled-statement
    */
    struct labeled_statement* _Owner _Opt labeled_statement;
    struct unlabeled_statement* _Owner _Opt unlabeled_statement;
};

struct statement* _Owner _Opt statement(struct parser_ctx* ctx);
void statement_delete(struct statement* _Owner _Opt  p);

struct designator_list
{
    /*
     designator-list:
       designator
       designator-list designator
    */
    struct designator* _Owner _Opt head;
    struct designator* _Opt tail;
};

struct designator_list* _Owner _Opt designator_list(struct parser_ctx* ctx);
void designator_list_delete(struct designator_list* _Owner _Opt p);
void designator_list_add(struct designator_list* list, struct designator* _Owner p_item);

struct designation
{
    /*
     designation:
       designator-list =
    */
    struct designator_list* _Owner designator_list;
    struct token* token;
};

struct designation* _Owner _Opt designation(struct parser_ctx* ctx);
void designation_delete(struct designation* _Owner _Opt p);

struct type_qualifier_list
{
    /*
     type-qualifier-list:
       type-qualifier
       type-qualifier-list type-qualifier
    */
    enum type_qualifier_flags flags;
    struct type_qualifier* _Owner _Opt head;
    struct type_qualifier* _Opt tail;
};

struct type_qualifier_list* _Owner _Opt type_qualifier_list(struct parser_ctx* ctx);
void type_qualifier_list_delete(struct type_qualifier_list* _Owner _Opt p);
void type_qualifier_list_add(struct type_qualifier_list* list, struct type_qualifier* _Owner p_item);



struct attribute
{
    enum msvc_declspec_flags msvc_declspec_flags;
    enum attribute_flags  attributes_flags;
    struct attribute_argument_clause* _Owner attribute_argument_clause;
    struct token* attribute_token;
    struct attribute* _Owner _Opt next;
};

void attribute_delete(struct attribute* _Owner _Opt p);

struct attribute_list
{
    enum attribute_flags  attributes_flags;
    struct attribute* _Owner _Opt head;
    struct attribute* _Opt tail;
};

struct attribute_list* _Owner _Opt attribute_list(struct parser_ctx* ctx);
void attribute_list_destroy(_Dtor struct attribute_list* p);
void attribute_list_delete(struct attribute_list* _Owner _Opt p);

void attribute_list_add(struct attribute_list* list, struct attribute* _Owner p_item);

struct enumerator
{
    /*
      enumeration-constant:
        identifier

      enumerator:
        enumeration-constant attribute-specifier-sequence _Opt
        enumeration-constant attribute-specifier-sequence _Opt = constant-expression
    */

    /*
       If has_shared_ownership is
        - true,  both AST and some map are sharing the ownership
        - false, only AST OR and some map have the ownership
    */
    bool has_shared_ownership;

    struct token* token;
    struct attribute_specifier_sequence* _Owner _Opt attribute_specifier_sequence_opt;

    struct expression* _Owner _Opt constant_expression_opt;

    /*
      having the enum specifier we have better information about the type
    */
    const struct enum_specifier* enum_specifier;

    struct enumerator* _Owner _Opt next;
    struct object value;
};

struct enumerator* _Owner _Opt enumerator(struct parser_ctx* ctx, const struct enum_specifier* p_enum_specifier, struct object* p_enumerator_value);
struct enumerator* _Owner enumerator_add_ref(struct enumerator* p);
void enumerator_delete(struct enumerator* _Owner _Opt  p);

struct attribute_argument_clause
{
    /*
     attribute-argument-clause:
       ( balanced-token-sequence opt )
    */
    struct balanced_token_sequence* _Owner _Opt p_balanced_token_sequence;
    struct token* token;
};

struct attribute_argument_clause* _Owner _Opt attribute_argument_clause(struct parser_ctx* ctx);
void attribute_argument_clause_delete(struct attribute_argument_clause* _Owner _Opt p);

bool first_of_attribute(const struct parser_ctx* ctx);

struct balanced_token
{
    struct token* token;
    struct balanced_token* _Owner _Opt next;
};

struct balanced_token_sequence
{
    struct balanced_token* _Owner _Opt head;
    struct balanced_token* _Opt tail;
};

struct balanced_token_sequence* _Owner _Opt balanced_token_sequence_opt(struct parser_ctx* ctx);
void balanced_token_sequence_delete(struct balanced_token_sequence* _Owner _Opt  p);

bool is_first_of_conditional_expression(struct parser_ctx* ctx);
bool first_of_type_name(const struct parser_ctx* ctx);
bool first_of_type_name_ahead(const struct parser_ctx* ctx);

struct argument_expression_list argument_expression_list(struct parser_ctx* ctx);

struct declaration_list
{
    struct declaration* _Owner _Opt head;
    struct declaration* _Opt tail;
};

struct declaration_list translation_unit(struct parser_ctx* ctx, bool* berror);
void declaration_list_destroy(_Dtor struct declaration_list* list);

struct label
{
    /*
     label:
       attribute-specifier-sequence opt identifier :
       attribute-specifier-sequence opt "case" constant-expression :
       attribute-specifier-sequence opt "default" :
    */
    struct expression* _Owner _Opt constant_expression;
    struct expression* _Owner _Opt constant_expression_end;

    struct token* _Opt p_identifier_opt;
    struct token* p_first_token;
    struct label* _Opt next;

    int label_id; //unique id inside the function scope
};

struct label* _Owner _Opt label(struct parser_ctx* ctx);
void label_delete(struct label* _Owner _Opt p);

struct ast
{
    struct token_list token_list;
    struct declaration_list declaration_list;
};


struct ast get_ast(struct options* options, const char* filename, const char* source, struct report* report);
void ast_destroy(_Dtor struct ast* ast);
struct type make_type_using_declarator(struct parser_ctx* ctx, struct declarator* pdeclarator);


struct declaration_list parse(struct parser_ctx* ctx, struct token_list* list, bool* berror);
const char* _Owner _Opt compile_source(const char* pszoptions, const char* content, struct report* report);

int initializer_init_new(struct parser_ctx* ctx,
                         struct type* p_current_object_type,
                         struct object* p_current_object,
                         struct initializer* braced_initializer,
                         bool is_constant,
                         bool requires_constant_initialization);

struct object* _Opt find_object_declarator_by_index(struct object* p_object, struct member_declaration_list* list, int member_index);


NODISCARD
bool unsigned_long_long_sub(_Ctor unsigned long long* result, unsigned long long a, unsigned long long b)
{
    *result = 0;

    if (a < b)
        return false;

    *result = a - b;
    return true;
}

NODISCARD
bool unsigned_long_long_mul(_Ctor unsigned long long* result, unsigned long long a, unsigned long long b)
{
    *result = 0;

    if (b == 0)
    {
        /*
          b cannot be zero in the next test
          so we solve this case here
        */
        *result = 0;
        return true;
    }

    if (a > ULLONG_MAX / b)
        return false;

    *result = a * b;
    return true;
}

NODISCARD
bool unsigned_long_long_add(_Ctor unsigned long long* result, unsigned long long a, unsigned long long b)
{
    *result = 0;

    if (a > ULLONG_MAX - b)
    {
        //a=2
        //b=254
        return false;
    }
    *result = a + b;
    return true;
}

NODISCARD
bool signed_long_long_sub(_Ctor signed long long* result, signed long long a, signed long long b)
{
    *result = 0;

    if (a >= 0 && b >= 0)
    {
    }
    else if (a < 0 && b < 0)
    {
    }
    else
    {
        if (a < 0)
        {
            if (a < LLONG_MIN + b)
            {
                // (-128) - (-1)
                return false;
            }
        }
        else
        {
            if (b == LLONG_MIN)
            {
                // 0 - (-128)                
                return false;
            }

            if (a > LLONG_MAX - (-b))
            {
                /*
                *  1 - (-127)
                *  2 - (-126)
                */
                return false;
            }
        }
    }

    *result = a - b;
    return true;
}

NODISCARD
bool signed_long_long_add(_Ctor signed long long* result, signed long long a, signed long long b)
{
    *result = 0;

    if (a >= 0 && b >= 0)
    {
        /*both positive*/
        if (a > LLONG_MAX - b)
        {
            //2+126
            return false;
        }
    }
    else if (a < 0 && b < 0)
    {

        if (a == LLONG_MIN || b == LLONG_MIN)
        {
            //(-128) + (-128)
            return false;
        }

        if (a < LLONG_MIN - b)
        {
            // (-127) + (-127)
            return false;
        }
    }
    else
    {
        /*one positive another negative*/

    }

    *result = a + b;
    return true;
}

NODISCARD
bool signed_long_long_mul(_Ctor signed long long* result, signed long long a, signed long long b)
{
    *result = 0;

    if (a > 0 && b > 0)
    {
        if (a > LLONG_MAX / b)
        {
            //2*64
            return false;
        }
    }
    else if (a < 0 && b < 0)
    {

        if (a == LLONG_MIN || b == LLONG_MIN)
        {
            //(-128)*(-128)
            return false;
        }

        if (-a > LLONG_MAX / -b)
        {
            //-127 * -127
            return false;
        }
    }
    else
    {
        if (a == 0 || b == 0)
        {
            *result = 0;
            return true;
        }
        if (b > 0)
        {
            if (a < LLONG_MIN / b)
                //(-127) * (2)
                return false;
        }
        else
        {
            if (b < LLONG_MIN / a)
            {
                //2*(-128)
                return false;
            }
        }
    }

    *result = a * b;
    return true;
}

void object_swap(struct object* a, struct object* b)
{
    struct object temp = *a;
    *a = *b;
    *b = temp;
}

void object_destroy(_Opt _Dtor struct object* p)
{
    assert(p->next == NULL);

    type_destroy(&p->type);
    free((void* _Owner)p->debug_name);

    struct object* _Owner _Opt item = p->members;
    while (item)
    {
        struct object* _Owner _Opt next = item->next;
        item->next = NULL;
        object_delete(item);
        item = next;
    }
}

void object_delete(struct object* _Opt _Owner p)
{
    if (p)
    {
        object_destroy(p);
        free(p);
    }
}

bool object_has_constant_value(const struct object* a)
{
    a = object_get_referenced(a);
    return a->state == CONSTANT_VALUE_STATE_CONSTANT;
}

void object_to_string(const struct object* a, char buffer[], int sz)
{
    a = object_get_referenced(a);

    buffer[0] = 0;
    switch (a->value_type)
    {
    case TYPE_BOOL:
        snprintf(buffer, sz, "%s", a->value.signed_char_value ? "true" : "false");
        break;

    case TYPE_SIGNED_CHAR:
        snprintf(buffer, sz, "%c", a->value.signed_char_value);
        break;

    case TYPE_UNSIGNED_CHAR:
        snprintf(buffer, sz, "%c", a->value.unsigned_char_value);
        break;

    case TYPE_SIGNED_SHORT:
        snprintf(buffer, sz, "%c", a->value.signed_short_value);
        break;
    case TYPE_UNSIGNED_SHORT:
        snprintf(buffer, sz, "%c", a->value.signed_short_value);
        break;

    case TYPE_SIGNED_INT:
        snprintf(buffer, sz, "%d", a->value.signed_int_value);
        break;

    case TYPE_UNSIGNED_INT:
        snprintf(buffer, sz, "%u", a->value.signed_int_value);
        break;

    case TYPE_SIGNED_LONG:
        snprintf(buffer, sz, "%ld", a->value.signed_long_value);
        break;

    case TYPE_UNSIGNED_LONG:
        break;

    case TYPE_SIGNED_LONG_LONG:
        snprintf(buffer, sz, "%lud", a->value.signed_long_value);
        break;

    case TYPE_UNSIGNED_LONG_LONG:
        snprintf(buffer, sz, "%llu", a->value.signed_long_long_value);
        break;

    case TYPE_FLOAT:
        snprintf(buffer, sz, "%f", a->value.float_value);
        break;

    case TYPE_DOUBLE:
        snprintf(buffer, sz, "%f", a->value.double_value);
        break;

    case TYPE_LONG_DOUBLE:
        snprintf(buffer, sz, "%Lf", a->value.long_double_value);
        break;

    case TYPE_VOID_PTR:
        if (a->value.void_pointer == NULL)
            snprintf(buffer, sz, "null");
        else
            snprintf(buffer, sz, "%p", a->value.void_pointer);
        break;
    }
}

struct object object_make_size_t(size_t value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;

#if defined(_WIN64) || defined(__x86_64__) 
    r.value_type = TYPE_UNSIGNED_LONG_LONG;
    r.value.unsigned_long_long_value = value;
#else
    r.value_type = TYPE_UNSIGNED_INT;
    r.value.unsigned_int_value = value;
#endif

    return r;
}

struct object object_make_nullptr()
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;

    r.value_type = TYPE_SIGNED_INT;
    r.value.signed_short_value = 0;
    return r;
}

struct object object_make_wchar_t(wchar_t value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;

#ifdef _WIN32
    //static_assert(_Generic(L' ', unsigned short : 1), "");
    r.value_type = TYPE_SIGNED_SHORT;
    r.value.signed_short_value = value;
#else
    //static_assert(_Generic(L' ', int : 1), "");
    r.value_type = TYPE_SIGNED_INT;
    r.value.signed_int_value = value;
#endif

    return r;
}

struct object object_make_bool(bool value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;

    r.value_type = TYPE_BOOL;
    r.value.bool_value = value;
    return r;
}

#pragma warning( push )
#pragma warning( disable : 4244 )

int object_to_str(const struct object* a, int n, char str[/*n*/])
{
    str[0] = '\0';

    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL:
    case TYPE_SIGNED_CHAR:
    case TYPE_SIGNED_SHORT:
    case TYPE_SIGNED_INT:
    case TYPE_SIGNED_LONG:
    case TYPE_SIGNED_LONG_LONG:
    {
        long long v = object_to_signed_long_long(a);
        snprintf(str, n, "%lld", v);
    }
    break;

    case TYPE_UNSIGNED_CHAR:
    case TYPE_UNSIGNED_SHORT:
    case TYPE_UNSIGNED_INT:
    case TYPE_UNSIGNED_LONG:
    case TYPE_UNSIGNED_LONG_LONG:
    {
        unsigned long long v = object_to_unsigned_long_long(a);
        snprintf(str, n, "%llu", v);
    }
    break;

    case TYPE_FLOAT:
    case TYPE_DOUBLE:
    case TYPE_LONG_DOUBLE:
    {
        long double v = object_to_long_double(a);
        snprintf(str, n, "%Lf", v);
    }
    break;
    }

    return 0;
}

void object_set_signed_int(struct object* a, long long value)
{
    a = object_get_non_const_referenced(a);
    a->state = CONSTANT_VALUE_EQUAL;

    switch (a->value_type)
    {

    case TYPE_BOOL: a->value.bool_value = value; break;
    case TYPE_SIGNED_CHAR:  a->value.signed_char_value = value; break;
    case TYPE_UNSIGNED_CHAR:  a->value.unsigned_char_value = value; break;
    case TYPE_SIGNED_SHORT:  a->value.signed_short_value = value; break;
    case TYPE_UNSIGNED_SHORT:  a->value.unsigned_short_value = value; break;
    case TYPE_SIGNED_INT:  a->value.signed_int_value = value; break;
    case TYPE_UNSIGNED_INT:  a->value.unsigned_int_value = value; break;
    case TYPE_SIGNED_LONG:  a->value.signed_long_value = value; break;
    case TYPE_UNSIGNED_LONG:  a->value.unsigned_long_value = value; break;
    case TYPE_SIGNED_LONG_LONG:  a->value.signed_long_long_value = value; break;
    case TYPE_UNSIGNED_LONG_LONG:  a->value.unsigned_long_long_value = value; break;
    case TYPE_FLOAT:  a->value.float_value = value; break;
    case TYPE_DOUBLE:  a->value.double_value = value; break;
    case TYPE_LONG_DOUBLE:  a->value.long_double_value = value; break;

    case TYPE_VOID_PTR:  assert(0);  break;

    }

}

void object_set_unsigned_int(struct object* a, unsigned long long value)
{
    a = object_get_non_const_referenced(a);
    a->state = CONSTANT_VALUE_EQUAL;

    switch (a->value_type)
    {

    case TYPE_BOOL: a->value.bool_value = value; break;
    case TYPE_SIGNED_CHAR:  a->value.signed_char_value = value; break;
    case TYPE_UNSIGNED_CHAR:  a->value.unsigned_char_value = value; break;
    case TYPE_SIGNED_SHORT:  a->value.signed_short_value = value; break;
    case TYPE_UNSIGNED_SHORT:  a->value.unsigned_short_value = value; break;
    case TYPE_SIGNED_INT:  a->value.signed_int_value = value; break;
    case TYPE_UNSIGNED_INT:  a->value.unsigned_int_value = value; break;
    case TYPE_SIGNED_LONG:  a->value.signed_long_value = value; break;
    case TYPE_UNSIGNED_LONG:  a->value.unsigned_long_value = value; break;
    case TYPE_SIGNED_LONG_LONG:  a->value.signed_long_long_value = value; break;
    case TYPE_UNSIGNED_LONG_LONG:  a->value.unsigned_long_long_value = value; break;
    case TYPE_FLOAT:  a->value.float_value = value; break;
    case TYPE_DOUBLE:  a->value.double_value = value; break;
    case TYPE_LONG_DOUBLE:  a->value.long_double_value = value; break;
    case TYPE_VOID_PTR:  assert(0);  break;

    }

}

bool object_to_bool(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR: return a->value.void_pointer != 0;
    }
    assert(0);
    return 0;
}
struct object object_make_signed_char(signed char value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_SIGNED_CHAR;
    r.value.signed_char_value = value;
    return r;
}

errno_t object_increment_value(struct object* a)
{
    a = object_get_non_const_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL:
        a->value.bool_value++;
        break;
    case TYPE_SIGNED_CHAR:
        a->value.signed_char_value++;
        break;
    case TYPE_UNSIGNED_CHAR:
        a->value.unsigned_char_value++;
        break;
    case TYPE_SIGNED_SHORT:
        a->value.signed_short_value++;
        break;
    case TYPE_UNSIGNED_SHORT:
        a->value.unsigned_short_value++;
        break;
    case TYPE_SIGNED_INT:
        a->value.signed_int_value++;
        break;
    case TYPE_UNSIGNED_INT:
        a->value.unsigned_int_value++;
        break;
    case TYPE_SIGNED_LONG:
        a->value.signed_long_value++;
        break;
    case TYPE_UNSIGNED_LONG:
        a->value.unsigned_long_value++;
        break;
    case TYPE_SIGNED_LONG_LONG:
        a->value.signed_long_long_value++;
        break;
    case TYPE_UNSIGNED_LONG_LONG:
        a->value.unsigned_long_long_value++;
        break;
    case TYPE_FLOAT:
        a->value.float_value++;
        break;
    case TYPE_DOUBLE:
        a->value.double_value++;
        break;
    case TYPE_LONG_DOUBLE:
        a->value.long_double_value++;
        break;

    case TYPE_VOID_PTR:  assert(0);  break;

    default:
        return 1;
    }

    return 0;
}

signed char object_to_signed_char(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR:  return 0;// a->value.void_pointer;  break;
    }
    assert(0);
    return 0;
}

struct object object_make_unsigned_char(unsigned char value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_UNSIGNED_CHAR;
    r.value.unsigned_char_value = value;
    return r;
}

unsigned char object_to_unsigned_char(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;

    }
    assert(0);
    return 0;
}
struct object object_make_signed_short(signed short value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_SIGNED_SHORT;
    r.value.signed_short_value = value;
    return r;
}

signed short object_to_signed_short(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR: assert(0); break;

    }
    assert(0);
    return 0;
}
struct object object_make_unsigned_short(unsigned short value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_UNSIGNED_SHORT;
    r.value.unsigned_short_value = value;
    return r;
}

unsigned short object_to_unsigned_short(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR: assert(0); break;
    }
    assert(0);
    return 0;
}
struct object object_make_signed_int(signed int value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_SIGNED_INT;
    r.value.signed_int_value = value;
    return r;
}

signed int object_to_signed_int(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR: return (int)a->value.void_pointer; break;
    }
    assert(0);
    return 0;
}
struct object object_make_unsigned_int(unsigned int value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_UNSIGNED_INT;
    r.value.unsigned_int_value = value;
    return r;
}

unsigned int object_to_unsigned_int(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR: return (int)a->value.void_pointer; break;
    }
    assert(0);
    return 0;
}
struct object object_make_signed_long(signed long value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_SIGNED_LONG;
    r.value.signed_long_value = value;
    return r;
}

signed long object_to_signed_long(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR: assert(0); break;
    }
    assert(0);
    return 0;
}
struct object object_make_unsigned_long(unsigned long value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_UNSIGNED_LONG;
    r.value.unsigned_long_value = value;
    return r;
}

unsigned long object_to_unsigned_long(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR: assert(0); break;
    }
    assert(0);
    return 0;
}
struct object object_make_signed_long_long(signed long long value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_SIGNED_LONG_LONG;
    r.value.signed_long_long_value = value;
    return r;
}

signed long long object_to_signed_long_long(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR: assert(0); break;
    }
    assert(0);
    return 0;
}
struct object object_make_unsigned_long_long(unsigned long long value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_UNSIGNED_LONG_LONG;
    r.value.unsigned_long_long_value = value;
    return r;
}

unsigned long long object_to_unsigned_long_long(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR: assert(0); break;
    }
    assert(0);
    return 0;
}
struct object object_make_float(float value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_FLOAT;
    r.value.float_value = value;
    return r;
}

float object_to_float(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR: assert(0); break;
    }
    assert(0);
    return 0;
}
struct object object_make_double(double value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_DOUBLE;
    r.value.double_value = value;
    return r;
}

double object_to_double(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR: assert(0); break;
    }
    assert(0);
    return 0;
}


struct object  object_make_null_pointer()
{
    struct object null_object = {
       .value_type = TYPE_VOID_PTR,
            .value.void_pointer = NULL,
            .state = CONSTANT_VALUE_EQUAL,
    };

    return null_object;
}

struct object object_make_pointer(struct object* object)
{
    object = object_get_non_const_referenced(object);

    struct object r = { 0 };
    r.state = CONSTANT_VALUE_EQUAL;
    r.value_type = TYPE_VOID_PTR;
    r.value.void_pointer = object;

    return r;
}

struct object object_make_reference(struct object* object)
{
    object = object_get_non_const_referenced(object);

    struct object r = { 0 };
    r.state = CONSTANT_VALUE_EQUAL;
    r.value_type = TYPE_VOID_PTR_REF;
    r.value.void_pointer = object;

    return r;
}

struct object object_make_long_double(long double value)
{
    struct object r = { 0 };
    r.state = CONSTANT_VALUE_STATE_CONSTANT;
    r.value_type = TYPE_LONG_DOUBLE;
    r.value.long_double_value = value;
    return r;
}

long double object_to_long_double(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL: return a->value.bool_value;
    case TYPE_SIGNED_CHAR: return a->value.signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->value.unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->value.signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->value.unsigned_short_value;
    case TYPE_SIGNED_INT: return a->value.signed_int_value;
    case TYPE_UNSIGNED_INT: return a->value.unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->value.signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->value.unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->value.signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->value.unsigned_long_long_value;
    case TYPE_FLOAT: return a->value.float_value;
    case TYPE_DOUBLE: return a->value.double_value;
    case TYPE_LONG_DOUBLE: return a->value.long_double_value;
    case TYPE_VOID_PTR: assert(0); break;
    }
    assert(0);
    return 0;
}



#pragma warning( pop )



struct object object_cast(enum object_value_type t, const struct object* v)
{
    v = object_get_referenced(v);

    //No changes
    if (v->value_type == t)
        return *v;


    //This function is generated by this program
    /*
            struct type
            {
                const char * type;
                const char * name;
                const char * value_type;
            };
            struct type types[] =
            {
                {"bool", "bool", "TYPE_BOOL"},
                {"signed char", "signed_char", "TYPE_SIGNED_CHAR"},
                {"unsigned char", "unsigned_char", "TYPE_UNSIGNED_CHAR"},
                {"signed short", "signed_short", "TYPE_SIGNED_SHORT"},
                {"unsigned short", "unsigned_short", "TYPE_UNSIGNED_SHORT"},
                {"signed int", "signed_int", "TYPE_SIGNED_INT"},
                {"unsigned int", "unsigned_int", "TYPE_UNSIGNED_INT"},
                {"signed long", "signed_long", "TYPE_SIGNED_LONG"},
                {"unsigned long", "unsigned_long", "TYPE_UNSIGNED_LONG"},
                {"signed long long", "signed_long_long", "TYPE_SIGNED_LONG_LONG"},
                {"unsigned long long", "unsigned_long_long", "TYPE_UNSIGNED_LONG_LONG"},
                {"float", "float", "TYPE_FLOAT"},
                {"double", "double", "TYPE_DOUBLE"},
                {"long double", "long_double", "TYPE_LONG_DOUBLE"}
            };


            int main()
            {
                FILE * f = fopen("imp.c", "w");
                if (f == NULL)
                    return;

                fprintf(f, "struct object cast(enum object_value_type t, struct object * v)\n");
                fprintf(f, "{\n");
                for (int i = 0; i < sizeof(types) / sizeof(types[0]); i++)
                {
                    fprintf(f, "if (t == %s)\n", types[i].value_type);
                    fprintf(f, "{\n");
                    for (int j = 0; j < sizeof(types) / sizeof(types[0]); j++)
                    {
                        if (i == j)
                            continue;
                        fprintf(f, "if (v->type == %s)\n", types[j].value_type);
                        fprintf(f, " return object_make_%s((%s)v->value.%s_value);\n", types[i].name, types[i].type, types[j].name);
                    }
                    fprintf(f, "}\n");
                }
                fprintf(f, "}\n");

                fclose(f);
            }
    */
    if (t == TYPE_BOOL)
    {
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_bool((bool)v->value.signed_char_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_bool((bool)v->value.unsigned_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_bool((bool)v->value.signed_short_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_bool((bool)v->value.unsigned_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_bool((bool)v->value.signed_int_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_bool((bool)v->value.unsigned_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_bool((bool)v->value.signed_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_bool((bool)v->value.unsigned_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_bool((bool)v->value.signed_long_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_bool((bool)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_bool((bool)v->value.float_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_bool((bool)v->value.double_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_bool((bool)v->value.long_double_value);
    }
    if (t == TYPE_SIGNED_CHAR)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_signed_char((signed char)v->value.bool_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_signed_char((signed char)v->value.unsigned_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_signed_char((signed char)v->value.signed_short_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_signed_char((signed char)v->value.unsigned_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_signed_char((signed char)v->value.signed_int_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_signed_char((signed char)v->value.unsigned_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_signed_char((signed char)v->value.signed_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_signed_char((signed char)v->value.unsigned_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_signed_char((signed char)v->value.signed_long_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_signed_char((signed char)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_signed_char((signed char)v->value.float_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_signed_char((signed char)v->value.double_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_signed_char((signed char)v->value.long_double_value);
    }
    if (t == TYPE_UNSIGNED_CHAR)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_unsigned_char((unsigned char)v->value.bool_value);
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_unsigned_char((unsigned char)v->value.signed_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_unsigned_char((unsigned char)v->value.signed_short_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_unsigned_char((unsigned char)v->value.unsigned_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_unsigned_char((unsigned char)v->value.signed_int_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_unsigned_char((unsigned char)v->value.unsigned_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_unsigned_char((unsigned char)v->value.signed_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_unsigned_char((unsigned char)v->value.unsigned_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_unsigned_char((unsigned char)v->value.signed_long_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_unsigned_char((unsigned char)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_unsigned_char((unsigned char)v->value.float_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_unsigned_char((unsigned char)v->value.double_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_unsigned_char((unsigned char)v->value.long_double_value);
    }
    if (t == TYPE_SIGNED_SHORT)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_signed_short((signed short)v->value.bool_value);
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_signed_short((signed short)v->value.signed_char_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_signed_short((signed short)v->value.unsigned_char_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_signed_short((signed short)v->value.unsigned_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_signed_short((signed short)v->value.signed_int_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_signed_short((signed short)v->value.unsigned_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_signed_short((signed short)v->value.signed_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_signed_short((signed short)v->value.unsigned_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_signed_short((signed short)v->value.signed_long_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_signed_short((signed short)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_signed_short((signed short)v->value.float_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_signed_short((signed short)v->value.double_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_signed_short((signed short)v->value.long_double_value);
    }
    if (t == TYPE_UNSIGNED_SHORT)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_unsigned_short((unsigned short)v->value.bool_value);
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_unsigned_short((unsigned short)v->value.signed_char_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_unsigned_short((unsigned short)v->value.unsigned_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_unsigned_short((unsigned short)v->value.signed_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_unsigned_short((unsigned short)v->value.signed_int_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_unsigned_short((unsigned short)v->value.unsigned_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_unsigned_short((unsigned short)v->value.signed_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_unsigned_short((unsigned short)v->value.unsigned_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_unsigned_short((unsigned short)v->value.signed_long_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_unsigned_short((unsigned short)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_unsigned_short((unsigned short)v->value.float_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_unsigned_short((unsigned short)v->value.double_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_unsigned_short((unsigned short)v->value.long_double_value);
    }
    if (t == TYPE_SIGNED_INT)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_signed_int((signed int)v->value.bool_value);
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_signed_int((signed int)v->value.signed_char_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_signed_int((signed int)v->value.unsigned_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_signed_int((signed int)v->value.signed_short_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_signed_int((signed int)v->value.unsigned_short_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_signed_int((signed int)v->value.unsigned_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_signed_int((signed int)v->value.signed_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_signed_int((signed int)v->value.unsigned_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_signed_int((signed int)v->value.signed_long_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_signed_int((signed int)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_signed_int((signed int)v->value.float_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_signed_int((signed int)v->value.double_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_signed_int((signed int)v->value.long_double_value);
    }
    if (t == TYPE_UNSIGNED_INT)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_unsigned_int((unsigned int)v->value.bool_value);
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_unsigned_int((unsigned int)v->value.signed_char_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_unsigned_int((unsigned int)v->value.unsigned_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_unsigned_int((unsigned int)v->value.signed_short_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_unsigned_int((unsigned int)v->value.unsigned_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_unsigned_int((unsigned int)v->value.signed_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_unsigned_int((unsigned int)v->value.signed_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_unsigned_int((unsigned int)v->value.unsigned_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_unsigned_int((unsigned int)v->value.signed_long_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_unsigned_int((unsigned int)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_unsigned_int((unsigned int)v->value.float_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_unsigned_int((unsigned int)v->value.double_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_unsigned_int((unsigned int)v->value.long_double_value);
    }
    if (t == TYPE_SIGNED_LONG)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_signed_long((signed long)v->value.bool_value);
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_signed_long((signed long)v->value.signed_char_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_signed_long((signed long)v->value.unsigned_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_signed_long((signed long)v->value.signed_short_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_signed_long((signed long)v->value.unsigned_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_signed_long((signed long)v->value.signed_int_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_signed_long((signed long)v->value.unsigned_int_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_signed_long((signed long)v->value.unsigned_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_signed_long((signed long)v->value.signed_long_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_signed_long((signed long)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_signed_long((signed long)v->value.float_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_signed_long((signed long)v->value.double_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_signed_long((signed long)v->value.long_double_value);
    }
    if (t == TYPE_UNSIGNED_LONG)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_unsigned_long((unsigned long)v->value.bool_value);
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_unsigned_long((unsigned long)v->value.signed_char_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_unsigned_long((unsigned long)v->value.unsigned_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_unsigned_long((unsigned long)v->value.signed_short_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_unsigned_long((unsigned long)v->value.unsigned_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_unsigned_long((unsigned long)v->value.signed_int_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_unsigned_long((unsigned long)v->value.unsigned_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_unsigned_long((unsigned long)v->value.signed_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_unsigned_long((unsigned long)v->value.signed_long_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_unsigned_long((unsigned long)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_unsigned_long((unsigned long)v->value.float_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_unsigned_long((unsigned long)v->value.double_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_unsigned_long((unsigned long)v->value.long_double_value);
    }
    if (t == TYPE_SIGNED_LONG_LONG)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_signed_long_long((signed long long)v->value.bool_value);
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_signed_long_long((signed long long)v->value.signed_char_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_signed_long_long((signed long long)v->value.unsigned_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_signed_long_long((signed long long)v->value.signed_short_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_signed_long_long((signed long long)v->value.unsigned_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_signed_long_long((signed long long)v->value.signed_int_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_signed_long_long((signed long long)v->value.unsigned_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_signed_long_long((signed long long)v->value.signed_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_signed_long_long((signed long long)v->value.unsigned_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_signed_long_long((signed long long)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_signed_long_long((signed long long)v->value.float_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_signed_long_long((signed long long)v->value.double_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_signed_long_long((signed long long)v->value.long_double_value);
    }
    if (t == TYPE_UNSIGNED_LONG_LONG)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_unsigned_long_long((unsigned long long)v->value.bool_value);
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_unsigned_long_long((unsigned long long)v->value.signed_char_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_unsigned_long_long((unsigned long long)v->value.unsigned_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_unsigned_long_long((unsigned long long)v->value.signed_short_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_unsigned_long_long((unsigned long long)v->value.unsigned_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_unsigned_long_long((unsigned long long)v->value.signed_int_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_unsigned_long_long((unsigned long long)v->value.unsigned_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_unsigned_long_long((unsigned long long)v->value.signed_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_unsigned_long_long((unsigned long long)v->value.unsigned_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_unsigned_long_long((unsigned long long)v->value.signed_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_unsigned_long_long((unsigned long long)v->value.float_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_unsigned_long_long((unsigned long long)v->value.double_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_unsigned_long_long((unsigned long long)v->value.long_double_value);
    }
    if (t == TYPE_FLOAT)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_float((float)v->value.bool_value);
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_float((float)v->value.signed_char_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_float((float)v->value.unsigned_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_float((float)v->value.signed_short_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_float((float)v->value.unsigned_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_float((float)v->value.signed_int_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_float((float)v->value.unsigned_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_float((float)v->value.signed_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_float((float)v->value.unsigned_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_float((float)v->value.signed_long_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_float((float)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_float((float)v->value.double_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_float((float)v->value.long_double_value);
    }
    if (t == TYPE_DOUBLE)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_double((double)v->value.bool_value);
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_double((double)v->value.signed_char_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_double((double)v->value.unsigned_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_double((double)v->value.signed_short_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_double((double)v->value.unsigned_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_double((double)v->value.signed_int_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_double((double)v->value.unsigned_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_double((double)v->value.signed_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_double((double)v->value.unsigned_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_double((double)v->value.signed_long_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_double((double)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_double((double)v->value.float_value);
        if (v->value_type == TYPE_LONG_DOUBLE)
            return object_make_double((double)v->value.long_double_value);
    }
    if (t == TYPE_LONG_DOUBLE)
    {
        if (v->value_type == TYPE_BOOL)
            return object_make_long_double((long double)v->value.bool_value);
        if (v->value_type == TYPE_SIGNED_CHAR)
            return object_make_long_double((long double)v->value.signed_char_value);
        if (v->value_type == TYPE_UNSIGNED_CHAR)
            return object_make_long_double((long double)v->value.unsigned_char_value);
        if (v->value_type == TYPE_SIGNED_SHORT)
            return object_make_long_double((long double)v->value.signed_short_value);
        if (v->value_type == TYPE_UNSIGNED_SHORT)
            return object_make_long_double((long double)v->value.unsigned_short_value);
        if (v->value_type == TYPE_SIGNED_INT)
            return object_make_long_double((long double)v->value.signed_int_value);
        if (v->value_type == TYPE_UNSIGNED_INT)
            return object_make_long_double((long double)v->value.unsigned_int_value);
        if (v->value_type == TYPE_SIGNED_LONG)
            return object_make_long_double((long double)v->value.signed_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG)
            return object_make_long_double((long double)v->value.unsigned_long_value);
        if (v->value_type == TYPE_SIGNED_LONG_LONG)
            return object_make_long_double((long double)v->value.signed_long_long_value);
        if (v->value_type == TYPE_UNSIGNED_LONG_LONG)
            return object_make_long_double((long double)v->value.unsigned_long_long_value);
        if (v->value_type == TYPE_FLOAT)
            return object_make_long_double((long double)v->value.float_value);
        if (v->value_type == TYPE_DOUBLE)
            return object_make_long_double((long double)v->value.double_value);
    }
    struct object empty = { 0 };
    return empty;
}

void object_default_initialization(struct object* p_object, bool is_constant)
{
    if (p_object->members == NULL)
    {
        if (is_constant)
            p_object->state = CONSTANT_VALUE_STATE_CONSTANT;
        else
            p_object->state = CONSTANT_VALUE_EQUAL;
        p_object->value.unsigned_long_long_value = 0;
    }

    if (type_is_union(&p_object->type))
    {
        struct object* _Opt p = p_object->members;
        if (p)
        {
            object_default_initialization(p, is_constant);
        }
    }
    else
    {
        struct object* _Opt p = p_object->members;
        while (p)
        {
            object_default_initialization(p, is_constant);
            p = p->next;
        }
    }
}

struct object* object_get_non_const_referenced(struct object* p_object)
{
    if (p_object->value_type == TYPE_VOID_PTR_REF)
    {
        p_object = p_object->value.void_pointer;
    }

    assert(p_object->value_type != TYPE_VOID_PTR_REF);

    return p_object;
}


const struct object* object_get_referenced(const struct object* p_object)
{
    if (p_object->value_type == TYPE_VOID_PTR_REF)
    {
        p_object = p_object->value.void_pointer;
    }

    assert(p_object->value_type != TYPE_VOID_PTR_REF);

    return p_object;
}


int get_rank(enum object_value_type t)
{
    //https://cigix.me/c23#6.3.1.1
    if (t == TYPE_SIGNED_LONG_LONG ||
        t == TYPE_UNSIGNED_LONG_LONG)
    {
        return 80;
    }
    else if (t == TYPE_SIGNED_LONG ||
             t == TYPE_UNSIGNED_LONG)
    {
        return 50;
    }
    else if (t == TYPE_SIGNED_INT ||
             t == TYPE_UNSIGNED_INT)
    {
        return 40;
    }
    else if (t == TYPE_SIGNED_SHORT ||
             t == TYPE_UNSIGNED_SHORT)
    {
        return 30;
    }
    else if (t == TYPE_SIGNED_CHAR ||
             t == TYPE_UNSIGNED_CHAR)
    {
        return 20;
    }
    return 0;
}


int get_size(enum object_value_type t)
{
    if (t == TYPE_SIGNED_LONG_LONG ||
        t == TYPE_UNSIGNED_LONG_LONG)
    {
        return sizeof(long long);
    }
    else if (t == TYPE_SIGNED_LONG ||
             t == TYPE_UNSIGNED_LONG)
    {
        return sizeof(long);
    }
    else if (t == TYPE_SIGNED_INT ||
             t == TYPE_UNSIGNED_INT)
    {
        return sizeof(int);
    }
    else if (t == TYPE_SIGNED_SHORT ||
             t == TYPE_UNSIGNED_SHORT)
    {
        return sizeof(short);
    }
    else if (t == TYPE_SIGNED_CHAR ||
             t == TYPE_UNSIGNED_CHAR)
    {
        return sizeof(char);
    }
    else if (t == TYPE_VOID_PTR)
    {
        return sizeof(void*);
    }

    return 1;
}

bool is_signed(enum object_value_type t)
{
    switch (t)
    {
    case TYPE_BOOL:
    case TYPE_SIGNED_CHAR:
    case TYPE_SIGNED_SHORT:
    case TYPE_SIGNED_INT:
    case TYPE_SIGNED_LONG:
    case TYPE_SIGNED_LONG_LONG:
    case TYPE_DOUBLE:
    case TYPE_LONG_DOUBLE:
        return true;
    case TYPE_VOID_PTR: break;
    default:
        break;
    }
    return false;
}

enum object_value_type to_unsigned(enum object_value_type t)
{
    switch (t)
    {
    case TYPE_SIGNED_CHAR: return TYPE_UNSIGNED_CHAR;
    case TYPE_SIGNED_SHORT:return TYPE_UNSIGNED_SHORT;
    case TYPE_SIGNED_INT: return TYPE_UNSIGNED_INT;
    case TYPE_SIGNED_LONG:return  TYPE_UNSIGNED_LONG;
    case TYPE_SIGNED_LONG_LONG: return TYPE_UNSIGNED_LONG_LONG;
    default:
        break;
    }
    return t;
}

bool is_unsigned(enum object_value_type t)
{
    switch (t)
    {
    case TYPE_BOOL:
    case TYPE_UNSIGNED_CHAR:
    case TYPE_UNSIGNED_SHORT:
    case TYPE_UNSIGNED_INT:
    case TYPE_UNSIGNED_LONG:
    case TYPE_UNSIGNED_LONG_LONG:
        return true;
    default:
        break;
    }
    return false;
}

void object_set_any(struct object* p_object)
{
    p_object = object_get_non_const_referenced(p_object);
    p_object->state = CONSTANT_VALUE_STATE_ANY;
    struct object* p = p_object->members;
    while (p)
    {
        object_set_any(p);
        p = p->next;
    }
}

bool object_is_signed(const struct object* p_object)
{
    p_object = (struct object* _Opt) object_get_referenced(p_object);
    return is_signed(p_object->value_type);
}

bool object_is_derived(const struct object* p_object)
{
    if (p_object->value_type == TYPE_VOID_PTR_REF)
        return false;

    return p_object->members != NULL;
}

bool object_is_reference(const struct object* p_object)
{
    return p_object->value_type == TYPE_VOID_PTR_REF;
}

static void object_fix_parent(struct object* p_object, struct object* parent)
{
    struct object* _Opt it = p_object->members;
    while (it)
    {
        it->parent = parent;
        it = it->next;
    }
}

struct object* _Opt object_get_member(struct object* p_object, int index)
{
    p_object = (struct object* _Opt) object_get_referenced(p_object);

    if (p_object->members == NULL)
        return NULL; //tODO

    struct object* _Opt it = p_object->members;
    int count = 0;
    while (it)
    {
        if (index == count)
            return it;
        count++;
        it = it->next;
    }

    return NULL;
}

int object_set(
    struct parser_ctx* ctx,
    struct object* to,
    struct expression* _Opt p_init_expression,
    const struct object* from,
    bool is_constant,
    bool requires_constant_initialization)
{
    try
    {
        from = object_get_referenced(from);

        to->p_init_expression = p_init_expression;

        if (object_is_derived(to))
        {
            struct object* _Opt it_to = to->members;
            struct object* _Opt it_from = from->members;

            while (it_from && it_to)
            {
                object_set(ctx, it_to, NULL, it_from, is_constant, requires_constant_initialization);
                it_to = it_to->next;
                it_from = it_from->next;
            }
            if (it_from != NULL || it_to != NULL)
            {
                //TODO  in dev
              // assert(false);//TODO
            }
            //assert(it_from == NULL);
            //assert(it_to == NULL);
        }
        else
        {
            assert(to->members == NULL);

            to->state = from->state;
            to->value = object_cast(to->value_type, from).value;

            if (requires_constant_initialization &&
                !object_has_constant_value(from))
            {
                if (!type_is_pointer_or_array(&p_init_expression->type) &&
                    !type_is_function(&p_init_expression->type))
                {
                    struct token* _Opt tk = p_init_expression ?
                        p_init_expression->first_token : ctx->current;

                    compiler_diagnostic(C_ERROR_REQUIRES_COMPILE_TIME_VALUE,
                        ctx,
                        tk,
                        NULL,
                        "requires a compile time object");

                    throw;
                }
            }

            if (is_constant && from->state == CONSTANT_VALUE_STATE_CONSTANT)
            {
                /*
                  struct point { int x; } p = { .x = 1 };
                  const int i = p.x; //not a exactly constant
                  int j = i;}
                */

                //TODO
                /*
                      struct X {int x;};
                      int main() { constexpr struct X x = (struct X){ .x = 50 };}
                */
                to->state = CONSTANT_VALUE_STATE_CONSTANT;
            }
            else
            {
                if (to->state == CONSTANT_VALUE_STATE_CONSTANT)
                {
                    //Sample int i = 1; 1 is constant but i will not be
                    to->state = CONSTANT_VALUE_EQUAL;
                }
            }
        }
    }
    catch
    {
        return 1;
    }

    return 0;
}

struct object* _Owner _Opt make_object_ptr_core(const struct type* p_type, const char* name)
{
    struct object* _Owner _Opt p_object = NULL;

    try
    {
        if (p_type->category == TYPE_CATEGORY_FUNCTION)
        {
            p_object = calloc(1, sizeof * p_object);
            if (p_object == NULL)
                throw;
            p_object->debug_name = strdup(name);
            p_object->type = type_dup(p_type);
            return p_object;
        }

        if (p_type->category == TYPE_CATEGORY_POINTER)
        {
            p_object = calloc(1, sizeof * p_object);
            if (p_object == NULL)
                throw;

            *p_object = object_make_nullptr();
            p_object->state = CONSTANT_VALUE_STATE_UNINITIALIZED;
            assert(p_object->debug_name == NULL);
            p_object->debug_name = strdup(name);

            type_destroy(&p_object->type);
            p_object->type = type_dup(p_type);

            return p_object;
        }

        if (p_type->category == TYPE_CATEGORY_ARRAY)
        {
            p_object = calloc(1, sizeof * p_object);
            if (p_object == NULL)
                throw;
            p_object->type = type_dup(p_type);
            p_object->debug_name = strdup(name);

            if (p_type->num_of_elements > 0)
            {
                struct type array_item_type = get_array_item_type(p_type);

                //too big..
                const unsigned long long max_elements = p_type->num_of_elements > 1000 ? 1000 : p_type->num_of_elements;

                struct object* _Opt p_tail_object = NULL;
                for (unsigned long long i = 0; i < max_elements; i++)
                {
                    char buffer[200] = { 0 };
                    snprintf(buffer, sizeof buffer, "%s[%llu]", name, i);
                    struct object* _Owner _Opt p_member_obj = make_object_ptr_core(&array_item_type, buffer);
                    if (p_member_obj == NULL)
                    {
                        type_destroy(&array_item_type);
                        throw;
                    }
                    p_member_obj->parent = p_object;

                    free(p_member_obj->debug_name);
                    p_member_obj->debug_name = strdup(buffer);
                    if (p_tail_object == NULL)
                    {
                        assert(p_object->members == NULL);
                        p_object->members = p_member_obj;
                    }
                    else
                    {
                        assert(p_object->next == NULL);
                        p_tail_object->next = p_member_obj;
                    }

                    p_tail_object = p_member_obj;
                }
                type_destroy(&array_item_type);
            }

            return p_object;
        }


        if (p_type->struct_or_union_specifier == NULL)
        {
            p_object = calloc(1, sizeof * p_object);
            if (p_object == NULL)
                throw;


            p_object->state = CONSTANT_VALUE_STATE_UNINITIALIZED;
            p_object->value_type = type_to_object_type(p_type);
            p_object->value.signed_long_long_value = -1;
            p_object->debug_name = strdup(name);
            p_object->type = type_dup(p_type);

            return p_object;
        }


        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier == NULL)
        {
            //incomplete
            throw;
        }

        p_object = calloc(1, sizeof * p_object);
        if (p_object == NULL)
            throw;

        p_object->debug_name = strdup(name);
        p_object->type = type_dup(p_type);

        struct object* _Opt p_last_member_obj = NULL;

        struct member_declaration* _Opt p_member_declaration =
            p_struct_or_union_specifier->member_declaration_list.head;

        while (p_member_declaration)
        {
            if (p_member_declaration->member_declarator_list_opt)
            {
                struct member_declarator* _Opt p_member_declarator =
                    p_member_declaration->member_declarator_list_opt->head;

                while (p_member_declarator)
                {
                    if (p_member_declarator->declarator)
                    {
                        char buffer[200] = { 0 };
                        snprintf(buffer, sizeof buffer, "%s.%s", name, p_member_declarator->declarator->name_opt->lexeme);


                        struct object* _Owner _Opt p_member_obj = make_object_ptr_core(&p_member_declarator->declarator->type, buffer);
                        if (p_member_obj == NULL)
                            throw;

                        p_member_obj->parent = p_object;

                        free(p_member_obj->debug_name);
                        p_member_obj->debug_name = strdup(buffer);

                        if (p_object->members == NULL)
                        {
                            p_object->members = p_member_obj;
                        }
                        else
                        {
                            //assert(p_last_member_obj->next != NULL);
                            p_last_member_obj->next = p_member_obj;
                        }
                        p_last_member_obj = p_member_obj;
                    }
                    p_member_declarator = p_member_declarator->next;
                }
            }
            else if (p_member_declaration->specifier_qualifier_list != NULL)
            {
                if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                {
                    struct type t = { 0 };
                    t.category = TYPE_CATEGORY_ITSELF;
                    t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                    t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                    char buffer[200] = { 0 };
                    snprintf(buffer, sizeof buffer, ".%s", name);


                    struct object* _Owner _Opt p_member_obj = make_object_ptr_core(&t, buffer);
                    if (p_member_obj == NULL)
                        throw;

                    free(p_member_obj->debug_name);
                    p_member_obj->debug_name = strdup(buffer);

                    p_member_obj->parent = p_object;
                    if (p_last_member_obj == NULL)
                    {
                        assert(p_object->members == NULL);
                        p_object->members = p_member_obj;
                    }
                    else
                    {
                        p_last_member_obj->next = p_member_obj;
                    }
                    p_last_member_obj = p_member_obj;

                    type_destroy(&t);
                }
            }
            p_member_declaration = p_member_declaration->next;
        }
        return p_object;
    }
    catch
    {
        object_delete(p_object);
        p_object = NULL;
    }

    return NULL;

}

struct object* _Owner _Opt make_object_ptr(const struct type* p_type)
{
    return make_object_ptr_core(p_type, "");
}

int make_object_with_name(const struct type* p_type, struct object* obj, const char* name)
{
    struct object* _Owner _Opt p = make_object_ptr_core(p_type, name);
    if (p)
    {
        *obj = *p;
        object_fix_parent(obj, obj);
        free(p);
        return 0;
    }
    return 1;
}

struct object object_dup(const struct object* src)
{
    assert(src->members == NULL);
    //assert(src->next == NULL); ??

    struct object result = *src;
    result.type = type_dup(&src->type);

    if (src->debug_name)
        result.debug_name = strdup(src->debug_name);

    result.next = NULL;

    return result;
}

int make_object(const struct type* p_type, struct object* obj)
{
    return make_object_with_name(p_type, obj, "");
}


enum object_value_type  type_specifier_to_object_type(const enum type_specifier_flags type_specifier_flags)
{

    if (type_specifier_flags & TYPE_SPECIFIER_BOOL)
        return TYPE_BOOL;

    if (type_specifier_flags & TYPE_SPECIFIER_FLOAT)
        return TYPE_FLOAT;

    if (type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
    {
        if (type_specifier_flags & TYPE_SPECIFIER_LONG)
            return TYPE_LONG_DOUBLE;
        return TYPE_DOUBLE;
    }


    if (type_specifier_flags & TYPE_SPECIFIER_UNSIGNED)
    {
        if (type_specifier_flags & TYPE_SPECIFIER_CHAR)
            return TYPE_UNSIGNED_CHAR;
        if (type_specifier_flags & TYPE_SPECIFIER_SHORT)
            return TYPE_UNSIGNED_SHORT;
        if (type_specifier_flags & TYPE_SPECIFIER_LONG)
            return TYPE_UNSIGNED_LONG; /*check before int*/
        if (type_specifier_flags & TYPE_SPECIFIER_INT)
            return TYPE_UNSIGNED_INT;
        if (type_specifier_flags & TYPE_SPECIFIER_LONG_LONG)
            return TYPE_UNSIGNED_LONG_LONG;
    }
    else
    {
        if (type_specifier_flags & TYPE_SPECIFIER_CHAR)
            return TYPE_SIGNED_CHAR;
        if (type_specifier_flags & TYPE_SPECIFIER_SHORT)
            return TYPE_SIGNED_SHORT;
        if (type_specifier_flags & TYPE_SPECIFIER_LONG)
            return TYPE_SIGNED_LONG; /*check before int*/
        if (type_specifier_flags & TYPE_SPECIFIER_INT)
            return TYPE_SIGNED_INT;
        if (type_specifier_flags & TYPE_SPECIFIER_LONG_LONG)
            return TYPE_SIGNED_LONG_LONG;
    }
    return TYPE_SIGNED_INT;
}

enum object_value_type type_to_object_type(const struct type* type)
{
    if (type_is_pointer(type))
    {
#if defined(_WIN64) || defined(__x86_64__) 
        return TYPE_UNSIGNED_LONG_LONG;
#else
        return TYPE_UNSIGNED_INT;
#endif
    }

    return type_specifier_to_object_type(type->type_specifier_flags);
}



void object_print_value_debug(const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL:
        printf("%s (bool)", a->value.bool_value ? "true" : "false");
        break;

    case TYPE_SIGNED_CHAR:

        printf("%d (signed char)", (int)a->value.signed_char_value);
        break;


    case TYPE_UNSIGNED_CHAR:
        printf("%d (unsigned char)", (int)a->value.unsigned_char_value);
        break;


    case TYPE_SIGNED_SHORT:
        printf("%d (short)", a->value.signed_short_value);
        break;

    case TYPE_UNSIGNED_SHORT:
        printf("%d (unsigned short)", a->value.unsigned_short_value);
        break;

    case TYPE_SIGNED_INT:
        printf("%d (int)", a->value.signed_int_value);
        break;
    case TYPE_UNSIGNED_INT:
        printf("%du (unsigned int)", a->value.unsigned_int_value);
        break;
    case TYPE_SIGNED_LONG:
        printf("%ld (long)", a->value.signed_long_value);
        break;
    case TYPE_UNSIGNED_LONG:
        printf("%lu (unsigned long)", a->value.unsigned_long_value);
        break;
    case TYPE_SIGNED_LONG_LONG:
        printf("%lld (long long)", a->value.signed_long_long_value);
        break;
    case TYPE_UNSIGNED_LONG_LONG:
        printf("%llu (unsigned long long)", a->value.unsigned_long_long_value);
        break;
    case TYPE_FLOAT:
        printf("%f (float)", a->value.float_value);
        break;
    case TYPE_DOUBLE:
        printf("%lf (double)", a->value.double_value);
        break;
    case TYPE_LONG_DOUBLE:
        printf("%Lf (long double)", a->value.long_double_value);
        break;
    case TYPE_VOID_PTR:
        printf("%p (void*)", a->value.void_pointer);
        break;
    }

}

void object_print_to_debug_core(const struct object* object, int n, enum target target)
{

    if (object_is_reference(object))
    {
        object = object_get_referenced(object);
    }


    for (int i = 0; i < n; i++) printf("  ");
    if (object->debug_name)
        printf("%s ", object->debug_name);

    if (object->members != NULL)
    {

        type_print(&object->type, target);

        printf(" {\n");

        struct object* _Opt member = object->members;
        while (member)
        {
            object_print_to_debug_core(member, n + 1, target);
            member = member->next;
        }

        for (int i = 0; i < n; i++) printf("  ");
        printf("}\n");
    }
    else
    {



        type_print(&object->type, target);


        printf(" = ");

        object_print_value_debug(object);

        switch (object->state)
        {
        case CONSTANT_VALUE_STATE_UNINITIALIZED: printf(" uninitialized "); break;
        case CONSTANT_VALUE_STATE_ANY:printf(" unknown "); break;
        case CONSTANT_VALUE_EQUAL:printf(" exact "); break;
        case CONSTANT_VALUE_STATE_CONSTANT:printf(" constant_exact "); break;

        }

        printf("\n");
    }

}

void object_print_to_debug(const struct object* object, enum target target)
{
    int n = 0;
    object_print_to_debug_core(object, n, target);
}


/*
   extends the array to the max_index returning the added item.
*/
struct object* object_extend_array_to_index(const struct type* p_type, struct object* a, size_t max_index, bool is_constant)
{
    struct object* _Opt it = a->members;

    try
    {
        int count = 0;
        while (it)
        {
            count++;
            if (it->next == NULL)
                break;
            it = it->next;
        }

        while (count < (max_index + 1))
        {
            if (it == NULL)
            {
                assert(a->members == NULL);
                a->members = make_object_ptr(p_type);
                if (a->members == NULL)
                    throw;

                char name[100] = { 0 };
                snprintf(name, sizeof name, "[%d]", count);

                free((void* _Owner)a->members->debug_name);
                a->members->debug_name = strdup(name);

                object_default_initialization(a->members, is_constant);

                it = a->members;
                it->parent = a;
                count++;
            }
            else
            {
                struct object* _Owner _Opt p = make_object_ptr(p_type);
                if (p == NULL)
                    throw;
                char name[100] = { 0 };
                snprintf(name, sizeof name, "[%d]", count);

                free((void* _Owner)p->debug_name);
                p->debug_name = strdup(name);


                p->parent = a;
                object_default_initialization(p, is_constant);

                assert(it->next == NULL);
                it->next = p;

                it = p;
                count++;
            }
        }
    }
    catch
    {
    }
    return it;
}


bool object_is_promoted(const struct object* a)
{
    /*
      types smaller than int are promoted to int
    */
    if ((a->value_type == TYPE_BOOL) ||
        (a->value_type == TYPE_SIGNED_CHAR) ||
        (a->value_type == TYPE_UNSIGNED_CHAR) ||
        (a->value_type == TYPE_SIGNED_SHORT) ||
        a->value_type == TYPE_UNSIGNED_SHORT)
    {
        return true;
    }
    return false;
}

enum object_value_type object_common(const struct object* a, const struct object* b)
{

    enum object_value_type a_type = a->value_type;
    enum object_value_type b_type = b->value_type;

    //See 6.3.1.8 Usual arithmetic conversions


    /*
       First, if the type of either operand is _Decimal128,
       the other operand is converted to _Decimal128.
    */

    /*
      Otherwise, if the type of either operand is _Decimal64,
      the other operand is converted to _Decimal64
    */

    /*
      Otherwise, if the type of either operand is _Decimal32,
      the other operand is converted to _Decimal32.
    */

    /*
      Otherwise, if the corresponding real type of either operand is long double,
      the other operand is converted, without change of type domain, to a type whose
      corresponding real type is long double
    */
    if (a_type == TYPE_LONG_DOUBLE || b_type == TYPE_LONG_DOUBLE)
    {
        return TYPE_LONG_DOUBLE;
    }

    /*
      Otherwise, if the corresponding real type of either operand is double,
      the other operand is converted, without change of type domain, to a type
      whose corresponding real type is double.
    */

    if (a_type == TYPE_DOUBLE || b_type == TYPE_DOUBLE)
    {
        return TYPE_LONG_DOUBLE;
    }

    /*
      Otherwise, if the corresponding real type of either operand is float,
      the other operand is converted, without change of type domain,
      to a type whose corresponding real type is float
    */
    if (a_type == TYPE_FLOAT || b_type == TYPE_FLOAT)
    {
        return TYPE_FLOAT;
    }


    /*
     Otherwise, if any of the two types is an enumeration, it is converted to its underlying type.
    */

    /*
      Then, the integer promotions are performed on both operands.
    */


    if (object_is_promoted(a))
    {
        a_type = TYPE_SIGNED_INT;
    }

    if (object_is_promoted(b))
    {
        b_type = TYPE_SIGNED_INT;
    }


    /*
      Next, the following rules are applied to the promoted operands
      if both operands have the same type, then no further conversion is needed
    */
    if (a_type == b_type)
    {
        return a_type;
    }

    /*
     Otherwise, if both operands have signed integer types or both have unsigned integer
     types, the operand with the type of lesser integer conversion rank is converted to the type
     of the operand with greater rank.
    */

    if (is_signed(a_type) == is_signed(b_type))
    {
        if (get_rank(a_type) > get_rank(b_type))
        {
            return a_type;
        }

        return b_type;
    }


    /*
     Otherwise, if the operand that has unsigned integer type has rank greater or equal to
     the rank of the type of the other operand, then the operand with signed integer type is
     converted to the type of the operand with unsigned integer type.
    */


    enum object_value_type  signed_promoted = is_signed(a_type) ? a_type : b_type;
    enum object_value_type  unsigned_promoted = is_unsigned(a_type) ? a_type : b_type;


    if (get_rank(unsigned_promoted) >= get_rank(signed_promoted))
    {
        return unsigned_promoted;
    }

    /*
      Otherwise, if the type of the operand with signed integer type can represent all the values
      of the type of the operand with unsigned integer type, then the operand with unsigned
      integer type is converted to the type of the operand with signed integer type
    */

    if (get_size(signed_promoted) > get_size(unsigned_promoted))
    {
        return signed_promoted;
    }

    /*
      Otherwise, both operands are converted to the unsigned integer type corresponding to
      the type of the operand with signed integer type
    */

    return to_unsigned(signed_promoted);

}

int object_greater_than_or_equal(const struct object* a, const struct object* b)
{
    a = object_get_referenced(a);
    b = object_get_referenced(b);

    enum object_value_type common_type = object_common(a, b);

    switch (common_type)
    {
    case TYPE_SIGNED_INT:
        return object_to_signed_int(a) >= object_to_signed_int(b);

    case TYPE_UNSIGNED_INT:
        return object_to_unsigned_int(a) >= object_to_unsigned_int(b);

    case TYPE_BOOL:
        return object_to_bool(a) >= object_to_bool(b);

    case TYPE_SIGNED_CHAR:
        return object_to_signed_char(a) >= object_to_signed_char(b);

        break;
    case TYPE_UNSIGNED_CHAR:
        return object_to_unsigned_char(a) >= object_to_unsigned_char(b);

    case TYPE_SIGNED_SHORT:
        return object_to_signed_short(a) >= object_to_signed_short(b);

    case TYPE_UNSIGNED_SHORT:
        return object_to_unsigned_short(a) >= object_to_unsigned_short(b);

    case TYPE_SIGNED_LONG:
        return object_to_signed_long(a) >= object_to_signed_long(b);

    case TYPE_UNSIGNED_LONG:
        return object_to_unsigned_long(a) >= object_to_unsigned_long(b);

    case TYPE_SIGNED_LONG_LONG:
        return object_to_signed_long_long(a) >= object_to_signed_long_long(b);

    case TYPE_UNSIGNED_LONG_LONG:
        return object_to_unsigned_long_long(a) >= object_to_unsigned_long_long(b);

    case TYPE_FLOAT:
        return object_to_float(a) >= object_to_float(b);

    case TYPE_DOUBLE:
        return object_to_double(a) >= object_to_double(b);

    case TYPE_LONG_DOUBLE:
        return object_to_long_double(a) >= object_to_long_double(b);

    }

    assert(false);
    return object_to_unsigned_long_long(a) >= object_to_unsigned_long_long(b);

}

int object_smaller_than_or_equal(const struct object* a, const struct object* b)
{
    a = object_get_referenced(a);
    b = object_get_referenced(b);

    enum object_value_type common_type = object_common(a, b);

    switch (common_type)
    {
    case TYPE_SIGNED_INT:
        return object_to_signed_int(a) <= object_to_signed_int(b);

    case TYPE_UNSIGNED_INT:
        return object_to_unsigned_int(a) <= object_to_unsigned_int(b);

    case TYPE_BOOL:
        return object_to_bool(a) <= object_to_bool(b);

    case TYPE_SIGNED_CHAR:
        return object_to_signed_char(a) <= object_to_signed_char(b);

        break;
    case TYPE_UNSIGNED_CHAR:
        return object_to_unsigned_char(a) <= object_to_unsigned_char(b);

    case TYPE_SIGNED_SHORT:
        return object_to_signed_short(a) <= object_to_signed_short(b);

    case TYPE_UNSIGNED_SHORT:
        return object_to_unsigned_short(a) <= object_to_unsigned_short(b);

    case TYPE_SIGNED_LONG:
        return object_to_signed_long(a) <= object_to_signed_long(b);

    case TYPE_UNSIGNED_LONG:
        return object_to_unsigned_long(a) <= object_to_unsigned_long(b);

    case TYPE_SIGNED_LONG_LONG:
        return object_to_signed_long_long(a) <= object_to_signed_long_long(b);

    case TYPE_UNSIGNED_LONG_LONG:
        return object_to_unsigned_long_long(a) <= object_to_unsigned_long_long(b);

    case TYPE_FLOAT:
        return object_to_float(a) <= object_to_float(b);

    case TYPE_DOUBLE:
        return object_to_double(a) <= object_to_double(b);

    case TYPE_LONG_DOUBLE:
        return object_to_long_double(a) <= object_to_long_double(b);

    }

    assert(false);
    return object_to_unsigned_long_long(a) <= object_to_unsigned_long_long(b);
}

struct object object_add(const struct object* a, const struct object* b)
{
    a = object_get_referenced(a);
    b = object_get_referenced(b);

    enum object_value_type common_type = object_common(a, b);

    switch (common_type)
    {
    case TYPE_SIGNED_INT:
        return object_make_signed_int(object_to_signed_int(a) + object_to_signed_int(b));

    case TYPE_UNSIGNED_INT:
        return object_make_unsigned_int(object_to_unsigned_int(a) + object_to_unsigned_int(b));

    case TYPE_BOOL:
        return object_make_bool(object_to_bool(a) + object_to_bool(b));

        //case TYPE_SIGNED_CHAR:
          //  return object_make_signed_char(object_to_signed_char(a) == object_to_signed_char(b);

          //  break;
        //case TYPE_UNSIGNED_CHAR:
    //        return object_to_unsigned_char(a) == object_to_unsigned_char(b);

        //case TYPE_SIGNED_SHORT:
          //  return object_to_signed_short(a) == object_to_signed_short(b);

        //case TYPE_UNSIGNED_SHORT:
          //  return object_to_unsigned_short(a) == object_to_unsigned_short(b);

    case TYPE_SIGNED_LONG:
        return object_make_signed_long(object_to_signed_long(a) + object_to_signed_long(b));

    case TYPE_UNSIGNED_LONG:
        return object_make_unsigned_long(object_to_unsigned_long(a) + object_to_unsigned_long(b));

    case TYPE_SIGNED_LONG_LONG:
        return object_make_signed_long_long(object_to_signed_long_long(a) + object_to_signed_long_long(b));

    case TYPE_UNSIGNED_LONG_LONG:
        return object_make_unsigned_long_long(object_to_unsigned_long_long(a) + object_to_unsigned_long_long(b));

    case TYPE_FLOAT:
        return object_make_float(object_to_float(a) + object_to_float(b));

    case TYPE_DOUBLE:
        return object_make_double(object_to_double(a) + object_to_double(b));

    case TYPE_LONG_DOUBLE:
        return object_make_long_double(object_to_long_double(a) + object_to_long_double(b));

    }

    assert(false);
    struct object o = { 0 };
    return o;
}


struct object object_sub(const struct object* a, const struct object* b)
{
    a = object_get_referenced(a);
    b = object_get_referenced(b);

    enum object_value_type common_type = object_common(a, b);

    switch (common_type)
    {
    case TYPE_SIGNED_INT:
        return object_make_signed_int(object_to_signed_int(a) - object_to_signed_int(b));

    case TYPE_UNSIGNED_INT:
        return object_make_unsigned_int(object_to_unsigned_int(a) - object_to_unsigned_int(b));

    case TYPE_BOOL:
        return object_make_bool(object_to_bool(a) - object_to_bool(b));

        //case TYPE_SIGNED_CHAR:
          //  return object_make_signed_char(object_to_signed_char(a) == object_to_signed_char(b);

          //  break;
        //case TYPE_UNSIGNED_CHAR:
    //        return object_to_unsigned_char(a) == object_to_unsigned_char(b);

        //case TYPE_SIGNED_SHORT:
          //  return object_to_signed_short(a) == object_to_signed_short(b);

        //case TYPE_UNSIGNED_SHORT:
          //  return object_to_unsigned_short(a) == object_to_unsigned_short(b);

    case TYPE_SIGNED_LONG:
        return object_make_signed_long(object_to_signed_long(a) - object_to_signed_long(b));

    case TYPE_UNSIGNED_LONG:
        return object_make_unsigned_long(object_to_unsigned_long(a) - object_to_unsigned_long(b));

    case TYPE_SIGNED_LONG_LONG:
        return object_make_signed_long_long(object_to_signed_long_long(a) - object_to_signed_long_long(b));

    case TYPE_UNSIGNED_LONG_LONG:
        return object_make_unsigned_long_long(object_to_unsigned_long_long(a) - object_to_unsigned_long_long(b));

    case TYPE_FLOAT:
        return object_make_float(object_to_float(a) - object_to_float(b));

    case TYPE_DOUBLE:
        return object_make_double(object_to_double(a) - object_to_double(b));

    case TYPE_LONG_DOUBLE:
        return object_make_long_double(object_to_long_double(a) - object_to_long_double(b));

    }

    assert(false);
    struct object o = { 0 };
    return o;
}


int object_equal(const struct object* a, const struct object* b)
{
    a = object_get_referenced(a);
    b = object_get_referenced(b);

    enum object_value_type common_type = object_common(a, b);

    switch (common_type)
    {
    case TYPE_SIGNED_INT:
        return object_to_signed_int(a) == object_to_signed_int(b);

    case TYPE_UNSIGNED_INT:
        return object_to_unsigned_int(a) == object_to_unsigned_int(b);

    case TYPE_BOOL:
        return object_to_bool(a) == object_to_bool(b);

    case TYPE_SIGNED_CHAR:
        return object_to_signed_char(a) == object_to_signed_char(b);

        break;
    case TYPE_UNSIGNED_CHAR:
        return object_to_unsigned_char(a) == object_to_unsigned_char(b);

    case TYPE_SIGNED_SHORT:
        return object_to_signed_short(a) == object_to_signed_short(b);

    case TYPE_UNSIGNED_SHORT:
        return object_to_unsigned_short(a) == object_to_unsigned_short(b);

    case TYPE_SIGNED_LONG:
        return object_to_signed_long(a) == object_to_signed_long(b);

    case TYPE_UNSIGNED_LONG:
        return object_to_unsigned_long(a) == object_to_unsigned_long(b);

    case TYPE_SIGNED_LONG_LONG:
        return object_to_signed_long_long(a) == object_to_signed_long_long(b);

    case TYPE_UNSIGNED_LONG_LONG:
        return object_to_unsigned_long_long(a) == object_to_unsigned_long_long(b);

    case TYPE_FLOAT:
        return object_to_float(a) == object_to_float(b);

    case TYPE_DOUBLE:
        return object_to_double(a) == object_to_double(b);

    case TYPE_LONG_DOUBLE:
        return object_to_long_double(a) == object_to_long_double(b);

    }

    assert(false);
    return object_to_unsigned_long_long(a) == object_to_unsigned_long_long(b);
}


int object_not_equal(const struct object* a, const struct object* b)
{
    a = object_get_referenced(a);
    b = object_get_referenced(b);

    enum object_value_type common_type = object_common(a, b);

    switch (common_type)
    {
    case TYPE_SIGNED_INT:
        return object_to_signed_int(a) != object_to_signed_int(b);

    case TYPE_UNSIGNED_INT:
        return object_to_unsigned_int(a) != object_to_unsigned_int(b);

    case TYPE_BOOL:
        return object_to_bool(a) != object_to_bool(b);

    case TYPE_SIGNED_CHAR:
        return object_to_signed_char(a) != object_to_signed_char(b);

        break;
    case TYPE_UNSIGNED_CHAR:
        return object_to_unsigned_char(a) != object_to_unsigned_char(b);

    case TYPE_SIGNED_SHORT:
        return object_to_signed_short(a) != object_to_signed_short(b);

    case TYPE_UNSIGNED_SHORT:
        return object_to_unsigned_short(a) != object_to_unsigned_short(b);

    case TYPE_SIGNED_LONG:
        return object_to_signed_long(a) != object_to_signed_long(b);

    case TYPE_UNSIGNED_LONG:
        return object_to_unsigned_long(a) != object_to_unsigned_long(b);

    case TYPE_SIGNED_LONG_LONG:
        return object_to_signed_long_long(a) != object_to_signed_long_long(b);

    case TYPE_UNSIGNED_LONG_LONG:
        return object_to_unsigned_long_long(a) != object_to_unsigned_long_long(b);

    case TYPE_FLOAT:
        return object_to_float(a) != object_to_float(b);

    case TYPE_DOUBLE:
        return object_to_double(a) != object_to_double(b);

    case TYPE_LONG_DOUBLE:
        return object_to_long_double(a) != object_to_long_double(b);

    }

    assert(false);
    return object_to_unsigned_long_long(a) != object_to_unsigned_long_long(b);
}


#define OBJECTS_INITIAL_CAPACITY 8

void objects_destroy(struct objects* arr)
{
    free(arr->items);
}

int objects_push(struct objects* arr, struct object* obj)
{
    if (arr->items == NULL)
    {
        arr->items = malloc(OBJECTS_INITIAL_CAPACITY * sizeof(struct object*));
        if (!arr->items)
        {
            arr->size = 0;
            arr->capacity = 0;
            return ENOMEM;
        }
        arr->size = 0;
        arr->capacity = OBJECTS_INITIAL_CAPACITY;
    }
    if (arr->size == arr->capacity)
    {
        size_t new_capacity = arr->capacity ? arr->capacity * 2 : OBJECTS_INITIAL_CAPACITY;
        struct object** _Opt new_items = realloc(arr->items, new_capacity * sizeof(struct object*));
        if (!new_items) return ENOMEM;
        arr->items = new_items;
        arr->capacity = new_capacity;
    }
    arr->items[arr->size++] = obj;
    return 0;
}




/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/


#pragma safety enable



#include <math.h>

#ifdef _WIN32
#endif

#if defined _MSC_VER && !defined __POCC__
#endif

struct expression* _Owner _Opt postfix_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt cast_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt multiplicative_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt unary_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt additive_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt shift_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt relational_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt equality_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt and_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt exclusive_or_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt inclusive_or_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt logical_and_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt logical_or_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt conditional_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt conditional_expression(struct parser_ctx* ctx);

NODISCARD
static errno_t execute_bitwise_operator(struct parser_ctx* ctx, struct expression* new_expression, int op);

static int compare_function_arguments(struct parser_ctx* ctx,
                                      struct type* p_type,
                                      struct argument_expression_list* p_argument_expression_list)
{
    try
    {
        struct param* _Opt p_current_parameter_type = NULL;

        const struct param_list* _Opt p_param_list = type_get_func_or_func_ptr_params(p_type);
        if (p_param_list == NULL) throw;

        p_current_parameter_type = p_param_list->head;

        struct argument_expression* _Opt p_current_argument = p_argument_expression_list->head;

        if (p_current_parameter_type && type_is_void(&p_current_parameter_type->type))
        {
            //(void) function
            p_current_parameter_type = NULL;
        }

        while (p_current_argument && p_current_parameter_type)
        {
            check_assigment(ctx, &p_current_parameter_type->type, p_current_argument->expression, ASSIGMENT_TYPE_PARAMETER);
            p_current_argument = p_current_argument->next;
            p_current_parameter_type = p_current_parameter_type->next;
        }

        if (p_current_argument != NULL && !p_param_list->is_var_args)
        {
            compiler_diagnostic(C_ERROR_TOO_MANY_ARGUMENTS, ctx,
                                        p_current_argument->expression->first_token, NULL,
                                        "too many arguments");
            throw;
        }

        if (p_current_parameter_type != NULL && !p_param_list->is_void)
        {
            if (p_argument_expression_list->tail)
            {
                compiler_diagnostic(C_ERROR_TOO_FEW_ARGUMENTS, ctx,
                                            p_argument_expression_list->tail->expression->first_token,
                    NULL,
                                            "too few arguments");
            }
            else
            {
                compiler_diagnostic(C_ERROR_TOO_FEW_ARGUMENTS, ctx, ctx->current, NULL, "too few arguments");
            }
            throw;
        }
    }
    catch
    {
        return 1; /*error*/
    }

    return 0;
}

bool is_enumeration_constant(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    if (ctx->current->type != TK_IDENTIFIER)
    {
        return false;
    }

    if (ctx->current->flags & TK_FLAG_IDENTIFIER_IS_ENUMERATOR)
        return true;

    if (ctx->current->flags & TK_FLAG_IDENTIFIER_IS_NOT_ENUMERATOR)
        return false;

    const bool is_enumerator = find_enumerator(ctx, ctx->current->lexeme, NULL) != NULL;

    if (is_enumerator)
    {
        ctx->current->flags |= TK_FLAG_IDENTIFIER_IS_ENUMERATOR;
    }
    else
    {
        ctx->current->flags |= TK_FLAG_IDENTIFIER_IS_NOT_ENUMERATOR;
    }

    return is_enumerator;
}

bool is_first_of_floating_constant(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    /*
     floating-constant:
      decimal-floating-constant
      hexadecimal-floating-constan
    */
    return ctx->current->type == TK_COMPILER_DECIMAL_FLOATING_CONSTANT ||
        ctx->current->type == TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT;
}

bool is_first_of_integer_constant(const struct parser_ctx* ctx)
{
    /*
     integer-constant:
      decimal-constant integer-suffixopt
      octal-constant integer-suffixopt
      hexadecimal-constant integer-suffixopt
      binary-constant integer-suffixop
    */

    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_COMPILER_DECIMAL_CONSTANT ||
        ctx->current->type == TK_COMPILER_OCTAL_CONSTANT ||
        ctx->current->type == TK_COMPILER_HEXADECIMAL_CONSTANT ||
        ctx->current->type == TK_COMPILER_BINARY_CONSTANT;
}

bool is_predefined_constant(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD_TRUE ||
        ctx->current->type == TK_KEYWORD_FALSE ||
        ctx->current->type == TK_KEYWORD_NULLPTR;
}

bool is_first_of_constant(const struct parser_ctx* ctx)
{
    /*
     constant:
      integer-constant
      floating-constant
      enumeration-constant
      character-constant
      predefined-constant
    */
    if (ctx->current == NULL)
        return false;

    return is_first_of_integer_constant(ctx) ||
        is_first_of_floating_constant(ctx) ||
        is_enumeration_constant(ctx) ||
        (ctx->current->type == TK_CHAR_CONSTANT) ||
        is_predefined_constant(ctx);
}

bool is_first_of_primary_expression(const struct parser_ctx* ctx)
{
    /*
     primary-expression:
      identifier
      constant
      string-literal
      ( expression )
      generic-selection
      typeid (expression )
    */
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_IDENTIFIER ||
        is_first_of_constant(ctx) ||
        ctx->current->type == TK_STRING_LITERAL ||
        ctx->current->type == '(' ||
        ctx->current->type == TK_KEYWORD__GENERIC;
}

struct generic_association* _Owner _Opt generic_association(struct parser_ctx* ctx)
{
    struct generic_association* _Owner _Opt p_generic_association = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_generic_association = calloc(1, sizeof * p_generic_association);
        if (p_generic_association == NULL)
            throw;

        p_generic_association->first_token = ctx->current;
        /*generic - association:
            type-name : assignment-expression
            default : assignment-expression
            */
        if (ctx->current->type == TK_KEYWORD_DEFAULT)
        {
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }
        }
        else if (first_of_type_name(ctx))
        {
            bool old = ctx->inside_generic_association;
            ctx->inside_generic_association = true;


            p_generic_association->p_type_name = type_name(ctx);
            if (p_generic_association->p_type_name == NULL) throw;

            assert(p_generic_association->p_type_name->abstract_declarator != NULL);

            ctx->inside_generic_association = old;
            p_generic_association->type = make_type_using_declarator(ctx, p_generic_association->p_type_name->abstract_declarator);
        }
        else
        {
            compiler_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "unexpected");
        }
        if (parser_match_tk(ctx, ':') != 0)
            throw;

        struct expression* _Owner _Opt p_expression_temp = assignment_expression(ctx);
        if (p_expression_temp == NULL)
        {
            throw;
        }

        p_generic_association->expression = p_expression_temp;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }
        p_generic_association->last_token = ctx->current;
    }
    catch
    {
        generic_association_delete(p_generic_association);
        p_generic_association = NULL;
    }

    return p_generic_association;
}

struct generic_assoc_list generic_association_list(struct parser_ctx* ctx)
{
    struct generic_assoc_list list = { 0 };
    try
    {
        struct generic_association* _Opt p_default_generic_association = NULL;

        struct generic_association* _Owner _Opt p_generic_association =
            generic_association(ctx);

        if (p_generic_association == NULL)
            throw;

        if (p_generic_association->first_token->type == TK_KEYWORD_DEFAULT)
        {
            p_default_generic_association = p_generic_association;
        }

        generic_assoc_list_add(&list, p_generic_association);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        while (ctx->current->type == ',')
        {
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            struct generic_association* _Owner _Opt p_generic_association2 = generic_association(ctx);
            if (p_generic_association2 == NULL)
                throw;

            if (p_generic_association2->first_token->type == TK_KEYWORD_DEFAULT)
            {
                if (p_default_generic_association != NULL)
                {
                    compiler_diagnostic(C_ERROR_DUPLICATE_DEFAULT_GENERIC_ASSOCIATION,
                        ctx,
                        p_generic_association2->first_token,
                        NULL,
                        "duplicate default generic association.");

                    compiler_diagnostic(W_NOTE,
                        ctx,
                        p_default_generic_association->first_token,
                        NULL,
                        "previous default generic association");
                }
                else
                {
                    p_default_generic_association = p_generic_association2;
                }
            }

            generic_assoc_list_add(&list, p_generic_association2);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }
        }
    }
    catch
    {
    }
    return list;
}
void generic_association_delete(struct generic_association* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        type_name_delete(p->p_type_name);
        expression_delete(p->expression);
        type_destroy(&p->type);
        free(p);
    }
}

void generic_assoc_list_add(struct generic_assoc_list* list, struct generic_association* _Owner pitem)
{
    if (list->head == NULL)
    {
        list->head = pitem;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = pitem;
    }
    list->tail = pitem;
}

void generic_assoc_list_destroy(_Dtor struct generic_assoc_list* p)
{
    struct generic_association* _Owner _Opt item = p->head;
    while (item)
    {
        struct generic_association* _Owner _Opt next = item->next;
        item->next = NULL;
        generic_association_delete(item);
        item = next;
    }
}
void generic_selection_delete(struct generic_selection* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->expression);
        type_name_delete(p->type_name);
        generic_assoc_list_destroy(&p->generic_assoc_list);
        free(p);
    }
}
struct generic_selection* _Owner _Opt generic_selection(struct parser_ctx* ctx)
{
    /*C23
      generic-selection:
        _Generic ( assignment-expression , generic-assoc-ctx )
    */

    /*
      Extension
      generic-selection:
        "_Generic" ( generic-argument, generic-assoc-list )

        generic-argument:
          assignment-expression
          type-name
    */

    struct generic_selection* _Owner _Opt p_generic_selection = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_generic_selection = calloc(1, sizeof * p_generic_selection);
        if (p_generic_selection == NULL)
            throw;

        p_generic_selection->first_token = ctx->current;

        if (parser_match_tk(ctx, TK_KEYWORD__GENERIC) != 0)
            throw;
        if (parser_match_tk(ctx, '(') != 0)
            throw;

        if (first_of_type_name(ctx))
        {
            /*extension*/
            p_generic_selection->type_name = type_name(ctx);
            if (p_generic_selection->type_name == NULL)
                throw;
        }
        else
        {
            p_generic_selection->expression = assignment_expression(ctx);
            if (p_generic_selection->expression == NULL)
                throw;
        }

        if (parser_match_tk(ctx, ',') != 0)
            throw;

        p_generic_selection->generic_assoc_list = generic_association_list(ctx);
        if (p_generic_selection->generic_assoc_list.head == NULL) throw;

        struct type lvalue_type = { 0 };

        struct type* _Opt p_type = NULL;

        if (p_generic_selection->expression)
        {
            p_type = &p_generic_selection->expression->type;

            if (expression_is_subjected_to_lvalue_conversion(p_generic_selection->expression))
            {
                lvalue_type = type_lvalue_conversion(&p_generic_selection->expression->type, ctx->options.null_checks_enabled);
                p_type = &lvalue_type;
            }
        }
        else if (p_generic_selection->type_name)
        {
            p_type = &p_generic_selection->type_name->abstract_declarator->type;
        }
        else
        {
            throw;
        }

        struct generic_association* _Opt current = p_generic_selection->generic_assoc_list.head;
        while (current)
        {
            if (current->p_type_name)
            {
                if (type_is_same(p_type, &current->type, true))
                {
                    p_generic_selection->p_view_selected_expression = current->expression;
                    break;
                }
            }
            else
            {
                /*default*/
                p_generic_selection->p_view_selected_expression = current->expression;
            }
            current = current->next;
        }

        type_destroy(&lvalue_type);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }
        p_generic_selection->last_token = ctx->current;

        if (parser_match_tk(ctx, ')') != 0)
        {
            throw;
        }
    }
    catch
    {
        generic_selection_delete(p_generic_selection);
        p_generic_selection = NULL;
    }
    return p_generic_selection;
}



struct expression* _Owner _Opt character_constant_expression(struct parser_ctx* ctx)
{
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_expression_node = calloc(1, sizeof * p_expression_node);
        if (p_expression_node == NULL)
            throw;

        p_expression_node->expression_type = PRIMARY_EXPRESSION_CHAR_LITERAL;
        p_expression_node->first_token = ctx->current;
        p_expression_node->last_token = p_expression_node->first_token;
        p_expression_node->type.attributes_flags |= CAKE_HIDDEN_ATTRIBUTE_INT_LIKE_CHAR;
        p_expression_node->type.category = TYPE_CATEGORY_ITSELF;

        const unsigned char* _Opt p = (const unsigned char*)ctx->current->lexeme;

        if (p[0] == 'u' && p[1] == '8')
        {
            p++;
            p++;
            p++;

            // A UTF-8 character constant has type char8_t.
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_CHAR;

            unsigned int c = 0;
            p = utf8_decode(p, &c);
            if (p == NULL)
            {
                throw;
            }

            if (c == '\\')
            {
                p = escape_sequences_decode_opt(p, &c);
                if (p == NULL) throw;
            }

            if (*p != '\'')
            {
                compiler_diagnostic(C_MULTICHAR_ERROR, ctx, ctx->current, NULL, "Unicode character literals may not contain multiple characters.");
            }

            if (c > 0x80)
            {
                compiler_diagnostic(C_CHARACTER_NOT_ENCODABLE_IN_A_SINGLE_CODE_UNIT, ctx, ctx->current, NULL, "character not encodable in a single code unit.");
            }

            p_expression_node->object = object_make_unsigned_char((unsigned char)c);//, ctx->evaluation_is_disabled);
        }
        else if (p[0] == 'u')
        {
            p++;
            p++;

            // A UTF-16 character constant has type char16_t which is an unsigned integer types defined in the <uchar.h> header
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_SHORT;

            unsigned int c = 0;
            p = utf8_decode(p, &c);
            if (p == NULL)
            {
                throw;
            }

            if (c == '\\')
            {
                p = escape_sequences_decode_opt(p, &c);
                if (p == NULL) throw;
            }

            if (*p != '\'')
            {
                compiler_diagnostic(W_MULTICHAR_ERROR, ctx, ctx->current, NULL, "Unicode character literals may not contain multiple characters.");
            }

            if (c > USHRT_MAX)
            {
                compiler_diagnostic(W_MULTICHAR_ERROR, ctx, ctx->current, NULL, "Character too large for enclosing character literal type.");
            }

            p_expression_node->object = object_make_wchar_t((wchar_t)c);
        }
        else if (p[0] == 'U')
        {
            p++;
            p++;

            // A UTF-16 character constant has type char16_t which is an unsigned integer types defined in the <uchar.h> header
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT;

            unsigned int c = 0;
            p = utf8_decode(p, &c);
            if (p == NULL)
            {
                throw;
            }

            if (c == '\\')
            {
                p = escape_sequences_decode_opt(p, &c);
                if (p == NULL) throw;
            }

            if (*p != '\'')
            {
                compiler_diagnostic(W_MULTICHAR_ERROR, ctx, ctx->current, NULL, "Unicode character literals may not contain multiple characters.");
            }

            if (c > UINT_MAX)
            {
                compiler_diagnostic(W_MULTICHAR_ERROR, ctx, ctx->current, NULL, "Character too large for enclosing character literal type.");
            }

            p_expression_node->object = object_make_wchar_t((wchar_t)c);
        }
        else if (p[0] == 'L')
        {
            // A wchar_t character constant is prefixed by the letter L
            p++;
            p++;

            p_expression_node->type.type_specifier_flags = get_wchar_type_specifier(ctx->options.target);

            /*
             wchar_t character constant prefixed by the letter L has type wchar_t, an integer type defined in
             the <stddef.h> header. The value of a wchar_t character constant containing a single multibyte
             character that maps to a single member of the extended execution character set is the wide character
             corresponding to that multibyte character in the implementation-defined wide literal encoding
             (6.2.9). The value of a wchar_t character constant containing more than one multibyte character or a
             single multibyte character that maps to multiple members of the extended execution character set,
             or containing a multibyte character or escape sequence not represented in the extended execution
             character set, is implementation-defined.
            */
            long long value = 0;
            while (*p != '\'')
            {
                unsigned int c = 0;
                p = utf8_decode(p, &c);
                if (p == NULL)
                {
                    throw;
                }

                if (c == '\\')
                {
                    p = escape_sequences_decode_opt(p, &c);
                    if (p == NULL) throw;
                }

                if (c < 0x80)
                {
                    value = value * 256 + c;
                }
                else
                {
                    //decoded
                    value = c;
                }
#ifdef _WIN32
                if (value > USHRT_MAX)
                {
                    compiler_diagnostic(W_OUT_OF_BOUNDS, ctx, ctx->current, NULL, "character constant too long for its type", ctx->current->lexeme);
                    break;
                }
#else
                if (value > UINT_MAX)
                {
                    compiler_diagnostic(W_OUT_OF_BOUNDS, ctx, ctx->current, NULL, "character constant too long for its type", ctx->current->lexeme);
                    break;
                }
#endif
            }

            p_expression_node->object = object_make_wchar_t((wchar_t)value);
        }
        else
        {
            p++;
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_INT;

            /*
              An integer character constant has type int. The value of an integer character constant containing
              a single character that maps to a single value in the literal encoding (6.2.9) is the numerical value
              of the representation of the mapped character in the literal encoding interpreted as an integer.
              The value of an integer character constant containing more than one character (e.g., ’ab’), or
              containing a character or escape sequence that does not map to a single value in the literal encoding,
              is implementation-defined. If an integer character constant contains a single character or escape
              sequence, its value is the one that results when an object with type char whose value is that of the
              single character or escape sequence is converted to type int.
            */
            long long value = 0;
            while (*p != '\'')
            {
                unsigned int c = 0;
                p = utf8_decode(p, &c);
                if (p == NULL)
                {
                    throw;
                }

                if (c == '\\')
                {
                    p = escape_sequences_decode_opt(p, &c);
                    if (p == NULL) throw;
                }

                value = value * 256 + c;
                if (value > INT_MAX)
                {
                    compiler_diagnostic(W_OUT_OF_BOUNDS, ctx, ctx->current, NULL, "character constant too long for its type", ctx->current->lexeme);
                    break;
                }
            }
            p_expression_node->object = object_make_signed_int((int)value);
        }

        parser_match(ctx);
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        // warning: character constant too long for its type
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }
    return p_expression_node;
}

int convert_to_number(struct parser_ctx* ctx, struct expression* p_expression_node, bool disabled)
{
    if (ctx->current == NULL)
    {
        unexpected_end_of_file(ctx);
        return 1;
    }

    struct token* token = ctx->current;

    /*copy removing separators*/
    // one of the largest buffers needed would be 128 bits binary... 
    // 0xb1'1'1....
    int c = 0;
    char buffer[128 * 2 + 4] = { 0 };
    const char* s = token->lexeme;
    while (*s)
    {
        if (*s != '\'')
        {
            buffer[c] = *s;
            c++;
        }
        s++;
    }

    char errormsg[100] = { 0 };
    char suffix[4] = { 0 };
    enum token_type r = parse_number(buffer, suffix, errormsg);
    if (r == TK_NONE)
    {
        compiler_diagnostic(
            C_INVALID_TOKEN,
            ctx,
            token,
            NULL,
            errormsg);
        return 0;
    }

    switch (token->type)
    {
    case TK_COMPILER_DECIMAL_CONSTANT:
    case TK_COMPILER_OCTAL_CONSTANT:
    case TK_COMPILER_HEXADECIMAL_CONSTANT:
    case TK_COMPILER_BINARY_CONSTANT:
    {
        unsigned long long value = 0;
        switch (token->type)
        {
        case TK_COMPILER_DECIMAL_CONSTANT:
            value = strtoull(buffer, NULL, 10);
            break;
        case TK_COMPILER_OCTAL_CONSTANT:
            if (buffer[1] == 'o' || buffer[1] == 'O')
            {
                //C2Y
                //https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3319.htm
                value = strtoull(buffer + 2, NULL, 8);
            }
            else
            {
                value = strtoull(buffer + 1, NULL, 8);
            }
            break;
        case TK_COMPILER_HEXADECIMAL_CONSTANT:
            value = strtoull(buffer + 2, NULL, 16);
            break;
        case TK_COMPILER_BINARY_CONSTANT:
            value = strtoull(buffer + 2, NULL, 2);
            break;
        default:
            break;
        }

        if (value == ULLONG_MAX && errno == ERANGE)
        {
            compiler_diagnostic(
            C_ERROR_LITERAL_OVERFLOW,
            ctx,
            token,
            NULL,
            "integer literal is too large to be represented in any integer type");
        }

        ///////////////MICROSOFT ////////////////////////
        //TODO i64 etc
        ////////////////////////////////////////////////

        if (suffix[0] == 'U')
        {
            /*fixing the type that fits the size*/
            if (value <= UINT_MAX && suffix[1] != 'L')
            {
                p_expression_node->object = object_make_unsigned_int((unsigned int)value);
                p_expression_node->type.type_specifier_flags = (TYPE_SPECIFIER_INT | TYPE_SPECIFIER_UNSIGNED);
            }
            else if (value <= ULONG_MAX && suffix[2] != 'L')
            {
                p_expression_node->object = object_make_unsigned_long((unsigned long)value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_UNSIGNED;
            }
            else //if (value <= ULLONG_MAX)
            {
                p_expression_node->object = object_make_unsigned_long_long((unsigned long long)value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_LONG_LONG | TYPE_SPECIFIER_UNSIGNED;
            }
        }
        else
        {
            /*fixing the type that fits the size*/
            if (value <= INT_MAX && suffix[0] != 'L')
            {
                p_expression_node->object = object_make_signed_int((int)value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_INT;
            }
            else if (value <= LONG_MAX && suffix[1] != 'L' /*!= LL*/)
            {
                p_expression_node->object = object_make_signed_long((long)value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_LONG;
            }
            else if (value <= LLONG_MAX)
            {
                p_expression_node->object = object_make_signed_long_long((long long)value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_LONG_LONG;
            }
            else
            {
                compiler_diagnostic(
                    W_IMPLICITLY_UNSIGNED_LITERAL,
                    ctx,
                    token,
                    NULL,
                    "integer literal is too large to be represented in a signed integer type, interpreting as unsigned");
                p_expression_node->object = object_make_signed_long_long(value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_LONG_LONG | TYPE_SPECIFIER_UNSIGNED;
            }
        }

    }
    break;

    case TK_COMPILER_DECIMAL_FLOATING_CONSTANT:
    case TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT:
    {
        if (suffix[0] == 'F')
        {
#ifdef __TINYC__
            long double value = strtod(buffer, NULL);
#else

            float value = strtof(buffer, NULL);
#endif
            if (value == HUGE_VALF && errno == ERANGE)
            {
            }
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_FLOAT;
            p_expression_node->object = object_make_float(value);
        }
        else if (suffix[0] == 'L')
        {
#ifdef __TINYC__
            long double value = strtod(buffer, NULL);
#else
            long double value = strtold(buffer, NULL);
#endif
            if (value == HUGE_VALL && errno == ERANGE)
            {
            }

            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_DOUBLE | TYPE_SPECIFIER_LONG;
            p_expression_node->object = object_make_long_double(value);
        }
        else
        {
            double value = strtod(buffer, NULL);
            if (value == HUGE_VAL && errno == ERANGE)
            {
            }
            p_expression_node->object = object_make_double(value);
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_DOUBLE;
        }
    }
    break;

    default:
        assert(false);
    }

    return 0;
}

static bool is_integer_or_floating_constant(enum token_type type)
{
    return type == TK_COMPILER_DECIMAL_CONSTANT ||
        type == TK_COMPILER_OCTAL_CONSTANT ||
        type == TK_COMPILER_HEXADECIMAL_CONSTANT ||
        type == TK_COMPILER_BINARY_CONSTANT ||
        type == TK_COMPILER_DECIMAL_FLOATING_CONSTANT ||
        type == TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT;
}

struct expression* _Owner _Opt primary_expression(struct parser_ctx* ctx)
{
    /*
     primary-expression:
      identifier
      constant
      string-literal
      ( expression )
      generic-selection
    */

    if (ctx->current == NULL)
    {
        unexpected_end_of_file(ctx);
        return NULL;
    }

    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        if (ctx->current->type == TK_IDENTIFIER)
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);

            if (p_expression_node == NULL)
                throw;

            p_expression_node->first_token = ctx->current;
            p_expression_node->last_token = ctx->current;

            struct scope* _Opt p_scope = NULL;
            struct map_entry* _Opt p_entry = find_variables(ctx, ctx->current->lexeme, &p_scope);

            if (p_entry && p_entry->type == TAG_TYPE_ENUMERATOR)
            {
                assert(p_entry->data.p_enumerator != NULL);
                struct enumerator* p_enumerator = p_entry->data.p_enumerator;
                p_expression_node->expression_type = PRIMARY_EXPRESSION_ENUMERATOR;
                p_expression_node->object = p_enumerator->value;

                p_expression_node->type = type_make_enumerator(p_enumerator->enum_specifier);
            }
            else if (p_entry &&
                     (p_entry->type == TAG_TYPE_DECLARATOR || p_entry->type == TAG_TYPE_INIT_DECLARATOR))
            {
                struct declarator* _Opt p_declarator = NULL;
                struct init_declarator* _Opt p_init_declarator = NULL;
                if (p_entry->type == TAG_TYPE_INIT_DECLARATOR)
                {
                    assert(p_entry->data.p_init_declarator != NULL);
                    p_init_declarator = p_entry->data.p_init_declarator;
                    p_declarator = p_init_declarator->p_declarator;
                }
                else
                {
                    p_declarator = p_entry->data.p_declarator;
                }

                assert(p_declarator != NULL);

                if (type_is_deprecated(&p_declarator->type))
                {
                    compiler_diagnostic(W_DEPRECATED, ctx, ctx->current, NULL, "'%s' is deprecated", ctx->current->lexeme);
                }


                if (p_scope->scope_level == 0)
                {
                    //file scope
                }
                else if ((p_declarator->type.storage_class_specifier_flags & STORAGE_SPECIFIER_STATIC) ||
                        (p_declarator->type.storage_class_specifier_flags & STORAGE_SPECIFIER_THREAD_LOCAL))
                {
                    //file scope or thread
                }
                else if (ctx->p_current_function_scope_opt)
                {
                    bool b_type_is_function = type_is_function(&p_declarator->type);
                    if (!ctx->evaluation_is_disabled && !b_type_is_function)
                    {
                        bool inside_current_function_scope = false;
                        while (p_scope)
                        {
                            if (ctx->p_current_function_scope_opt == p_scope)
                            {
                                inside_current_function_scope = true;
                                break;
                            }
                            p_scope = p_scope->previous;
                        }
                        if (!inside_current_function_scope)
                        {
                            compiler_diagnostic(C_ERROR_OUTER_SCOPE,
                                ctx,
                                ctx->current,
                                NULL,
                                "'%s' cannot be evaluated in this scope", ctx->current->lexeme);
                        }
                    }
                }

                p_declarator->num_uses++;
                p_expression_node->declarator = p_declarator;
                p_expression_node->p_init_declarator = p_init_declarator;

                p_expression_node->expression_type = PRIMARY_EXPRESSION_DECLARATOR;

                p_expression_node->type = type_dup(&p_declarator->type);
                p_expression_node->object = object_make_reference(&p_declarator->object);

            }
            else if (ctx->p_current_function_opt &&
                     strcmp(ctx->current->lexeme, "__func__") == 0)
            {

                const char* func_name = ctx->p_current_function_opt->name_opt ?
                    ctx->p_current_function_opt->name_opt->lexeme :
                    "unnamed";



                p_expression_node->expression_type = PRIMARY_EXPRESSION__FUNC__;
                p_expression_node->first_token = ctx->current;
                p_expression_node->last_token = ctx->current;

                p_expression_node->type = type_make_literal_string(strlen(func_name) + 1, TYPE_SPECIFIER_CHAR, TYPE_QUALIFIER_CONST, ctx->options.target);
            }
            else
            {
                compiler_diagnostic(C_ERROR_NOT_FOUND, ctx, ctx->current, NULL, "not found '%s'", ctx->current->lexeme);
                throw;
            }
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }
        }
        else if (ctx->current->type == TK_STRING_LITERAL)
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;

            p_expression_node->expression_type = PRIMARY_EXPRESSION_STRING_LITERAL;
            p_expression_node->first_token = ctx->current;
            p_expression_node->last_token = ctx->current;

            enum type_specifier_flags char_type = TYPE_SPECIFIER_CHAR;

            if (get_char_type(ctx->current->lexeme) == 2)
            {
                /*
                   automatically finding out the type of wchar_t to copy
                   GCC or MSVC.
                   windows it is short linux is
                */
                char_type = get_wchar_type_specifier(ctx->options.target);
            }
            /*
              string concatenation should have been done in a previous phase
              but since we keep the source format here it was an alternative
            */

            const int char_byte_size = string_literal_char_byte_size(ctx->current->lexeme);
            int number_of_bytes = 0;
            struct object* last = NULL;

            while (ctx->current->type == TK_STRING_LITERAL)
            {
                //"part1" "part2" TODO check different types

                const unsigned char* it = ctx->current->lexeme + 1;
                unsigned int value = 0;
                while (it && *it != '"')
                {
                    if (*it == '\\')
                        it = escape_sequences_decode_opt(it, &value);
                    else
                    {
                        value = *it;
                        it++;
                    }

                    struct object* p_new = calloc(1, sizeof * p_new);
                    if (p_new == NULL) throw;

                    p_new->state = CONSTANT_VALUE_STATE_CONSTANT;
                    p_new->value_type = TYPE_SIGNED_CHAR;
                    p_new->value.signed_char_value = value;

                    if (p_expression_node->object.members == NULL)
                    {
                        p_expression_node->object.members = p_new;
                    }
                    else
                    {
                        if (last)
                            last->next = p_new;
                    }
                    last = p_new;
                }

                struct object* p_new = calloc(1, sizeof * p_new);
                if (p_new == NULL) throw;

                p_new->state = CONSTANT_VALUE_STATE_CONSTANT;
                p_new->value_type = TYPE_SIGNED_CHAR;
                p_new->value.signed_char_value = 0;

                if (last == NULL)
                {
                    p_expression_node->object.members = p_new;
                }
                else
                {
                    last->next = p_new;
                }

                number_of_bytes += string_literal_byte_size_not_zero_included(ctx->current->lexeme);

                parser_match(ctx);
                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    throw;
                }
            }

            enum type_qualifier_flags lit_flags = ctx->options.const_literal ? TYPE_QUALIFIER_CONST : TYPE_QUALIFIER_NONE;
            p_expression_node->type = type_make_literal_string(number_of_bytes + (1 * char_byte_size), char_type, lit_flags, ctx->options.target);
        }
        else if (ctx->current->type == TK_CHAR_CONSTANT)
        {
            p_expression_node = character_constant_expression(ctx);
        }

        else if (ctx->current->type == TK_KEYWORD_TRUE ||
                 ctx->current->type == TK_KEYWORD_FALSE)
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;

            p_expression_node->expression_type = PRIMARY_EXPRESSION_PREDEFINED_CONSTANT;
            p_expression_node->first_token = ctx->current;
            p_expression_node->last_token = ctx->current;

            p_expression_node->object = object_make_bool(ctx->current->type == TK_KEYWORD_TRUE);

            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_BOOL;
            p_expression_node->type.type_qualifier_flags = 0;

            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }
        }
        else if (ctx->current->type == TK_KEYWORD_NULLPTR)
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;

            p_expression_node->expression_type = PRIMARY_EXPRESSION_PREDEFINED_CONSTANT;
            p_expression_node->first_token = ctx->current;
            p_expression_node->last_token = ctx->current;

            p_expression_node->object = object_make_nullptr();

            /*TODO nullptr type*/
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_NULLPTR_T;
            p_expression_node->type.type_qualifier_flags = 0;

            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }
        }
        else if (is_integer_or_floating_constant(ctx->current->type))
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;

            p_expression_node->first_token = ctx->current;
            p_expression_node->last_token = ctx->current;
            p_expression_node->expression_type = PRIMARY_EXPRESSION_NUMBER;

            convert_to_number(ctx, p_expression_node, false /*ctx->evaluation_is_disabled*/);

            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }
        }
        else if (ctx->current->type == TK_KEYWORD__GENERIC)
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;
            p_expression_node->first_token = ctx->current;

            p_expression_node->expression_type = PRIMARY_EXPRESSION_GENERIC;

            p_expression_node->generic_selection = generic_selection(ctx);
            if (p_expression_node->generic_selection == NULL)
                throw;

            p_expression_node->last_token = p_expression_node->generic_selection->last_token;

            if (p_expression_node->generic_selection->p_view_selected_expression)
            {
                p_expression_node->type = type_dup(&p_expression_node->generic_selection->p_view_selected_expression->type);

                p_expression_node->object = p_expression_node->generic_selection->p_view_selected_expression->object;
            }
            else
            {
                compiler_diagnostic(C_ERROR_NO_MATCH_FOR_GENERIC, ctx, ctx->current, NULL, "no match for generic");
            }
        }
        else if (ctx->current->type == '(')
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL) throw;

            p_expression_node->expression_type = PRIMARY_EXPRESSION_PARENTESIS;
            p_expression_node->first_token = ctx->current;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            p_expression_node->right = expression(ctx);
            if (p_expression_node->right == NULL)
                throw;

            p_expression_node->type = type_dup(&p_expression_node->right->type);
            p_expression_node->object = p_expression_node->right->object;

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            p_expression_node->last_token = ctx->current;
            if (parser_match_tk(ctx, ')') != 0)
                throw;
        }
        else
        {
            compiler_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "unexpected");
            throw;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    assert(p_expression_node == NULL || (p_expression_node->first_token && p_expression_node->last_token));

    return p_expression_node;
}

void argument_expression_delete(struct argument_expression* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->expression);
        assert(p->next == NULL);
        free(p);
    }
}

struct argument_expression_list argument_expression_list(struct parser_ctx* ctx)
{
    /*
     argument-expression-list:
      assignment-expression
      argument-expression-ctx , assignment-expression
    */

    /*
     argument-expression-list: (extended)
      assignment-expression
      move assignment-expression
      argument-expression-ctx , assignment-expression
      argument-expression-ctx , assignment-expression
    */

    struct argument_expression_list list = { 0 };
    struct argument_expression* _Owner _Opt p_argument_expression = NULL;

    try
    {
        p_argument_expression = calloc(1, sizeof(struct argument_expression));
        if (p_argument_expression == NULL)
            throw;

        struct expression* _Owner _Opt p_assignment_expression = assignment_expression(ctx);
        if (p_assignment_expression == NULL)
        {
            argument_expression_delete(p_argument_expression);
            throw;
        }

        p_argument_expression->expression = p_assignment_expression;
        argument_expression_list_push(&list, p_argument_expression);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        while (ctx->current->type == ',')
        {
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            struct argument_expression* _Owner _Opt p_argument_expression_2 = calloc(1, sizeof * p_argument_expression_2);
            if (p_argument_expression_2 == NULL)
                throw;
            struct expression* _Owner _Opt p_assignment_expression_2 = assignment_expression(ctx);
            if (p_assignment_expression_2 == NULL)
            {
                argument_expression_delete(p_argument_expression_2);
                throw;
            }
            p_argument_expression_2->expression = p_assignment_expression_2;

            argument_expression_list_push(&list, p_argument_expression_2);

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }
        }
    }
    catch
    {
    }
    return list;
}

bool first_of_postfix_expression(const struct parser_ctx* ctx)
{
    //( type-name )  postfix confunde com (expression) primary
    if (first_of_type_name_ahead(ctx))
        return true;// I don't think it's necessary because primary also works for postfix
    return is_first_of_primary_expression(ctx);
}

static void fix_member_type(struct type* p_type, const struct type* struct_type, const struct type* member_type)
{
    if (struct_type->type_qualifier_flags & TYPE_QUALIFIER_CONST)
    {
        /*
          struct X { int i; };
          const struct X x;
          x.i ;//x.i is const
        */
        p_type->type_qualifier_flags |= TYPE_QUALIFIER_CONST;
    }

    /*
          struct X { int i; };
          const struct X x;
          x.i ;//x.i is also local, or parameter etc.
    */
    p_type->storage_class_specifier_flags = struct_type->storage_class_specifier_flags;

    if (struct_type->type_qualifier_flags & TYPE_QUALIFIER_VIEW)
    {
        /*
          struct X { _Owner int i; };
          _View struct X x;
          x.i ;//is is not _Owner
        */
        p_type->type_qualifier_flags &= ~TYPE_QUALIFIER_OWNER;
    }

    if (struct_type->type_qualifier_flags & TYPE_QUALIFIER_OPT)
    {
        /*
          struct X { _Owner int i; };
          _View struct X x;
          x.i ;//is is not _Owner
        */
        p_type->type_qualifier_flags |= TYPE_QUALIFIER_OPT;
    }

}

static void fix_arrow_member_type(struct type* p_type, const struct type* left, const struct type* member_type)
{
    struct type t = type_remove_pointer(left);

    if (t.type_qualifier_flags & TYPE_QUALIFIER_CONST)
    {
        /*
           const struct X * p;
        */

        p_type->type_qualifier_flags |= TYPE_QUALIFIER_CONST;
    }

    if (t.type_qualifier_flags & TYPE_QUALIFIER_OPT)
    {
        /*
           const struct X * p;
        */

        p_type->type_qualifier_flags |= TYPE_QUALIFIER_OPT;
    }

    if (t.type_qualifier_flags & TYPE_QUALIFIER_VIEW)
    {
        /*
          _View struct X * p;
        */
        p_type->type_qualifier_flags &= ~TYPE_QUALIFIER_OWNER;
    }

    type_destroy(&t);
}

struct expression* _Owner _Opt postfix_expression_tail(struct parser_ctx* ctx, struct expression* _Owner p_expression_node_param)
{

    /*
       argument cannot be null, but here p_expression_node can be null
    */
    struct expression* _Owner _Opt p_expression_node = p_expression_node_param;

    try
    {
        while (ctx->current != NULL)
        {
            if (ctx->current->type == '[')
            {
                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL) throw;
                p_expression_node->last_token = ctx->current;
                p_expression_node_new->first_token = ctx->current;
                p_expression_node_new->expression_type = POSTFIX_ARRAY;
                // the result of the subscription operator ([])

                if (!type_is_pointer_or_array(&p_expression_node->type))
                {
                    compiler_diagnostic(C_ERROR_SUBSCRIPTED_VALUE_IS_NEITHER_ARRAY_NOR_POINTER,
                                                ctx,
                                                ctx->current, NULL,
                                                "subscripted value is neither array nor pointer");
                }

                if (type_is_pointer(&p_expression_node->type))
                {
                    p_expression_node_new->type = type_remove_pointer(&p_expression_node->type);
                }
                else if (type_is_array(&p_expression_node->type))
                {
                    p_expression_node_new->type = get_array_item_type(&p_expression_node->type);
                }

                parser_match(ctx);
                if (ctx->current == NULL)
                {

                    unexpected_end_of_file(ctx);

                    expression_delete(p_expression_node_new);
                    throw;
                }

                /*contem a expresao de dentro do  [ ] */
                p_expression_node_new->right = expression(ctx);
                if (p_expression_node_new->right == NULL)
                {
                    expression_delete(p_expression_node_new);
                    throw;
                }

                if (!type_is_integer(&p_expression_node_new->right->type))
                {
                    compiler_diagnostic(C_ERROR_SUBSCRIPT_IS_NOT_AN_INTEGER,
                                            ctx,
                                            p_expression_node_new->right->first_token,
                                            NULL,
                                            "array subscript is not an integer");

                }

                if (object_has_constant_value(&p_expression_node_new->right->object))
                {
                    unsigned long long index =
                        object_to_unsigned_long_long(&p_expression_node_new->right->object);
                    if (type_is_array(&p_expression_node->type))
                    {
                        if (p_expression_node->type.num_of_elements > 0)
                        {
                            if (index >= (unsigned long long)p_expression_node->type.num_of_elements)
                            {
                                compiler_diagnostic(W_OUT_OF_BOUNDS,
                                                            ctx,
                                                            ctx->current, NULL,
                                                            "index %d is past the end of the array", index);
                            }


                            struct object* _Opt it = object_get_member(&p_expression_node->object, (int)index);

                            if (it != NULL)
                                p_expression_node_new->object = object_make_reference(it);
                        }
                    }
                }
                if (parser_match_tk(ctx, ']') != 0)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                p_expression_node_new->left = p_expression_node;
                p_expression_node = p_expression_node_new;
            }
            else if (ctx->current->type == '(')
            {
                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL) throw;
                p_expression_node->last_token = ctx->current;
                p_expression_node_new->first_token = p_expression_node->first_token;
                p_expression_node_new->expression_type = POSTFIX_FUNCTION_CALL;

                if (!type_is_function_or_function_pointer(&p_expression_node->type))
                {
                    compiler_diagnostic(C_ERROR_CALLED_OBJECT_IS_NOT_FUNCTION_OR_FUNCTION_POINTER,
                                                ctx,
                                                ctx->current,
                                                NULL,
                                                "called object is not attr function or function pointer");
                }

                p_expression_node_new->type = get_function_return_type(&p_expression_node->type);

                parser_match(ctx);
                if (ctx->current == NULL)
                {

                    unexpected_end_of_file(ctx);

                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                if (ctx->current->type != ')')
                {
                    p_expression_node_new->argument_expression_list = argument_expression_list(ctx);
                }
                if (parser_match_tk(ctx, ')') != 0)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                compare_function_arguments(ctx, &p_expression_node->type, &p_expression_node_new->argument_expression_list);

                if (ctx->previous == NULL)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                make_object(&p_expression_node_new->type, &p_expression_node_new->object);
                p_expression_node_new->last_token = ctx->previous;
                p_expression_node_new->left = p_expression_node;
                p_expression_node = p_expression_node_new;
            }
            else if (ctx->current->type == '.')
            {
                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL) throw;
                p_expression_node->last_token = ctx->current;
                p_expression_node_new->first_token = ctx->current;
                p_expression_node_new->expression_type = POSTFIX_DOT;
                p_expression_node_new->left = p_expression_node;
                p_expression_node = NULL; /*MOVED*/

                p_expression_node_new->declarator = p_expression_node_new->left->declarator;

                parser_match(ctx);
                if (ctx->current == NULL)
                {

                    unexpected_end_of_file(ctx);

                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                if (p_expression_node_new->left->type.type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION)
                {
                    assert(p_expression_node_new->left->type.struct_or_union_specifier != NULL);

                    struct struct_or_union_specifier* _Opt p_complete =
                        find_struct_or_union_specifier(ctx, p_expression_node_new->left->type.struct_or_union_specifier->tag_name);

                    if (p_complete)
                        p_complete = get_complete_struct_or_union_specifier(p_complete);

                    if (p_complete)
                    {
                        assert(ctx->current != NULL);

                        int member_index = 0;
                        struct member_declarator* _Opt p_member_declarator =
                            find_member_declarator(&p_complete->member_declaration_list, ctx->current->lexeme, &member_index);

                        if (p_member_declarator)
                        {
                            p_expression_node_new->member_index = member_index;

                            if (p_member_declarator->declarator)
                            {
                                p_expression_node_new->type = make_type_using_declarator(ctx, p_member_declarator->declarator);
                            }
                            else
                            {
                                /*
                                struct X {
                                    int : 1;
                                };
                                */
                            }

                            if (p_member_declarator->declarator != NULL)
                            {
                                fix_member_type(&p_expression_node_new->type,
                                                &p_expression_node_new->left->type,
                                                &p_member_declarator->declarator->type);
                            }

                            struct object* object = find_object_declarator_by_index(&p_expression_node_new->left->object, &p_complete->member_declaration_list, member_index);

                            if (object)
                            {
                                p_expression_node_new->object = object_make_reference(object);
                            }
                            else
                            {
                                //not fixed yet
                                 //assert(false);                                    
                            }
                        }
                        else
                        {
                            compiler_diagnostic(C_ERROR_STRUCT_MEMBER_NOT_FOUND,
                                                    ctx,
                                                    ctx->current, NULL,
                                                    "member '%s' not found in 'struct %s'",
                                                    ctx->current->lexeme,
                                                    p_complete->tag_name);
                        }
                    }
                    else
                    {
                        compiler_diagnostic(C_ERROR_STRUCT_MEMBER_NOT_FOUND,
                                                 ctx,
                                                 ctx->current, NULL,
                                                 "incomplete struct type '%s'",
                                                 p_expression_node_new->left->type.struct_or_union_specifier->tag_name);
                        //print_scope(&ctx->scopes);
                    }
                    if (parser_match_tk(ctx, TK_IDENTIFIER) != 0)
                    {
                        expression_delete(p_expression_node_new);
                        p_expression_node_new = NULL;
                        throw;
                    }
                }
                else
                {
                    compiler_diagnostic(C_ERROR_STRUCTURE_OR_UNION_REQUIRED,
                                                ctx,
                                                ctx->current, NULL,
                                                "structure or union required");
                }
                // todo apontar pro nome?
                p_expression_node = p_expression_node_new;
            }
            else if (ctx->current->type == '->')
            {
                /*
                             p_expression_node_new
                           (left)   /  \  (right)
                                   /    \
                  p_expression_node      NULL
                */

                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL) throw;

                p_expression_node->last_token = ctx->current;
                p_expression_node_new->first_token = p_expression_node->first_token;
                p_expression_node_new->last_token = ctx->current;
                p_expression_node_new->expression_type = POSTFIX_ARROW;

                // the result of a member access through pointer -> operator is lvalue

                parser_match(ctx);
                if (ctx->current == NULL)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                if (type_is_pointer_or_array(&p_expression_node->type))
                {
                    struct type item_type = { 0 };
                    if (type_is_array(&p_expression_node->type))
                    {
                        compiler_diagnostic(W_ARRAY_INDIRECTION, ctx, ctx->current, NULL, "using indirection '->' in array");
                        item_type = get_array_item_type(&p_expression_node->type);
                    }
                    else
                    {
                        item_type = type_remove_pointer(&p_expression_node->type);
                    }

                    if (type_is_struct_or_union(&item_type))
                    {
                        assert(p_expression_node->type.next);
                        assert(p_expression_node->type.next->struct_or_union_specifier);

                        struct struct_or_union_specifier* _Opt p_complete =
                            get_complete_struct_or_union_specifier(p_expression_node->type.next->struct_or_union_specifier);

                        if (p_complete)
                        {
                            int member_index = 0;
                            struct member_declarator* _Opt p_member_declarator =
                                find_member_declarator(&p_complete->member_declaration_list, ctx->current->lexeme, &member_index);

                            if (p_member_declarator)
                            {
                                if (p_member_declarator->declarator)
                                {
                                    p_expression_node_new->member_index = member_index;
                                    p_expression_node_new->type = make_type_using_declarator(ctx, p_member_declarator->declarator);
                                    fix_arrow_member_type(&p_expression_node_new->type, &p_expression_node->type, &p_expression_node_new->type);
                                }
                                else
                                {
                                    assert(false); //TODO
                                }
                            }
                            else
                            {
                                compiler_diagnostic(C_ERROR_STRUCT_MEMBER_NOT_FOUND,
                                                            ctx,
                                                            ctx->current, NULL,
                                                            "member '%s' not found in struct '%s'",
                                                            ctx->current->lexeme,
                                                            p_expression_node->type.next->struct_or_union_specifier->tag_name);
                            }
                        }
                        else
                        {
                            compiler_diagnostic(C_ERROR_STRUCT_IS_INCOMPLETE,
                                                        ctx,
                                                        ctx->current, NULL,
                                                        "struct '%s' is incomplete.",
                                                        ctx->current->lexeme);
                        }
                        if (parser_match_tk(ctx, TK_IDENTIFIER) != 0)
                        {
                            type_destroy(&item_type);
                            expression_delete(p_expression_node_new);
                            p_expression_node_new = NULL;
                            throw;
                        }
                    }
                    else
                    {
                        compiler_diagnostic(C_ERROR_STRUCTURE_OR_UNION_REQUIRED,
                                                    ctx,
                                                    ctx->current, NULL,
                                                    "structure or union required");
                    }
                    type_destroy(&item_type);
                }
                else
                {
                    compiler_diagnostic(C_ERROR_STRUCTURE_OR_UNION_REQUIRED,
                                                ctx,
                                                ctx->current, NULL,
                                                "structure or union required");
                }

                p_expression_node_new->left = p_expression_node;
                p_expression_node = p_expression_node_new;
            }
            else if (ctx->current->type == '++')
            {
                p_expression_node->last_token = ctx->current;

                if (type_is_owner(&p_expression_node->type))
                {
                    compiler_diagnostic(C_ERROR_OPERATOR_INCREMENT_CANNOT_BE_USED_IN_OWNER,
                                                ctx,
                                                p_expression_node->first_token, NULL,
                                                "operator ++ cannot be used in _Owner pointers");
                }

                if (!expression_is_lvalue(p_expression_node))
                {
                    compiler_diagnostic(C_ERROR_OPERATOR_NEEDS_LVALUE,
                                                ctx,
                                                p_expression_node->first_token, NULL,
                                                "lvalue required as increment operand");
                }


                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL) throw;

                p_expression_node->last_token = ctx->current;
                p_expression_node_new->first_token = ctx->current;
                p_expression_node_new->expression_type = POSTFIX_INCREMENT;

                p_expression_node_new->type = type_dup(&p_expression_node->type);
                parser_match(ctx);
                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                p_expression_node_new->left = p_expression_node;
                p_expression_node = p_expression_node_new;
            }
            else if (ctx->current->type == '--')
            {
                p_expression_node->last_token = ctx->current;

                if (type_is_owner(&p_expression_node->type))
                {
                    compiler_diagnostic(C_ERROR_OPERATOR_DECREMENT_CANNOT_BE_USED_IN_OWNER,
                                                ctx,
                                                p_expression_node->first_token, NULL,
                                                "operator -- cannot be used in owner pointers");
                }

                if (!expression_is_lvalue(p_expression_node))
                {
                    compiler_diagnostic(C_ERROR_OPERATOR_NEEDS_LVALUE,
                                                ctx,
                                                p_expression_node->first_token, NULL,
                                                "lvalue required as decrement operand");
                }

                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL) throw;


                p_expression_node_new->first_token = ctx->current;
                p_expression_node_new->expression_type = POSTFIX_DECREMENT;

                p_expression_node_new->type = type_dup(&p_expression_node->type);
                parser_match(ctx);
                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                p_expression_node_new->left = p_expression_node;
                p_expression_node = p_expression_node_new;
            }
            else
            {
                struct token* _Opt p_last = previous_parser_token(ctx->current);
                if (p_last == NULL)
                    throw; //unexpected

                p_expression_node->last_token = p_last;
                break;
            }
        }
    }
    catch
    {
    }

    return p_expression_node;
}

struct expression* _Owner _Opt postfix_expression_type_name(struct parser_ctx* ctx, struct type_name* _Owner p_type_name_par)
{
    /*
        ( type-name ) { initializer-ctx }
        ( type-name ) { initializer-ctx , }

        //My extension : if type-name is function then follow is compound-statement
        ( type-name ) compound-statement

    */
    struct type_name* _Owner _Opt p_type_name = p_type_name_par; //MOVED
    struct expression* _Owner _Opt p_expression_node = NULL;

    try
    {
        p_expression_node = calloc(1, sizeof * p_expression_node);
        if (p_expression_node == NULL)
            throw;

        assert(p_expression_node->type_name == NULL);

        struct token* _Opt p_previous = previous_parser_token(p_type_name->first_token);
        if (p_previous == NULL)
            throw;

        p_expression_node->first_token = p_previous;
        assert(p_expression_node->first_token->type == '(');

        p_expression_node->type_name = p_type_name; /*MOVED*/
        p_type_name = NULL; /*MOVED*/
        p_expression_node->type = make_type_using_declarator(ctx, p_expression_node->type_name->abstract_declarator);

        if (type_is_function(&p_expression_node->type_name->abstract_declarator->type))
        {
            p_expression_node->expression_type = POSTFIX_EXPRESSION_FUNCTION_LITERAL;



            struct scope* parameters_scope =
                &p_expression_node->type_name->abstract_declarator->direct_declarator->function_declarator->parameters_scope;

            scope_list_push(&ctx->scopes, parameters_scope);

            struct declarator* _Opt p_current_function_opt = ctx->p_current_function_opt;
            ctx->p_current_function_opt = p_expression_node->type_name->abstract_declarator;

            struct scope* p_current_function_scope_opt = ctx->p_current_function_scope_opt;
            ctx->p_current_function_scope_opt = ctx->scopes.tail;

            p_expression_node->compound_statement = function_body(ctx);

            scope_list_pop(&ctx->scopes);
            ctx->p_current_function_opt = p_current_function_opt; //restore
            ctx->p_current_function_scope_opt = p_current_function_scope_opt; //restore

        }
        else
        {
            p_expression_node->expression_type = POSTFIX_EXPRESSION_COMPOUND_LITERAL;
            p_expression_node->braced_initializer = braced_initializer(ctx);
            p_expression_node->type = type_dup(&p_expression_node->type_name->type);
            //TODO

            if (p_expression_node->type.storage_class_specifier_flags & STORAGE_SPECIFIER_TYPEDEF)
            {
            }
            else
            {
                int er = make_object(&p_expression_node->type, &p_expression_node->object);
                if (er != 0)
                {
                    compiler_diagnostic(C_ERROR_STRUCT_IS_INCOMPLETE, ctx, p_expression_node->first_token, NULL, "incomplete struct/union type");
                    throw;
                }
            }

            const bool is_constant = type_is_const_or_constexpr(&p_expression_node->type);

            object_default_initialization(&p_expression_node->object, is_constant);

            struct initializer initializer = { 0 };
            initializer.braced_initializer = p_expression_node->braced_initializer;
            initializer.first_token = p_expression_node->first_token;

            const bool requires_constant_initialization = false;

            initializer_init_new(ctx,
                         &p_expression_node->type,
                         &p_expression_node->object,
                         &initializer,
                         is_constant,
                         requires_constant_initialization);
        }

        if (ctx->previous == NULL)
            throw;

        p_expression_node->last_token = ctx->previous;

        p_expression_node = postfix_expression_tail(ctx, p_expression_node);
        if (p_expression_node == NULL)
            throw;
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }
    type_name_delete(p_type_name);
    return p_expression_node;
}

struct expression* _Owner _Opt postfix_expression(struct parser_ctx* ctx)
{
    /*
      postfix-expression:
        primary-expression
        postfix-expression [ expression ]
        postfix-expression ( argument-expression-list_opt)
        postfix-expression . identifier
        postfix-expression -> identifier
        postfix-expression ++
        postfix-expression --
        ( type-name ) { initializer-ctx }
        ( type-name ) { initializer-ctx , }

        //My extension : if type-name is function then follow is compound-statement
        ( type-name ) compound-statement

        */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {


        if (first_of_type_name_ahead(ctx)) // aqui preciso ver se nao eh primary
        {
            assert(false); // este caso esta pegando lá dentro deo cast expression.
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;


            assert(ctx->current != NULL);
            p_expression_node->first_token = ctx->current;
            if (parser_match_tk(ctx, '(') != 0)
                throw;

            p_expression_node->type_name = type_name(ctx);
            if (p_expression_node->type_name == NULL)
                throw;

            p_expression_node->type = make_type_using_declarator(ctx, p_expression_node->type_name->abstract_declarator);

            if (parser_match_tk(ctx, ')') != 0)
                throw;
            // printf("\n");
            // print_type(&p_expression_node->type);

            if (type_is_function(&p_expression_node->type))
            {
                p_expression_node->expression_type = POSTFIX_EXPRESSION_FUNCTION_LITERAL;
                p_expression_node->compound_statement = compound_statement(ctx);
                if (p_expression_node->compound_statement == NULL)
                    throw;

                p_expression_node->last_token = p_expression_node->compound_statement->last_token;
            }
            else
            {
                p_expression_node->expression_type = POSTFIX_EXPRESSION_COMPOUND_LITERAL;
                p_expression_node->braced_initializer = braced_initializer(ctx);
                if (p_expression_node->braced_initializer == NULL) throw;
                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    throw;
                }

                p_expression_node->last_token = ctx->current;
            }
        }
        else
        {
            p_expression_node = primary_expression(ctx);
            if (p_expression_node == NULL)
                throw;
        }

        p_expression_node = postfix_expression_tail(ctx, p_expression_node);
        if (p_expression_node == NULL)
            throw;
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }
    return p_expression_node;
}

bool is_first_of_compiler_function(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return
        // traits
        ctx->current->type == TK_KEYWORD_IS_LVALUE ||
        ctx->current->type == TK_KEYWORD_IS_OWNER ||
        ctx->current->type == TK_KEYWORD_IS_CONST ||
        ctx->current->type == TK_KEYWORD_IS_POINTER ||
        ctx->current->type == TK_KEYWORD_IS_ARRAY ||
        ctx->current->type == TK_KEYWORD_IS_FUNCTION ||

        ctx->current->type == TK_KEYWORD_ASSERT ||

        ctx->current->type == TK_KEYWORD_IS_SCALAR ||
        ctx->current->type == TK_KEYWORD_IS_ARITHMETIC ||
        ctx->current->type == TK_KEYWORD_IS_FLOATING_POINT ||
        ctx->current->type == TK_KEYWORD_IS_INTEGRAL;
}

bool is_first_of_unary_expression(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    if (ctx->current->type == TK_KEYWORD_CONST)
    {
        struct token* ahead = parser_look_ahead(ctx);
        if (ahead->type == '(')
            return true; //const(expr)
    }

    return first_of_postfix_expression(ctx) ||
        ctx->current->type == '++' ||
        ctx->current->type == '--' ||
        ctx->current->type == '&' ||
        ctx->current->type == '*' ||
        ctx->current->type == '+' ||
        ctx->current->type == '-' ||
        ctx->current->type == '~' ||
        ctx->current->type == '!' ||
        ctx->current->type == TK_KEYWORD_SIZEOF ||
        ctx->current->type == TK_KEYWORD__COUNTOF ||
        ctx->current->type == TK_KEYWORD__ALIGNOF ||

        ctx->current->type == TK_KEYWORD_GCC__BUILTIN_VA_END ||
        ctx->current->type == TK_KEYWORD_GCC__BUILTIN_VA_ARG ||
        ctx->current->type == TK_KEYWORD_GCC__BUILTIN_C23_VA_START ||
        ctx->current->type == TK_KEYWORD_GCC__BUILTIN_VA_COPY ||
        ctx->current->type == TK_KEYWORD_GCC__BUILTIN_OFFSETOF ||

        is_first_of_compiler_function(ctx);
}

static int check_sizeof_argument(struct parser_ctx* ctx,
    const struct expression* p_expression,
    const struct type* const p_type)
{
    //sizeof(type)  p_expression is the sizeof expression
    //sizeof(expression) p_expression is expression


    enum type_category category = type_get_category(p_type);

    if (category == TYPE_CATEGORY_FUNCTION)
    {
        //In GCC returns 1

        //The sizeof operator shall not be applied to an expression that has function type or an incomplete type
    }
    else if (category == TYPE_CATEGORY_ITSELF &&
            p_type->type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION)
    {
        assert(p_type->struct_or_union_specifier);

        struct struct_or_union_specifier* _Opt p_complete =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
        if (p_complete == NULL)
        {
            //The sizeof operator shall not be applied to an expression that has function type or an incomplete type
            compiler_diagnostic(C_ERROR_STRUCT_IS_INCOMPLETE,
                                       ctx,
                                       p_expression->first_token,
                                       NULL,
                                       "struct is incomplete type");
            return -1;
        }
    }
    else if (category == TYPE_CATEGORY_ARRAY)
    {
        if (type_is_vla(p_type))
        {
            return 0;
        }

        if (p_type->storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
        {
            //GCC
            //<source>:4:21: warning: 'sizeof' on array function parameter 'a' will return size of 'int *' [-Wsizeof-array-argument]
            //CLANG
            //<source>:4:21: warning: sizeof on array function parameter will return size of 'int *' instead of 'int[]' [-Wsizeof-array-argument]

            compiler_diagnostic(W_SIZEOF_ARRAY_ARGUMENT,
                                        ctx,
                                        p_expression->first_token,
                                        NULL,
                                        "sizeof applied to array function parameter");

        }
    }

    return 0; //ok
}

struct expression* _Owner _Opt unary_expression(struct parser_ctx* ctx)
{
    /*
    unary-expression:
        postfix-expression
        ++ unary-expression
        -- unary-expression
        unary-operator cast-expression
        sizeof unary-expression
        sizeof ( type-name )
        _Countof unary-expression   //C2Y
        _Countof ( type-name )      //C2Y
        alignof ( type-name )
    */

    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == '++' || ctx->current->type == '--')
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;

            if (ctx->current->type == '++')
                new_expression->expression_type = UNARY_EXPRESSION_INCREMENT;
            else
                new_expression->expression_type = UNARY_EXPRESSION_DECREMENT;
            parser_match(ctx);
            if (ctx->current == NULL)
            {

                unexpected_end_of_file(ctx);

                expression_delete(new_expression);
                throw;
            }
            new_expression->right = unary_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            new_expression->type = type_dup(&new_expression->right->type);
            p_expression_node = new_expression;
        }
        else if (ctx->current->type == '&' ||
                 ctx->current->type == '*' ||
                 ctx->current->type == '+' ||
                 ctx->current->type == '-' ||
                 ctx->current->type == '~' ||
                 ctx->current->type == '!')
        {

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;

            struct token* op_position = ctx->current; // marcar posicao
            enum token_type op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                throw;
            }
#if 0
            //visual studio formater is adding spaces..
            if (style_has_space(ctx->current))
            {
                compiler_diagnostic(W_STYLE, ctx, ctx->current, "don't use spaces");
            }
#endif

            new_expression->right = cast_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            new_expression->last_token = new_expression->right->last_token;
            if (op == '!')
            {
                new_expression->expression_type = UNARY_EXPRESSION_NOT;
                if (!ctx->evaluation_is_disabled &&
                    object_has_constant_value(&new_expression->right->object))
                {
                    const bool v = object_to_bool(&new_expression->right->object);
                    new_expression->object = object_make_signed_int(!v);
                }
                new_expression->type = type_make_int_bool_like();
            }
            else if (op == '~')
            {
                if (!type_is_integer(&new_expression->right->type))
                {
                    compiler_diagnostic(C_ERROR_RIGHT_IS_NOT_INTEGER,
                                               ctx,
                                               op_position,
                                               NULL,
                                               "requires integer type");

                    expression_delete(new_expression);
                    throw;
                }

                new_expression->expression_type = UNARY_EXPRESSION_BITNOT;

                /*
                The result of the ~ operator is the bitwise complement of its (promoted) operand (that is, each bit in
                the result is set if and only if the corresponding bit in the converted operand is not set). The integer
                promotions are performed on the operand, and the result has the promoted type. If the promoted
                type is an unsigned type, the expression ~E is equivalent to the maximum value representable in
                that type minus E.
                */
                struct type promoted = type_dup(&new_expression->right->type);
                type_integer_promotion(&promoted);
                new_expression->type = promoted;

                if (!ctx->evaluation_is_disabled &&
                  object_has_constant_value(&new_expression->right->object))
                {
                    enum object_value_type vt = type_to_object_type(&new_expression->type);
                    switch (vt)
                    {
                    case TYPE_SIGNED_INT:
                    {
                        signed int r = object_to_signed_int(&new_expression->right->object);
                        new_expression->object = object_make_signed_int(~r);
                    }
                    break;

                    case TYPE_UNSIGNED_INT:
                    {
                        unsigned int r = object_to_unsigned_int(&new_expression->right->object);
                        new_expression->object = object_make_unsigned_int(~r);
                    }
                    break;

                    case TYPE_SIGNED_LONG:
                    {
                        signed long r = object_to_signed_long(&new_expression->right->object);
                        new_expression->object = object_make_signed_long(~r);
                    }
                    break;
                    case TYPE_UNSIGNED_LONG:
                    {
                        unsigned long r = object_to_unsigned_long(&new_expression->right->object);
                        new_expression->object = object_make_unsigned_long(~r);
                    }
                    break;

                    case TYPE_SIGNED_LONG_LONG:
                    {
                        signed long long r = object_to_signed_long_long(&new_expression->right->object);
                        new_expression->object = object_make_signed_long_long(~r);
                    }
                    break;
                    case TYPE_UNSIGNED_LONG_LONG:
                    {
                        unsigned long long r = object_to_unsigned_long_long(&new_expression->right->object);
                        new_expression->object = object_make_unsigned_long_long(~r);
                    }
                    break;

                    case TYPE_SIGNED_SHORT:
                    case TYPE_UNSIGNED_SHORT:
                    case TYPE_SIGNED_CHAR:
                    case TYPE_UNSIGNED_CHAR:

                    case TYPE_BOOL:
                    case TYPE_FLOAT:
                    case TYPE_DOUBLE:
                    case TYPE_LONG_DOUBLE:
                        break;
                    };
                }
            }
            else if (op == '-' || op == '+')
            {
                if (op == '-')
                    new_expression->expression_type = UNARY_EXPRESSION_NEG;
                else
                    new_expression->expression_type = UNARY_EXPRESSION_PLUS;

                //promote
                new_expression->type = type_common(&new_expression->right->type, &new_expression->right->type, ctx->options.target);

                if (!ctx->evaluation_is_disabled &&
                    object_has_constant_value(&new_expression->right->object))
                {
                    enum object_value_type vt = type_to_object_type(&new_expression->type);
                    switch (vt)
                    {
                    case TYPE_SIGNED_INT:
                    {
                        const int a = object_to_signed_int(&new_expression->right->object);
                        if (op == '-')
                            new_expression->object = object_make_signed_int(-a);
                        else
                            new_expression->object = object_make_signed_int(+a);
                    }
                    break;

                    case TYPE_UNSIGNED_INT:
                    {
                        unsigned int a = object_to_unsigned_int(&new_expression->right->object);
                        if (op == '-')
                        {
                            //error C4146: unary minus operator applied to unsigned type, result still unsigned
                            new_expression->object = object_make_unsigned_int(-a);
                        }
                        else
                            new_expression->object = object_make_unsigned_int(+a);
                    }
                    break;

                    case TYPE_SIGNED_LONG:
                    {
                        const signed long a = object_to_signed_long(&new_expression->right->object);
                        if (op == '-')
                        {
                            //TODO check overflow
                            new_expression->object = object_make_signed_long(-a);
                        }
                        else
                            new_expression->object = object_make_signed_long(+a);
                    }
                    break;
                    case TYPE_UNSIGNED_LONG:
                    {
                        unsigned long a = object_to_unsigned_long(&new_expression->right->object);
                        if (op == '-')
                        {
                            //
                            //error C4146: unary minus operator applied to unsigned type, result still unsigned
                            new_expression->object = object_make_unsigned_long(-a);
                        }
                        else
                            new_expression->object = object_make_unsigned_long(+a);
                    }
                    break;

                    case TYPE_SIGNED_LONG_LONG:
                    {
                        signed long long a = object_to_signed_long_long(&new_expression->right->object);
                        if (op == '-')
                            new_expression->object = object_make_signed_long_long(-a);
                        else
                            new_expression->object = object_make_signed_long_long(+a);
                    }
                    break;

                    case TYPE_UNSIGNED_LONG_LONG:
                    {
                        unsigned long long a = object_to_unsigned_long_long(&new_expression->right->object);

                        if (op == '-')
                        {
                            //error C4146: unary minus operator applied to unsigned type, result still unsigned
                            new_expression->object = object_make_unsigned_long_long(-a);
                        }
                        else
                            new_expression->object = object_make_unsigned_long_long(+a);
                    }
                    break;

                    case TYPE_BOOL:
                    case TYPE_SIGNED_CHAR:
                    case TYPE_UNSIGNED_CHAR:
                    case TYPE_SIGNED_SHORT:
                    case TYPE_UNSIGNED_SHORT:
                        assert(false); //they are promoted
                        expression_delete(new_expression);
                        throw;
                        break;

                    case TYPE_FLOAT:
                    {
                        float a = object_to_float(&new_expression->right->object);
                        if (op == '-')
                            new_expression->object = object_make_float(-a);
                        else
                            new_expression->object = object_make_float(+a);
                    }
                    break;
                    case TYPE_DOUBLE:
                    {
                        double a = object_to_double(&new_expression->right->object);
                        if (op == '-')
                            new_expression->object = object_make_double(-a);
                        else
                            new_expression->object = object_make_double(+a);
                    }
                    break;
                    case TYPE_LONG_DOUBLE:
                    {
                        long double a = object_to_long_double(&new_expression->right->object);
                        if (op == '-')
                            new_expression->object = object_make_long_double(-a);
                        else
                            new_expression->object = object_make_long_double(+a);
                    }
                    break;
                    };
                }
                //'//'new_expression->type = type_dup(&new_expression->right->type);
                //type_integer_promotion(&new_expression->type);
            }
            else if (op == '*')
            {
                new_expression->expression_type = UNARY_EXPRESSION_CONTENT;
                // the result of the indirection(unary*) operator applied to a pointer to object

                if (!type_is_pointer_or_array(&new_expression->right->type))
                {
                    compiler_diagnostic(C_ERROR_INDIRECTION_REQUIRES_POINTER_OPERAND,
                                                ctx,
                                                op_position,
                        NULL,
                                                "indirection requires pointer operand");
                }
                if (type_is_pointer(&new_expression->right->type))
                {
                    new_expression->type = type_remove_pointer(&new_expression->right->type);
                }
                else
                {
                    compiler_diagnostic(W_ARRAY_INDIRECTION,
                                                ctx,
                                                op_position, NULL,
                                                "array indirection");
                    new_expression->type = get_array_item_type(&new_expression->right->type);
                }
            }
            else if (op == '&')
            {
                /*
                  The result of the unary & operator is a pointer to the object referred to by the lvalue-expression.
                  If the type of the lvalue-expression is " . . . ", the type of the result is
                  "pointer to . . ."
                */
                new_expression->expression_type = UNARY_EXPRESSION_ADDRESSOF;

                if (!expression_is_lvalue(new_expression->right))
                {
                    compiler_diagnostic(C_ERROR_ADDRESS_OF_REGISTER,
                                                ctx,
                                                new_expression->right->first_token,
                                                NULL,
                                                "lvalue required as unary '&' operand");
                }

                if (new_expression->right->type.storage_class_specifier_flags & STORAGE_SPECIFIER_REGISTER)
                {
                    const char* variable_name = "?";

                    if (new_expression->right->declarator &&
                        new_expression->right->declarator->name_opt)
                    {
                        variable_name = new_expression->right->declarator->name_opt->lexeme;
                    }

                    compiler_diagnostic(C_ERROR_ADDRESS_OF_REGISTER,
                                                ctx,
                                                new_expression->right->first_token,
                                                NULL,
                                                "address of register variable 'x' requested",
                                                variable_name);

                }

                new_expression->type = type_add_pointer(&new_expression->right->type, ctx->options.null_checks_enabled);
                new_expression->type.address_of = true;
            }
            else
            {
                expression_delete(new_expression);
                compiler_diagnostic(C_ERROR_INVALID_TOKEN,
                                            ctx,
                                            ctx->current,
                    NULL,
                                            "invalid token");
                throw;
            }
            p_expression_node = new_expression;
        }
        else if (ctx->current->type == TK_KEYWORD_GCC__BUILTIN_C23_VA_START)
        {
            parser_match(ctx);

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;
            new_expression->first_token = ctx->current;
            new_expression->expression_type = UNARY_EXPRESSION_GCC__BUILTIN_VA_START;

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (parser_match_tk(ctx, '(') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }
            new_expression->left = unary_expression(ctx);
            if (new_expression->left == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            if (ctx->current->type == ',')
            {
                parser_match(ctx);
                new_expression->right = unary_expression(ctx);
                if (new_expression->right == NULL)
                {
                    expression_delete(new_expression);
                    throw;
                }
            }

            if (parser_match_tk(ctx, ')') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }
            new_expression->type = make_void_type();
            return new_expression;

        }
        else if (ctx->current->type == TK_KEYWORD_GCC__BUILTIN_VA_END)
        {
            parser_match(ctx);

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;
            new_expression->first_token = ctx->current;
            new_expression->expression_type = UNARY_EXPRESSION_GCC__BUILTIN_VA_END;

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (parser_match_tk(ctx, '(') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }
            new_expression->left = unary_expression(ctx);
            if (new_expression->left == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            if (parser_match_tk(ctx, ')') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }
            new_expression->type = make_void_type();
            return new_expression;

        }
        else if (ctx->current->type == TK_KEYWORD_GCC__BUILTIN_VA_ARG)
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;
            new_expression->first_token = ctx->current;
            new_expression->expression_type = UNARY_EXPRESSION_GCC__BUILTIN_VA_ARG;

            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (parser_match_tk(ctx, '(') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->left = unary_expression(ctx);
            if (new_expression->left == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            if (parser_match_tk(ctx, ',') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->type_name = type_name(ctx);
            if (new_expression->type_name == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            if (parser_match_tk(ctx, ')') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->type = type_dup(&new_expression->type_name->type);
            return new_expression;
        }
        else if (ctx->current->type == TK_KEYWORD_GCC__BUILTIN_VA_COPY)
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;
            new_expression->first_token = ctx->current;
            new_expression->expression_type = UNARY_EXPRESSION_GCC__BUILTIN_VA_COPY;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (parser_match_tk(ctx, '(') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->left = unary_expression(ctx);
            if (new_expression->left == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            if (parser_match_tk(ctx, ',') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->right = unary_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            if (parser_match_tk(ctx, ')') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->type = make_void_type();
            return new_expression;
        }
        else if (ctx->current->type == TK_KEYWORD_GCC__BUILTIN_OFFSETOF)
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;
            new_expression->first_token = ctx->current;
            new_expression->expression_type = UNARY_EXPRESSION_GCC__BUILTIN_OFFSETOF;

            parser_match(ctx);

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (parser_match_tk(ctx, '(') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->type_name = type_name(ctx);
            if (new_expression->type_name == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            if (parser_match_tk(ctx, ',') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            if (ctx->current->type != TK_IDENTIFIER)
            {
                //TODO
                //https://gcc.gnu.org/onlinedocs/gcc/Offsetof.html#Offsetof
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }
            new_expression->offsetof_member_designator = ctx->current;

            parser_match(ctx);

            if (parser_match_tk(ctx, ')') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->type = make_size_t_type(ctx->options.target);

            size_t offsetof = 0;

            enum sizeof_error e =
                type_get_offsetof(&new_expression->type_name->type, new_expression->offsetof_member_designator->lexeme, &offsetof, ctx->options.target);

            if (e != 0)
            {
                throw;
            }

            new_expression->object = object_make_size_t(offsetof);

            return new_expression;
        }
        else if (ctx->current->type == TK_KEYWORD_SIZEOF)
        {
            const bool disable_evaluation_copy = ctx->evaluation_is_disabled;
            ctx->evaluation_is_disabled = true;

            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;

            if (first_of_type_name_ahead(ctx))
            {
                new_expression->expression_type = UNARY_EXPRESSION_SIZEOF_TYPE;
                if (parser_match_tk(ctx, '(') != 0)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }
                new_expression->type_name = type_name(ctx);
                if (new_expression->type_name == NULL)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }

                new_expression->type = make_size_t_type(ctx->options.target);

                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    expression_delete(new_expression);
                    throw;
                }

                new_expression->last_token = ctx->current;

                if (parser_match_tk(ctx, ')') != 0)
                {
                    expression_delete(new_expression);
                    throw;
                }

                if (check_sizeof_argument(ctx, new_expression, &new_expression->type_name->type) != 0)
                {
                    //not fatal error
                    //fatal will be if someone need the sizeof at compile time
                    //but we don't have the object set here
                }
                else
                {
                    if (type_is_vla(&new_expression->type_name->abstract_declarator->type))
                    {
                        //not constant
                    }
                    else
                    {
                        size_t type_sizeof = 0;
                        if (type_get_sizeof(&new_expression->type_name->abstract_declarator->type, &type_sizeof, ctx->options.target) != 0)
                        {
                            throw;
                        }

                        new_expression->object = object_make_size_t(type_sizeof);
                    }
                }
            }
            else
            {
                new_expression->right = unary_expression(ctx);
                if (new_expression->right == NULL)
                {
                    /*restore*/
                    ctx->evaluation_is_disabled = disable_evaluation_copy;
                    expression_delete(new_expression);
                    throw;
                }

                new_expression->expression_type = UNARY_EXPRESSION_SIZEOF_EXPRESSION;

                if (check_sizeof_argument(ctx, new_expression->right, &new_expression->right->type) != 0)
                {
                    expression_delete(new_expression);
                    throw;
                }

                if (type_is_vla(&new_expression->right->type))
                {
                    //not constant
                }
                else
                {
                    size_t sz = 0;
                    if (type_get_sizeof(&new_expression->right->type, &sz, ctx->options.target) != 0)
                        throw;
                    new_expression->object = object_make_size_t(sz);
                }
            }

            type_destroy(&new_expression->type);
            new_expression->type = type_make_size_t(ctx->options.target);
            p_expression_node = new_expression;

            /*restore*/
            ctx->evaluation_is_disabled = disable_evaluation_copy;
        }
        else if (ctx->current->type == TK_KEYWORD__COUNTOF)//C2Y
        {
            // defer would be nice here...


            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;

            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                throw;
            }

            new_expression->expression_type = UNARY_EXPRESSION_COUNTOF;

            if (first_of_type_name_ahead(ctx))
            {
                if (parser_match_tk(ctx, '(') != 0)
                {
                    expression_delete(new_expression);
                    throw;
                }
                new_expression->type_name = type_name(ctx);
                if (new_expression->type_name == NULL)
                {
                    expression_delete(new_expression);
                    throw;
                }

                new_expression->type = make_size_t_type(ctx->options.target);

                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    expression_delete(new_expression);
                    throw;
                }

                new_expression->last_token = ctx->current;

                if (parser_match_tk(ctx, ')') != 0)
                {
                    expression_delete(new_expression);
                    throw;
                }

                if (type_is_enum(&new_expression->type_name->abstract_declarator->type))
                {
                    const struct enum_specifier* _Opt p_enum_specifier =
                        get_complete_enum_specifier(new_expression->type_name->type.enum_specifier);
                    size_t nelements = 0;
                    if (p_enum_specifier)
                    {
                        struct enumerator* _Owner _Opt p =
                            p_enum_specifier->enumerator_list.head;
                        while (p)
                        {
                            nelements++;
                            p = p->next;
                        }
                    }
                    new_expression->object = object_make_size_t(nelements);
                }
                else if (type_is_array(&new_expression->type_name->abstract_declarator->type))
                {
                    size_t nelements = new_expression->type_name->abstract_declarator->type.num_of_elements;
                    if (nelements > 0)
                        new_expression->object = object_make_size_t(nelements);
                }
                else
                {
                    compiler_diagnostic(C_INVALID_ARGUMENT_NELEMENTSOF,
                                        ctx,
                                        new_expression->type_name->first_token,
                                        NULL,
                                        "argument of _Countof must be an array");

                    expression_delete(new_expression);
                    throw;
                }
            }
            else
            {
                if (parser_match_tk(ctx, '(') != 0)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }

                const bool disable_evaluation_copy = ctx->evaluation_is_disabled;
                ctx->evaluation_is_disabled = true;
                new_expression->right = unary_expression(ctx);
                /*restore*/
                ctx->evaluation_is_disabled = disable_evaluation_copy;

                if (new_expression->right == NULL)
                {
                    expression_delete(new_expression);
                    throw;
                }

                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    expression_delete(new_expression);
                    throw;
                }

                new_expression->last_token = ctx->current;

                if (parser_match_tk(ctx, ')') != 0)
                {
                    expression_delete(new_expression);
                    throw;
                }

                if (type_is_enum(&new_expression->right->type))
                {
                    const struct enum_specifier* _Opt p_enum_specifier =
                        get_complete_enum_specifier(new_expression->right->type.enum_specifier);
                    size_t nelements = 0;
                    if (p_enum_specifier)
                    {
                        struct enumerator* _Owner _Opt p =
                            p_enum_specifier->enumerator_list.head;
                        while (p)
                        {
                            nelements++;
                            p = p->next;
                        }
                    }
                    new_expression->object = object_make_size_t(nelements);

                }
                else if (type_is_array(&new_expression->right->type))
                {
                    size_t nelements = new_expression->right->type.num_of_elements;
                    if (nelements > 0)
                    {
                        new_expression->object = object_make_size_t(nelements);
                    }
                    else
                    {
                        //vla [n][2] but not vla[2][n]
                    }
                }
                else
                {
                    compiler_diagnostic(C_INVALID_ARGUMENT_NELEMENTSOF,
                        ctx,
                        new_expression->right->first_token,
                        NULL,
                        "argument of _Countof must be an array");

                    expression_delete(new_expression);
                    throw;
                }
            }

            type_destroy(&new_expression->type);
            new_expression->type = type_make_size_t(ctx->options.target);
            p_expression_node = new_expression;

        }

        else if (ctx->current->type == TK_KEYWORD_ASSERT)
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->expression_type = UNARY_EXPRESSION_ASSERT;
            new_expression->first_token = ctx->current;

            parser_match(ctx);

            if (ctx->current == NULL || parser_match_tk(ctx, '(') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }
            new_expression->right = expression(ctx);

            if (parser_match_tk(ctx, ')') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }
            return new_expression;
        }
        else if (ctx->current->type == TK_KEYWORD_CONST) /*new keyword consteval?? */
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->expression_type = UNARY_EXPRESSION_CONSTEVAL;
            new_expression->first_token = ctx->current;

            parser_match(ctx);

            if (ctx->current == NULL || parser_match_tk(ctx, '(') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }
            new_expression->right = constant_expression(ctx, true);

            if (parser_match_tk(ctx, ')') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }
            return new_expression;
        }
        else if (ctx->current->type == TK_KEYWORD__ALIGNOF)
        {
            const bool disable_evaluation_copy = ctx->evaluation_is_disabled;
            ctx->evaluation_is_disabled = true;

            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;

            if (first_of_type_name_ahead(ctx))
            {
                new_expression->expression_type = UNARY_EXPRESSION_ALIGNOF_TYPE;
                if (parser_match_tk(ctx, '(') != 0)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }
                new_expression->type_name = type_name(ctx);
                if (new_expression->type_name == NULL)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }

                new_expression->type = make_size_t_type(ctx->options.target);

                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    expression_delete(new_expression);
                    throw;
                }

                new_expression->last_token = ctx->current;

                if (parser_match_tk(ctx, ')') != 0)
                {
                    expression_delete(new_expression);
                    throw;
                }

                if (check_sizeof_argument(ctx, new_expression, &new_expression->type_name->type) != 0)
                {
                    //not fatal error
                    //fatal will be if someone need the sizeof at compile time
                    //but we don't have the object set here
                }
                else
                {
                    if (type_is_vla(&new_expression->type_name->abstract_declarator->type))
                    {
                        //not constant
                    }
                    else
                    {
                        size_t type_alignof = 0;
                        type_alignof = type_get_alignof(&new_expression->type_name->abstract_declarator->type, ctx->options.target);

                        new_expression->object = object_make_size_t(type_alignof);
                    }
                }
            }
            else
            {
                new_expression->right = unary_expression(ctx);
                if (new_expression->right == NULL)
                {
                    /*restore*/
                    ctx->evaluation_is_disabled = disable_evaluation_copy;
                    expression_delete(new_expression);
                    throw;
                }

                new_expression->expression_type = UNARY_EXPRESSION_ALIGNOF_EXPRESSION;

                if (check_sizeof_argument(ctx, new_expression->right, &new_expression->right->type) != 0)
                {
                    expression_delete(new_expression);
                    throw;
                }

                if (type_is_vla(&new_expression->right->type))
                {
                    //not constant
                }
                else
                {
                    size_t sz = 0;
                    sz = type_get_alignof(&new_expression->right->type, ctx->options.target);
                    new_expression->object = object_make_size_t(sz);
                }
            }

            type_destroy(&new_expression->type);
            new_expression->type = type_make_size_t(ctx->options.target);
            p_expression_node = new_expression;

            /*restore*/
            ctx->evaluation_is_disabled = disable_evaluation_copy;
        }
        else if (
            ctx->current->type == TK_KEYWORD_IS_LVALUE ||
            ctx->current->type == TK_KEYWORD_IS_OWNER ||
            ctx->current->type == TK_KEYWORD_IS_CONST ||
            ctx->current->type == TK_KEYWORD_IS_POINTER ||
            ctx->current->type == TK_KEYWORD_IS_ARRAY ||
            ctx->current->type == TK_KEYWORD_IS_FUNCTION ||
            ctx->current->type == TK_KEYWORD_IS_ARITHMETIC ||
            ctx->current->type == TK_KEYWORD_IS_SCALAR ||
            ctx->current->type == TK_KEYWORD_IS_FLOATING_POINT ||
            ctx->current->type == TK_KEYWORD_IS_INTEGRAL)
        {
            const bool disable_evaluation_copy = ctx->evaluation_is_disabled;
            ctx->evaluation_is_disabled = true;


            struct token* traits_token = ctx->current;

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;
            new_expression->expression_type = UNARY_EXPRESSION_TRAITS;

            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            struct type* _Opt p_type = NULL;
            if (first_of_type_name_ahead(ctx))
            {
                if (parser_match_tk(ctx, '(') != 0)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }
                new_expression->type_name = type_name(ctx);
                if (new_expression->type_name == NULL)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }

                if (ctx->current == NULL)
                {

                    unexpected_end_of_file(ctx);

                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }

                new_expression->last_token = ctx->current;
                if (parser_match_tk(ctx, ')') != 0)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }
                p_type = &new_expression->type_name->abstract_declarator->type;
            }
            else
            {

                new_expression->right = unary_expression(ctx);
                if (new_expression->right == NULL)
                {
                    /*restore*/
                    ctx->evaluation_is_disabled = disable_evaluation_copy;
                    expression_delete(new_expression);
                    throw;
                }

                p_type = &new_expression->right->type;
                if (ctx->previous == NULL)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }

                new_expression->last_token = ctx->previous;
            }

            switch (traits_token->type)
            {
            case TK_KEYWORD_IS_LVALUE:
                assert(new_expression->right != NULL);
                new_expression->object = object_make_signed_int(expression_is_lvalue(new_expression->right));
                break;

            case TK_KEYWORD_IS_CONST:
                new_expression->object = object_make_signed_int(type_is_const(p_type));
                break;
            case TK_KEYWORD_IS_OWNER:
                new_expression->object = object_make_signed_int(type_is_owner(p_type));
                break;

            case TK_KEYWORD_IS_POINTER:
                new_expression->object = object_make_signed_int(type_is_pointer(p_type));

                break;
            case TK_KEYWORD_IS_FUNCTION:
                new_expression->object = object_make_signed_int(type_is_function(p_type));

                break;
            case TK_KEYWORD_IS_ARRAY:
                new_expression->object = object_make_signed_int(type_is_array(p_type));

                break;
            case TK_KEYWORD_IS_ARITHMETIC:
                new_expression->object = object_make_signed_int(type_is_arithmetic(p_type));

                break;
            case TK_KEYWORD_IS_SCALAR:
                new_expression->object = object_make_signed_int(type_is_scalar(p_type));

                break;
            case TK_KEYWORD_IS_FLOATING_POINT:
                new_expression->object = object_make_signed_int(type_is_floating_point(p_type));

                break;
            case TK_KEYWORD_IS_INTEGRAL:
                new_expression->object = object_make_signed_int(type_is_integer(p_type));

                break;

            default:
                assert(false);
            }

            new_expression->type = type_make_int_bool_like();
            p_expression_node = new_expression;
            /*restore*/
            ctx->evaluation_is_disabled = disable_evaluation_copy;
        }
        else // if (is_first_of_primary_expression(ctx))
        {
            p_expression_node = postfix_expression(ctx);
            if (p_expression_node == NULL)
                throw;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

struct expression* _Owner _Opt cast_expression(struct parser_ctx* ctx)
{
    /*
     cast-expression:
      unary-expression
      ( type-name ) cast-expression


      ( type-name ) //<- extension void value
    */

    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (first_of_type_name_ahead(ctx))
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;

            p_expression_node->first_token = ctx->current;
            p_expression_node->expression_type = CAST_EXPRESSION;
            if (parser_match_tk(ctx, '(') != 0)
                throw;

            p_expression_node->type_name = type_name(ctx);
            if (p_expression_node->type_name == NULL)
            {
                expression_delete(p_expression_node);
                p_expression_node = NULL;
                throw;
            }

            p_expression_node->type = type_dup(&p_expression_node->type_name->type);


            if (parser_match_tk(ctx, ')') != 0)
                throw;

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->type == '{')
            {
                // Thinking it was a cast expression was a mistake... 
                // because the { appeared then it is a compound literal which is a postfix.
                struct expression* _Owner _Opt new_expression = postfix_expression_type_name(ctx, p_expression_node->type_name);
                p_expression_node->type_name = NULL; // MOVED

                if (new_expression == NULL) throw;

                expression_delete(p_expression_node);
                p_expression_node = new_expression;
            }
            else if (is_first_of_unary_expression(ctx))
            {
                p_expression_node->left = cast_expression(ctx);
                if (p_expression_node->left == NULL)
                {
                    expression_delete(p_expression_node);
                    p_expression_node = NULL;
                    throw;
                }

                if (type_is_floating_point(&p_expression_node->type) &&
                    type_is_pointer(&p_expression_node->left->type))
                {
                    compiler_diagnostic(C_ERROR_POINTER_TO_FLOATING_TYPE,
                        ctx,
                        p_expression_node->first_token,
                        NULL,
                        "pointer type cannot be converted to any floating type");
                }
                else if (type_is_pointer(&p_expression_node->type) &&
                         type_is_floating_point(&p_expression_node->left->type))
                {
                    compiler_diagnostic(C_ERROR_FLOATING_TYPE_TO_POINTER,
                     ctx,
                     p_expression_node->first_token,
                     NULL,
                     "A floating type cannot be converted to any pointer type");
                }
                else if (type_is_nullptr_t(&p_expression_node->left->type))
                {
                    if (type_is_void(&p_expression_node->type) ||
                        type_is_bool(&p_expression_node->type) ||
                        type_is_pointer(&p_expression_node->type))
                    {
                        /*
                          The type nullptr_t shall not be converted to any type other than
                          void, bool or a pointer type
                        */
                    }
                    else
                    {
                        compiler_diagnostic(C_ERROR_NULLPTR_CAST_ERROR,
                        ctx,
                        p_expression_node->first_token,
                        NULL,
                        "cannot cast nullptr_t to this type");
                    }
                }
                else if (type_is_nullptr_t(&p_expression_node->type))
                {
                    /*
                      If the target type is nullptr_t, the cast expression shall
                      be a null pointer constant or have type nullptr_t.
                    */

                    if (expression_is_null_pointer_constant(p_expression_node->left) ||
                        type_is_nullptr_t(&p_expression_node->left->type))
                    {
                        //ok
                    }
                    else
                    {
                        compiler_diagnostic(C_ERROR_NULLPTR_CAST_ERROR,
                        ctx,
                        p_expression_node->left->first_token,
                        NULL,
                        "cannot cast this expression to nullptr_t");
                    }
                }

                if (p_expression_node->left->type.storage_class_specifier_flags & STORAGE_SPECIFIER_FUNCTION_RETURN &&
                    type_is_owner(&p_expression_node->left->type))
                {
                    if (!type_is_owner(&p_expression_node->type))
                    {
                        if (type_is_pointer(&p_expression_node->left->type))
                        {
                            //(int*) malloc(1)
                            compiler_diagnostic(W_OWNERSHIP_DISCARDING_OWNER, ctx, p_expression_node->first_token, NULL, "discarding _Owner pointer");
                        }
                        else
                        {
                            compiler_diagnostic(W_OWNERSHIP_DISCARDING_OWNER, ctx, p_expression_node->first_token, NULL, "discarding _Owner");
                        }
                    }
                }

                type_destroy(&p_expression_node->type);
                p_expression_node->type = make_type_using_declarator(ctx, p_expression_node->type_name->abstract_declarator);

                if (!ctx->evaluation_is_disabled &&
                    object_has_constant_value(&p_expression_node->left->object))
                {
                    enum object_value_type vt = type_to_object_type(&p_expression_node->type);

                    p_expression_node->object =
                        object_cast(vt, &p_expression_node->left->object);

                }



                p_expression_node->type.storage_class_specifier_flags =
                    p_expression_node->left->type.storage_class_specifier_flags;
            }
            else
            {
                compiler_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "expected expression");
            }
        }
        else if (is_first_of_unary_expression(ctx))
        {
            p_expression_node = unary_expression(ctx);
            if (p_expression_node == NULL)
            {
                throw;
            }
        }
        else
        {
            compiler_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "expected expression");
            assert(p_expression_node == NULL);
            throw;
        }

        if (ctx->current == NULL || ctx->previous == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_expression_node->last_token = ctx->previous;
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}


NODISCARD
errno_t execute_arithmetic(const struct parser_ctx* ctx,
                      const struct expression* new_expression,
                      int op,
                      struct object* result)
{

    assert(!ctx->evaluation_is_disabled);

    struct type common_type = { 0 };

    try
    {
        if (new_expression->left == NULL || new_expression->right == NULL)
        {
            assert(false);
            throw;
        }

        struct object value = { 0 };
        switch (op)
        {
        case '+':
        case '-':

        case '*':
        case '/':
        case '%':
            //
        case '>':
        case '<':
        case '>=':
        case '<=':
            //
        case '==':
        case '!=':
            break;
        default:
            assert(false);
            throw;
        }

        //Each of the operands shall have arithmetic type
        if (!type_is_arithmetic(&new_expression->left->type))
        {
            compiler_diagnostic(C_ERROR_LEFT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "left type must be an arithmetic type");
            throw;
        }

        if (!type_is_arithmetic(&new_expression->right->type))
        {
            compiler_diagnostic(C_ERROR_LEFT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "right type must be an arithmetic type");
            throw;
        }


        if (!ctx->evaluation_is_disabled &&
            object_has_constant_value(&new_expression->left->object) &&
            object_has_constant_value(&new_expression->right->object))
        {

            const struct marker m =
            {
                .p_token_begin = new_expression->left->first_token,
                .p_token_end = new_expression->right->last_token
            };

            common_type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);

            enum object_value_type vt = type_to_object_type(&common_type);
            switch (vt)
            {
            case TYPE_SIGNED_INT:
            {
                const int a = object_to_signed_int(&new_expression->left->object);
                const int b = object_to_signed_int(&new_expression->right->object);

                if (op == '+')
                {
                    const int computed_result = a + b;
                    signed long long exact_result;
                    if (signed_long_long_add(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        assert(false);
                    }
                    value = object_make_signed_int(computed_result);
                }
                else if (op == '-')
                {
                    const int computed_result = a - b;
                    signed long long exact_result;
                    if (signed_long_long_sub(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        assert(false);
                    }
                    value = object_make_signed_int(computed_result);
                }
                else if (op == '*')
                {
                    const int computed_result = a * b;
                    signed long long exact_result;
                    if (signed_long_long_mul(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        assert(false);
                    }
                    value = object_make_signed_int(computed_result);
                }
                else if (op == '/')
                {
                    if (b == 0)
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else if (a == INT_MIN && b == -1)
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, new_expression->right->first_token, NULL, "integer overflow");
                        value = object_make_signed_int(INT_MIN); //this is what other compiler are doing
                    }
                    else
                        value = object_make_signed_int(a / b);
                }
                else if (op == '%')
                {
                    if (b == 0)
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else
                        value = object_make_signed_int(a % b);
                }
                //////////
                else if (op == '>')
                {
                    value = object_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = object_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = object_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = object_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = object_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = object_make_signed_int(a != b);
                }
            }
            break;

            case TYPE_UNSIGNED_INT:
            {
                unsigned int a = object_to_unsigned_int(&new_expression->left->object);
                unsigned int b = object_to_unsigned_int(&new_expression->right->object);

                if (op == '+')
                {
                    const unsigned int computed_result = a + b;
                    unsigned long long exact_result;
                    if (unsigned_long_long_add(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        assert(false);
                    }
                    value = object_make_signed_int(computed_result);
                }
                else if (op == '-')
                {
                    const unsigned int computed_result = a - b;
                    unsigned long long exact_result;
                    if (unsigned_long_long_sub(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        assert(false);
                    }
                    value = object_make_signed_int(computed_result);
                }
                else if (op == '*')
                {
                    const unsigned int computed_result = a * b;
                    unsigned long long exact_result;
                    if (unsigned_long_long_mul(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        assert(false);
                    }
                    value = object_make_signed_int(computed_result);
                }
                else if (op == '/')
                {
                    if (b == 0)
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else
                        value = object_make_unsigned_int(a / b);
                }
                else if (op == '%')
                {
                    if (b == 0)
                    {
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                        throw;
                    }

                    value = object_make_unsigned_int(a % b);
                }
                //////////                
                else if (op == '>')
                {
                    value = object_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = object_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = object_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = object_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = object_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = object_make_signed_int(a != b);
                }

            }
            break;

            case TYPE_SIGNED_LONG:
            {
                const signed long a = object_to_signed_long(&new_expression->left->object);
                const signed long b = object_to_signed_long(&new_expression->right->object);

                if (op == '+')
                {
                    const signed long computed_result = a + b;
                    signed long long exact_result;
                    if (signed_long_long_add(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow");
                    }
                    value = object_make_signed_long(computed_result);
                }
                else if (op == '-')
                {
                    const signed long computed_result = a - b;
                    signed long long exact_result;
                    if (signed_long_long_sub(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow");
                    }
                    value = object_make_signed_long(computed_result);
                }
                else if (op == '*')
                {
                    const signed long computed_result = a * b;
                    signed long long exact_result;
                    if (signed_long_long_mul(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow");
                    }
                    value = object_make_signed_long(computed_result);
                }
                else if (op == '/')
                {
                    if (b == 0)
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else if (a == LONG_MIN && b == -1)
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, new_expression->right->first_token, NULL, "integer overflow");
                        value = object_make_signed_long(LONG_MIN); //this is what compilers are doing
                    }
                    else
                        value = object_make_signed_long(a / b);
                }
                else if (op == '%')
                {
                    if (b == 0)
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else
                        value = object_make_signed_long(a % b);
                }
                //////////
                else if (op == '>')
                {
                    value = object_make_signed_long(a > b);
                }
                else if (op == '<')
                {
                    value = object_make_signed_long(a < b);
                }
                else if (op == '>=')
                {
                    value = object_make_signed_long(a >= b);
                }
                else if (op == '<=')
                {
                    value = object_make_signed_long(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = object_make_signed_long(a == b);
                }
                else if (op == '!=')
                {
                    value = object_make_signed_long(a != b);
                }
            }
            break;

            case TYPE_UNSIGNED_LONG:
            {
                unsigned long a = object_to_unsigned_long(&new_expression->left->object);
                unsigned long b = object_to_unsigned_long(&new_expression->right->object);

                if (op == '+')
                {
                    const unsigned long computed_result = a + b;
                    unsigned long long exact_result;
                    if (unsigned_long_long_add(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow");
                    }
                    value = object_make_unsigned_long(computed_result);
                }
                else if (op == '-')
                {
                    const unsigned long computed_result = a - b;
                    unsigned long long exact_result;
                    if (unsigned_long_long_sub(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow");
                    }
                    value = object_make_unsigned_long(computed_result);
                }
                else if (op == '*')
                {
                    const unsigned long computed_result = a * b;
                    unsigned long long exact_result;
                    if (unsigned_long_long_mul(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow");
                    }

                    value = object_make_unsigned_long(computed_result);
                }
                else if (op == '/')
                {
                    if (b == 0)
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else
                        value = object_make_unsigned_long(a / b);
                }
                else if (op == '%')
                {
                    if (b == 0)
                    {
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                        throw;
                    }

                    value = object_make_unsigned_long(a % b);
                }
                //////////                
                else if (op == '>')
                {
                    value = object_make_unsigned_long(a > b);
                }
                else if (op == '<')
                {
                    value = object_make_unsigned_long(a < b);
                }
                else if (op == '>=')
                {
                    value = object_make_unsigned_long(a >= b);
                }
                else if (op == '<=')
                {
                    value = object_make_unsigned_long(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = object_make_unsigned_long(a == b);
                }
                else if (op == '!=')
                {
                    value = object_make_unsigned_long(a != b);
                }

            }
            break;

            case TYPE_SIGNED_LONG_LONG:
            {
                long long a = object_to_signed_long_long(&new_expression->left->object);
                long long b = object_to_signed_long_long(&new_expression->right->object);

                if (op == '+')
                {
                    const long long computed_result = a + b;
                    signed long long exact_result;
                    if (!signed_long_long_add(&exact_result, a, b))
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%dll'. ", computed_result);
                    }
                    value = object_make_signed_long_long(computed_result);
                }
                else if (op == '-')
                {
                    const long long computed_result = a - b;
                    signed long long exact_result;
                    if (!signed_long_long_sub(&exact_result, a, b))
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%dll'.", computed_result);
                    }
                    value = object_make_signed_long_long(computed_result);
                }
                else if (op == '*')
                {
                    const long long computed_result = a * b;
                    signed long long exact_result;
                    if (!signed_long_long_mul(&exact_result, a, b))
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%dll", computed_result);
                    }
                    value = object_make_signed_long_long(computed_result);
                }
                else if (op == '/')
                {
                    if (b == 0)
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else if (a == LLONG_MIN && b == -1)
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, new_expression->right->first_token, NULL, "integer overflow");
                        value = object_make_signed_long_long(LLONG_MIN); //this is what compilers are doing
                    }
                    else
                        value = object_make_signed_long_long(a / b);
                }
                else if (op == '%')
                {

                    if (b == 0)
                    {
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                        throw;
                    }

                    value = object_make_signed_long_long(a % b);
                }
                //////////                
                else if (op == '>')
                {
                    value = object_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = object_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = object_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = object_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = object_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = object_make_signed_int(a != b);
                }
            }
            break;

            case TYPE_UNSIGNED_LONG_LONG:
            {
                unsigned long long a = object_to_unsigned_long_long(&new_expression->left->object);
                unsigned long long b = object_to_unsigned_long_long(&new_expression->right->object);


                if (op == '+')
                {
                    //const unsigned long long computed_result = a + b;
                    unsigned long long exact_result;
                    if (unsigned_long_long_add(&exact_result, a, b))
                    {
                    }
                    else
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow");
                    }

                    value = object_make_unsigned_long_long(a + b);
                }
                else if (op == '-')
                {
                    //const unsigned long long computed_result = a - b;
                    unsigned long long exact_result;
                    if (unsigned_long_long_sub(&exact_result, a, b))
                    {
                    }
                    else
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow");
                    }

                    value = object_make_unsigned_long_long(a - b);
                }
                else if (op == '*')
                {
                    //const unsigned long long computed_result = a * b;
                    unsigned long long exact_result;
                    if (unsigned_long_long_mul(&exact_result, a, b))
                    {
                    }
                    else
                    {
                        compiler_diagnostic(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow");
                    }
                    value = object_make_unsigned_long_long(a * b);
                }
                else if (op == '/')
                {
                    if (b == 0)
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");


                    value = object_make_unsigned_long_long(a / b);
                }
                else if (op == '%')
                {
                    if (b == 0)
                    {
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                        throw;
                    }
                    value = object_make_unsigned_long_long(a % b);
                }
                //////////
                //////////                
                else if (op == '>')
                {
                    value = object_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = object_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = object_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = object_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = object_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = object_make_signed_int(a != b);
                }

            }
            break;

            case TYPE_BOOL:
            case TYPE_SIGNED_CHAR:
            case TYPE_UNSIGNED_CHAR:
            case TYPE_SIGNED_SHORT:
            case TYPE_UNSIGNED_SHORT:
                assert(false); //they are promoted
                throw;
                break;

            case TYPE_FLOAT:
            {
                float a = object_to_float(&new_expression->left->object);
                float b = object_to_float(&new_expression->right->object);


                if (op == '+')
                {
                    value = object_make_float(a + b);
                }
                else if (op == '-')
                {
                    value = object_make_float(a - b);
                }
                else if (op == '*')
                {
                    value = object_make_float(a * b);
                }
                else if (op == '/')
                {
                    if (b == 0)
                    {
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    }

                    value = object_make_float(a / b);
                }
                else if (op == '%')
                {
                    //error C2296: '%': not valid as left operand has type 'float'
                    compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "'%': not valid as left operand has type 'float'");
                    throw;
                    //r = a % b;
                }
                //////////                
                else if (op == '>')
                {
                    value = object_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = object_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = object_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = object_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = object_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = object_make_signed_int(a != b);
                }

            }
            break;
            case TYPE_DOUBLE:
            {
                double a = object_to_double(&new_expression->left->object);
                double b = object_to_double(&new_expression->right->object);

                if (op == '+')
                {
                    value = object_make_double(a + b);
                }
                else if (op == '-')
                {
                    value = object_make_double(a - b);
                }
                else if (op == '*')
                {
                    value = object_make_double(a * b);
                }
                else if (op == '/')
                {
                    if (b == 0)
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else
                        value = object_make_double(a / b);
                }
                else if (op == '%')
                {
                    //value = object_make_double(r);
                    //error C2296: '%': not valid as left operand has type 'float'
                    compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "'%': not valid as left operand has type 'float'");
                    throw;
                    //r = a % b;
                }
                //////////                
                else if (op == '>')
                {
                    value = object_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = object_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = object_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = object_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = object_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = object_make_signed_int(a != b);
                }

            }
            break;
            case TYPE_LONG_DOUBLE:
            {
                long double a = object_to_long_double(&new_expression->left->object);
                long double b = object_to_long_double(&new_expression->right->object);

                if (op == '+')
                {
                    value = object_make_long_double(a + b);
                }
                else if (op == '-')
                {
                    value = object_make_long_double(a - b);
                }
                else if (op == '*')
                {
                    value = object_make_long_double(a * b);
                }
                else if (op == '/')
                {
                    if (b == 0)
                        compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else
                        value = object_make_long_double(a / b);
                }
                else if (op == '%')
                {
                    //error C2296: '%': not valid as left operand has type 'float'
                    //value = object_make_long_double(a % b);
                    compiler_diagnostic(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "'%': not valid as left operand has type 'float'");
                    //r = a % b;
                    throw;
                }
                //////////                
                else if (op == '>')
                {
                    value = object_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = object_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = object_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = object_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = object_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = object_make_signed_int(a != b);
                }

            }
            break;

            };


        }

        type_destroy(&common_type);
        *result = value;
        return 0;//ok
    }
    catch
    {
    }

    type_destroy(&common_type);

    struct object empty = { 0 };
    *result = empty;
    return 1; //error
}

struct expression* _Owner _Opt multiplicative_expression(struct parser_ctx* ctx)
{

    /*
     multiplicative-expression:
    cast-expression
    multiplicative-expression * cast-expression
    multiplicative-expression / cast-expression
    multiplicative-expression % cast-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        p_expression_node = cast_expression(ctx);
        if (p_expression_node == NULL)
        {
            throw;
        }

        while (ctx->current != NULL &&
               (ctx->current->type == '*' ||
                   ctx->current->type == '/' ||
                   ctx->current->type == '%'))
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
            {
                expression_delete(p_expression_node);
                p_expression_node = NULL;
                throw;
            }

            new_expression->first_token = ctx->current;
            const enum token_type op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                throw;
            }

            switch (op)
            {
            case '*':
                new_expression->expression_type = MULTIPLICATIVE_EXPRESSION_MULT;
                break;
            case '/':
                new_expression->expression_type = MULTIPLICATIVE_EXPRESSION_DIV;
                break;
            case '%':
                new_expression->expression_type = MULTIPLICATIVE_EXPRESSION_MOD;
                break;
            default:
                assert(false);
                break;
            }


            new_expression->left = p_expression_node;
            p_expression_node = NULL; // MOVED

            new_expression->right = cast_expression(ctx);

            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }
            new_expression->last_token = new_expression->right->last_token;


            if (op == '%')
            {
                /*The operands of the % operator shall have integer type*/
                if (!type_is_integer(&new_expression->left->type))
                {
                    compiler_diagnostic(C_ERROR_LEFT_IS_NOT_INTEGER,
                        ctx,
                        new_expression->left->first_token,
                        NULL,
                        "left is not an integer type");
                }

                if (!type_is_integer(&new_expression->right->type))
                {
                    compiler_diagnostic(C_ERROR_RIGHT_IS_NOT_INTEGER,
                        ctx,
                        new_expression->right->first_token,
                        NULL,
                        "right is not an integer type");
                }
            }
            else
            {
                /*Each of the operands shall have arithmetic type.*/
                if (!type_is_arithmetic(&new_expression->left->type))
                {
                    compiler_diagnostic(C_ERROR_LEFT_IS_NOT_ARITHMETIC,
                        ctx,
                        new_expression->left->first_token,
                        NULL,
                        "left is not an arithmetic type");
                }

                if (!type_is_arithmetic(&new_expression->right->type))
                {
                    compiler_diagnostic(C_ERROR_RIGHT_IS_NOT_ARITHMETIC,
                        ctx,
                        new_expression->right->first_token,
                        NULL,
                        "right is not an arithmetic type");
                }
            }
            new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);

            if (!ctx->evaluation_is_disabled && execute_arithmetic(ctx, new_expression, op, &new_expression->object) != 0)
            {
                expression_delete(new_expression);
                throw;
            }

            p_expression_node = new_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }
    return p_expression_node;
}


struct expression* _Owner _Opt additive_expression(struct parser_ctx* ctx)
{
    /*
     additive-expression:
    multiplicative-expression
    additive-expression + multiplicative-expression
    additive-expression - multiplicative-expression
    */

    struct expression* _Owner _Opt p_expression_node = NULL;

    try
    {
        p_expression_node = multiplicative_expression(ctx);
        if (p_expression_node == NULL)
        {
            throw;
        }

        while (ctx->current != NULL &&
               (ctx->current->type == '+' ||
                   ctx->current->type == '-'))
        {
            struct token* operator_position = ctx->current;

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
            {
                compiler_diagnostic(C_ERROR_OUT_OF_MEM, ctx, ctx->current, NULL, "out of mem");
                throw;
            }

            new_expression->first_token = ctx->current;

            enum token_type op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/


            new_expression->right = multiplicative_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->last_token = new_expression->right->last_token;



            if (!type_is_scalar(&new_expression->left->type) && !type_is_array(&new_expression->left->type))
            {
                compiler_diagnostic(C_ERROR_LEFT_IS_NOT_SCALAR, ctx, operator_position, NULL, "left operator is not scalar");
            }
            if (!type_is_scalar(&new_expression->right->type) && !type_is_array(&new_expression->right->type))
            {
                compiler_diagnostic(C_ERROR_RIGHT_IS_NOT_SCALAR, ctx, operator_position, NULL, "right operator is not scalar");
            }

            const bool b_left_is_arithmetic = type_is_arithmetic(&new_expression->left->type);
            const bool b_right_is_arithmetic = type_is_arithmetic(&new_expression->right->type);

            const enum type_category left_category = type_get_category(&new_expression->left->type);
            const enum type_category right_category = type_get_category(&new_expression->right->type);

            if (op == '+')
            {
                new_expression->expression_type = ADDITIVE_EXPRESSION_PLUS;

                /*
                 For addition, either both operands shall have arithmetic type,
                 or one operand shall be a pointer to a complete object type and
                 the other shall have integer type. (Incrementing is equivalent to adding 1.)
                */
                if (b_left_is_arithmetic && b_right_is_arithmetic)
                {
                    new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);

                    if (!ctx->evaluation_is_disabled && execute_arithmetic(ctx, new_expression, op, &new_expression->object) != 0)
                    {
                        expression_delete(new_expression);
                        throw;
                    }
                }
                else
                {
                    if (left_category == TYPE_CATEGORY_POINTER || left_category == TYPE_CATEGORY_ARRAY /* || left_category == TYPE_CATEGORY_FUNCTION*/)
                    {
                        if (type_is_integer(&new_expression->right->type))
                        {
                            if (left_category == TYPE_CATEGORY_ARRAY)
                            {
                                struct type t = get_array_item_type(&new_expression->left->type);
                                new_expression->type = type_add_pointer(&t, ctx->options.null_checks_enabled);
                                //new_expression->type.type_qualifier_flags |= not_nu;
                                type_destroy(&t);
                            }
                            else
                            {
                                new_expression->type = type_dup(&new_expression->left->type);
                            }
                        }
                        else
                        {
                            compiler_diagnostic(C_ERROR_RIGHT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "expected integer type on right");
                        }
                    }
                    else if (right_category == TYPE_CATEGORY_POINTER || right_category == TYPE_CATEGORY_ARRAY /*|| right_category == TYPE_CATEGORY_FUNCTION*/)
                    {
                        if (type_is_integer(&new_expression->left->type))
                        {
                            if (right_category == TYPE_CATEGORY_ARRAY)
                            {
                                new_expression->type = get_array_item_type(&new_expression->right->type);
                            }
                            else
                            {
                                new_expression->type = type_dup(&new_expression->right->type);
                            }
                        }
                        else
                        {
                            compiler_diagnostic(C_ERROR_LEFT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "expected integer type on left");
                        }
                    }
                    else
                    {
                        compiler_diagnostic(C_ERROR_INVALID_TYPE, ctx, ctx->current, NULL, "invalid types additive expression");
                    }
                }
            }
            else if (op == '-')
            {
                new_expression->expression_type = ADDITIVE_EXPRESSION_MINUS;

                /*
                 For subtraction, one of the following shall hold:
                    — both operands have arithmetic type;
                    — both operands are pointers to qualified or unqualified versions of compatible complete object
                    types; or
                    — the left operand is a pointer to a complete object type and the right operand has integer type.
                    (Decrementing is equivalent to subtracting 1.)
                */
                if (b_left_is_arithmetic && b_right_is_arithmetic)
                {
                    new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);

                    if (!ctx->evaluation_is_disabled && execute_arithmetic(ctx, new_expression, op, &new_expression->object) != 0)
                    {
                        expression_delete(new_expression);
                        throw;
                    }
                }
                else
                {
                    if (left_category == TYPE_CATEGORY_POINTER || left_category == TYPE_CATEGORY_ARRAY)
                    {
                        if (right_category == TYPE_CATEGORY_POINTER || right_category == TYPE_CATEGORY_ARRAY)
                        {
                            // — both operands are pointers to qualified or unqualified versions of compatible complete object
                            //  types;
                            struct type t1 = type_lvalue_conversion(&new_expression->left->type, ctx->options.null_checks_enabled);
                            struct type t2 = type_lvalue_conversion(&new_expression->right->type, ctx->options.null_checks_enabled);

                            if (!type_is_same(&t1, &t2, false))
                            {
                                compiler_diagnostic(C_ERROR_INCOMPATIBLE_POINTER_TYPES, ctx, ctx->current, NULL, "incompatible pointer types");
                            }

                            new_expression->type = type_make_int();
                            type_destroy(&t1);
                            type_destroy(&t2);
                        }
                        else
                        {
                            if (type_is_integer(&new_expression->right->type))
                            {
                                //- the left operand is a pointer to a complete object typeand the right operand has integer type.
                                new_expression->type = type_dup(&new_expression->left->type);
                            }
                            else
                            {
                                compiler_diagnostic(C_ERROR_RIGHT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "right must be integer type");
                            }
                        }
                    }
                    else
                    {
                        compiler_diagnostic(C_ERROR_INVALID_TYPE, ctx, ctx->current, NULL, "invalid types for operator -");
                    }
                }
            }

            p_expression_node = new_expression;
            new_expression = NULL; /*MOVED*/
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

struct expression* _Owner _Opt shift_expression(struct parser_ctx* ctx)
{
    /*
     shift-expression:
       additive-expression
       shift-expression << additive-expression
       shift-expression >> additive-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        p_expression_node = additive_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '>>' ||
                   ctx->current->type == '<<'))
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;

            enum token_type op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = multiplicative_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            new_expression->last_token = new_expression->right->last_token;

            if (op == '>>')
            {
                new_expression->expression_type = SHIFT_EXPRESSION_RIGHT;
            }
            else if (op == '<<')
            {
                new_expression->expression_type = SHIFT_EXPRESSION_LEFT;
            }
            if (execute_bitwise_operator(ctx, new_expression, op) != 0)
            {
                expression_delete(new_expression);
                throw;
            }


            p_expression_node = new_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

struct expression* _Owner _Opt relational_expression(struct parser_ctx* ctx)
{
    /*
    relational-expression:
        shift-expression
        relational-expression < shift-expression
        relational-expression > shift-expression
        relational-expression <= shift-expression
        relational-expression >= shift-expression
    */

    struct expression* _Owner _Opt p_expression_node = NULL;
    struct expression* _Owner _Opt new_expression = NULL;
    try
    {
        p_expression_node = shift_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '>' ||
                   ctx->current->type == '<' ||
                   ctx->current->type == '>=' ||
                   ctx->current->type == '<='))
        {
            assert(new_expression == NULL);
            new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
            {
                throw;
            }
            new_expression->first_token = ctx->current;
            enum token_type op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = shift_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->last_token = new_expression->right->last_token;
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            check_comparison(ctx,
              new_expression->left,
              new_expression->right,
              ctx->current);

            if (op == '>')
            {
                new_expression->expression_type = RELATIONAL_EXPRESSION_BIGGER_THAN;
            }
            else if (op == '<')
            {
                new_expression->expression_type = RELATIONAL_EXPRESSION_LESS_THAN;
            }
            else if (op == '>=')
            {
                new_expression->expression_type = RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN;
            }
            else if (op == '<=')
            {
                new_expression->expression_type = RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN;
            }

            //Each of the operands shall have arithmetic type
            if (type_is_arithmetic(&new_expression->left->type) &&
                type_is_arithmetic(&new_expression->right->type))
            {
                new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);

                if (!ctx->evaluation_is_disabled && execute_arithmetic(ctx, new_expression, op, &new_expression->object) != 0)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }
            }

            type_destroy(&new_expression->type);
            new_expression->type = type_make_int_bool_like();

            p_expression_node = new_expression;
            new_expression = NULL; /*MOVED*/
        }
    }
    catch
    {
        expression_delete(new_expression);
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

void check_diferent_enuns(struct parser_ctx* ctx,
                                 const struct token* operator_token,
                                 const struct expression* left,
                                 const struct expression* right,
                                 const char* message)
{
    if (left->type.type_specifier_flags & TYPE_SPECIFIER_ENUM &&
        right->type.type_specifier_flags & TYPE_SPECIFIER_ENUM)
    {
        assert(left->type.enum_specifier);
        assert(right->type.enum_specifier);

        if (get_complete_enum_specifier(left->type.enum_specifier) !=
            get_complete_enum_specifier(right->type.enum_specifier))
        {
            assert(left->type.enum_specifier != NULL);
            assert(right->type.enum_specifier != NULL);

            const char* lefttag = "";
            if (left->type.enum_specifier->tag_token)
                lefttag = left->type.enum_specifier->tag_token->lexeme;

            const char* righttag = "";
            if (right->type.enum_specifier->tag_token)
                righttag = right->type.enum_specifier->tag_token->lexeme;

            char finalmessage[200] = { 0 };
            snprintf(finalmessage,
                sizeof finalmessage,
                "%s (enum %s, enum %s)",
                message,
                lefttag,
                righttag);

            compiler_diagnostic(W_ENUN_CONVERSION,
                                        ctx,
                                        operator_token, NULL,
                                        finalmessage,
                                        lefttag,
                                        righttag);
        }
    }
}
void expression_evaluate_equal_not_equal(const struct expression* left,
                                         const struct expression* right,
                                         struct expression* result,
                                         int op,
                                         bool disabled)
{
    assert(op == '==' || op == '!=');
    //result->object =
        //object_op(&left->object, &right->object, op);
}

struct expression* _Owner _Opt equality_expression(struct parser_ctx* ctx)
{
    /*
      equality-expression:
       relational-expression
       equality-expression == relational-expression
       equality-expression != relational-expression
    */
    /*
    * Equality operators
    One of the following shall hold:
    — both operands have arithmetic type;
    — both operands are pointers to qualified or unqualified versions of compatible types;
    — one operand is a pointer to an object type and the other is a pointer to a qualified or unqualified
    version of void; or
    — one operand is a pointer and the other is a null pointer constant.
    */
    struct expression* _Owner _Opt  p_expression_node = NULL;
    struct expression* _Owner _Opt new_expression = NULL;

    try
    {
        p_expression_node = relational_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '==' ||
                   ctx->current->type == '!='))
        {
            assert(new_expression == NULL);
            new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;

            new_expression->first_token = ctx->current;

            struct token* operator_token = ctx->current;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (operator_token->type == '==')
                new_expression->expression_type = EQUALITY_EXPRESSION_EQUAL;
            else
                new_expression->expression_type = EQUALITY_EXPRESSION_NOT_EQUAL;

            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = relational_expression(ctx);
            if (new_expression->right == NULL)
                throw;

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            check_comparison(ctx,
              new_expression->left,
              new_expression->right,
              ctx->current);

            new_expression->last_token = new_expression->right->last_token;
            new_expression->first_token = operator_token;

            //TODO missing general checks described in standard
            //like pointer, nullptr etc...
            if (type_is_arithmetic(&new_expression->left->type) &&
                type_is_arithmetic(&new_expression->right->type))
            {
                if (!ctx->evaluation_is_disabled && execute_arithmetic(ctx, new_expression, operator_token->type, &new_expression->object) != 0)
                {
                    throw;
                }
            }

            new_expression->type = type_make_int_bool_like();
            p_expression_node = new_expression;
            new_expression = NULL; /*MOVED*/
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    expression_delete(new_expression);
    return p_expression_node;
}

struct expression* _Owner _Opt and_expression(struct parser_ctx* ctx)
{
    /*
     AND-expression:
      equality-expression
      AND-expression & equality-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    struct expression* _Owner _Opt new_expression = NULL;

    try
    {
        p_expression_node = equality_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL && ctx->current->type == '&')
        {
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            assert(new_expression == NULL);
            new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;

            new_expression->first_token = ctx->current;
            new_expression->expression_type = AND_EXPRESSION;
            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = equality_expression(ctx);
            if (new_expression->right == NULL)
                throw;

            new_expression->last_token = new_expression->right->last_token;

            if (execute_bitwise_operator(ctx, new_expression, '&') != 0)
                throw;

            p_expression_node = new_expression;
            new_expression = NULL; /*MOVED*/
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    expression_delete(new_expression);
    return p_expression_node;
}

struct expression* _Owner _Opt  exclusive_or_expression(struct parser_ctx* ctx)
{
    /*
     exclusive-OR-expression:
      AND-expression
      exclusive-OR-expression ^ AND-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    struct expression* _Owner _Opt new_expression = NULL;

    try
    {
        p_expression_node = and_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '^'))
        {
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            assert(new_expression == NULL);
            new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;

            new_expression->first_token = ctx->current;
            new_expression->expression_type = EXCLUSIVE_OR_EXPRESSION;
            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = and_expression(ctx);
            if (new_expression->right == NULL)
                throw;

            new_expression->last_token = new_expression->right->last_token;

            if (execute_bitwise_operator(ctx, new_expression, '^') != 0)
                throw;

            p_expression_node = new_expression;
            new_expression = NULL;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    expression_delete(new_expression);
    return p_expression_node;
}


NODISCARD
static errno_t execute_bitwise_operator(struct parser_ctx* ctx, struct expression* new_expression, int op)
{
    try
    {
        switch (op)
        {
        case '&':
        case '^':
        case '|':
        case '>>':
        case '<<':
            break;
        default:
            assert(false);
            throw;
        }


        //Each of the operands shall have integer type.
        if (!type_is_integer(&new_expression->left->type))
        {
            compiler_diagnostic(C_ERROR_LEFT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "left type must be an integer type");
            throw;
        }

        if (!type_is_integer(&new_expression->right->type))
        {
            compiler_diagnostic(C_ERROR_LEFT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "right type must be an integer type");
            throw;
        }

        type_destroy(&new_expression->type);
        new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);

        if (!ctx->evaluation_is_disabled &&
            object_has_constant_value(&new_expression->left->object) &&
            object_has_constant_value(&new_expression->right->object))
        {
            enum object_value_type vt = type_to_object_type(&new_expression->type);
            switch (vt)
            {
            case TYPE_SIGNED_INT:
            {
                int a = object_to_signed_int(&new_expression->left->object);
                int b = object_to_signed_int(&new_expression->right->object);

                int r = 0;
                if (op == '|')
                    r = a | b;
                else if (op == '^')
                    r = a ^ b;
                else if (op == '&')
                    r = a & b;
                //
                else if (op == '>>')
                    r = a >> b;
                else if (op == '<<')
                    r = a << b;

                object_destroy(&new_expression->object);
                new_expression->object = object_make_signed_int(r);
            }
            break;
            case TYPE_UNSIGNED_INT:
            {
                unsigned int a = object_to_unsigned_int(&new_expression->left->object);
                unsigned int b = object_to_unsigned_int(&new_expression->right->object);
                int r = 0;
                if (op == '|')
                    r = a | b;
                else if (op == '^')
                    r = a ^ b;
                else if (op == '&')
                    r = a & b;
                //
                else if (op == '>>')
                    r = a >> b;
                else if (op == '<<')
                    r = a << b;

                object_destroy(&new_expression->object);
                new_expression->object = object_make_unsigned_int(r);
            }
            break;

            case TYPE_SIGNED_LONG:
            {
                signed long a = object_to_signed_long(&new_expression->left->object);
                signed long b = object_to_signed_long(&new_expression->right->object);

                int r = 0;
                if (op == '|')
                    r = a | b;
                else if (op == '^')
                    r = a ^ b;
                else if (op == '&')
                    r = a & b;
                //
                else if (op == '>>')
                    r = a >> b;
                else if (op == '<<')
                    r = a << b;

                object_destroy(&new_expression->object);
                new_expression->object = object_make_signed_long(r);
            }
            break;

            case TYPE_UNSIGNED_LONG:
            {
                unsigned long a = object_to_unsigned_long(&new_expression->left->object);
                unsigned long b = object_to_unsigned_long(&new_expression->right->object);
                int r = 0;
                if (op == '|')
                    r = a | b;
                else if (op == '^')
                    r = a ^ b;
                else if (op == '&')
                    r = a & b;
                //
                else if (op == '>>')
                    r = a >> b;
                else if (op == '<<')
                    r = a << b;

                object_destroy(&new_expression->object);
                new_expression->object = object_make_unsigned_long(r);
            }
            break;


            case TYPE_SIGNED_LONG_LONG:
            {
                signed long long a = object_to_signed_long_long(&new_expression->left->object);
                signed long long b = object_to_signed_long_long(&new_expression->right->object);
                signed long long r = 0;
                if (op == '|')
                    r = a | b;
                else if (op == '^')
                    r = a ^ b;
                else if (op == '&')
                    r = a & b;
                //
                else if (op == '>>')
                    r = a >> b;
                else if (op == '<<')
                    r = a << b;

                object_destroy(&new_expression->object);
                new_expression->object = object_make_signed_long_long(r);

            }
            break;

            case TYPE_UNSIGNED_LONG_LONG:
            {
                unsigned long long a = object_to_unsigned_long_long(&new_expression->left->object);
                unsigned long long b = object_to_unsigned_long_long(&new_expression->right->object);
                unsigned long long r = 0;
                if (op == '|')
                    r = a | b;
                else if (op == '^')
                    r = a ^ b;
                else if (op == '&')
                    r = a & b;
                //
                else if (op == '>>')
                    r = a >> b;
                else if (op == '<<')
                    r = a << b;

                object_destroy(&new_expression->object);
                new_expression->object = object_make_unsigned_long_long(r);
            }
            break;

            case TYPE_BOOL:
            case TYPE_SIGNED_CHAR:
            case TYPE_UNSIGNED_CHAR:
            case TYPE_SIGNED_SHORT:
            case TYPE_UNSIGNED_SHORT:
                assert(false); //they are promoted
                throw;
                break;


            case TYPE_FLOAT:
            case TYPE_DOUBLE:
            case TYPE_LONG_DOUBLE:
                assert(false); //works for integers only
                throw;
                break;
            };
        }
        return 0;//ok
    }
    catch
    {
    }
    return 1; //error
}

struct expression* _Owner _Opt inclusive_or_expression(struct parser_ctx* ctx)
{
    /*
    inclusive-OR-expression:
        exclusive-OR-expression
        inclusive-OR-expression | exclusive-OR-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        p_expression_node = exclusive_or_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '|'))
        {
            struct token* operator_token = ctx->current;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;


            new_expression->first_token = ctx->current;
            new_expression->expression_type = INCLUSIVE_OR_EXPRESSION;
            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = exclusive_or_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            check_diferent_enuns(ctx,
                                operator_token,
                                new_expression->left,
                                new_expression->right,
                                "operator '|' between enumerations of different types.");

            new_expression->last_token = new_expression->right->last_token;

            if (execute_bitwise_operator(ctx, new_expression, '|') != 0)
            {
                expression_delete(new_expression);
                throw;
            }

            p_expression_node = new_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

struct expression* _Owner _Opt logical_and_expression(struct parser_ctx* ctx)
{
    /*
    logical-AND-expression:
     inclusive-OR-expression
     logical-AND-expression && inclusive-OR-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        p_expression_node = inclusive_or_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '&&'))
        {
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;

            new_expression->first_token = ctx->current;
            new_expression->expression_type = LOGICAL_AND_EXPRESSION;
            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            bool right_evaluation_is_disabled = false;

            if (object_has_constant_value(&new_expression->left->object))
            {
                if (!object_to_bool(&new_expression->left->object))
                {
                    right_evaluation_is_disabled = true;
                }
            }

            const bool old_evaluation_is_disabled = ctx->evaluation_is_disabled;
            ctx->evaluation_is_disabled = right_evaluation_is_disabled;

            new_expression->right = inclusive_or_expression(ctx);

            ctx->evaluation_is_disabled = old_evaluation_is_disabled; //restore

            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }
            new_expression->last_token = new_expression->right->last_token;

            if (!ctx->evaluation_is_disabled)
            {
                if (object_has_constant_value(&new_expression->left->object))
                {
                    bool a = object_to_bool(&new_expression->left->object);
                    if (a == 0)
                    {
                        // 0 && something
                        new_expression->object = object_make_signed_int(0);
                    }
                    else
                    {
                        // 1 && something
                        if (object_has_constant_value(&new_expression->right->object))
                        {
                            bool b = object_to_bool(&new_expression->right->object);
                            new_expression->object = object_make_signed_int(a && b);
                        }
                    }
                }
            }

            //Each of the operands shall have scalar type
            if (!type_is_scalar(&new_expression->left->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic(C_ERROR_LEFT_IS_NOT_SCALAR, ctx, ctx->current, NULL, "left type is not scalar for or expression");
                throw;
            }

            if (!type_is_scalar(&new_expression->right->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic(C_ERROR_RIGHT_IS_NOT_SCALAR, ctx, ctx->current, NULL, "right type is not scalar for or expression");
                throw;
            }

            //The result has type int
            new_expression->type = type_make_int_bool_like();

            p_expression_node = new_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

struct expression* _Owner _Opt logical_or_expression(struct parser_ctx* ctx)
{
    /*
      logical-OR-expression:
       logical-AND-expression
       logical-OR-expression || logical-AND-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {


        p_expression_node = logical_and_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '||'))
        {
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;

            new_expression->first_token = ctx->current;
            new_expression->expression_type = LOGICAL_OR_EXPRESSION;
            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            bool right_evaluation_is_disabled = false;

            if (object_has_constant_value(&new_expression->left->object))
            {
                if (object_to_bool(&new_expression->left->object))
                {
                    /*
                      If the first operand compares unequal to 0, the second operand is not evaluated.
                    */
                    right_evaluation_is_disabled = true;
                }
            }

            const bool old_evaluation_is_disabled = ctx->evaluation_is_disabled;
            ctx->evaluation_is_disabled = right_evaluation_is_disabled;

            new_expression->right = logical_and_expression(ctx);

            ctx->evaluation_is_disabled = old_evaluation_is_disabled; //restore

            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            new_expression->last_token = new_expression->right->last_token;

            if (!ctx->evaluation_is_disabled)
            {
                if (object_has_constant_value(&new_expression->left->object))
                {
                    bool a = object_to_bool(&new_expression->left->object);
                    if (a == 1)
                    {
                        // 1 || something
                        new_expression->object = object_make_signed_int(1);
                    }
                    else
                    {
                        // 0 || something
                        if (object_has_constant_value(&new_expression->right->object))
                        {
                            bool b = object_to_bool(&new_expression->right->object);
                            new_expression->object = object_make_signed_int(a || b);
                        }
                    }
                }
            }


            //Each of the operands shall have scalar type
            if (!type_is_scalar(&new_expression->left->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic(C_ERROR_LEFT_IS_NOT_SCALAR, ctx, ctx->current, NULL, "left type is not scalar for or expression");
                throw;
            }

            if (!type_is_scalar(&new_expression->right->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic(C_ERROR_RIGHT_IS_NOT_SCALAR, ctx, ctx->current, NULL, "right type is not scalar for or expression");
                throw;
            }

            //The result has type int
            new_expression->type = type_make_int_bool_like();

            p_expression_node = new_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

struct expression* _Owner _Opt assignment_expression(struct parser_ctx* ctx)
{
    /*
    assignment-expression:
       conditional-expression
       unary-expression assignment-operator assignment-expression
       */
       /*
          assignment-operator: one of
          = *= /= %= += -= <<= >>= &= ^= |=
       */
       // aqui eh duvidoso mas conditional faz a unary tb.
       // a diferenca q nao eh qualquer expressao
       // que pode ser de atribuicao
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        p_expression_node = conditional_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        assert(p_expression_node->expression_type != EXPRESSION_TYPE_INVALID);

        while (ctx->current != NULL &&
               (ctx->current->type == '=' ||
                   ctx->current->type == '*=' ||
                   ctx->current->type == '/=' ||
                   ctx->current->type == '%=' ||
                   ctx->current->type == '+=' ||
                   ctx->current->type == '-=' ||
                   ctx->current->type == '<<=' ||
                   ctx->current->type == '>>=' ||
                   ctx->current->type == '&=' ||
                   ctx->current->type == '^=' ||
                   ctx->current->type == '|='))
        {

            const struct token* const op_token = ctx->current;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;

            new_expression->first_token = ctx->current;

            switch (op_token->type)
            {
            case '=':
                new_expression->expression_type = ASSIGNMENT_EXPRESSION_ASSIGN;
                break;
            case '*=':
                new_expression->expression_type = ASSIGNMENT_EXPRESSION_MULTI_ASSIGN;
                break;
            case '/=':
                new_expression->expression_type = ASSIGNMENT_EXPRESSION_DIV_ASSIGN;
                break;
            case '%=':
                new_expression->expression_type = ASSIGNMENT_EXPRESSION_MOD_ASSIGN;
                break;
            case '+=':
                new_expression->expression_type = ASSIGNMENT_EXPRESSION_PLUS_ASSIGN;
                break;
            case '-=':
                new_expression->expression_type = ASSIGNMENT_EXPRESSION_MINUS_ASSIGN;
                break;
            case '<<=':
                new_expression->expression_type = ASSIGNMENT_EXPRESSION_SHIFT_LEFT_ASSIGN;
                break;
            case '>>=':
                new_expression->expression_type = ASSIGNMENT_EXPRESSION_SHIFT_RIGHT_ASSIGN;
                break;
            case '&=':
                new_expression->expression_type = ASSIGNMENT_EXPRESSION_AND_ASSIGN;
                break;
            case '^=':
                new_expression->expression_type = ASSIGNMENT_EXPRESSION_NOT_ASSIGN;
                break;
            case '|=':
                new_expression->expression_type = ASSIGNMENT_EXPRESSION_OR_ASSIGN;
                break;
            default:
                assert(false);
                break;
            }


            new_expression->left = p_expression_node;
            p_expression_node = NULL; // MOVED

            const struct marker left_operand_marker = {
                      .p_token_begin = new_expression->left->first_token,
                      .p_token_end = new_expression->left->last_token,
            };

            if (type_is_function(&new_expression->left->type))
            {
                compiler_diagnostic(C_ERROR_ASSIGNMENT_OF_FUNCTION,
                    ctx,
                    NULL,
                    &left_operand_marker,
                    "assignment of function");
            }
            else if (type_is_array(&new_expression->left->type))
            {
                if (new_expression->left->type.storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
                {
                    /*
                      assignment of array parameter
                    */
                    compiler_diagnostic(W_ASSIGNMENT_OF_ARRAY_PARAMETER,
                        ctx,
                        NULL,
                        &left_operand_marker,
                        "assignment to array parameter");
                }
                else
                {
                    compiler_diagnostic(C_ERROR_ASSIGNMENT_TO_EXPRESSION_WITH_ARRAY_TYPE,
                        ctx,
                        NULL,
                        &left_operand_marker,
                        "assignment to expression with array type");
                }
            }

            if (type_is_const(&new_expression->left->type))
            {
                compiler_diagnostic(C_ERROR_ASSIGNMENT_OF_READ_ONLY_OBJECT,
                    ctx,
                    NULL,
                    &left_operand_marker,
                    "assignment of read-only object");
            }


            if (!expression_is_lvalue(new_expression->left))
            {
                compiler_diagnostic(C_ERROR_OPERATOR_NEEDS_LVALUE,
                                            ctx,
                                            NULL,
                                            &left_operand_marker,
                                            "lvalue required as left operand of assignment");
            }

            new_expression->right = assignment_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            if (op_token->type == '=')
            {
                check_assigment(ctx, &new_expression->left->type, new_expression->right, ASSIGMENT_TYPE_OBJECTS);
            }

            new_expression->last_token = new_expression->right->last_token;

            new_expression->type = type_dup(&new_expression->left->type);

            new_expression->type.storage_class_specifier_flags &= ~STORAGE_SPECIFIER_FUNCTION_RETURN;
            new_expression->type.storage_class_specifier_flags &= ~STORAGE_SPECIFIER_FUNCTION_RETURN_NODISCARD;

            check_diferent_enuns(ctx,
                op_token,
                new_expression->left,
                new_expression->right,
                "assignment of different enums.");

            new_expression->left->is_assignment_expression = true;
            if (new_expression->left->left)
                new_expression->left->left->is_assignment_expression = true;
            p_expression_node = new_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

void argument_expression_list_push(struct argument_expression_list* list, struct argument_expression* _Owner pitem)
{
    if (list->head == NULL)
    {
        list->head = pitem;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = pitem;
    }
    list->tail = pitem;
}

void argument_expression_list_destroy(_Dtor struct argument_expression_list* p)
{
    struct argument_expression* _Owner _Opt item = p->head;
    while (item)
    {
        struct argument_expression* _Owner _Opt next = item->next;
        item->next = NULL;
        argument_expression_delete(item);
        item = next;
    }
}

bool expression_is_malloc(const struct expression* p)
{
    if (p->expression_type == POSTFIX_FUNCTION_CALL &&
        p->left &&
        p->left->declarator &&
        p->left->declarator->name_opt)
    {
        if (strcmp(p->left->declarator->name_opt->lexeme, "malloc") == 0)
            return true;
    }
    return false;
}

bool expression_is_calloc(const struct expression* p)
{
    if (p->expression_type == POSTFIX_FUNCTION_CALL &&
        p->left &&
        p->left->declarator &&
        p->left->declarator->name_opt)
    {
        if (strcmp(p->left->declarator->name_opt->lexeme, "calloc") == 0)
            return true;
    }
    return false;
}

void expression_delete(struct expression* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->condition_expr);
        compound_statement_delete(p->compound_statement);
        type_name_delete(p->type_name);

        expression_delete(p->right);
        expression_delete(p->left);
        braced_initializer_delete(p->braced_initializer);
        generic_selection_delete(p->generic_selection);
        type_destroy(&p->type);
        argument_expression_list_destroy(&p->argument_expression_list);

        //explodindo
        //object_destroy(&p->object);

        free(p);
    }
}
struct expression* _Owner _Opt expression(struct parser_ctx* ctx)
{
    /*expression:
      assignment-expression
      expression, assignment-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_expression_node = assignment_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == ',')
        {
            while (ctx->current->type == ',')
            {
                parser_match(ctx);
                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    throw;
                }

                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL)
                    throw;

                p_expression_node_new->first_token = ctx->current;
                p_expression_node_new->expression_type = EXPRESSION_EXPRESSION;
                p_expression_node_new->left = p_expression_node;
                p_expression_node = NULL; /*MOVED*/

                p_expression_node_new->right = expression(ctx);
                if (p_expression_node_new->right == NULL)
                {
                    expression_delete(p_expression_node_new);
                    throw;
                }
                p_expression_node_new->left->last_token = p_expression_node_new->right->last_token;

                p_expression_node = p_expression_node_new;

                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    throw;
                }
            }

            /*same type of the last expression*/
            type_destroy(&p_expression_node->type);
            p_expression_node->type = type_dup(&p_expression_node->right->type);
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }
    return p_expression_node;
}

bool is_first_of_conditional_expression(struct parser_ctx* ctx)
{
    return is_first_of_unary_expression(ctx) ||
        is_first_of_primary_expression(ctx);
}

bool expression_is_one(const struct expression* expression)
{
    if (expression->expression_type == PRIMARY_EXPRESSION_NUMBER)
    {
        return (object_has_constant_value(&expression->object) &&
            object_to_signed_int(&expression->object) == 1);
    }
    return false;
}

bool expression_is_zero(const struct expression* expression)
{
    if (expression->expression_type == PRIMARY_EXPRESSION_NUMBER)
    {
        return (object_has_constant_value(&expression->object) &&
            object_to_signed_int(&expression->object) == 0);
    }
    return false;
}

bool expression_is_null_pointer_constant(const struct expression* expression)
{
    /*
      An integer constant expression with the value 0,
      such an expression cast to type void *, or the
      predefined constant nullptr is called a null pointer constant.57)
    */
    if (type_is_integer(&expression->type) &&
        object_has_constant_value(&expression->object) &&
        object_to_signed_int(&expression->object) == 0)
    {
        return true;
    }
    if (type_is_void_ptr(&expression->type) &&
        object_has_constant_value(&expression->object) &&
        object_to_signed_int(&expression->object) == 0)
    {
        return true;
    }

    if (type_is_nullptr_t(&expression->type))
    {
        return true;
    }

    return false;
}

struct expression* _Owner _Opt conditional_expression(struct parser_ctx* ctx)
{
    /*
      conditional-expression:
      logical-OR-expression
      logical-OR-expression ? expression : conditional-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    struct type left_type = { 0 };
    struct type right_type = { 0 };
    try
    {
        p_expression_node = logical_or_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        if (ctx->current && ctx->current->type == '?')
        {
            struct expression* _Owner _Opt p_conditional_expression = calloc(1, sizeof(struct expression));
            if (p_conditional_expression == NULL) throw;


            p_conditional_expression->first_token = ctx->current;
            p_conditional_expression->expression_type = CONDITIONAL_EXPRESSION;
            p_conditional_expression->condition_expr = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            parser_match(ctx); //?
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                expression_delete(p_conditional_expression);
                throw;
            }

            bool constant_expression_is_true = false;
            bool has_constant_expression = false;

            if (object_has_constant_value(&p_conditional_expression->condition_expr->object))
            {
                has_constant_expression = true;
                if (object_to_bool(&p_conditional_expression->condition_expr->object))
                {
                    constant_expression_is_true = true;
                }
            }

            const bool old_evaluation_is_disabled = ctx->evaluation_is_disabled;
            ctx->evaluation_is_disabled = has_constant_expression && !constant_expression_is_true;

            struct expression* _Owner _Opt p_left = expression(ctx);

            //restore original state (before throw)
            ctx->evaluation_is_disabled = old_evaluation_is_disabled;


            if (p_left == NULL)
            {
                expression_delete(p_conditional_expression);
                throw;
            }
            p_conditional_expression->left = p_left;


            if (parser_match_tk(ctx, TK_COLON) != 0)
            {
                unexpected_end_of_file(ctx);
                expression_delete(p_conditional_expression);
                throw;
            }

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                expression_delete(p_conditional_expression);
                throw;
            }

            ctx->evaluation_is_disabled = has_constant_expression && constant_expression_is_true;

            struct expression* _Owner _Opt p_right = conditional_expression(ctx);
            //restore original state (before throw)
            ctx->evaluation_is_disabled = old_evaluation_is_disabled;

            if (p_right == NULL)
            {
                expression_delete(p_conditional_expression);
                throw;
            }
            p_conditional_expression->right = p_right;

            if (object_has_constant_value(&p_conditional_expression->condition_expr->object))
            {
                if (object_to_bool(&p_conditional_expression->condition_expr->object))
                {
                    p_conditional_expression->object = object_make_reference(&p_conditional_expression->left->object);
                }
                else
                {
                    p_conditional_expression->object = object_make_reference(&p_conditional_expression->right->object);
                }
            }

            if (expression_is_subjected_to_lvalue_conversion(p_conditional_expression->left))
            {
                left_type = type_lvalue_conversion(&p_conditional_expression->left->type, ctx->options.null_checks_enabled);
            }
            else
            {
                left_type = type_dup(&p_conditional_expression->left->type);
            }

            if (expression_is_subjected_to_lvalue_conversion(p_conditional_expression->right))
            {
                right_type = type_lvalue_conversion(&p_conditional_expression->right->type, ctx->options.null_checks_enabled);
            }
            else
            {
                right_type = type_dup(&p_conditional_expression->right->type);
            }

            /*The first operand shall have scalar type*/
            if (!type_is_scalar(&p_conditional_expression->condition_expr->type))
            {
                compiler_diagnostic(C_ERROR_CONDITION_MUST_HAVE_SCALAR_TYPE, ctx, ctx->current, NULL, "condition must have scalar type");
            }
            else if (type_is_arithmetic(&left_type) &&
                     type_is_arithmetic(&right_type))
            {
                /*
                 *  both operands have arithmetic type;
                */
                type_destroy(&p_conditional_expression->type);
                p_conditional_expression->type = type_common(&left_type, &right_type, ctx->options.target);
            }
            else if (type_is_struct_or_union(&left_type) && type_is_struct_or_union(&right_type))
            {
                /*
                 *  both operands have compatible structure or union type;
                 */
                if (!type_is_same(&left_type, &right_type, true))
                {
                    compiler_diagnostic(C_ERROR_INCOMPATIBLE_TYPES, ctx, p_conditional_expression->condition_expr->first_token, NULL, "incompatible types");
                }
                type_swap(&p_conditional_expression->type, &right_type);
            }
            else if (type_is_void(&left_type) && type_is_void(&right_type))
            {
                /*
                 *  both operands have void type;
                 */
                type_swap(&p_conditional_expression->type, &right_type);
            }
            else if (type_is_nullptr_t(&left_type) && type_is_nullptr_t(&right_type))
            {
                /* both operands have nullptr_t type;*/
                type_swap(&p_conditional_expression->type, &right_type);
            }
            else if (type_is_pointer(&left_type))
            {
                /*
                — one operand is a pointer and the other is a null pointer constant or has type nullptr_t; or
                    — one operand is a pointer to an object type and the other is a pointer to a qualified or unqualified
                    version of void
            */
                if (expression_is_null_pointer_constant(p_conditional_expression->right) ||
                    type_is_nullptr_t(&right_type) ||
                    type_is_void_ptr(&right_type))
                {
                    type_swap(&p_conditional_expression->type, &left_type);
                }
                else if (type_is_pointer(&right_type))
                {
                    if (type_is_nullptr_t(&left_type) || type_is_void_ptr(&left_type))
                    {
                        type_swap(&p_conditional_expression->type, &left_type);
                    }
                    else if (!type_is_same(&left_type, &right_type, false))
                    {
                        // type_print(&left_type);
                        // type_print(&right_type);
                        compiler_diagnostic(C_ERROR_INCOMPATIBLE_TYPES, ctx, ctx->current, NULL, "incompatible types");
                    }
                    else
                    {
                        type_swap(&p_conditional_expression->type, &right_type);
                    }
                }
                else
                {
                    compiler_diagnostic(C_ERROR_INCOMPATIBLE_TYPES, ctx, p_conditional_expression->condition_expr->first_token, NULL, "incompatible types");
                }
            }
            else if (type_is_pointer(&right_type))
            {
                if (expression_is_null_pointer_constant(p_conditional_expression->left) ||
                    type_is_nullptr_t(&left_type) ||
                    type_is_void_ptr(&left_type))
                {
                    type_swap(&p_conditional_expression->type, &right_type);
                }
                else if (type_is_pointer(&left_type))
                {
                    if (type_is_nullptr_t(&left_type) || type_is_void_ptr(&left_type))
                    {
                        type_swap(&p_conditional_expression->type, &right_type);
                    }
                    else if (!type_is_same(&left_type, &right_type, false))
                    {
                        compiler_diagnostic(C_ERROR_INCOMPATIBLE_TYPES, ctx, p_conditional_expression->condition_expr->first_token, NULL, "incompatible types");
                    }
                    else
                    {
                        type_swap(&p_conditional_expression->type, &right_type);
                    }
                }
                else
                {
                    compiler_diagnostic(C_ERROR_INCOMPATIBLE_TYPES, ctx, p_conditional_expression->condition_expr->first_token, NULL, "incompatible types");
                }
            }
            else
            {
                compiler_diagnostic(C_ERROR_INCOMPATIBLE_TYPES, ctx, p_conditional_expression->condition_expr->first_token, NULL, "incompatible types??");
                assert(false);
            }
            p_expression_node = p_conditional_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    type_destroy(&left_type);
    type_destroy(&right_type);

    return p_expression_node;
}

struct expression* _Owner _Opt constant_expression(struct parser_ctx* ctx, bool show_error_if_not_constant)
{
    struct expression* _Owner _Opt p_expression = conditional_expression(ctx);

    if (show_error_if_not_constant &&
        p_expression &&
        !object_has_constant_value(&p_expression->object))
    {
        compiler_diagnostic(C_ERROR_EXPECTED_CONSTANT_EXPRESSION, ctx, ctx->current, NULL, "expected constant expression");
    }

    return p_expression;
}

bool expression_get_variables(const struct expression* expr, int n, struct object* variables[/*n*/])
{
    int count = 0;
    switch (expr->expression_type)
    {

    case EXPRESSION_TYPE_INVALID:  break;

    case PRIMARY_EXPRESSION_ENUMERATOR:  break;
    case PRIMARY_EXPRESSION_DECLARATOR:
        if (!object_has_constant_value(&expr->object))
        {
            if (count < n)
            {
                variables[count] = object_get_non_const_referenced(&expr->object);
                count++;
            }

        }
        break;

    case PRIMARY_EXPRESSION_STRING_LITERAL:  break;
    case PRIMARY_EXPRESSION__FUNC__:  break; /*predefined identifier __func__ */
    case PRIMARY_EXPRESSION_CHAR_LITERAL:  break;
    case PRIMARY_EXPRESSION_PREDEFINED_CONSTANT:  break; /*true false*/
    case PRIMARY_EXPRESSION_GENERIC:  break;
    case PRIMARY_EXPRESSION_NUMBER:  break;

    case PRIMARY_EXPRESSION_PARENTESIS:
        count += expression_get_variables(expr->right, n, variables);
        break;

    case POSTFIX_EXPRESSION_FUNCTION_LITERAL:  break;
    case POSTFIX_EXPRESSION_COMPOUND_LITERAL:  break;

    case POSTFIX_FUNCTION_CALL:  break; // ( ) 
    case POSTFIX_ARRAY:  break; // [ ]
    case POSTFIX_DOT:  break; // .
    case POSTFIX_ARROW:  break; // .
    case POSTFIX_INCREMENT:  break;
    case POSTFIX_DECREMENT:  break;


    case UNARY_EXPRESSION_SIZEOF_EXPRESSION:  break;
    case UNARY_EXPRESSION_SIZEOF_TYPE:  break;
    case UNARY_EXPRESSION_COUNTOF:  break;

    case UNARY_EXPRESSION_TRAITS:  break;
    case UNARY_EXPRESSION_IS_SAME:  break;
    case UNARY_DECLARATOR_ATTRIBUTE_EXPR:  break;

    case UNARY_EXPRESSION_ALIGNOF_TYPE:  break;
    case UNARY_EXPRESSION_ALIGNOF_EXPRESSION:  break;

    case UNARY_EXPRESSION_ASSERT:  break;

    case UNARY_EXPRESSION_INCREMENT:  break;
    case UNARY_EXPRESSION_DECREMENT:  break;

    case UNARY_EXPRESSION_NOT:  break;
    case UNARY_EXPRESSION_BITNOT:  break;
    case UNARY_EXPRESSION_NEG:  break;
    case UNARY_EXPRESSION_PLUS:  break;
    case UNARY_EXPRESSION_CONTENT:  break;
    case UNARY_EXPRESSION_ADDRESSOF:  break;

    case CAST_EXPRESSION:  break;

    case MULTIPLICATIVE_EXPRESSION_MULT:
    case MULTIPLICATIVE_EXPRESSION_DIV:
    case MULTIPLICATIVE_EXPRESSION_MOD:
        count += expression_get_variables(expr->left, n, variables);
        count += expression_get_variables(expr->right, n, variables);
        break;

    case ADDITIVE_EXPRESSION_PLUS:
    case ADDITIVE_EXPRESSION_MINUS:
        count += expression_get_variables(expr->left, n, variables);
        count += expression_get_variables(expr->right, n, variables);
        break;


    case SHIFT_EXPRESSION_RIGHT:
    case SHIFT_EXPRESSION_LEFT:

    case RELATIONAL_EXPRESSION_BIGGER_THAN:
    case RELATIONAL_EXPRESSION_LESS_THAN:
    case RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN:
    case RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN:
    case EQUALITY_EXPRESSION_EQUAL:
    case EQUALITY_EXPRESSION_NOT_EQUAL:
        count += expression_get_variables(expr->left, n, variables);
        count += expression_get_variables(expr->right, n, variables);
        break;

    case AND_EXPRESSION:  break;
    case EXCLUSIVE_OR_EXPRESSION:  break;
    case INCLUSIVE_OR_EXPRESSION:  break;

    case LOGICAL_OR_EXPRESSION:
    case LOGICAL_AND_EXPRESSION:
        count += expression_get_variables(expr->left, n, variables);
        count += expression_get_variables(expr->right, n, variables);
        break; //&&

    case ASSIGNMENT_EXPRESSION_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_PLUS_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_MINUS_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_MULTI_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_DIV_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_MOD_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_SHIFT_LEFT_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_SHIFT_RIGHT_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_AND_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_OR_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_NOT_ASSIGN:  break;


    case EXPRESSION_EXPRESSION:  break;

    case CONDITIONAL_EXPRESSION:  break;
    }
    return count;
}

bool expression_is_lvalue(const struct expression* expr)
{
    // https://en.cppreference.com/w/c/language/value_category

    switch (expr->expression_type)
    {
    case PRIMARY_EXPRESSION_DECLARATOR:
    case PRIMARY_EXPRESSION__FUNC__:
    case PRIMARY_EXPRESSION_STRING_LITERAL:
    case POSTFIX_ARRAY:
    case POSTFIX_ARROW:
    case POSTFIX_EXPRESSION_COMPOUND_LITERAL:
    case UNARY_EXPRESSION_CONTENT:
        return true;
    default:
        break;
    }

    if (expr->expression_type == PRIMARY_EXPRESSION_PARENTESIS &&
        expr->right)
    {
        return expression_is_lvalue(expr->right);
    }
    else if (expr->expression_type == POSTFIX_DOT &&
             expr->left)
    {
        return expression_is_lvalue(expr->left);
    }

    return false;
}


/*
 * Returns true if the type of expression is subjected to type_lvalue_conversion
 */
bool expression_is_subjected_to_lvalue_conversion(const struct expression* expression)
{

    switch (expression->expression_type)
    {
    case UNARY_EXPRESSION_ADDRESSOF:
    case UNARY_EXPRESSION_INCREMENT:
    case UNARY_EXPRESSION_DECREMENT:
    case POSTFIX_INCREMENT:
    case POSTFIX_DECREMENT:
        return false;
    default:
        if (expression->type.storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
            return true;
    }

    return true;
}

void check_comparison(struct parser_ctx* ctx,
    struct expression* p_a_expression,
    struct expression* p_b_expression,
    const struct token* op_token)
{
    //TODO more checks unsigned < 0

    struct type* p_a_type = &p_a_expression->type;
    struct type* p_b_type = &p_b_expression->type;

    if (type_is_pointer(p_a_type) && type_is_integer(p_b_type))
    {
        if (expression_is_zero(p_b_expression))
        {
            // p == 0
            //style warning
        }
        else
        {
            //array functions..
            compiler_diagnostic(W_ENUN_CONVERSION,
                                        ctx,
                                        op_token, NULL,
                                        "comparison between pointer and integer");
        }
    }

    check_diferent_enuns(ctx,
                         op_token,
                         p_a_expression,
                         p_b_expression,
                         "comparing different enums.");
}

void check_assigment(struct parser_ctx* ctx,
    const struct type* p_a_type, /*this is not expression because function parameters*/
    const struct expression* p_b_expression,
    enum assigment_type assignment_type)
{
    const struct type* const p_b_type = &p_b_expression->type;

    const bool is_null_pointer_constant = expression_is_null_pointer_constant(p_b_expression);

    if (type_is_pointer(p_a_type))
    {
        if (!type_is_nullptr_t(p_b_type) &&
            !type_is_pointer_or_array(p_b_type) &&
            !type_is_function(p_b_type))
        {
            if (is_null_pointer_constant)
            {
                if (p_b_expression->expression_type == PRIMARY_EXPRESSION_NUMBER)
                {
                    // This is the only exception.
                    // p = 0;
                    compiler_diagnostic(W_STYLE, ctx, p_b_expression->first_token, NULL, "use NULL instead of 0");
                }
                else
                {
                    //Everything else is unusual
                    // p = false;
                    // p = 1-1;
                    // p = '\0';
                    compiler_diagnostic(W_UNSUAL_NULL_POINTER_CONSTANT, ctx, p_b_expression->first_token, NULL, "unusual expression/type used as null pointer constant");
                }
            }
            else
            {
                compiler_diagnostic(C_ERROR_INT_TO_POINTER, ctx, p_b_expression->first_token, NULL, "non-pointer to pointer");
            }
        }
    }

    if (type_is_bool(p_a_type) && type_is_nullptr_t(p_b_type))
    {
        struct marker marker = {
        .p_token_begin = p_b_expression->first_token,
        .p_token_end = p_b_expression->first_token
        };

        compiler_diagnostic(W_NULL_CONVERTION,
        ctx,
        NULL,
        &marker,
        "implicit conversion of nullptr constant to 'bool'");
    }

    struct type b_type_lvalue = { 0 };

    if (expression_is_subjected_to_lvalue_conversion(p_b_expression))
    {
        b_type_lvalue = type_lvalue_conversion(p_b_type, ctx->options.null_checks_enabled);
    }
    else
    {
        b_type_lvalue = type_dup(p_b_type);
    }


    if (type_is_owner(p_a_type) && !type_is_owner(&p_b_expression->type))
    {
        if (!is_null_pointer_constant)
        {
            compiler_diagnostic(W_OWNERSHIP_NON_OWNER_TO_OWNER_ASSIGN, ctx, p_b_expression->first_token, NULL, "cannot assign a non-owner to owner");
            type_destroy(&b_type_lvalue);
            //type_destroy(&t2);
            return;
        }
    }

    if (!type_is_owner(p_a_type) && type_is_owner_or_pointer_to_dtor(&p_b_expression->type))
    {
        if (p_b_expression->type.storage_class_specifier_flags & STORAGE_SPECIFIER_FUNCTION_RETURN)
        {
            compiler_diagnostic(W_OWNERSHIP_USING_TEMPORARY_OWNER,
                ctx,
                p_b_expression->first_token, NULL,
                "cannot assign a temporary owner to non-owner object.");
            type_destroy(&b_type_lvalue);
            //type_destroy(&t2);
            return;
        }
    }

    if (assignment_type == ASSIGMENT_TYPE_RETURN)
    {
        if (!type_is_owner(p_a_type) && type_is_owner_or_pointer_to_dtor(&p_b_expression->type))
        {
            if (is_automatic_variable(p_b_expression->type.storage_class_specifier_flags))
            {
                compiler_diagnostic(C_ERROR_RETURN_LOCAL_OWNER_TO_NON_OWNER,
                    ctx,
                    p_b_expression->first_token, NULL,
                    "cannot return a automatic storage duration _Owner to non-owner");
                type_destroy(&b_type_lvalue);
                // type_destroy(&t2);
                return;
            }
        }
    }
#if 1
    /*
    TODO REMOVE THiS
    #pragma safety enable

      #include <stdlib.h>

      struct X {
       struct Y * _Owner p;
      };

      void x_destroy(_Dtor struct X * p);

      void f(struct X * x) {
        x_destroy(x);
        static_debug(*x);
      }
    */
    if (type_is_pointed_dtor(p_a_type) && type_is_pointer(p_a_type))
    {
        if (type_is_owner(p_b_type))
        {
        }
        else if (!p_b_type->address_of)
        {
            compiler_diagnostic(W_MUST_USE_ADDRESSOF,
                       ctx,
                       p_b_expression->first_token, NULL,
                       "source expression of _Dtor must be addressof");
        }
    }
#endif


    if (type_is_pointer(p_a_type) &&
        !type_is_opt(p_a_type, ctx->options.null_checks_enabled) &&
        is_null_pointer_constant)
    {

        compiler_diagnostic(W_FLOW_NULLABLE_TO_NON_NULLABLE,
            ctx,
            p_b_expression->first_token, NULL,
            "cannot convert a null pointer constant to non-nullable pointer");

        type_destroy(&b_type_lvalue);
        //type_destroy(&t2);

        return;

    }



    /*
       less generic tests are first
    */
    if (type_is_enum(p_b_type) && type_is_enum(p_a_type))
    {
        if (!type_is_same(p_b_type, p_a_type, false))
        {
            compiler_diagnostic(W_INCOMPATIBLE_ENUN_TYPES, ctx,
                p_b_expression->first_token, NULL,
                " incompatible types ");
        }


        type_destroy(&b_type_lvalue);
        // type_destroy(&t2);
        return;
    }

    if (type_is_arithmetic(p_b_type) && type_is_arithmetic(p_a_type))
    {

        type_destroy(&b_type_lvalue);
        //type_destroy(&t2);
        return;
    }

    if (is_null_pointer_constant && type_is_pointer(p_a_type))
    {
        //TODO void F(int * [[_Opt]] p)
        // F(0) when passing null we will check if the parameter
        //have the anotation [[_Opt]]

        /*can be converted to any type*/

        type_destroy(&b_type_lvalue);
        //type_destroy(&t2);
        return;
    }

    if (is_null_pointer_constant && type_is_array(p_a_type))
    {
        compiler_diagnostic(W_FLOW_NON_NULL,
            ctx,
            p_b_expression->first_token, NULL,
            " passing null as array");


        type_destroy(&b_type_lvalue);
        //type_destroy(&t2);
        return;
    }

    /*
       We have two pointers or pointer/array combination
    */
    if (type_is_pointer_or_array(p_b_type) && type_is_pointer_or_array(p_a_type))
    {
        if (type_is_void_ptr(p_b_type))
        {
            /*void pointer can be converted to any type*/

            type_destroy(&b_type_lvalue);
            //type_destroy(&t2);
            return;
        }

        if (type_is_void_ptr(p_a_type))
        {
            /*any pointer can be converted to void* */

            type_destroy(&b_type_lvalue);
            // type_destroy(&t2);
            return;
        }


        //TODO  lvalue

        struct type a_type_lvalue = { 0 };

        if (type_is_array(p_a_type))
        {
            if (assignment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                size_t parameter_array_size = p_a_type->num_of_elements;
                if (type_is_array(p_b_type))
                {
                    size_t argument_array_size = p_b_type->num_of_elements;
                    if (parameter_array_size != 0 &&
                        argument_array_size < parameter_array_size)
                    {
                        compiler_diagnostic(C_ERROR_ARGUMENT_SIZE_SMALLER_THAN_PARAMETER_SIZE, ctx,
                            p_b_expression->first_token, NULL,
                            " argument of size [%d] is smaller than parameter of size [%d]", argument_array_size, parameter_array_size);
                    }
                }
                else if (is_null_pointer_constant || type_is_nullptr_t(p_b_type))
                {
                    compiler_diagnostic(W_PASSING_NULL_AS_ARRAY, ctx,
                        p_b_expression->first_token, NULL,
                        " passing null as array");
                }
            }
            a_type_lvalue = type_lvalue_conversion(p_a_type, ctx->options.null_checks_enabled);
        }
        else
        {
            a_type_lvalue = type_dup(p_a_type);
        }



        if (!type_is_same(&b_type_lvalue, &a_type_lvalue, false))
        {
            type_print(&b_type_lvalue, ctx->options.target);
            type_print(&a_type_lvalue, ctx->options.target);

            compiler_diagnostic(W_ERROR_INCOMPATIBLE_TYPES, ctx,
                p_b_expression->first_token, NULL,
                " incompatible types");
        }


        if (assignment_type == ASSIGMENT_TYPE_PARAMETER)
        {
            if (type_is_pointer(&b_type_lvalue) && type_is_pointer(&a_type_lvalue))
            {
                //parameter pointer do non const
                //argument const.
                struct type b_pointed_type_lvalue = type_remove_pointer(&b_type_lvalue);
                struct type a_lvalue_pointed_type = type_remove_pointer(&a_type_lvalue);
                if (type_is_const(&b_pointed_type_lvalue) && !type_is_const(&a_lvalue_pointed_type))
                {
                    compiler_diagnostic(W_DISCARDED_QUALIFIERS, ctx,
                        p_b_expression->first_token, NULL,
                        " discarding const at argument ");
                }
                type_destroy(&b_pointed_type_lvalue);
                type_destroy(&a_lvalue_pointed_type);
            }
        }
        else
        {
            if (type_is_pointer(p_a_type) && type_is_pointer(&b_type_lvalue))
            {
                struct type b_pointed_type = type_remove_pointer(&b_type_lvalue);
                struct type a_pointed_type = type_remove_pointer(p_a_type);
                if (type_is_const(&b_pointed_type) && !type_is_const(&a_pointed_type))
                {
                    compiler_diagnostic(W_DISCARDED_QUALIFIERS, ctx,
                        p_b_expression->first_token, NULL,
                        " discarding const");
                }
                type_destroy(&b_pointed_type);
                type_destroy(&a_pointed_type);
            }
        }

        //return true;
        type_destroy(&a_type_lvalue);
    }

    if (!type_is_same(p_a_type, &b_type_lvalue, false))
    {
        // compiler_diagnostic(C_ERROR_INCOMPATIBLE_TYPES,
        //     ctx,
        //       p_b_expression->first_token, 
        //       NULL,
        //       " incompatible types ");
    }


    type_destroy(&b_type_lvalue);


}

struct object expression_eval(struct expression* p_expression) //used by flow II
{
    struct object result = { 0 };

    switch (p_expression->expression_type)
    {
    case EXPRESSION_TYPE_INVALID: break;

    case PRIMARY_EXPRESSION_ENUMERATOR:
    case PRIMARY_EXPRESSION_DECLARATOR:
        result = object_dup(&p_expression->object);
        break;

    case PRIMARY_EXPRESSION_STRING_LITERAL:  break;
    case PRIMARY_EXPRESSION__FUNC__:  break; /*predefined identifier __func__ */

    case PRIMARY_EXPRESSION_CHAR_LITERAL:
    case PRIMARY_EXPRESSION_PREDEFINED_CONSTANT:
        result = object_dup(&p_expression->object);
        break;

    case PRIMARY_EXPRESSION_GENERIC:  break;
    case PRIMARY_EXPRESSION_NUMBER:
        result = object_dup(&p_expression->object);
        break;


    case PRIMARY_EXPRESSION_PARENTESIS:
        result = expression_eval(p_expression->right);
        break;

    case POSTFIX_EXPRESSION_FUNCTION_LITERAL:  break;
    case POSTFIX_EXPRESSION_COMPOUND_LITERAL:  break;

    case POSTFIX_FUNCTION_CALL:  break; // ( ) 
    case POSTFIX_ARRAY:  break; // [ ]
    case POSTFIX_DOT:  break; // .
    case POSTFIX_ARROW:  break; // .
    case POSTFIX_INCREMENT:  break;
    case POSTFIX_DECREMENT:  break;


    case UNARY_EXPRESSION_SIZEOF_EXPRESSION:  break;
    case UNARY_EXPRESSION_SIZEOF_TYPE:  break;
    case UNARY_EXPRESSION_COUNTOF:  break;

    case UNARY_EXPRESSION_TRAITS:  break;
    case UNARY_EXPRESSION_IS_SAME:  break;
    case UNARY_DECLARATOR_ATTRIBUTE_EXPR:  break;
    case UNARY_EXPRESSION_ALIGNOF_TYPE:  break;
    case UNARY_EXPRESSION_ALIGNOF_EXPRESSION:  break;
    case UNARY_EXPRESSION_ASSERT:  break;

    case UNARY_EXPRESSION_INCREMENT:  break;
    case UNARY_EXPRESSION_DECREMENT:  break;

    case UNARY_EXPRESSION_NOT:  break;
    case UNARY_EXPRESSION_BITNOT:  break;
    case UNARY_EXPRESSION_NEG:  break;
    case UNARY_EXPRESSION_PLUS:  break;
    case UNARY_EXPRESSION_CONTENT:  break;
    case UNARY_EXPRESSION_ADDRESSOF:  break;

    case CAST_EXPRESSION:  break;

    case MULTIPLICATIVE_EXPRESSION_MULT:  break;
    case MULTIPLICATIVE_EXPRESSION_DIV:  break;
    case MULTIPLICATIVE_EXPRESSION_MOD:  break;

    case ADDITIVE_EXPRESSION_PLUS:
    {
        struct object a = expression_eval(p_expression->left);
        if (object_has_constant_value(&a))
        {
            struct object b = expression_eval(p_expression->right);
            if (object_has_constant_value(&b))
            {
                result = object_add(&a, &b);
            }
            object_destroy(&b);
        }
        object_destroy(&a);
    }
    break;
    case ADDITIVE_EXPRESSION_MINUS:
    {
        struct object a = expression_eval(p_expression->left);
        if (object_has_constant_value(&a))
        {
            struct object b = expression_eval(p_expression->right);
            if (object_has_constant_value(&b))
            {
                result = object_sub(&a, &b);
            }
            object_destroy(&b);
        }
        object_destroy(&a);
    }
    break;

    case SHIFT_EXPRESSION_RIGHT:  break;
    case SHIFT_EXPRESSION_LEFT:  break;

    case RELATIONAL_EXPRESSION_BIGGER_THAN:  break;
    case RELATIONAL_EXPRESSION_LESS_THAN:  break;
    case RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN:  break;
    case RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN:  break;

    case EQUALITY_EXPRESSION_EQUAL:
        if (object_equal(&p_expression->left->object, &p_expression->right->object))
        {
            result = object_make_signed_int(1);
        }
        else
        {
            result = object_make_signed_int(0);
        }
        break;


    case EQUALITY_EXPRESSION_NOT_EQUAL:
        if (object_not_equal(&p_expression->left->object, &p_expression->right->object))
        {
            result = object_make_signed_int(1);
        }
        else
        {
            result = object_make_signed_int(0);
        }
        break;


    case AND_EXPRESSION:  break;
    case EXCLUSIVE_OR_EXPRESSION:  break;
    case INCLUSIVE_OR_EXPRESSION:  break;

    case LOGICAL_OR_EXPRESSION:
    {
        struct object a = expression_eval(p_expression->left);
        if (object_has_constant_value(&a))
        {
            bool r1 = object_to_bool(&a);
            if (r1)
            {
                result = object_make_signed_int(1);
            }
            else
            {
                struct object b = expression_eval(p_expression->right);
                if (object_has_constant_value(&b))
                {
                    bool r2 = object_to_bool(&b);
                    if (r2)
                    {
                        result = object_make_signed_int(r2);
                    }
                }
                object_destroy(&b);
            }
        }
        object_destroy(&a);
    }
    break;  //||

    case LOGICAL_AND_EXPRESSION:  break; //&&

    case ASSIGNMENT_EXPRESSION_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_PLUS_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_MINUS_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_MULTI_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_DIV_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_MOD_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_SHIFT_LEFT_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_SHIFT_RIGHT_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_AND_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_OR_ASSIGN:  break;
    case ASSIGNMENT_EXPRESSION_NOT_ASSIGN:  break;


    case EXPRESSION_EXPRESSION:  break;

    case CONDITIONAL_EXPRESSION:  break;

    }
    return result;
}

/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

#pragma safety enable

/*
  For performance reasons we will separate expression from preprocessor from compiler.
*/



#include <locale.h>

#ifdef _WIN32
#endif

#if defined _MSC_VER && !defined __POCC__
#endif

/*context expressions preprocessor*/
struct pre_expression_ctx
{
    /*all preprocessor expressions are calculated with long long*/
    long long value;
};

static void pre_postfix_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_cast_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_multiplicative_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_unary_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_additive_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_shift_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_relational_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_equality_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_and_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_exclusive_or_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_inclusive_or_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_logical_and_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_logical_or_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_conditional_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_conditional_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);

//TODO share this with parser!
/*
 * preprocessor uses long long
 */
static int ppnumber_to_longlong(struct preprocessor_ctx* ctx, struct token* token, long long* result)
{
    /*copy removing the separators*/
    // um dos maiores buffer necessarios seria 128 bits binario...
    // 0xb1'1'1....
    int c = 0;
    char buffer[128 * 2 + 4] = { 0 };
    const char* s = token->lexeme;
    while (*s)
    {
        if (*s != '\'')
        {
            buffer[c] = *s;
            c++;
        }
        s++;
    }

    char errormsg[100];
    char suffix[4] = { 0 };
    const enum token_type type = parse_number(token->lexeme, suffix, errormsg);
    if (type == TK_NONE)
    {
        preprocessor_diagnostic(
            C_INVALID_TOKEN,
            ctx,
            token,
            "%s",
            errormsg);
        return 0;
    }
    struct object  cv = { 0 };
    switch (type)
    {
    case TK_COMPILER_DECIMAL_CONSTANT:
    case TK_COMPILER_OCTAL_CONSTANT:
    case TK_COMPILER_HEXADECIMAL_CONSTANT:
    case TK_COMPILER_BINARY_CONSTANT:
    {
        unsigned long long value = 0;
        switch (type)
        {
        case TK_COMPILER_DECIMAL_CONSTANT:
            value = strtoull(buffer, NULL, 10);
            break;
        case TK_COMPILER_OCTAL_CONSTANT:
            value = strtoull(buffer + 1, NULL, 8);
            break;
        case TK_COMPILER_HEXADECIMAL_CONSTANT:
            value = strtoull(buffer + 2, NULL, 16);
            break;
        case TK_COMPILER_BINARY_CONSTANT:
            value = strtoull(buffer + 2, NULL, 2);
            break;
        default:
            break;
        }

        if (value == ULLONG_MAX && errno == ERANGE)
        {
            //compiler_diagnostic(
            //C_ERROR_LITERAL_OVERFLOW,
            //ctx,
            //token,
            //NULL,
            //"integer literal is too large to be represented in any integer type");
        }

        if (suffix[0] == 'U')
        {
            /*fixing the type that fits the size*/
            if (value <= UINT_MAX && suffix[1] != 'L')
            {
                cv = object_make_unsigned_int((unsigned int)value);

            }
            else if (value <= ULONG_MAX && suffix[2] != 'L')
            {
                cv = object_make_unsigned_long((unsigned long)value);
            }
            else //if (value <= ULLONG_MAX)
            {
                cv = object_make_unsigned_long_long((unsigned long long)value);
            }
        }
        else
        {
            /*fixing the type that fits the size*/
            if (value <= INT_MAX && suffix[0] != 'L')
            {
                cv = object_make_signed_int((int)value);
            }
            else if (value <= LONG_MAX && suffix[1] != 'L' /*!= LL*/)
            {
                cv = object_make_signed_long((long)value);
            }
            else if (value <= LLONG_MAX)
            {
                cv = object_make_signed_long_long((long long)value);
            }
            else
            {
                cv = object_make_signed_long_long(value);
            }
        }

    }
    break;

    case TK_COMPILER_DECIMAL_FLOATING_CONSTANT:
    case TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT:
        //error
        break;

    default:
        assert(false);
    }

    *result = object_to_signed_long_long(&cv);

    return 0;
}

/*
  ctx->current and pre_match are used only in preprocessor constant expressions
  (the preprocessor itself uses concept of removing from one list and adding
  into another so the head of the input list is the current.
  We could use the same concept here removing current.
*/
static struct token* _Opt pre_match(struct preprocessor_ctx* ctx)
{
    if (ctx->current == NULL)
        return NULL;

    ctx->current = ctx->current->next;

    while (ctx->current && token_is_blank(ctx->current))
    {
        ctx->current = ctx->current->next;
    }

    return ctx->current;
}

//TODO share this with parser
static struct object char_constant_to_value(const char* s, char error_message[/*sz*/], int error_message_sz_bytes)
{
    error_message[0] = '\0';

    const unsigned char* _Opt p = (const unsigned char*)s;

    try
    {
        if (p[0] == 'u' && p[1] == '8')
        {
            p++;
            p++;
            p++;

            // A UTF-8 character constant has type char8_t.

            unsigned int c = 0;
            p = utf8_decode(p, &c);
            if (p == NULL)
            {
                throw;
            }

            if (c == '\\')
            {
                p = escape_sequences_decode_opt(p, &c);
                if (p == NULL)
                {
                    throw;
                }
            }

            if (*p != '\'')
            {
                snprintf(error_message, error_message_sz_bytes, "Unicode character literals may not contain multiple characters.");
            }

            if (c > 0x80)
            {
                snprintf(error_message, error_message_sz_bytes, "Character too large for enclosing character literal type.");
            }

            return object_make_wchar_t((wchar_t)c);//, ctx->evaluation_is_disabled);
        }
        else if (p[0] == 'u')
        {
            p++;
            p++;

            // A UTF-16 character constant has type char16_t which is an unsigned integer types defined in the <uchar.h> header

            unsigned int c = 0;
            p = utf8_decode(p, &c);
            if (p == NULL)
            {
                throw;
            }

            if (c == '\\')
            {
                p = escape_sequences_decode_opt(p, &c);
                if (p == NULL)
                {
                    throw;
                }
            }

            if (*p != '\'')
            {
                snprintf(error_message, error_message_sz_bytes, "Unicode character literals may not contain multiple characters.");
            }

            if (c > USHRT_MAX)
            {
                snprintf(error_message, error_message_sz_bytes, "Character too large for enclosing character literal type.");
            }

            return object_make_wchar_t((wchar_t)c);
        }
        else if (p[0] == 'U')
        {
            p++;
            p++;

            // A UTF-16 character constant has type char16_t which is an unsigned integer types defined in the <uchar.h> header

            unsigned int c = 0;
            p = utf8_decode(p, &c);
            if (p == NULL)
            {
                throw;
            }

            if (c == '\\')
            {
                p = escape_sequences_decode_opt(p, &c);

                if (p == NULL)
                {
                    throw;
                }
            }

            if (*p != '\'')
            {
                snprintf(error_message, error_message_sz_bytes, "Unicode character literals may not contain multiple characters.");
            }

            if (c > UINT_MAX)
            {
                snprintf(error_message, error_message_sz_bytes, "Character too large for enclosing character literal type.");
            }

            return object_make_wchar_t((wchar_t)c);
        }
        else if (p[0] == 'L')
        {
            // A wchar_t character constant is prefixed by the letter L
            p++;
            p++;

            /*
             wchar_t character constant prefixed by the letter L has type wchar_t, an integer type defined in
             the <stddef.h> header. The value of a wchar_t character constant containing a single multibyte
             character that maps to a single member of the extended execution character set is the wide character
             corresponding to that multibyte character in the implementation-defined wide literal encoding
             (6.2.9). The value of a wchar_t character constant containing more than one multibyte character or a
             single multibyte character that maps to multiple members of the extended execution character set,
             or containing a multibyte character or escape sequence not represented in the extended execution
             character set, is implementation-defined.
            */
            long long value = 0;
            while (*p != '\'')
            {
                unsigned int c = 0;
                p = utf8_decode(p, &c);
                if (p == NULL)
                {
                    throw;
                }
                if (c == '\\')
                {
                    p = escape_sequences_decode_opt(p, &c);
                    if (p == NULL)
                        throw;
                }
       
                // TODO \u
                value = value * 256 + c;
#ifdef _WIN32
                if (value > USHRT_MAX)
                {
                    snprintf(error_message, error_message_sz_bytes, "character constant too long for its type");
                    break;
                }
#else
                if (value > UINT_MAX)
                {
                    snprintf(error_message, error_message_sz_bytes, "character constant too long for its type");
                    break;
                }
#endif
            }

            return object_make_wchar_t((wchar_t)value);
        }
        else
        {
            p++;

            /*
              An integer character constant has type int. The value of an integer character constant containing
              a single character that maps to a single value in the literal encoding (6.2.9) is the numerical value
              of the representation of the mapped character in the literal encoding interpreted as an integer.
              The value of an integer character constant containing more than one character (e.g., ’ab’), or
              containing a character or escape sequence that does not map to a single value in the literal encoding,
              is implementation-defined. If an integer character constant contains a single character or escape
              sequence, its value is the one that results when an object with type char whose value is that of the
              single character or escape sequence is converted to type int.
            */
            long long value = 0;
            while (*p != '\'')
            {
                unsigned int c = 0;
                p = utf8_decode(p, &c);
                if (p == NULL)
                {
                    throw;
                }

                if (c == '\\')
                {
                    p = escape_sequences_decode_opt(p, &c);
                    if (p == NULL)
                        throw;
                }


                if (c < 0x80)
                {
                    value = value * 256 + c;
                }
                else
                {
                    value = c;
                }
                if (value > INT_MAX)
                {
                    snprintf(error_message, error_message_sz_bytes, "character constant too long for its type");
                    break;
                }
            }
            return object_make_wchar_t((wchar_t)value);
        }
    }
    catch
    {
    }

    struct object empty = { 0 };
    return empty;
}

static void pre_primary_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     primary-expression:
      identifier
      constant
      string-literal
      ( expression )
      generic-selection
    */
    try
    {
        if (ctx->current == NULL)
        {
            pre_unexpected_end_of_file(ctx->input_list.tail, ctx);
            throw;
        }

        if (ctx->current->type == TK_CHAR_CONSTANT)
        {
            const char* p = ctx->current->lexeme + 1;
            char errmsg[200] = { 0 };
            struct object v = char_constant_to_value(p, errmsg, sizeof errmsg);
            if (errmsg[0] != '\0')
            {
                preprocessor_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, "%s", errmsg);
            }
            ectx->value = object_to_signed_long_long(&v);
            pre_match(ctx);
            object_destroy(&v);
        }
        else if (ctx->current->type == TK_PPNUMBER)
        {
            ppnumber_to_longlong(ctx, ctx->current, &ectx->value);
            pre_match(ctx);
        }        
        else if (ctx->current->type == '(')
        {
            pre_match(ctx);
            pre_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;
            if (ctx->current && ctx->current->type != ')')
            {
                preprocessor_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, "expected )");
                throw;
            }
            pre_match(ctx);
        }
        else
        {
            preprocessor_diagnostic(C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS,
                                              ctx,
                                              ctx->current,
                                              "token '%s' is not valid in preprocessor expressions",
                                              ctx->current->lexeme);
            throw;
        }
    }
    catch
    {
    }
}

static void pre_postfix_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
      postfix-expression:
        primary-expression
        postfix-expression [ expression ]
        postfix-expression ( argument-expression-list_opt)
        postfix-expression . identifier
        postfix-expression -> identifier
        postfix-expression ++
        postfix-expression --
        ( type-name ) { initializer-ctx }
        ( type-name ) { initializer-ctx , }

        //My extension : if type-name is function then follow is compound-statement
        ( type-name ) compound-statement

        */
    try
    {
        pre_primary_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;
    }
    catch
    {
    }
}

static void pre_unary_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
    unary-expression:
      postfix-expression
      ++ unary-expression
      -- unary-expression

      one of (& * + - ~ !) cast-expression

      sizeof unary-expression
      sizeof ( type-name )
      _Alignof ( type-name )
      */
    try
    {
        if (ctx->current && (ctx->current->type == '++' || ctx->current->type == '--'))
        {
            preprocessor_diagnostic(C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS,
                                              ctx,
                                              ctx->current,
                                              "token '%s' is not valid in preprocessor expressions",
                                              ctx->current->lexeme);
            throw;
        }
        else if (ctx->current != NULL &&
                 (ctx->current->type == '&' || ctx->current->type == '*' || ctx->current->type == '+' || ctx->current->type == '-' || ctx->current->type == '~' || ctx->current->type == '!'))
        {
            const struct token* const p_old = ctx->current;
            enum token_type op = ctx->current->type;
            pre_match(ctx);
            pre_cast_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            if (op == '!')
                ectx->value = !ectx->value;
            else if (op == '~')
                ectx->value = ~ectx->value;
            else if (op == '-')
                ectx->value = -ectx->value;
            else if (op == '+')
                ectx->value = +ectx->value;
            else if (op == '*')
            {
                preprocessor_diagnostic(C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS, ctx, p_old, "token '%s' is not valid in preprocessor expressions", p_old->lexeme);
            }
            else if (op == '&')
            {
                preprocessor_diagnostic(C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS, ctx, p_old, "token '%s' is not valid in preprocessor expressions", p_old->lexeme);
            }
            else
            {
                preprocessor_diagnostic(C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS, ctx, p_old, "token '%s' is not valid in preprocessor expressions", p_old->lexeme);
            }
        }
        else
        {
            pre_postfix_expression(ctx, ectx);
        }
    }
    catch
    {
    }
}

static void pre_cast_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     cast-expression:
      unary-expression
      ( type-name ) cast-expression
    */
    pre_unary_expression(ctx, ectx);
}

static void pre_multiplicative_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     multiplicative-expression:
    cast-expression
    multiplicative-expression * cast-expression
    multiplicative-expression / cast-expression
    multiplicative-expression % cast-expression
    */
    try
    {
        pre_cast_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '*' ||
                   ctx->current->type == '/' ||
                   ctx->current->type == '%'))
        {
            struct token* op_token = ctx->current;
            enum token_type op = ctx->current->type;
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_cast_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            if (op == '*')
            {
                ectx->value = (left_value * ectx->value);
            }
            else if (op == '/')
            {
                if (ectx->value == 0)
                {
                    preprocessor_diagnostic(C_PRE_DIVISION_BY_ZERO, ctx, op_token, "division by zero");
                    throw;
                }
                else
                {
                    ectx->value = (left_value / ectx->value);
                }
            }
            else if (op == '%')
            {
                ectx->value = (left_value % ectx->value);
            }
        }
    }
    catch
    {
    }
}

static void pre_additive_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     additive-expression:
       multiplicative-expression
       additive-expression + multiplicative-expression
       additive-expression - multiplicative-expression
    */
    try
    {
        pre_multiplicative_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '+' ||
                   ctx->current->type == '-'))
        {
            const struct token* p_op_token = ctx->current;
            pre_match(ctx);
            if (ctx->current == NULL)
            {
                pre_unexpected_end_of_file(ctx->input_list.tail, ctx);
                throw;
            }
            long long left_value = ectx->value;
            pre_multiplicative_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            if (p_op_token->type == '+')
            {
                ectx->value = left_value + ectx->value;
            }
            else if (p_op_token->type == '-')
            {
                ectx->value = left_value - ectx->value;
            }
            else
            {
                throw;
            }
        }
    }
    catch
    {
    }
}

static void pre_shift_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     shift-expression:
       additive-expression
       shift-expression << additive-expression
       shift-expression >> additive-expression
    */
    try
    {
        pre_additive_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '>>' ||
                   ctx->current->type == '<<'))
        {
            enum token_type op = ctx->current->type;
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_multiplicative_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            if (op == '>>')
            {
                ectx->value = left_value >> ectx->value;
            }
            else if (op == '<<')
            {
                ectx->value = left_value << ectx->value;
            }
        }
    }
    catch
    {
    }
}

static void pre_relational_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
    relational-expression:
      shift-expression
      relational-expression < shift-expression
      relational-expression > shift-expression
      relational-expression <= shift-expression
      relational-expression >= shift-expression
    */
    try
    {
        pre_shift_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '>' ||
                   ctx->current->type == '<' ||
                   ctx->current->type == '>=' ||
                   ctx->current->type == '<='))
        {
            enum token_type op = ctx->current->type;
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_shift_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            if (op == '>')
            {
                ectx->value = left_value > ectx->value;
            }
            else if (op == '<')
            {
                ectx->value = left_value < ectx->value;
            }
            else if (op == '>=')
            {
                ectx->value = left_value >= ectx->value;
            }
            else if (op == '<=')
            {
                ectx->value = left_value <= ectx->value;
            }
        }
    }
    catch
    {
    }
}

static void pre_equality_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
      equality-expression:
        relational-expression
        equality-expression == relational-expression
        equality-expression != relational-expression
    */

    /*
    * Equality operators
    One of the following shall hold:
    — both operands have arithmetic type;
    — both operands are pointers to qualified or unqualified versions of compatible types;
    — one operand is a pointer to an object type and the other is a pointer to a qualified or unqualified
    version of void; or
    — one operand is a pointer and the other is a null pointer constant.
    */
    try
    {
        pre_relational_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '==' ||
                   ctx->current->type == '!='))
        {
            enum token_type op = ctx->current->type;
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_multiplicative_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            if (op == '==')
            {
                ectx->value = left_value == ectx->value;
            }
            else if (op == '!=')
            {
                ectx->value = left_value != ectx->value;
            }
        }
    }
    catch
    {
    }
}

static void pre_and_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     AND-expression:
      equality-expression
      AND-expression & equality-expression
    */
    try
    {
        pre_equality_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;
        while (ctx->current != NULL &&
               (ctx->current->type == '&'))
        {
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_equality_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;
            ectx->value = left_value & ectx->value;
        }
    }
    catch
    {
    }
}

static void pre_exclusive_or_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     exclusive-OR-expression:
      AND-expression
     exclusive-OR-expression ^ AND-expression
    */
    try
    {
        pre_and_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '^'))
        {
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_and_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;
            ectx->value = left_value ^ ectx->value;
        }
    }
    catch
    {
    }
}

static void pre_inclusive_or_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
    inclusive-OR-expression:
    exclusive-OR-expression
    inclusive-OR-expression | exclusive-OR-expression
    */
    try
    {
        pre_exclusive_or_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '|'))
        {
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_exclusive_or_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            ectx->value = left_value | ectx->value;
        }
    }
    catch
    {
    }
}

static void pre_logical_and_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
    logical-AND-expression:
     inclusive-OR-expression
     logical-AND-expression && inclusive-OR-expression
    */
    try
    {
        pre_inclusive_or_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '&&'))
        {
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_inclusive_or_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            ectx->value = left_value && ectx->value;
        }
    }
    catch
    {
    }
}

static void pre_logical_or_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
      logical-OR-expression:
       logical-AND-expression
       logical-OR-expression || logical-AND-expression
    */
    try
    {
        pre_logical_and_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '||'))
        {
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_logical_and_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            ectx->value = left_value || ectx->value;
        }
    }
    catch
    {
    }
}

static void pre_assignment_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
    assignment-expression:
       conditional-expression
       unary-expression assignment-operator assignment-expression
       */
       /*
          assignment-operator: one of
          = *= /= %= += -= <<= >>= &= ^= |=
       */
       // here it is doubtful but conditional does unary too. 
       // the difference is that it is not just any expression 
       // which can be an assignment
    try
    {
        pre_conditional_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '=' ||
                   ctx->current->type == '*=' ||
                   ctx->current->type == '/=' ||
                   ctx->current->type == '+=' ||
                   ctx->current->type == '-=' ||
                   ctx->current->type == '<<=' ||
                   ctx->current->type == '>>=' ||
                   ctx->current->type == '&=' ||
                   ctx->current->type == '^=' ||
                   ctx->current->type == '|='))
        {
            preprocessor_diagnostic(C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS, ctx, ctx->current, "token '%s' is not valid in preprocessor expressions", ctx->current->lexeme);
            throw;
        }
    }
    catch
    {
    }
}

static void pre_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*expression:
      assignment-expression
      expression, assignment-expression
    */
    try
    {
        pre_assignment_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current && ctx->current->type == ',')
        {
            pre_match(ctx);
            pre_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;
        }
    }
    catch
    {
    }
}

static void pre_conditional_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
      conditional-expression:
      logical-OR-expression
      logical-OR-expression ? expression : conditional-expression
    */
    try
    {
        pre_logical_or_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        if (ctx->current && ctx->current->type == '?')
        {
            pre_match(ctx);
            if (ectx->value)
            {
                pre_expression(ctx, ectx);
                if (ctx->n_errors > 0)
                    throw;

                pre_match(ctx); //:
                struct pre_expression_ctx temp = { 0 };
                pre_conditional_expression(ctx, &temp);
                if (ctx->n_errors > 0)
                    throw;
            }
            else
            {
                struct pre_expression_ctx temp = { 0 };
                pre_expression(ctx, &temp);
                if (ctx->n_errors > 0)
                    throw;

                pre_match(ctx); //:
                pre_conditional_expression(ctx, ectx);
                if (ctx->n_errors > 0)
                    throw;
            }
        }
    }
    catch
    {
    }
}

int pre_constant_expression(struct preprocessor_ctx* ctx, long long* pvalue)
{
    struct pre_expression_ctx ectx = { 0 };        
    pre_conditional_expression(ctx, &ectx);
    *pvalue = ectx.value;
    return ctx->n_errors > 0;
}



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable




/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/
 
//#pragma once

struct flow_visit_ctx;

extern unsigned int s_visit_number; //creates a unique number


enum flow_state
{
    /*
       Not applicable. The state cannot be used.
       struct...
       TODO we need empty state when object does not exist
       and the merge it is not a problem
       merge with nothing then
    */
    FLOW_OBJECT_STATE_NOT_APPLICABLE = 0,

    FLOW_OBJECT_STATE_UNINITIALIZED = 1 << 0,


    /*
      The only reason we have null and zero is because
      of non pointer references -1 for instance can be the "null"
    */
    FLOW_OBJECT_STATE_NULL = 1 << 1,
    FLOW_OBJECT_STATE_NOT_NULL = 1 << 2,

    //means not-null moved at same time
    FLOW_OBJECT_STATE_MOVED = 1 << 3,

    FLOW_OBJECT_STATE_ZERO = 1 << 5,
    FLOW_OBJECT_STATE_NOT_ZERO = 1 << 6,

    FLOW_OBJECT_STATE_LIFE_TIME_ENDED = 1 << 7,
    
    FLOW_OBJECT_STATE_DANGLING = 1 << 8
};


struct flow_objects
{
    struct flow_object* _Owner* _Owner _Opt data;
    int size;
    int capacity;
};

void flow_objects_clear(struct flow_objects* p);
void flow_objects_destroy(_Dtor struct flow_objects* p);
int flow_objects_push_back(struct flow_objects* p, struct flow_object* _Owner p_object);
const struct flow_object* _Opt flow_objects_find(const struct flow_objects* p, const struct flow_object* p_object);


struct flow_objects_view 
{
    struct flow_object** _Owner _Opt data;
    int size;
    int capacity;
};

void objects_view_destroy(_Dtor struct flow_objects_view* p);
int objects_view_push_back(struct flow_objects_view* p, struct flow_object* p_object);
bool objects_view_find(const struct flow_objects_view* p, const struct flow_object* p_object);
void objects_view_copy(struct flow_objects_view* dest, const struct flow_objects_view* source);
void objects_view_merge(struct flow_objects_view* dest, const struct flow_objects_view* source);
void objects_view_clear(struct flow_objects_view* p);


struct flow_object_state
{
    const char* dbg_name;
    int state_number;

    struct flow_object* _Opt pointed;
    enum flow_state state;
    struct flow_objects_view alternatives;
    struct flow_object_state* _Owner _Opt next;
};

void flow_object_state_copy(struct flow_object_state* to, const struct flow_object_state* from);
void flow_object_state_delete(struct flow_object_state* _Owner _Opt p);


/*
  Used in flow analysis to represent the object instance
*/
struct flow_object
{
    //used to avoid infinite recursion
    unsigned int visit_number;

    struct flow_object* _Opt parent;

    /*object are the result of expressions or they are declarators*/
    const struct declarator* _Opt p_declarator_origin;
    const struct expression* _Opt p_expression_origin;

    struct flow_objects_view members;

    struct flow_object_state current;

    int id; //helps debugging
    bool is_temporary;
};

void flow_object_set_is_moved(struct flow_object* p_object);
void flow_object_set_can_be_uninitialized(struct flow_object* p_object);
void flow_object_set_is_unitialized(struct flow_object* p_object);
void flow_object_update_current(struct flow_object* p);
void flow_object_set_current_state_to_can_be_null(struct flow_object* p);
void flow_object_set_current_state_to_is_null(struct flow_object* p);

int flow_object_add_state(struct flow_object* p, struct flow_object_state* _Owner pnew);

bool flow_object_is_zero_or_null(const struct flow_object* p_object);

bool flow_object_is_not_null(const struct flow_object* p);
bool flow_object_can_be_not_null_or_moved(const struct flow_object* p);

bool flow_object_is_null(const struct flow_object* p);
bool flow_object_can_be_null(const struct flow_object* p);
bool flow_object_can_be_moved(const struct flow_object* p);
bool flow_object_can_be_zero(const struct flow_object* p);



bool flow_object_is_not_zero(const struct flow_object* p);
bool flow_object_is_zero(const struct flow_object* p);

bool flow_object_is_uninitialized(const struct flow_object* p);
bool flow_object_can_be_uninitialized(const struct flow_object* p);

bool flow_object_can_have_its_lifetime_ended(const struct flow_object* p);

void flow_object_print_state(struct flow_object* p);

void object_set_pointer(struct flow_object* p_object, struct flow_object* p_object2);

void flow_object_destroy(_Dtor struct flow_object* p);
void flow_object_delete(struct flow_object* _Owner _Opt p);
void flow_object_swap(struct flow_object* a, struct flow_object* b);
void print_object_line(struct flow_object* p_object, int cols);
void print_object_state_to_str(enum flow_state e, char str[], int sz);

struct declarator;
struct flow_object* _Opt make_flow_object(struct flow_visit_ctx* ctx,
                                     struct type* p_type,
                                     const struct declarator* _Opt p_declarator_opt,
                                     const struct expression* _Opt p_expression_origin);

void flow_object_add_new_state_as_a_copy_of_current_state(struct flow_object* object, const char* name, int state_number);
struct token* _Opt flow_object_get_token(const struct flow_object* object);
void flow_object_remove_state(struct flow_object* object, int state_number);


int flow_object_restore_current_state_from(struct flow_object* object, int state_number);

void flow_object_merge_state(struct flow_object* pdest, struct flow_object* object1, struct flow_object* object2);


struct flow_visit_ctx;
struct token;


void print_flow_object(struct type* p_type, struct flow_object* p_object, bool short_version);

struct marker;

void flow_check_assignment(struct flow_visit_ctx* ctx,
    const struct token* error_position,
    const struct marker* p_a_marker,
    const struct marker* p_b_marker,
    enum  assigment_type assigment_type,
    bool check_uninitialized_b,
    bool a_type_is_view,
    bool a_type_is_nullable,
    struct type* p_a_type, struct flow_object* p_a_object,
    struct type* p_b_type, struct flow_object* p_b_object,
    bool * _Opt set_argument_to_unkown);

void flow_object_set_end_of_lifetime(struct type* p_type, struct flow_object* p_object);
void flow_object_set_zero(struct type* p_type, struct flow_object* p_object);
void flow_object_set_uninitialized(struct type* p_type, struct flow_object* p_object);
void flow_object_set_moved(struct type* p_type, struct flow_object* p_object);

void flow_object_set_unknown(struct type* p_type, bool t_is_nullable, struct flow_object* p_object, bool nullable_enabled);


void checked_read_object(struct flow_visit_ctx* ctx,
    struct type* p_type,
    bool is_nullable,
    struct flow_object* p_object,
    const struct token* _Opt position_token,
    const struct marker* _Opt p_marker,
    bool check_pointed_object);


void flow_end_of_block_visit(struct flow_visit_ctx* ctx,
    struct type* p_type,
    bool type_is_view,
    struct flow_object* p_object,
    const struct token* position_token,
    const char* previous_names);


bool flow_object_is_expansible(const struct flow_object* _Opt p_object);
void flow_object_expand_pointer(struct flow_visit_ctx* ctx, struct type* p_type, struct flow_object* p_object);
void flow_object_push_states_from(const struct flow_object* p_object_from, struct flow_object* p_object_to);

struct flow_object* _Opt expression_get_flow_object(struct flow_visit_ctx* ctx, struct expression* p_expression, bool nullable_enabled);


struct label_state
{
    const char * label_name;
    int state_number;
};

struct flow_visit_ctx
{
    struct secondary_block* _Opt catch_secondary_block_opt;

    struct parser_ctx *ctx;
    _View struct ast ast;    
 
    struct type* _Opt p_return_type;
    int parameter_list;
    
    int state_number_generator;
    bool expression_is_not_evaluated; //true when is expression for sizeof, missing state_set, typeof
    bool inside_assert;
    bool inside_contract;

    /*avoid messages like always something, because in loop the same expression is visited in diferent states*/
    bool inside_loop;

    int throw_join_state; /*state where throws are joined*/
    int break_join_state; /*state where breaks are joined*/
    int initial_state;    /*used to keep the original state*/

    struct flow_objects arena;

    struct label_state labels[100]; //max 100 labels in a function (case not included)
    int labels_size;
};

void flow_visit_ctx_destroy(_Dtor struct flow_visit_ctx* p);
void flow_start_visit_declaration(struct flow_visit_ctx* ctx, struct declaration* p_declaration);



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
 *
 *  The objective of this visit is to build the "defer list" on AST
 *  The defer list is the list of items that will go out of scope.
 *  Each item can point to a declarator or defer.
 *  It is complicated algorithm we make it ready to use on AST
*/

//#pragma once

struct defer_visit_ctx
{
    struct secondary_block* _Opt catch_secondary_block_opt;
    struct parser_ctx *ctx;
    _View struct ast ast;    
    struct defer_defer_scope* _Owner _Opt tail_block;
    int parameter_list;
};

void defer_visit_ctx_destroy(_Dtor struct defer_visit_ctx* p);
void defer_start_visit_declaration(struct defer_visit_ctx* ctx, struct declaration* p_declaration);


#ifdef _WIN32
#endif


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake 
*/

//#pragma once

#define CAKE_VERSION "0.10.53"





#if defined _MSC_VER && !defined __POCC__
#endif



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
 *  This visit generates a new and preprocessed C89 code from the AST
 */
 
//#pragma once

struct d_visit_ctx
{
    struct options options;
    int indentation;

    unsigned int cake_declarator_number; //used to create unique declarator names

    unsigned int cake_tag_count; //used to create unique tag names
    struct hash_map tag_names;
    struct hash_map structs_map;
    struct hash_map file_scope_declarator_map;
    
    struct osstream block_scope_declarators;
    struct osstream add_this_before;
    struct osstream add_this_before_external_decl;
    struct osstream add_this_after_external_decl;
    bool is_local;
    
    bool zero_mem_used;
    bool memcpy_used;
    /*
    * Points to the function we're in. Or null in file scope.
    */
    const struct declarator* _Opt p_current_function_opt;

    struct break_reference
    {
      struct selection_statement * _Opt p_selection_statement;
      struct iteration_statement * _Opt p_iteration_statement;
    } break_reference;

    bool is__func__predefined_identifier_added;

    _View struct ast ast;    
};

void d_visit(struct d_visit_ctx* ctx, struct osstream* oss);
void d_visit_ctx_destroy( _Dtor struct d_visit_ctx* ctx);


#ifdef PATH_MAX
#define MYMAX_PATH PATH_MAX // Linux uses it in realpath
#else
#define MYMAX_PATH MAX_PATH
#endif

NODISCARD
int initializer_init_new(struct parser_ctx* ctx,
                       struct type* p_type, /*in (in/out for arrays [])*/
                        struct object* object, /*in (in/out for arrays [])*/
                        struct initializer* initializer, /*rtocar para initializer item??*/
                        bool is_constant,
                        bool requires_constant_initialization);

struct defer_statement* _Owner _Opt defer_statement(struct parser_ctx* ctx);

void defer_statement_delete(struct defer_statement* _Owner _Opt p)
{
    if (p)
    {
        secondary_block_delete(p->secondary_block);
        free(p);
    }
}

static int s_anonymous_struct_count = 0;

///////////////////////////////////////////////////////////////////////////////
void naming_convention_struct_tag(struct parser_ctx* ctx, struct token* token);
void naming_convention_enum_tag(struct parser_ctx* ctx, struct token* token);
void naming_convention_function(struct parser_ctx* ctx, struct token* token);
void naming_convention_enumerator(struct parser_ctx* ctx, struct token* token);
void naming_convention_struct_member(struct parser_ctx* ctx, struct token* token, struct type* type);
void naming_convention_parameter(struct parser_ctx* ctx, struct token* token, struct type* type);
void naming_convention_global_var(struct parser_ctx* ctx, struct token* token, struct type* type, enum storage_class_specifier_flags storage);
void naming_convention_local_var(struct parser_ctx* ctx, struct token* token, struct type* type);

///////////////////////////////////////////////////////////////////////////////

static bool parser_is_diagnostic_enabled(const struct parser_ctx* ctx, enum diagnostic_id w)
{
    if (w > W_NOTE)
        return true;

    return ((ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors & w) != 0) ||
        ((ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings & w) != 0) ||
        ((ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes & w) != 0);
}

static void check_open_brace_style(struct parser_ctx* ctx, struct token* token)
{
    // token points to {

    if (token->level == 0 &&
        !(token->flags & TK_FLAG_MACRO_EXPANDED) &&
        token->type == '{' &&
        token->prev &&
        parser_is_diagnostic_enabled(ctx, W_STYLE))
    {
        if (ctx->options.style == STYLE_CAKE)
        {
            if (token->prev->type == TK_BLANKS &&
                token->prev->prev &&
                token->prev->prev->type == TK_NEWLINE)
            {
            }
            else
            {
                compiler_diagnostic(W_STYLE, ctx, token, NULL, "not following correct brace style {");
            }
        }
    }
}

static void check_close_brace_style(struct parser_ctx* ctx, struct token* token)
{
    // token points to {

    if (token->level == 0 &&
        !(token->flags & TK_FLAG_MACRO_EXPANDED) &&
        token->type == '}' &&
        token->prev &&
        token->prev->prev &&
        parser_is_diagnostic_enabled(ctx, W_STYLE))
    {
        if (ctx->options.style == STYLE_CAKE)
        {
            if (token->prev->type == TK_BLANKS &&
                token->prev->prev->type == TK_NEWLINE)
            {
            }
            else
            {
                compiler_diagnostic(W_STYLE, ctx, token, NULL, "not following correct close brace style }");
            }
        }
    }
}

static void check_func_open_brace_style(struct parser_ctx* ctx, struct token* token)
{
    // token points to {

    if (token->level == 0 &&
        !(token->flags & TK_FLAG_MACRO_EXPANDED) &&
        token->type == '{' &&
        token->prev &&
        parser_is_diagnostic_enabled(ctx, W_STYLE))
    {
        if (ctx->options.style == STYLE_CAKE)
        {
            if (token->prev->type == TK_NEWLINE)
            {
            }
            else
            {
                compiler_diagnostic(W_STYLE, ctx, token, NULL, "not following correct brace style {");
            }
        }
    }
}
/*
static void check_func_close_brace_style(struct parser_ctx* ctx, struct token* token)
{
    //token points to {

    if (token->level == 0 &&
        !(token->flags & TK_FLAG_MACRO_EXPANDED) &&
        token->type == '}' &&
        parser_is_warning_enabled(ctx, W_STYLE))
    {
        if (ctx->options.style == STYLE_CAKE)
        {
            if (token->prev->prev->type == TK_NEWLINE)
            {
            }
            else
            {
                compiler_diagnostic(W_STYLE, ctx, token, "not following correct close brace style }");
            }
        }
    }
}
*/


void scope_destroy(_Dtor struct scope* p)
{
    hashmap_destroy(&p->tags);
    hashmap_destroy(&p->variables);
}

void scope_list_push(struct scope_list* list, struct scope* pnew)
{
    if (list->tail)
        pnew->scope_level = list->tail->scope_level + 1;

    if (list->head == NULL)
    {
        list->head = pnew;
        list->tail = pnew;
        // pnew->prev = list->tail;
    }
    else
    {
        assert(list->tail != NULL);
        pnew->previous = list->tail;
        list->tail->next = pnew;
        list->tail = pnew;
    }
}

void scope_list_pop(struct scope_list* list)
{

    if (list->head == NULL)
        return;
    assert(list->tail != NULL);
    struct scope* p = list->tail;
    if (list->head == list->tail)
    {
        list->head = NULL;
        list->tail = NULL;
    }
    else
    {
        list->tail = list->tail->previous;
        if (list->tail == list->head)
        {
            assert(list->tail != NULL);
            list->tail->next = NULL;
            list->tail->previous = NULL;
        }
    }
    p->next = NULL;
    p->previous = NULL;
}

void parser_ctx_destroy(_Opt _Dtor struct parser_ctx* ctx)
{
    label_list_clear(&ctx->label_list);
    assert(ctx->label_list.head == NULL);
    assert(ctx->label_list.tail == NULL);

    if (ctx->sarif_file)
    {
        fclose(ctx->sarif_file);
    }
}

static void stringfy(const char* input, char* json_str_message, int output_size)
{
    json_str_message[0] = '\0'; //out

    int k = 0;
    while (*input != '\0')
    {
        if (*input == '\"')
        {
            if (k < output_size)
                json_str_message[k] = '\\';
            k++;
            if (k < output_size)
                json_str_message[k] = '"';
            k++;
            input++;
        }
        else if (*input == '\n')
        {
            if (k < output_size)
                json_str_message[k] = '\\';
            k++;
            if (k < output_size)
                json_str_message[k] = 'n';
            k++;
            input++;
        }
        else
        {
            if (k < output_size)
                json_str_message[k] = *input;
            k++;
            input++;
        }
    }
    if (k < output_size)
        json_str_message[k] = '\0';
    else
        json_str_message[output_size - 1] = '\0';
}

_Bool compiler_diagnostic(enum diagnostic_id w,
    const struct parser_ctx* ctx,
    const struct token* _Opt p_token_opt,
    const struct marker* _Opt p_marker_temp,
    const char* fmt, ...)
{
    bool included_file_location = false;
    struct marker marker = { 0 };
    if (p_marker_temp == NULL)
    {
        if (p_token_opt == NULL) return false;

        marker.file = p_token_opt->token_origin->lexeme;
        marker.line = p_token_opt->line;
        marker.start_col = p_token_opt->col;
        marker.end_col = p_token_opt->col;
        marker.p_token_caret = p_token_opt;
        included_file_location = p_token_opt->level > 0;
    }
    else
    {
        //assert(p_token_opt == NULL);
        marker = *p_marker_temp;
        if (marker.p_token_caret)
            p_token_opt = marker.p_token_caret;
        else if (marker.p_token_begin)
            p_token_opt = marker.p_token_begin;

        if (p_token_opt == NULL) return false;
        marker.file = p_token_opt->token_origin->lexeme;
        included_file_location = p_token_opt->level > 0;

        marker.line = p_token_opt->line;
        marker.start_col = p_token_opt->col;
        marker.end_col = p_token_opt->col;
    }

    bool is_error = false;
    bool is_warning = false;
    bool is_note = false;

    if (is_diagnostic_configurable(w))
    {
        is_error =
            (ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors & (1ULL << w)) != 0;

        is_warning =
            (ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings & (1ULL << w)) != 0;

        is_note =
            ((ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes & (1ULL << w)) != 0);
    }
    else
    {
        is_note = is_diagnostic_note(w);
        is_error = is_diagnostic_error(w);
        is_warning = is_diagnostic_warning(w);
    }

    if (is_error)
    {
        ctx->p_report->error_count++;
    }
    else if (is_warning)
    {
        /*warnings inside headers are ignored*/
        if (included_file_location)
        {
            return false;
        }

        ctx->p_report->warnings_count++;
    }
    else if (is_note)
    {
        /*notes inside headers are ignored*/
        if (included_file_location)
        {
            return false;
        }

        if (w != W_LOCATION)
            ctx->p_report->info_count++;
    }
    else
    {
        return false;
    }

    if (w != W_LOCATION)
    {
        //index 0 is the most recent
        ctx->p_report->last_diagnostics_ids[1] = ctx->p_report->last_diagnostics_ids[0];
        ctx->p_report->last_diagnostics_ids[0] = w;
    }

    const char* func_name = "module";
    if (ctx->p_current_function_opt)
    {
        if (ctx->p_current_function_opt->name_opt)
            func_name = ctx->p_current_function_opt->name_opt->lexeme;
        else
            func_name = "unnamed";
    }

    char buffer[200] = { 0 };

    char diagnostic_name[100] = { 0 };
    get_warning_name(w, sizeof diagnostic_name, diagnostic_name);




    print_position(marker.file, marker.line, marker.start_col, ctx->options.visual_studio_ouput_format);

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"

    va_list args = { 0 };
    va_start(args, fmt);
    /*int n =*/vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);

#pragma CAKE diagnostic pop

    //bool show_warning_name = w < W_NOTE && w != W_LOCATION;


    if (ctx->options.visual_studio_ouput_format)
    {
        if (is_error)
            printf("error: ");
        else if (is_warning)
            printf("warning: ");
        else if (is_note)
            printf("note: ");

        printf("%s", buffer);

        printf(" [%s]\n", diagnostic_name);
    }
    else
    {
        if (is_error)
        {
            printf(LIGHTRED "error: " WHITE "%s [" LIGHTRED "%s" WHITE "]\n" RESET, buffer, diagnostic_name);
        }
        else if (is_warning)
        {
            printf(LIGHTMAGENTA "warning: " WHITE "%s [" LIGHTMAGENTA "%s" WHITE "]\n" RESET, buffer, diagnostic_name);
        }
        else if (is_note)
        {
            if (w == W_LOCATION)
                printf(LIGHTCYAN "note: " WHITE "%s\n" RESET, buffer);
            else
                printf(LIGHTCYAN "note: " WHITE "%s [" LIGHTCYAN "%s" WHITE "]\n" RESET, buffer, diagnostic_name);
        }
    }

    print_line_and_token(&marker, ctx->options.visual_studio_ouput_format);


    if (ctx->sarif_file)
    {

        char json_str_message[200] = { 0 };
        stringfy(buffer, json_str_message, sizeof json_str_message);

        if (ctx->sarif_entries > 0)
        {
            fprintf(ctx->sarif_file, "   ,\n");
        }

        ((struct parser_ctx*)ctx)->sarif_entries++;

        fprintf(ctx->sarif_file, "   {\n");
        fprintf(ctx->sarif_file, "     \"ruleId\":\"%s\",\n", diagnostic_name);

        if (is_error)
            fprintf(ctx->sarif_file, "     \"level\":\"error\",\n");
        else if (is_warning)
            fprintf(ctx->sarif_file, "     \"level\":\"warning\",\n");
        else if (is_note)
            fprintf(ctx->sarif_file, "     \"level\":\"note\",\n");

        fprintf(ctx->sarif_file, "     \"message\": {\n");
        fprintf(ctx->sarif_file, "            \"text\": \"%s\"\n", json_str_message);
        fprintf(ctx->sarif_file, "      },\n");
        fprintf(ctx->sarif_file, "      \"locations\": [\n");
        fprintf(ctx->sarif_file, "       {\n");

        fprintf(ctx->sarif_file, "       \"physicalLocation\": {\n");

        fprintf(ctx->sarif_file, "             \"artifactLocation\": {\n");
        fprintf(ctx->sarif_file, "                 \"uri\": \"file:///%s\"\n", marker.file);
        fprintf(ctx->sarif_file, "              },\n");

        fprintf(ctx->sarif_file, "              \"region\": {\n");
        fprintf(ctx->sarif_file, "                  \"startLine\": %d,\n", marker.line);
        fprintf(ctx->sarif_file, "                  \"startColumn\": %d,\n", marker.start_col);
        fprintf(ctx->sarif_file, "                  \"endLine\": %d,\n", marker.line);
        fprintf(ctx->sarif_file, "                  \"endColumn\": %d\n", marker.end_col);
        fprintf(ctx->sarif_file, "               }\n");
        fprintf(ctx->sarif_file, "         },\n");

        fprintf(ctx->sarif_file, "         \"logicalLocations\": [\n");
        fprintf(ctx->sarif_file, "          {\n");

        fprintf(ctx->sarif_file, "              \"fullyQualifiedName\": \"%s\",\n", func_name);
        fprintf(ctx->sarif_file, "              \"decoratedName\": \"%s\",\n", func_name);

        fprintf(ctx->sarif_file, "              \"kind\": \"%s\"\n", "function");
        fprintf(ctx->sarif_file, "          }\n");

        fprintf(ctx->sarif_file, "         ]\n");

        fprintf(ctx->sarif_file, "       }\n");
        fprintf(ctx->sarif_file, "     ]\n");

        fprintf(ctx->sarif_file, "   }\n");
    }

    return 1;
}

void print_scope(struct scope_list* e)
{
    printf("--- begin of scope---\n");
    struct scope* _Opt p = e->head;
    int level = 0;
    while (p)
    {
        if (p->variables.table)
        {
            for (int i = 0; i < p->variables.capacity; i++)
            {
                if (p->variables.table[i])
                {
                    for (int k = 0; k < level; k++)
                        printf(" ");
                    printf("%s\n", p->variables.table[i]->key);
                }
            }

            for (int i = 0; i < p->tags.capacity; i++)
            {
                if (p->tags.table[i])
                {
                    for (int k = 0; k < level; k++)
                        printf(" ");
                    printf("tag %s\n", p->tags.table[i]->key);
                }
            }
        }

        level++;
        p = p->next;
    }
    printf("--- end of scope---\n");
}


bool first_of_function_specifier(const struct parser_ctx* ctx)
{
    struct token* _Opt token = ctx->current;

    if (token == NULL)
        return false;

    return token->type == TK_KEYWORD_INLINE ||
        token->type == TK_KEYWORD__NORETURN;
}

bool first_of_enum_specifier_token(const struct token* token)
{
    return token->type == TK_KEYWORD_ENUM;
}

bool first_of_enum_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return first_of_enum_specifier_token(ctx->current);
}


bool first_of_alignment_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;
    return ctx->current->type == TK_KEYWORD__ALIGNAS;
}

bool first_of_atomic_type_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    /*
      If the _Atomic keyword is immediately followed by a left parenthesis, it is interpreted
      as a type specifier (with a type name), not as a type qualifier.
    */

    if (ctx->current->type == TK_KEYWORD__ATOMIC)
    {
        struct token* _Opt ahead = parser_look_ahead(ctx);
        if (ahead != NULL)
        {
            return ahead->type == '(';
        }
    }
    return false;
}

bool first_of_storage_class_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD_TYPEDEF ||
        ctx->current->type == TK_KEYWORD_CONSTEXPR ||
        ctx->current->type == TK_KEYWORD_EXTERN ||
        ctx->current->type == TK_KEYWORD_STATIC ||
        ctx->current->type == TK_KEYWORD__THREAD_LOCAL ||
        ctx->current->type == TK_KEYWORD_AUTO ||
        ctx->current->type == TK_KEYWORD_REGISTER;
}

bool first_of_struct_or_union_token(const struct token* token)
{
    return token->type == TK_KEYWORD_STRUCT || token->type == TK_KEYWORD_UNION;
}

bool first_of_struct_or_union(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return first_of_struct_or_union_token(ctx->current);
}

bool first_of_type_qualifier_token(const struct token* p_token)
{

    return p_token->type == TK_KEYWORD_CONST ||
        p_token->type == TK_KEYWORD_RESTRICT ||
        p_token->type == TK_KEYWORD_VOLATILE ||
        p_token->type == TK_KEYWORD__ATOMIC ||

        //MSVC
        p_token->type == TK_KEYWORD_MSVC__PTR32 ||
        p_token->type == TK_KEYWORD_MSVC__PTR64 ||

        /*extensions*/
        p_token->type == TK_KEYWORD__CTOR ||
        p_token->type == TK_KEYWORD_CAKE_OWNER ||
        p_token->type == TK_KEYWORD__DTOR ||
        p_token->type == TK_KEYWORD_CAKE_VIEW ||
        p_token->type == TK_KEYWORD_CAKE_OPT;

    //__fastcall
    //__stdcall
}

bool first_of_type_qualifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    if (ctx->current->type == TK_KEYWORD_CONST)
    {
        struct token* ahead = parser_look_ahead(ctx);
        if (ahead->type == '(')
            return false; //expression const(expr)
    }
    return first_of_type_qualifier_token(ctx->current);
}

struct map_entry* _Opt find_tag(struct parser_ctx* ctx, const char* lexeme)
{
    struct scope* _Opt scope = ctx->scopes.tail;
    while (scope)
    {
        struct map_entry* _Opt p_entry = hashmap_find(&scope->tags, lexeme);
        if (p_entry)
        {
            return p_entry;
        }
        scope = scope->previous;
    }
    return NULL;
}

struct map_entry* _Opt find_variables(const struct parser_ctx* ctx, const char* lexeme, struct scope* _Opt* _Opt ppscope_opt)
{
    if (ppscope_opt != NULL)
        *ppscope_opt = NULL; // out

    struct scope* _Opt scope = ctx->scopes.tail;
    while (scope)
    {
        struct map_entry* _Opt p_entry = hashmap_find(&scope->variables, lexeme);
        if (p_entry)
        {
            if (ppscope_opt)
                *ppscope_opt = scope;
            return p_entry;
        }
        scope = scope->previous;
    }
    return NULL;
}

struct enum_specifier* _Opt find_enum_specifier(struct parser_ctx* ctx, const char* lexeme)
{
    struct enum_specifier* _Opt best = NULL;
    struct scope* _Opt scope = ctx->scopes.tail;
    while (scope)
    {
        struct map_entry* _Opt p_entry = hashmap_find(&scope->tags, lexeme);
        if (p_entry &&
            p_entry->type == TAG_TYPE_ENUN_SPECIFIER)
        {
            assert(p_entry->data.p_enum_specifier != NULL);

            best = p_entry->data.p_enum_specifier;
            if (best->enumerator_list.head != NULL)
                return best; // OK bem completo
            else
            {
                // it's not complete let's keep going up
            }
        }
        scope = scope->previous;
    }
    return best; // mesmo que nao seja tao completo vamos retornar.
}

struct struct_or_union_specifier* _Opt find_struct_or_union_specifier(const struct parser_ctx* ctx, const char* lexeme)
{
    struct struct_or_union_specifier* _Opt p = NULL;
    struct scope* _Opt scope = ctx->scopes.tail;
    while (scope)
    {
        struct map_entry* _Opt p_entry = hashmap_find(&scope->tags, lexeme);
        if (p_entry &&
            p_entry->type == TAG_TYPE_STRUCT_OR_UNION_SPECIFIER)
        {
            assert(p_entry->data.p_struct_or_union_specifier != NULL);
            p = p_entry->data.p_struct_or_union_specifier;
            break;
        }
        scope = scope->previous;
    }
    return p;
}

struct declarator* _Opt find_declarator(const struct parser_ctx* ctx, const char* lexeme, struct scope** _Opt ppscope_opt)
{
    struct map_entry* _Opt p_entry = find_variables(ctx, lexeme, ppscope_opt);

    if (p_entry)
    {
        if (p_entry->type == TAG_TYPE_INIT_DECLARATOR)
        {
            assert(p_entry->data.p_init_declarator != NULL);
            struct init_declarator* p_init_declarator = p_entry->data.p_init_declarator;
            return (struct declarator*)p_init_declarator->p_declarator;
        }
        else if (p_entry->type == TAG_TYPE_DECLARATOR)
        {
            return p_entry->data.p_declarator;
        }
    }

    return NULL;
}

struct enumerator* _Opt find_enumerator(const struct parser_ctx* ctx, const char* lexeme, struct scope** _Opt ppscope_opt)
{
    struct map_entry* _Opt p_entry = find_variables(ctx, lexeme, ppscope_opt);

    if (p_entry && p_entry->type == TAG_TYPE_ENUMERATOR)
        return p_entry->data.p_enumerator;

    return NULL;
}

bool first_of_typedef_name(const struct parser_ctx* ctx, struct token* p_token)
{

    if (p_token->type != TK_IDENTIFIER)
    {
        // no need to check
        return false;
    }
    if (p_token->flags & TK_FLAG_IDENTIFIER_IS_TYPEDEF)
    {
        // it has already been verified that it is a typedef
        return true;
    }
    if (p_token->flags & TK_FLAG_IDENTIFIER_IS_NOT_TYPEDEF)
    {
        // it has already been verified that it is NOT a typedef
        return false;
    }

    struct declarator* _Opt p_declarator = find_declarator(ctx, p_token->lexeme, NULL);

    if (p_declarator &&
        p_declarator->declaration_specifiers &&
        (p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_TYPEDEF))
    {
        p_declarator->num_uses++;
        p_token->flags |= TK_FLAG_IDENTIFIER_IS_TYPEDEF;
        return true;
    }
    else
    {
        p_token->flags |= TK_FLAG_IDENTIFIER_IS_NOT_TYPEDEF;
    }
    return false;
}

bool first_of_type_specifier(const struct parser_ctx* ctx);
bool first_of_type_specifier_token(const struct parser_ctx* ctx, struct token* token);

bool first_of_type_name_ahead(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    if (ctx->current->type != '(')
        return false;

    struct token* _Opt token_ahead = parser_look_ahead(ctx);

    if (token_ahead == NULL)
        return false;

    return first_of_type_specifier_token(ctx, token_ahead) ||
        first_of_type_qualifier_token(token_ahead);
}

bool first_of_type_name(const struct parser_ctx* ctx)
{
    return first_of_type_specifier(ctx) || first_of_type_qualifier(ctx);
}

bool first_of_type_specifier_token(const struct parser_ctx* ctx, struct token* p_token)
{
    return p_token->type == TK_KEYWORD_VOID ||
        p_token->type == TK_KEYWORD_CHAR ||
        p_token->type == TK_KEYWORD_SHORT ||
        p_token->type == TK_KEYWORD_INT ||
        p_token->type == TK_KEYWORD_LONG ||
        p_token->type == TK_KEYWORD_FLOAT ||
        p_token->type == TK_KEYWORD_DOUBLE ||
        p_token->type == TK_KEYWORD_SIGNED ||
        p_token->type == TK_KEYWORD_UNSIGNED ||
        p_token->type == TK_KEYWORD__BITINT ||
        p_token->type == TK_KEYWORD__BOOL ||
        p_token->type == TK_KEYWORD__COMPLEX ||
        p_token->type == TK_KEYWORD__DECIMAL32 ||
        p_token->type == TK_KEYWORD__DECIMAL64 ||
        p_token->type == TK_KEYWORD__DECIMAL128 ||
        p_token->type == TK_KEYWORD_TYPEOF ||        // C23
        p_token->type == TK_KEYWORD_TYPEOF_UNQUAL || // C23

        p_token->type == TK_KEYWORD_GCC__BUILTIN_VA_LIST ||

        p_token->type == TK_KEYWORD_MSVC__INT8 ||
        p_token->type == TK_KEYWORD_MSVC__INT16 ||
        p_token->type == TK_KEYWORD_MSVC__INT32 ||
        p_token->type == TK_KEYWORD_MSVC__INT64 ||

        first_of_atomic_type_specifier(ctx) ||
        first_of_struct_or_union_token(p_token) ||
        first_of_enum_specifier_token(p_token) ||
        first_of_typedef_name(ctx, p_token);
}

bool first_of_type_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;
    return first_of_type_specifier_token(ctx, ctx->current);
}

bool first_of_type_specifier_qualifier(const struct parser_ctx* ctx)
{
    return first_of_type_specifier(ctx) ||
        first_of_type_qualifier(ctx) ||
        first_of_alignment_specifier(ctx);
}

bool first_of_compound_statement(const struct parser_ctx* ctx)
{
    return ctx->current != NULL && ctx->current->type == '{';
}

bool first_of_jump_statement(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD_GOTO ||
        ctx->current->type == TK_KEYWORD_CONTINUE ||
        ctx->current->type == TK_KEYWORD_BREAK ||
        ctx->current->type == TK_KEYWORD_RETURN ||
        ctx->current->type == TK_KEYWORD_CAKE_THROW /*extension*/;
}

bool first_of_selection_statement(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD_IF ||
        ctx->current->type == TK_KEYWORD_SWITCH;
}

bool first_of_iteration_statement(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD_WHILE ||
        ctx->current->type == TK_KEYWORD_DO ||
        ctx->current->type == TK_KEYWORD_FOR;
}

bool first_of_label(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    if (ctx->current->type == TK_IDENTIFIER)
    {
        struct token* _Opt next = parser_look_ahead(ctx);
        return next && next->type == ':';
    }
    else if (ctx->current->type == TK_KEYWORD_CASE)
    {
        return true;
    }
    else if (ctx->current->type == TK_KEYWORD_DEFAULT)
    {
        return true;
    }

    return false;
}

bool first_of_declaration_specifier(const struct parser_ctx* ctx)
{
    /*
    declaration-specifier:
    storage-class-specifier
    type-specifier-qualifier
    function-specifier
    */
    return first_of_storage_class_specifier(ctx) ||
        first_of_function_specifier(ctx) ||
        first_of_type_specifier_qualifier(ctx);
}

bool first_of_pragma_declaration(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_PRAGMA;
}

bool first_of_static_assert_declaration(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD__STATIC_ASSERT ||
        ctx->current->type == TK_KEYWORD_CAKE_STATIC_DEBUG ||
        ctx->current->type == TK_KEYWORD_CAKE_STATIC_DEBUG_EX ||
        ctx->current->type == TK_KEYWORD_STATIC_STATE ||
        ctx->current->type == TK_KEYWORD_STATIC_SET;
}

bool first_of_attribute_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    if (ctx->current->type != '[')
    {
        return false;
    }
    struct token* _Opt p_token = parser_look_ahead(ctx);
    return p_token != NULL && p_token->type == '[';
}

bool first_of_labeled_statement(const struct parser_ctx* ctx)
{
    return first_of_label(ctx);
}

bool first_of_designator(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == '[' || ctx->current->type == '.';
}

struct token* _Opt previous_parser_token(const struct token* token)
{
    if (token->prev == NULL)
    {
        return NULL;
    }

    struct token* _Opt prev = token->prev;
    while (prev && !(prev->flags & TK_FLAG_FINAL))
    {
        prev = prev->prev;
    }

    return prev;
}

enum token_type is_keyword(const char* text)
{
    switch (text[0])
    {
    case 'a':
        if (strcmp("alignof", text) == 0)
            return TK_KEYWORD__ALIGNOF;
        if (strcmp("auto", text) == 0)
            return TK_KEYWORD_AUTO;
        if (strcmp("alignas", text) == 0)
            return TK_KEYWORD__ALIGNAS; /*C23 alternate spelling _Alignas*/
        if (strcmp("alignof", text) == 0)
            return TK_KEYWORD__ALIGNAS; /*C23 alternate spelling _Alignof*/
        if (strcmp("assert", text) == 0)
            return TK_KEYWORD_ASSERT; /*extension*/
        break;

    case 'b':
        if (strcmp("break", text) == 0)
            return TK_KEYWORD_BREAK;
        if (strcmp("bool", text) == 0)
            return TK_KEYWORD__BOOL; /*C23 alternate spelling _Bool*/
        break;

    case 'c':
        if (strcmp("case", text) == 0)
            return TK_KEYWORD_CASE;
        if (strcmp("char", text) == 0)
            return TK_KEYWORD_CHAR;
        if (strcmp("const", text) == 0)
            return TK_KEYWORD_CONST;
        if (strcmp("constexpr", text) == 0)
            return TK_KEYWORD_CONSTEXPR;
        if (strcmp("continue", text) == 0)
            return TK_KEYWORD_CONTINUE;
        if (strcmp("catch", text) == 0)
            return TK_KEYWORD_CAKE_CATCH;
        break;

    case 'd':
        if (strcmp("default", text) == 0)
            return TK_KEYWORD_DEFAULT;
        if (strcmp("do", text) == 0)
            return TK_KEYWORD_DO;
        if (strcmp("defer", text) == 0)
            return TK_KEYWORD_DEFER;
        if (strcmp("double", text) == 0)
            return TK_KEYWORD_DOUBLE;
        break;

    case 'e':
        if (strcmp("else", text) == 0)
            return TK_KEYWORD_ELSE;
        if (strcmp("enum", text) == 0)
            return TK_KEYWORD_ENUM;
        if (strcmp("extern", text) == 0)
            return TK_KEYWORD_EXTERN;
        break;

    case 'f':
        if (strcmp("float", text) == 0)
            return TK_KEYWORD_FLOAT;
        if (strcmp("for", text) == 0)
            return TK_KEYWORD_FOR;
        if (strcmp("false", text) == 0)
            return TK_KEYWORD_FALSE;
        break;

    case 'g':
        if (strcmp("goto", text) == 0)
            return TK_KEYWORD_GOTO;
        break;

    case 'i':
        if (strcmp("if", text) == 0)
            return TK_KEYWORD_IF;
        if (strcmp("inline", text) == 0)
            return TK_KEYWORD_INLINE;
        if (strcmp("int", text) == 0)
            return TK_KEYWORD_INT;
        break;

    case 'n':
        if (strcmp("nullptr", text) == 0)
            return TK_KEYWORD_NULLPTR;
        break;

    case 'l':
        if (strcmp("long", text) == 0)
            return TK_KEYWORD_LONG;
        break;

    case 'r':
        if (strcmp("register", text) == 0)
            return TK_KEYWORD_REGISTER;
        if (strcmp("restrict", text) == 0)
            return TK_KEYWORD_RESTRICT;
        if (strcmp("return", text) == 0)
            return TK_KEYWORD_RETURN;
        break;

    case 's':
        if (strcmp("short", text) == 0)
            return TK_KEYWORD_SHORT;
        if (strcmp("signed", text) == 0)
            return TK_KEYWORD_SIGNED;
        if (strcmp("sizeof", text) == 0)
            return TK_KEYWORD_SIZEOF;
        if (strcmp("static", text) == 0)
            return TK_KEYWORD_STATIC;
        if (strcmp("struct", text) == 0)
            return TK_KEYWORD_STRUCT;
        if (strcmp("switch", text) == 0)
            return TK_KEYWORD_SWITCH;
        if (strcmp("static_assert", text) == 0)
            return TK_KEYWORD__STATIC_ASSERT; /*C23 alternate spelling _Static_assert*/
        if (strcmp("static_debug", text) == 0)
            return TK_KEYWORD_CAKE_STATIC_DEBUG;
        if (strcmp("static_debug_ex", text) == 0)
            return TK_KEYWORD_CAKE_STATIC_DEBUG_EX;
        if (strcmp("static_state", text) == 0)
            return TK_KEYWORD_STATIC_STATE;
        if (strcmp("static_set", text) == 0)
            return TK_KEYWORD_STATIC_SET;
        break;

    case 't':
        if (strcmp("typedef", text) == 0)
            return TK_KEYWORD_TYPEDEF;
        if (strcmp("typeof", text) == 0)
            return TK_KEYWORD_TYPEOF; /*C23*/
        if (strcmp("typeof_unqual", text) == 0)
            return TK_KEYWORD_TYPEOF_UNQUAL; /*C23*/
        if (strcmp("true", text) == 0)
            return TK_KEYWORD_TRUE; /*C23*/
        if (strcmp("thread_local", text) == 0)
            return TK_KEYWORD__THREAD_LOCAL; /*C23 alternate spelling _Thread_local*/
        if (strcmp("try", text) == 0)
            return TK_KEYWORD_CAKE_TRY;
        if (strcmp("throw", text) == 0)
            return TK_KEYWORD_CAKE_THROW;
        break;

    case 'u':
        if (strcmp("union", text) == 0)
            return TK_KEYWORD_UNION;
        if (strcmp("unsigned", text) == 0)
            return TK_KEYWORD_UNSIGNED;
        break;

    case 'v':
        if (strcmp("void", text) == 0)
            return TK_KEYWORD_VOID;
        if (strcmp("volatile", text) == 0)
            return TK_KEYWORD_VOLATILE;
        break;

    case 'w':
        if (strcmp("while", text) == 0)
            return TK_KEYWORD_WHILE;
        break;
    case '_':

        /*ownership*/
        if (strcmp("_Ctor", text) == 0)
            return TK_KEYWORD__CTOR; /*extension*/
        if (strcmp("_Owner", text) == 0)
            return TK_KEYWORD_CAKE_OWNER; /*extension*/
        if (strcmp("_Dtor", text) == 0)
            return TK_KEYWORD__DTOR; /*extension*/
        if (strcmp("_Opt", text) == 0)
            return TK_KEYWORD_CAKE_OPT; /*extension*/

        if (strcmp("_View", text) == 0)
            return TK_KEYWORD_CAKE_VIEW; /*extension*/

        if (strcmp("_Countof", text) == 0)
            return TK_KEYWORD__COUNTOF; /*C2Y*/

        /*TRAITS EXTENSION*/
        if (strcmp("_is_lvalue", text) == 0)
            return TK_KEYWORD_IS_LVALUE;
        if (strcmp("_is_const", text) == 0)
            return TK_KEYWORD_IS_CONST;
        if (strcmp("_is_owner", text) == 0)
            return TK_KEYWORD_IS_OWNER;
        if (strcmp("_is_pointer", text) == 0)
            return TK_KEYWORD_IS_POINTER;
        if (strcmp("_is_array", text) == 0)
            return TK_KEYWORD_IS_ARRAY;
        if (strcmp("_is_function", text) == 0)
            return TK_KEYWORD_IS_FUNCTION;
        if (strcmp("_is_arithmetic", text) == 0)
            return TK_KEYWORD_IS_ARITHMETIC;
        if (strcmp("_is_floating_point", text) == 0)
            return TK_KEYWORD_IS_FLOATING_POINT;
        if (strcmp("_is_integral", text) == 0)
            return TK_KEYWORD_IS_INTEGRAL;
        if (strcmp("_is_scalar", text) == 0)
            return TK_KEYWORD_IS_SCALAR;
        /*TRAITS EXTENSION*/

        if (strcmp("_Alignof", text) == 0)
            return TK_KEYWORD__ALIGNOF;
        if (strcmp("_Alignas", text) == 0)
            return TK_KEYWORD__ALIGNAS;
        if (strcmp("_Atomic", text) == 0)
            return TK_KEYWORD__ATOMIC;

        if (strcmp("__builtin_va_list", text) == 0)
            return TK_KEYWORD_GCC__BUILTIN_VA_LIST;

        if (strcmp("__attribute__", text) == 0)
            return TK_KEYWORD_GCC__ATTRIBUTE;

        if (strcmp("__builtin_offsetof", text) == 0)
            return TK_KEYWORD_GCC__BUILTIN_OFFSETOF;

        if (strcmp("__builtin_va_end", text) == 0)
            return TK_KEYWORD_GCC__BUILTIN_VA_END;

        if (strcmp("__builtin_va_arg", text) == 0)
            return TK_KEYWORD_GCC__BUILTIN_VA_ARG;

        if (strcmp("__builtin_c23_va_start", text) == 0)
            return TK_KEYWORD_GCC__BUILTIN_C23_VA_START;

        if (strcmp("__builtin_va_start", text) == 0)
            return TK_KEYWORD_GCC__BUILTIN_C23_VA_START;

        if (strcmp("__builtin_va_copy", text) == 0)
            return TK_KEYWORD_GCC__BUILTIN_VA_COPY;

        if (strcmp("__ptr32", text) == 0)
            return TK_KEYWORD_MSVC__PTR32;
        if (strcmp("__ptr64", text) == 0)
            return TK_KEYWORD_MSVC__PTR64;


        if (strcmp("_Bool", text) == 0)
            return TK_KEYWORD__BOOL;
        if (strcmp("_Complex", text) == 0)
            return TK_KEYWORD__COMPLEX;
        if (strcmp("_Decimal32", text) == 0)
            return TK_KEYWORD__DECIMAL32;
        if (strcmp("_Decimal64", text) == 0)
            return TK_KEYWORD__DECIMAL64;
        if (strcmp("_Decimal128", text) == 0)
            return TK_KEYWORD__DECIMAL128;
        if (strcmp("_Generic", text) == 0)
            return TK_KEYWORD__GENERIC;
        if (strcmp("_Imaginary", text) == 0)
            return TK_KEYWORD__IMAGINARY;
        if (strcmp("_Noreturn", text) == 0)
            return TK_KEYWORD__NORETURN; /*_Noreturn deprecated C23*/
        if (strcmp("_Static_assert", text) == 0)
            return TK_KEYWORD__STATIC_ASSERT;
        if (strcmp("_Thread_local", text) == 0)
            return TK_KEYWORD__THREAD_LOCAL;
        if (strcmp("_BitInt", text) == 0)
            return TK_KEYWORD__BITINT; /*(C23)*/
        if (strcmp("__typeof__", text) == 0)
            return TK_KEYWORD_TYPEOF; /*(C23)*/
#ifdef  _MSC_VER
        // begin microsoft
        if (strcmp("__int8", text) == 0)
            return TK_KEYWORD_MSVC__INT8;
        if (strcmp("__int16", text) == 0)
            return TK_KEYWORD_MSVC__INT16;
        if (strcmp("__int32", text) == 0)
            return TK_KEYWORD_MSVC__INT32;
        if (strcmp("__int64", text) == 0)
            return TK_KEYWORD_MSVC__INT64;
        if (strcmp("__forceinline", text) == 0)
            return TK_KEYWORD_INLINE;
        if (strcmp("__inline", text) == 0)
            return TK_KEYWORD_INLINE;
        if (strcmp("_asm", text) == 0 || strcmp("__asm", text) == 0)
            return TK_KEYWORD__ASM;
        if (strcmp("__stdcall", text) == 0 || strcmp("_stdcall", text) == 0)
            return TK_KEYWORD_MSVC__STDCALL;
        if (strcmp("__cdecl", text) == 0)
            return TK_KEYWORD_MSVC__CDECL;
        if (strcmp("__fastcall", text) == 0)
            return TK_KEYWORD_MSVC__FASTCALL;
        if (strcmp("__alignof", text) == 0)
            return TK_KEYWORD__ALIGNOF;
        if (strcmp("__restrict", text) == 0)
            return TK_KEYWORD_RESTRICT;
        if (strcmp("__declspec", text) == 0)
            return TK_KEYWORD_MSVC__DECLSPEC;
#endif
        break;
    default:
        break;
    }

    return 0;
}


static void token_promote(const struct parser_ctx* ctx, struct token* token)
{
    if (token->type == TK_IDENTIFIER_RECURSIVE_MACRO)
    {
        // talvez desse para remover antesisso..
        // assim que sai do tetris
        // virou passado
        token->type = TK_IDENTIFIER; /*nao precisamos mais disso*/
    }

    if (token->type == TK_IDENTIFIER)
    {
        enum token_type t = is_keyword(token->lexeme);
        if (t != TK_NONE)
            token->type = t;
    }
    else if (token->type == TK_PPNUMBER)
    {
        char errormsg[100] = { 0 };
        char suffix[4] = { 0 };
        token->type = parse_number(token->lexeme, suffix, errormsg);
        if (token->type == TK_NONE)
        {
            compiler_diagnostic(C_INVALID_TOKEN, ctx, token, NULL, errormsg);
        }
    }
}

struct token* _Opt parser_look_ahead(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return NULL;

    struct token* _Opt p = ctx->current->next;
    while (p && !(p->flags & TK_FLAG_FINAL))
    {
        p = p->next;
    }

    if (p)
    {
        token_promote(ctx, p);
    }

    return p;
}


static struct token* _Opt pragma_match(const struct token* p_current)
{
    struct token* _Opt p_token = p_current->next;
    while (p_token && p_token->type == TK_BLANKS)
    {
        p_token = p_token->next;
    }
    return p_token;
}

static void pragma_skip_blanks(struct parser_ctx* ctx)
{
    while (ctx->current && ctx->current->type == TK_BLANKS)
    {
        ctx->current = ctx->current->next;
    }
}

/*
 * Some pragmas needs to be handled by the compiler
 */
static void parse_pragma(struct parser_ctx* ctx, struct token* token)
{
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == TK_PRAGMA)
        {
            ctx->current = ctx->current->next;
            pragma_skip_blanks(ctx);

            if (ctx->current &&
                (strcmp(ctx->current->lexeme, "CAKE") == 0 ||
                    strcmp(ctx->current->lexeme, "cake") == 0))
            {
                ctx->current = ctx->current->next;
                pragma_skip_blanks(ctx);
            }

            if (ctx->current && strcmp(ctx->current->lexeme, "nullchecks") == 0)
            {
                ctx->current = ctx->current->next;
                pragma_skip_blanks(ctx);

                // This is not working because this information needs to be in the AST. 
                // because it is used in a second step.
                bool onoff = false;
                if (ctx->current && strcmp(ctx->current->lexeme, "ON") == 0)
                {
                    onoff = true;
                }
                else if (ctx->current && strcmp(ctx->current->lexeme, "OFF") == 0)
                {
                    onoff = false;
                }
                else
                {
                    compiler_diagnostic(C_ERROR_PRAGMA_ERROR, ctx, ctx->current, NULL, "nullchecks pragma needs to use ON OFF");
                }
                ctx->options.null_checks_enabled = onoff;
            }

            if (ctx->current && strcmp(ctx->current->lexeme, "diagnostic") == 0)
            {
                ctx->current = ctx->current->next;
                pragma_skip_blanks(ctx);

                if (ctx->current && strcmp(ctx->current->lexeme, "push") == 0)
                {
                    // #pragma GCC diagnostic push
                    if (ctx->options.diagnostic_stack.top_index <
                        sizeof(ctx->options.diagnostic_stack) / sizeof(ctx->options.diagnostic_stack.stack[0]))
                    {
                        ctx->options.diagnostic_stack.top_index++;
                        ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] =
                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index - 1];
                    }
                    ctx->current = ctx->current->next;
                    pragma_skip_blanks(ctx);
                }
                else if (ctx->current && strcmp(ctx->current->lexeme, "pop") == 0)
                {
                    // #pragma CAKE diagnostic pop
                    if (ctx->options.diagnostic_stack.top_index > 0)
                    {
                        ctx->options.diagnostic_stack.top_index--;
                    }
                    ctx->current = ctx->current->next;
                    pragma_skip_blanks(ctx);
                }
                else if (ctx->current &&
                    (strcmp(ctx->current->lexeme, "error") == 0 ||
                        strcmp(ctx->current->lexeme, "warning") == 0 ||
                        strcmp(ctx->current->lexeme, "note") == 0 ||
                        strcmp(ctx->current->lexeme, "ignored") == 0))
                {
                    const bool is_error = strcmp(ctx->current->lexeme, "error") == 0;
                    const bool is_warning = strcmp(ctx->current->lexeme, "warning") == 0;
                    const bool is_note = strcmp(ctx->current->lexeme, "note") == 0;

                    ctx->current = ctx->current->next;
                    pragma_skip_blanks(ctx);

                    if (ctx->current && ctx->current->type == TK_STRING_LITERAL)
                    {
                        unsigned long long w = get_warning_bit_mask(ctx->current->lexeme + 1 /*+ 2*/);

                        ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
                        ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
                        ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

                        if (is_error)
                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors |= w;
                        else if (is_warning)
                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings |= w;
                        else if (is_note)
                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes |= w;
                    }
                }
                else if (ctx->current &&
                    (strcmp(ctx->current->lexeme, "check") == 0))
                {
                    // TODO better name .  Ack. : means ‘alarm acknowledged’ ?
                    ctx->current = ctx->current->next;
                    pragma_skip_blanks(ctx);

                    if (ctx->current && ctx->current->type == TK_STRING_LITERAL)
                    {
                        enum diagnostic_id id = get_warning(ctx->current->lexeme + 1 + 2);
                        bool found = false;
                        for (int i = 0;
                             i < (int)(sizeof(ctx->p_report->last_diagnostics_ids) / sizeof(ctx->p_report->last_diagnostics_ids[0]));
                             i++)
                        {
                            if (ctx->p_report->last_diagnostics_ids[i] == 0) break;

                            if (ctx->p_report->last_diagnostics_ids[i] == id)
                            {
                                found = true;
                                // lets remove this error/warning/info from the final report.

                                int t =
                                    get_diagnostic_type(&ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index],
                                        id);
                                if (t == 3)
                                    ctx->p_report->error_count--;
                                else if (t == 2)
                                    ctx->p_report->warnings_count--;
                                else if (t == 1)
                                    ctx->p_report->info_count--;

                                break;
                            }
                        }

                        if (!found)
                        {
                            compiler_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "pragma check failed");
                        }
                    }
                }
                else
                {
                    compiler_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "unknown pragma");
                }
            }
        }
    }
    catch
    {
    }
}

static void parser_skip_blanks(struct parser_ctx* ctx)
{
    while (ctx->current && !(ctx->current->flags & TK_FLAG_FINAL))
    {
        if (ctx->current->type == TK_PRAGMA)
        {
            /*only active block have TK_PRAGMA*/
            parse_pragma(ctx, ctx->current);
        }

        if (ctx->current)
            ctx->current = ctx->current->next;
    }

    if (ctx->current)
    {
        token_promote(ctx, ctx->current); // transform to parser token
    }
}

void parser_match(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return;

    ctx->previous = ctx->current;
    ctx->current = ctx->current->next;
    parser_skip_blanks(ctx);
}

void unexpected_end_of_file(struct parser_ctx* ctx)
{
    compiler_diagnostic(C_ERROR_UNEXPECTED_TOKEN, ctx, ctx->input_list.tail, NULL, "unexpected end of file");
}

NODISCARD
int parser_match_tk(struct parser_ctx* ctx, enum token_type type)
{
    int error = 0;
    if (ctx->current != NULL)
    {
        if (ctx->current->type != type)
        {
            compiler_diagnostic(C_ERROR_UNEXPECTED_TOKEN, ctx, ctx->current, NULL, "expected %s", get_token_name(type));
            error = 1;
        }

        ctx->previous = ctx->current;
        ctx->current = ctx->current->next;
        parser_skip_blanks(ctx);
    }
    else
    {
        compiler_diagnostic(C_ERROR_UNEXPECTED_TOKEN, ctx, ctx->input_list.tail, NULL, "unexpected end of file after");
        error = 1;
    }

    return error;
}

void print_declaration_specifiers(struct osstream* ss, struct declaration_specifiers* p_declaration_specifiers)
{
    bool first = true;
    print_type_qualifier_flags(ss, &first, p_declaration_specifiers->type_qualifier_flags);

    if (p_declaration_specifiers->enum_specifier)
    {

        if (p_declaration_specifiers->enum_specifier->tag_token)
        {
            ss_fprintf(ss, "enum %s", p_declaration_specifiers->enum_specifier->tag_token->lexeme);
        }
        else
        {
            assert(false);
        }
    }
    else if (p_declaration_specifiers->struct_or_union_specifier)
    {
        ss_fprintf(ss, "struct %s", p_declaration_specifiers->struct_or_union_specifier->tag_name);
    }
    else if (p_declaration_specifiers->typedef_declarator)
    {
        if (p_declaration_specifiers->typedef_declarator->name_opt)
            print_item(ss, &first, p_declaration_specifiers->typedef_declarator->name_opt->lexeme);
    }
    else
    {
        print_type_specifier_flags(ss, &first, p_declaration_specifiers->type_specifier_flags);
    }
}

bool type_specifier_is_integer(enum type_specifier_flags flags)
{
    if ((flags & TYPE_SPECIFIER_CHAR) ||
        (flags & TYPE_SPECIFIER_SHORT) ||
        (flags & TYPE_SPECIFIER_INT) ||
        (flags & TYPE_SPECIFIER_LONG) ||
        (flags & TYPE_SPECIFIER_INT) ||
        (flags & TYPE_SPECIFIER_INT8) ||
        (flags & TYPE_SPECIFIER_INT16) ||
        (flags & TYPE_SPECIFIER_INT32) ||
        (flags & TYPE_SPECIFIER_INT64) ||
        (flags & TYPE_SPECIFIER_LONG_LONG))
    {
        return true;
    }
    return false;
}

int final_specifier(struct parser_ctx* ctx, enum type_specifier_flags* flags)
{
    if (((*flags) & TYPE_SPECIFIER_UNSIGNED) ||
        ((*flags) & TYPE_SPECIFIER_SIGNED))
    {
        //TODO leave as it is..and check at comparison 
        if (!type_specifier_is_integer(*flags))
        {
            // if you didn't specify anything, it becomes integer
            (*flags) |= TYPE_SPECIFIER_INT;
        }
    }

    return 0;
}

int add_specifier(struct parser_ctx* ctx,
    enum type_specifier_flags* flags,
    enum type_specifier_flags new_flag)
{
    /*
        transform the sequence of two longs
        in
        TYPE_SPECIFIER_LONG_LONG
    */
    if (new_flag & TYPE_SPECIFIER_LONG) // adding a long
    {
        if ((*flags) & TYPE_SPECIFIER_LONG_LONG) // ja tinha long long
        {
            compiler_diagnostic(C_ERROR_CANNOT_COMBINE_WITH_PREVIOUS_LONG_LONG, ctx, ctx->current, NULL, "cannot combine with previous 'long long' declaration specifier");
            return 1;
        }
        else if ((*flags) & TYPE_SPECIFIER_LONG) // ja tinha um long
        {
            (*flags) = (*flags) & ~TYPE_SPECIFIER_LONG;
            (*flags) |= TYPE_SPECIFIER_LONG_LONG;
        }
        else // nao tinha nenhum long
        {
            (*flags) = (*flags) & ~TYPE_SPECIFIER_INT;
            (*flags) |= TYPE_SPECIFIER_LONG;
        }
    }
    else
    {
        (*flags) |= new_flag;
    }

    //Following 6.7.2 we check possible combinations
    switch ((unsigned int)*flags)
    {
    case TYPE_SPECIFIER_NONE:  //void
    case TYPE_SPECIFIER_VOID:  //void
    case TYPE_SPECIFIER_GCC__BUILTIN_VA_LIST:
    case TYPE_SPECIFIER_CHAR:  //char
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_CHAR:  //signed char
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_CHAR:  //unsigned char
    case TYPE_SPECIFIER_SHORT:  //short
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_SHORT:  //signed short
    case TYPE_SPECIFIER_SHORT | TYPE_SPECIFIER_INT:  //short int
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_SHORT | TYPE_SPECIFIER_INT:  //signed short int
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_SHORT:  //unsigned short 
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_SHORT | TYPE_SPECIFIER_INT:  //unsigned short int
    case TYPE_SPECIFIER_INT:  //int
    case TYPE_SPECIFIER_SIGNED:  //signed
    case TYPE_SPECIFIER_INT | TYPE_SPECIFIER_SIGNED:  //int signed
    case TYPE_SPECIFIER_UNSIGNED:  //signed
    case TYPE_SPECIFIER_INT | TYPE_SPECIFIER_UNSIGNED:  //int unsigned
    case TYPE_SPECIFIER_LONG:  //long
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_LONG:  //signed long
    case TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_INT:  //long int
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_INT:  //signed long int
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_LONG:  //unsigned long
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_INT:  //unsigned long int
    case TYPE_SPECIFIER_LONG_LONG:  //long long
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_LONG_LONG:  //signed long long
    case TYPE_SPECIFIER_LONG_LONG | TYPE_SPECIFIER_INT:  //long long int
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_LONG_LONG | TYPE_SPECIFIER_INT:  //signed long long
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_LONG_LONG:  //unsigned long long
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_LONG_LONG | TYPE_SPECIFIER_INT:  //unsigned long long int
        // _BitInt constant-expression, or signed _BitInt constant-expression        
        // unsigned _BitInt constant-expression
    case TYPE_SPECIFIER_FLOAT:  //float
    case TYPE_SPECIFIER_DOUBLE:  //double
    case TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_DOUBLE:  //long double
    case TYPE_SPECIFIER_DECIMAL32:  //_Decimal32
    case TYPE_SPECIFIER_DECIMAL64:  //_Decimal64
    case TYPE_SPECIFIER_DECIMAL128:  //_Decimal128
    case TYPE_SPECIFIER_BOOL:  //bool
    case TYPE_SPECIFIER_COMPLEX | TYPE_SPECIFIER_FLOAT:  //complex float
    case TYPE_SPECIFIER_COMPLEX | TYPE_SPECIFIER_DOUBLE:  //complex double
    case TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_COMPLEX | TYPE_SPECIFIER_DOUBLE:  //complex long double        
    case TYPE_SPECIFIER_ATOMIC:  //complex long double
    case TYPE_SPECIFIER_STRUCT_OR_UNION:  //complex long double
    case TYPE_SPECIFIER_ENUM:  //complex long double
    case TYPE_SPECIFIER_TYPEOF:  //typeof        
    case TYPE_SPECIFIER_TYPEDEF:

    case TYPE_SPECIFIER_INT8:
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT8:

    case TYPE_SPECIFIER_INT16:
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT16:
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_INT16:
    case TYPE_SPECIFIER_INT32:
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT32:
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_INT32:
    case TYPE_SPECIFIER_INT64:
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT64:
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_INT64:
        //VALID
        break;
    default:
        compiler_diagnostic(C_ERROR_TWO_OR_MORE_SPECIFIERS, ctx, ctx->current, NULL, "incompatible specifiers");
        return 1;
    }

    return 0;
}

void declaration_specifiers_delete(struct declaration_specifiers* _Owner _Opt p)
{
    if (p)
    {
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence_opt);

        struct declaration_specifier* _Owner _Opt item = p->head;
        while (item)
        {
            struct declaration_specifier* _Owner _Opt next = item->next;
            item->next = NULL;
            declaration_specifier_delete(item);
            item = next;
        }
        free(p);
    }
}

void declaration_specifiers_add(struct declaration_specifiers* list, struct declaration_specifier* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

struct declaration_specifiers* _Owner _Opt declaration_specifiers(struct parser_ctx* ctx,
    enum storage_class_specifier_flags default_storage_flag)
{
    /*
        declaration-specifiers:
          declaration-specifier attribute-specifier-sequence_opt
          declaration-specifier declaration-specifiers
    */

    /*
     Ao fazer parser do segundo o X ja existe mas ele nao deve ser usado
     typedef char X;
     typedef char X;
    */

    if (ctx->current == NULL)
        return NULL;

    _Opt struct declaration_specifiers* _Owner _Opt p_declaration_specifiers = calloc(1, sizeof(struct declaration_specifiers));

    try
    {
        if (p_declaration_specifiers == NULL)
            throw;

        p_declaration_specifiers->first_token = ctx->current;

        while (first_of_declaration_specifier(ctx))
        {
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->flags & TK_FLAG_IDENTIFIER_IS_TYPEDEF)
            {
                if (p_declaration_specifiers->type_specifier_flags != TYPE_SPECIFIER_NONE)
                {
                    // typedef tem que aparecer sozinho
                    // exemplo Socket eh nome e nao typdef
                    // typedef int Socket;
                    // struct X {int Socket;};
                    break;
                }
            }

            struct declaration_specifier* _Owner _Opt p_declaration_specifier = declaration_specifier(ctx);
            if (p_declaration_specifier == NULL) throw;

            if (p_declaration_specifier->type_specifier_qualifier)
            {
                if (p_declaration_specifier->type_specifier_qualifier->type_specifier)
                {
                    if (add_specifier(ctx,
                        &p_declaration_specifiers->type_specifier_flags,
                        p_declaration_specifier->type_specifier_qualifier->type_specifier->flags) != 0)
                    {
                        //not fatal error
                    }

                    if (p_declaration_specifier->type_specifier_qualifier->type_specifier->struct_or_union_specifier)
                    {
                        p_declaration_specifiers->struct_or_union_specifier = p_declaration_specifier->type_specifier_qualifier->type_specifier->struct_or_union_specifier;
                    }
                    else if (p_declaration_specifier->type_specifier_qualifier->type_specifier->enum_specifier)
                    {
                        p_declaration_specifiers->enum_specifier = p_declaration_specifier->type_specifier_qualifier->type_specifier->enum_specifier;
                    }
                    else if (p_declaration_specifier->type_specifier_qualifier->type_specifier->typeof_specifier)
                    {
                        p_declaration_specifiers->typeof_specifier = p_declaration_specifier->type_specifier_qualifier->type_specifier->typeof_specifier;
                    }
                    else if (p_declaration_specifier->type_specifier_qualifier->type_specifier->token->type == TK_IDENTIFIER)
                    {
                        p_declaration_specifiers->typedef_declarator =
                            find_declarator(ctx,
                                p_declaration_specifier->type_specifier_qualifier->type_specifier->token->lexeme,
                                NULL);

                        // p_declaration_specifiers->typedef_declarator = p_declaration_specifier->type_specifier_qualifier->pType_specifier->token->lexeme;
                    }
                }
                else if (p_declaration_specifier->type_specifier_qualifier->alignment_specifier)
                {
                    p_declaration_specifiers->alignment_specifier_flags =
                        p_declaration_specifier->type_specifier_qualifier->alignment_specifier->flags;

                }
                else if (p_declaration_specifier->type_specifier_qualifier->type_qualifier)
                {
                    p_declaration_specifiers->type_qualifier_flags |= p_declaration_specifier->type_specifier_qualifier->type_qualifier->flags;
                }
            }
            else if (p_declaration_specifier->storage_class_specifier)
            {
                p_declaration_specifiers->storage_class_specifier_flags |= p_declaration_specifier->storage_class_specifier->flags;
            }
            else if (p_declaration_specifier->function_specifier)
            {
                p_declaration_specifiers->function_specifier_flags |= p_declaration_specifier->function_specifier->flags;
            }
            else if (p_declaration_specifier->alignment_specifier)
            {
                p_declaration_specifiers->alignment_specifier_flags |= p_declaration_specifier->alignment_specifier->flags;
            }

            declaration_specifiers_add(p_declaration_specifiers, p_declaration_specifier);

            if (p_declaration_specifiers->p_attribute_specifier_sequence_opt == NULL)
            {
                attribute_specifier_sequence_delete(p_declaration_specifiers->p_attribute_specifier_sequence_opt);
                p_declaration_specifiers->p_attribute_specifier_sequence_opt = NULL;//
            }

            p_declaration_specifiers->p_attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->type == TK_IDENTIFIER &&
                p_declaration_specifiers->type_specifier_flags != TYPE_SPECIFIER_NONE)
            {
                // typedef nao pode aparecer com outro especifier
                // entao ja tem tem algo e vier identifier signfica que acabou
                // exemplo
                /*
                 typedef char X;
                 typedef char X;
                */
                break;
            }
        }

        struct token* _Opt prev = previous_parser_token(ctx->current);
        if (prev == NULL)
            throw;

        p_declaration_specifiers->last_token = prev;

        // int main() { static int i; } // i is not automatic
        final_specifier(ctx, &p_declaration_specifiers->type_specifier_flags);

        p_declaration_specifiers->storage_class_specifier_flags |= default_storage_flag;
    }
    catch
    {
        declaration_specifiers_delete(p_declaration_specifiers);
        p_declaration_specifiers = NULL;
    }
    return p_declaration_specifiers;
}

struct declaration* _Owner _Opt declaration_core(struct parser_ctx* ctx,
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt /*SINK*/,
    bool can_be_function_definition,
    bool* is_function_definition,
    enum storage_class_specifier_flags default_storage_class_specifier_flags,
    bool without_semicolon)
{
    /*
                                  declaration-specifiers init-declarator-list_opt ;
     attribute-specifier-sequence declaration-specifiers init-declarator-list ;
     static_assert-declaration
     attribute-declaration
  */

    struct declaration* _Owner _Opt p_declaration = NULL;

    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_declaration = calloc(1, sizeof(struct declaration));
        if (p_declaration == NULL)
        {
            throw;
        }

        p_declaration->p_attribute_specifier_sequence_opt = p_attribute_specifier_sequence_opt;
        p_attribute_specifier_sequence_opt = NULL; /*MOVED*/

        p_declaration->first_token = ctx->current;

        if (ctx->current->type == ';')
        {
            p_declaration->last_token = ctx->current;
            parser_match(ctx);
            // empty declaration
            return p_declaration;
        }

        if (first_of_static_assert_declaration(ctx))
        {
            p_declaration->static_assert_declaration = static_assert_declaration(ctx);
        }
        else if (first_of_pragma_declaration(ctx))
        {
            p_declaration->pragma_declaration = pragma_declaration(ctx);
        }
        else
        {

            if (first_of_declaration_specifier(ctx))
            {
                p_declaration->declaration_specifiers = declaration_specifiers(ctx, default_storage_class_specifier_flags);
                if (p_declaration->declaration_specifiers == NULL) throw;

                if (p_declaration->p_attribute_specifier_sequence_opt)
                {
                    p_declaration->declaration_specifiers->attributes_flags =
                        p_declaration->p_attribute_specifier_sequence_opt->attributes_flags;

                    p_declaration->declaration_specifiers->msvc_declspec_flags =
                        p_declaration->p_attribute_specifier_sequence_opt->msvc_declspec_flags;
                }

                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    throw;
                }

                if (ctx->current->type != ';')
                {
                    p_declaration->init_declarator_list = init_declarator_list(ctx,
                        p_declaration->declaration_specifiers);

                    if (p_declaration->init_declarator_list.head == NULL)
                        throw;
                }

                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    throw;
                }

                p_declaration->last_token = ctx->current;

                if (ctx->current->type == '{')
                {
                    if (can_be_function_definition)
                        *is_function_definition = true;
                }
#if EXPERIMENTAL_CONTRACTS
                else if (ctx->current->type == TK_KEYWORD_TRUE ||
                         ctx->current->type == TK_KEYWORD_FALSE ||
                         ctx->current->type == TK_IDENTIFIER)
                {
                    if (can_be_function_definition)
                        *is_function_definition = true;
                }
#endif
                else
                {
                    if (!without_semicolon && parser_match_tk(ctx, ';') != 0)
                        throw;
                }
            }
            else
            {
                if (ctx->current->type == TK_IDENTIFIER)
                {
                    compiler_diagnostic(C_ERROR_INVALID_TYPE, ctx, ctx->current, NULL, "invalid type '%s'", ctx->current->lexeme);
                }
                else
                {
                    compiler_diagnostic(C_ERROR_EXPECTED_DECLARATION, ctx, ctx->current, NULL, "expected declaration not '%s'", ctx->current->lexeme);
                }
                parser_match(ctx); // we need to go ahead
            }
        }
    }
    catch
    {
        declaration_delete(p_declaration);
        p_declaration = NULL;
    }

    attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);

    return p_declaration;
}

struct declaration* _Owner _Opt declaration(struct parser_ctx* ctx,
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt,
    enum storage_class_specifier_flags storage_specifier_flags,
    bool extern_declaration);

struct declaration* _Owner _Opt function_definition_or_declaration(struct parser_ctx* ctx)
{
    return declaration(ctx, NULL, STORAGE_SPECIFIER_NONE, true);
    /*
     function-definition:
        attribute-specifier-sequence _Opt declaration-specifiers declarator function-body
    */

    /*
      declaration:
        declaration-specifiers                              init-declarator-list opt ;
        attribute-specifier-sequence declaration-specifiers init-declarator-list ;
        static_assert-declaration
        attribute-declaration
    */

}

struct simple_declaration* _Owner _Opt simple_declaration(struct parser_ctx* ctx,
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt,
    bool ignore_semicolon)
{

    if (ctx->current == NULL)
    {
        unexpected_end_of_file(ctx);
        attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);
        return NULL;
    }

    enum storage_class_specifier_flags storage_specifier_flags = STORAGE_SPECIFIER_BLOCK_SCOPE;
    /*
      simple-declaration:
      declaration-specifiers init-declarator-list _Opt ;
      attribute-specifier-sequence declaration-specifiers init-declarator-list ;
    */

    struct simple_declaration* _Owner _Opt p_simple_declaration = calloc(1, sizeof(struct simple_declaration));

    try
    {
        if (p_simple_declaration == NULL)
            throw;

        p_simple_declaration->first_token = ctx->current;

        p_simple_declaration->p_attribute_specifier_sequence_opt = p_attribute_specifier_sequence_opt;
        p_attribute_specifier_sequence_opt = NULL; /*MOVED*/

        struct declaration_specifiers* _Owner _Opt ptemp = declaration_specifiers(ctx, storage_specifier_flags);
        if (ptemp == NULL) throw;

        p_simple_declaration->p_declaration_specifiers = ptemp;

        if (p_simple_declaration->p_attribute_specifier_sequence_opt)
        {
            p_simple_declaration->p_declaration_specifiers->attributes_flags =
                p_simple_declaration->p_attribute_specifier_sequence_opt->attributes_flags;
        }

        p_simple_declaration->init_declarator_list = init_declarator_list(ctx, p_simple_declaration->p_declaration_specifiers);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        struct token* _Opt prev = previous_parser_token(ctx->current);
        if (prev == NULL) throw;

        p_simple_declaration->last_token = prev;

        if (!ignore_semicolon && parser_match_tk(ctx, ';') != 0) throw;
    }
    catch
    {
        simple_declaration_delete(p_simple_declaration);
        p_simple_declaration = NULL;
    }

    attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);

    return p_simple_declaration;
}

static void check_unused_parameters(struct parser_ctx* ctx, struct parameter_list* parameter_list)
{
    struct parameter_declaration* _Opt parameter = NULL;
    parameter = parameter_list->head;

    while (parameter)
    {
        if (!type_is_maybe_unused(&parameter->declarator->type) &&
            parameter->declarator &&
            parameter->declarator->num_uses == 0)
        {
            if (parameter->declarator->name_opt &&
                parameter->declarator->name_opt->level == 0 /*direct source*/
                )
            {
                compiler_diagnostic(W_UNUSED_PARAMETER,
                    ctx,
                    parameter->declarator->name_opt, NULL,
                    "'%s': unreferenced formal parameter",
                    parameter->declarator->name_opt->lexeme);
            }
        }
        parameter = parameter->next;
    }
}

struct declaration* _Owner _Opt declaration(struct parser_ctx* ctx,
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt00,
    enum storage_class_specifier_flags storage_specifier_flags,
    bool extern_declaration)
{
    struct declaration* _Owner _Opt p_declaration = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt =
            attribute_specifier_sequence_opt(ctx);

        bool is_function_definition = false;

        p_declaration = declaration_core(ctx, p_attribute_specifier_sequence_opt, true, &is_function_definition, storage_specifier_flags, false);
        if (p_declaration == NULL)
            throw;

        if (is_function_definition)
        {

            if (p_declaration->init_declarator_list.head == NULL ||
                p_declaration->init_declarator_list.head->p_declarator->direct_declarator == NULL ||
                p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator == NULL)
            {
                compiler_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "unexpected");
                throw; //unexpected
            }

            struct declarator* p_declarator =
                p_declaration->init_declarator_list.head->p_declarator;


            //ctx->p_current_function_opt = p_declaration->init_declarator_list.head->p_declarator;

            /*
                scope of parameters is the inner declarator

                void (*f(int i))(void) {
                    i = 1;
                    return 0;
                }
            */

            assert(p_declaration->init_declarator_list.head != NULL); //because functions definitions have names

            struct declarator* inner = p_declaration->init_declarator_list.head->p_declarator;
            for (;;)
            {
                if (inner->direct_declarator &&
                    inner->direct_declarator->function_declarator &&
                    inner->direct_declarator->function_declarator->direct_declarator &&
                    inner->direct_declarator->function_declarator->direct_declarator->declarator)
                {
                    inner = inner->direct_declarator->function_declarator->direct_declarator->declarator;
                }
                else
                    break;
            }


            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            check_func_open_brace_style(ctx, ctx->current);

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;

            }
            struct diagnostic before_function_diagnostics = ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index];
#if EXPERIMENTAL_CONTRACTS


            if (ctx->current->type == TK_KEYWORD_TRUE ||
                ctx->current->type == TK_KEYWORD_FALSE ||
                ctx->current->type == TK_IDENTIFIER)
            {
                for (;;)
                {
                    if (ctx->current == NULL)
                    {
                        unexpected_end_of_file(ctx);
                        throw;
                    }

                    enum token_type type = ctx->current->type;
                    if (type != TK_KEYWORD_TRUE &&
                        type != TK_KEYWORD_FALSE &&
                        type != TK_IDENTIFIER)
                    {
                        throw;
                    }
                    parser_match(ctx); //true
                    parser_match(ctx); //(

                    if (type != TK_KEYWORD_FALSE)
                    {
                        assert(p_declarator->p_expression_true == NULL);
                        p_declarator->p_expression_true = expression(ctx);
                    }
                    else
                    {
                        assert(p_declarator->p_expression_false == NULL);
                        p_declarator->p_expression_false = expression(ctx);
                    }
                    parser_match(ctx); //)

                    if (ctx->current == NULL)
                    {
                        unexpected_end_of_file(ctx);
                        throw;
                    }

                    if (ctx->current->type != ',')
                        break;

                    parser_match(ctx); //)
                }
            }
#endif
            struct declarator* _Opt p_current_function_opt = ctx->p_current_function_opt;
            ctx->p_current_function_opt = p_declarator;


            struct scope* parameters_scope = &inner->direct_declarator->function_declarator->parameters_scope;
            scope_list_push(&ctx->scopes, parameters_scope);

            struct scope* _Opt p_current_function_scope_opt = ctx->p_current_function_scope_opt;
            ctx->p_current_function_scope_opt = ctx->scopes.tail;

            struct compound_statement* _Owner _Opt p_function_body = function_body(ctx);

            ctx->p_current_function_scope_opt = p_current_function_scope_opt; //restore
            ctx->p_current_function_opt = p_current_function_opt; //restore
            scope_list_pop(&ctx->scopes);

            if (p_function_body == NULL)
                throw;

            assert(p_declaration->function_body == NULL);
            p_declaration->function_body = p_function_body;
            p_declaration->init_declarator_list.head->p_declarator->function_body = p_declaration->function_body;

            if (p_declaration->init_declarator_list.head &&
                p_declaration->init_declarator_list.head->p_declarator->direct_declarator &&
                p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator &&
                p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator->parameter_type_list_opt &&
                p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator->parameter_type_list_opt->parameter_list)
            {
                check_unused_parameters(ctx, p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator->parameter_type_list_opt->parameter_list);
            }

            if (p_declaration->function_body)
            {
                /*
                   Now we have the function body, let's see if we had a previous
                   function body.
                */
                const char* func_name =
                    p_declaration->init_declarator_list.head->p_declarator->name_opt->lexeme;

                struct scope* _Opt p_previous_scope = NULL;
                struct declarator* _Opt p_previous_declarator = find_declarator(ctx, func_name, &p_previous_scope);
                if (p_previous_declarator && p_previous_declarator != p_declaration->init_declarator_list.head->p_declarator)
                {
                    p_previous_declarator->p_complete_declarator = p_declaration->init_declarator_list.head->p_declarator;

                    struct scope* p_current_scope = ctx->scopes.tail;
                    if (p_current_scope == p_previous_scope) //same function
                    {
                        if (p_previous_declarator->function_body)
                        {
                            compiler_diagnostic(
                                 C_ERROR_REDECLARATION,
                                 ctx,
                                 p_declaration->init_declarator_list.head->p_declarator->name_opt,
                                 NULL,
                                 "function redefinition");

                            compiler_diagnostic(W_LOCATION,
                                ctx,
                                p_previous_declarator->name_opt,
                                NULL,
                                "previous definition");
                        }
                        else
                        {
                            //If we want to point the the declarator that has the function body
                            //previous->p_declarator_with_function_body = p_declaration->init_declarator_list.head->p_declarator;
                        }
                    }
                }
            }

            if (extern_declaration)
            {
                struct defer_visit_ctx ctx2 = { .ctx = ctx };
                defer_start_visit_declaration(&ctx2, p_declaration);
                defer_visit_ctx_destroy(&ctx2);

                if (ctx->options.flow_analysis)
                {
                    /*
                     Now we have the full function AST let´s visit to Analise
                     jumps
                    */

                    /*we are going to visit the function again.. lets put the same diagnostic state*/
                    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] = before_function_diagnostics;

                    struct flow_visit_ctx ctx3 = { 0 };
                    ctx3.ctx = ctx;
                    flow_start_visit_declaration(&ctx3, p_declaration);
                    flow_visit_ctx_destroy(&ctx3);
                }
            }

        }
        else
        {
            if (ctx->options.flow_analysis && extern_declaration)
            {
                _Opt struct flow_visit_ctx ctx2 = { 0 };
                ctx2.ctx = ctx;
                flow_start_visit_declaration(&ctx2, p_declaration);
                flow_visit_ctx_destroy(&ctx2);
            }
        }
    }
    catch
    {
        declaration_delete(p_declaration);
        p_declaration = NULL;
    }

    return p_declaration;

    //bool is_function_definition = false;
    //return declaration_core(ctx, p_attribute_specifier_sequence_opt, false, &is_function_definition, storage_specifier_flags, false);
}

//(6.7) declaration-specifiers:
// declaration-specifier attribute-specifier-sequenceopt
// declaration-specifier declaration-specifiers

void declaration_specifier_delete(struct declaration_specifier* _Owner _Opt p)
{
    if (p)
    {
        free(p->function_specifier);
        type_specifier_qualifier_delete(p->type_specifier_qualifier);
        free(p->storage_class_specifier);
        assert(p->next == NULL);
        free(p);
    }
}

struct declaration_specifier* _Owner _Opt declaration_specifier(struct parser_ctx* ctx)
{
    //    storage-class-specifier
    //    type-specifier-qualifier
    //    function-specifier

    struct declaration_specifier* _Owner _Opt p_declaration_specifier = NULL;
    try
    {
        p_declaration_specifier = calloc(1, sizeof * p_declaration_specifier);
        if (p_declaration_specifier == NULL)
            throw;

        if (first_of_storage_class_specifier(ctx))
        {
            p_declaration_specifier->storage_class_specifier = storage_class_specifier(ctx);
            if (p_declaration_specifier->storage_class_specifier == NULL) throw;
        }
        else if (first_of_type_specifier_qualifier(ctx))
        {
            p_declaration_specifier->type_specifier_qualifier = type_specifier_qualifier(ctx);
            if (p_declaration_specifier->type_specifier_qualifier == NULL) throw;
        }
        else if (first_of_function_specifier(ctx))
        {
            p_declaration_specifier->function_specifier = function_specifier(ctx);
            if (p_declaration_specifier->function_specifier == NULL) throw;
        }
        else
        {
            compiler_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "unexpected");
        }
    }
    catch
    {
        declaration_specifier_delete(p_declaration_specifier);
        p_declaration_specifier = NULL;
    }

    return p_declaration_specifier;
}

struct init_declarator* _Owner init_declarator_add_ref(struct init_declarator* p)
{
    p->has_shared_ownership = true;
    return (struct init_declarator* _Owner)p;
}


void init_declarator_sink(struct init_declarator* _Owner _Opt p) {}

void init_declarator_delete(struct init_declarator* _Owner _Opt p)
{
    if (p)
    {
        if (p->has_shared_ownership)
        {
            p->has_shared_ownership = false;
            init_declarator_sink(p);
            return;
        }

        initializer_delete(p->initializer);
        declarator_delete(p->p_declarator);
        assert(p->next == NULL);
        free(p);
    }
}


struct init_declarator* _Owner _Opt init_declarator(struct parser_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers)
{
    /*
     init-declarator:
       declarator
       declarator = initializer
    */

    struct init_declarator* _Owner _Opt p_init_declarator = NULL;
    try
    {
        p_init_declarator = calloc(1, sizeof(struct init_declarator));
        if (p_init_declarator == NULL)
            throw;

        struct token* _Opt tkname = NULL;

        {
            struct declarator* _Owner _Opt p_temp_declarator = declarator(ctx,
                NULL,
                p_declaration_specifiers,
                false,
                &tkname);
            if (p_temp_declarator == NULL) throw;
            p_init_declarator->p_declarator = p_temp_declarator;
        }

        if (tkname == NULL)
        {
            compiler_diagnostic(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "init declarator must have a name");
            throw;
        }

        p_init_declarator->p_declarator->declaration_specifiers = p_declaration_specifiers;
        p_init_declarator->p_declarator->name_opt = tkname;

        if (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_AUTO)
        {
            /*
              auto requires we find the type after initializer
            */
        }
        else
        {
            assert(p_init_declarator->p_declarator->type.type_specifier_flags == 0);
            p_init_declarator->p_declarator->type = make_type_using_declarator(ctx, p_init_declarator->p_declarator);
        }

        assert(p_init_declarator->p_declarator->declaration_specifiers != NULL);

        assert(ctx->scopes.tail != NULL);

        /*
          Checking naming conventions
        */
        if (ctx->scopes.tail->scope_level == 0)
        {
            naming_convention_global_var(ctx,
                tkname,
                &p_init_declarator->p_declarator->type,
                p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags);
        }

        /////////////////////////////////////////////////////////////////////////////
        const char* declarator_name = p_init_declarator->p_declarator->name_opt->lexeme;
        struct scope* _Opt out_scope = NULL;
        struct declarator* _Opt p_previous_declarator = find_declarator(ctx, declarator_name, &out_scope);
        if (p_previous_declarator)
        {
            p_init_declarator->p_declarator->p_complete_declarator = p_previous_declarator;
            assert(out_scope != NULL);
            assert(ctx->scopes.tail != NULL);

            if (out_scope->scope_level == ctx->scopes.tail->scope_level)
            {
                if (out_scope->scope_level == 0)
                {
                    /*
                    __C_ASSERT__ is failing..maybe because __builtin_offsetof is not implemented
                    */
                    if (strcmp(declarator_name, "__C_ASSERT__") != 0)
                    {
                        //TODO type_is_same needs changes see #164
                        if (!type_is_same(&p_previous_declarator->type, &p_init_declarator->p_declarator->type, false))
                        {
                            struct osstream ss = { 0 };
                            print_type_no_names(&ss, &p_previous_declarator->type, ctx->options.target);

                            compiler_diagnostic(
                                C_ERROR_REDECLARATION,
                                ctx,
                                ctx->current,
                                NULL,
                                "conflicting types for '%s' (%s)", declarator_name, ss.c_str);

                            ss_clear(&ss);
                            print_type_no_names(&ss, &p_init_declarator->p_declarator->type, ctx->options.target);

                            compiler_diagnostic(C_ERROR_REDECLARATION,
                                ctx,
                                p_previous_declarator->name_opt,
                                NULL,
                                "previous declaration (%s)", ss.c_str);
                            ss_close(&ss);
                        }
                    }
                }
                else
                {
                    compiler_diagnostic(C_ERROR_REDECLARATION, ctx, ctx->current, NULL, "redeclaration");
                    compiler_diagnostic(W_NOTE, ctx, p_previous_declarator->name_opt, NULL, "previous declaration");
                }
            }
            else
            {
                struct hash_item_set item = { 0 };
                item.p_init_declarator = init_declarator_add_ref(p_init_declarator);
                hashmap_set(&ctx->scopes.tail->variables, declarator_name, &item);
                hash_item_set_destroy(&item);

                /*global scope no warning...*/
                if (out_scope->scope_level != 0)
                {
                    /*but redeclaration at function scope we show warning*/
                    if (compiler_diagnostic(W_DECLARATOR_HIDE, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "declaration of '%s' hides previous declaration", declarator_name))
                    {
                        compiler_diagnostic(W_NOTE, ctx, p_previous_declarator->first_token_opt, NULL, "previous declaration is here");
                    }
                }
            }
        }
        else
        {
            /*first time we see this declarator*/
            struct hash_item_set item = { 0 };
            item.p_init_declarator = init_declarator_add_ref(p_init_declarator);
            hashmap_set(&ctx->scopes.tail->variables, declarator_name, &item);
            hash_item_set_destroy(&item);
        }
        /////////////////////////////////////////////////////////////////////////////


        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == '=')
        {
            const bool requires_constant_initialization =
                (ctx->p_current_function_opt == NULL) ||
                (p_declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_STATIC);

            parser_match(ctx);

            assert(p_init_declarator->initializer == NULL);
            p_init_declarator->initializer = initializer(ctx);

            if (p_init_declarator->initializer == NULL)
            {
                throw;
            }

            if (p_init_declarator->initializer->braced_initializer)
            {
                if (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_AUTO)
                {
                    compiler_diagnostic(C_ERROR_AUTO_NEEDS_SINGLE_DECLARATOR, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "'auto' requires a plain identifier");
                    throw;
                }


                int er = make_object(&p_init_declarator->p_declarator->type, &p_init_declarator->p_declarator->object);
                if (er != 0)
                {
                    compiler_diagnostic(C_ERROR_STRUCT_IS_INCOMPLETE, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "incomplete struct/union type");
                    throw;
                }



                const bool is_constant =
                    type_is_const_or_constexpr(&p_init_declarator->p_declarator->type);

                if (initializer_init_new(ctx,
                    &p_init_declarator->p_declarator->type,
                    &p_init_declarator->p_declarator->object,
                    p_init_declarator->initializer,
                    is_constant,
                    requires_constant_initialization) != 0)
                {
                    throw;
                }

                p_init_declarator->p_declarator->object.type.num_of_elements =
                    p_init_declarator->p_declarator->type.num_of_elements;
                //fixing the name of members?
            }
            else if (p_init_declarator->initializer->assignment_expression)
            {
                if (type_is_array(&p_init_declarator->p_declarator->type))
                {
                    const unsigned long long array_size_elements = p_init_declarator->p_declarator->type.num_of_elements;
                    if (array_size_elements == 0)
                    {
                        p_init_declarator->p_declarator->type.num_of_elements =
                            p_init_declarator->initializer->assignment_expression->type.num_of_elements;
                    }
                    else
                    {
                        if (p_init_declarator->initializer->assignment_expression->type.num_of_elements > array_size_elements)
                        {
                            if (p_init_declarator->p_declarator->first_token_opt)
                            {
                                compiler_diagnostic(W_ARRAY_SIZE, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "initializer for array is too long");
                            }
                        }
                    }
                }

                /*
                  Fixing the type of auto declarator
                */
                assert(p_init_declarator->p_declarator->declaration_specifiers != NULL);

                if (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_AUTO)
                {

                    if (p_init_declarator->p_declarator->direct_declarator &&
                        (p_init_declarator->p_declarator->direct_declarator->array_declarator != NULL ||
                            p_init_declarator->p_declarator->direct_declarator->function_declarator != NULL))
                    {
                        compiler_diagnostic(C_ERROR_AUTO_NEEDS_SINGLE_DECLARATOR, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "'auto' requires a plain identifier");
                        throw;
                    }

                    if (p_init_declarator->p_declarator->pointer != NULL)
                    {
                        compiler_diagnostic(C_ERROR_AUTO_NEEDS_SINGLE_DECLARATOR, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "'auto' requires a plain identifier");
                    }

                    struct type t = { 0 };

                    if (p_init_declarator->initializer->assignment_expression->expression_type == UNARY_EXPRESSION_ADDRESSOF)
                    {
                        t = type_dup(&p_init_declarator->initializer->assignment_expression->type);
                    }
                    else
                    {
                        struct type t2 = type_lvalue_conversion(&p_init_declarator->initializer->assignment_expression->type, ctx->options.null_checks_enabled);
                        type_swap(&t2, &t);
                        type_destroy(&t2);
                    }

                    type_remove_names(&t);
                    assert(t.name_opt == NULL);
                    t.name_opt = strdup(p_init_declarator->p_declarator->name_opt->lexeme);

                    type_set_qualifiers_using_declarator(&t, p_init_declarator->p_declarator);

                    type_visit_to_mark_anonymous(&t);
                    type_swap(&p_init_declarator->p_declarator->type, &t);
                    type_destroy(&t);
                }

                check_assigment(ctx, &p_init_declarator->p_declarator->type, p_init_declarator->initializer->assignment_expression, ASSIGMENT_TYPE_INIT);

                const char* name2 = p_init_declarator->p_declarator->name_opt ?
                    p_init_declarator->p_declarator->name_opt->lexeme : "";

                int er = make_object_with_name(&p_init_declarator->p_declarator->type,
                    &p_init_declarator->p_declarator->object, name2);

                if (er != 0)
                {
                    throw;
                }

                const bool is_constant =
                    type_is_const_or_constexpr(&p_init_declarator->p_declarator->type);


                if (initializer_init_new(ctx,
                    &p_init_declarator->p_declarator->type,
                    &p_init_declarator->p_declarator->object,
                    p_init_declarator->initializer,
                    is_constant,
                    requires_constant_initialization) != 0)
                {
                    throw;
                }
                //object_print_to_debug(&p_init_declarator->p_declarator->object);
            }
        }
        else
        {
            if (p_init_declarator->p_declarator->type.category != TYPE_CATEGORY_FUNCTION &&
                !(p_init_declarator->p_declarator->type.storage_class_specifier_flags & STORAGE_SPECIFIER_TYPEDEF))
            {
                const char* name2 = p_init_declarator->p_declarator->name_opt ?
                    p_init_declarator->p_declarator->name_opt->lexeme : "";

                int er = make_object_with_name(&p_init_declarator->p_declarator->type,
                    &p_init_declarator->p_declarator->object,
                    name2);

                if (er != 0)
                {
                    if (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_EXTERN)
                    {
                        //extern struct X x;
                    }
                    else
                    {
                        compiler_diagnostic(C_ERROR_STRUCT_IS_INCOMPLETE, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "incomplete struct/union type");
                        throw;
                    }
                }

                if (type_is_const(&p_init_declarator->p_declarator->type))
                {
                    if (p_declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_TYPEDEF)
                    {
                        //no warning on typedefs
                    }
                    else
                    {
                        compiler_diagnostic(W_CONST_NOT_INITIALIZED,
                            ctx,
                            p_init_declarator->p_declarator->first_token_opt, NULL,
                            "const object should be initialized");
                    }
                }
            }
        }

        /*
           checking usage of [static ] other than in function arguments
        */
        if (p_init_declarator->p_declarator)
        {
            if (type_is_array(&p_init_declarator->p_declarator->type))
                if (p_init_declarator->p_declarator->type.type_qualifier_flags != 0 ||
                    p_init_declarator->p_declarator->type.has_static_array_size)
                {
                    if (p_init_declarator->p_declarator->first_token_opt)
                    {
                        compiler_diagnostic(C_ERROR_STATIC_OR_TYPE_QUALIFIERS_NOT_ALLOWED_IN_NON_PARAMETER,
                            ctx,
                            p_init_declarator->p_declarator->first_token_opt, NULL,
                            "static or type qualifiers are not allowed in non-parameter array declarator");
                    }
                    else if (p_init_declarator->initializer)
                    {
                        compiler_diagnostic(C_ERROR_STATIC_OR_TYPE_QUALIFIERS_NOT_ALLOWED_IN_NON_PARAMETER,
                        ctx,
                        p_init_declarator->initializer->first_token, NULL,
                        "static or type qualifiers are not allowed in non-parameter array declarator");
                    }
                }

            if (!type_is_pointer(&p_init_declarator->p_declarator->type) &&
                p_init_declarator->p_declarator->type.type_qualifier_flags & TYPE_QUALIFIER_DTOR)
            {
                if (p_init_declarator->p_declarator->first_token_opt)
                {
                    compiler_diagnostic(C_ERROR_OBJ_OWNER_CAN_BE_USED_ONLY_IN_POINTER,
                        ctx,
                        p_init_declarator->p_declarator->first_token_opt, NULL,
                        "_Dtor qualifier can only be used with pointers");
                }
                else if (p_init_declarator->initializer)
                {
                    compiler_diagnostic(C_ERROR_OBJ_OWNER_CAN_BE_USED_ONLY_IN_POINTER,
                    ctx,
                    p_init_declarator->initializer->first_token, NULL,
                    "_Dtor qualifier can only be used with pointers");
                }
            }
        }

        if (
            !(p_init_declarator->p_declarator->type.storage_class_specifier_flags & STORAGE_SPECIFIER_TYPEDEF) &&
            !type_is_function(&p_init_declarator->p_declarator->type))
        {

            if (type_is_vla(&p_init_declarator->p_declarator->type))
            {
            }
            else if (type_is_function(&p_init_declarator->p_declarator->type))
            {
                compiler_diagnostic(C_ERROR_STORAGE_SIZE,
                  ctx,
                  p_init_declarator->p_declarator->name_opt, NULL,
                  "invalid application of 'sizeof' to a function type");
            }
            else
            {
                size_t sz = 0;
                enum sizeof_error size_result = type_get_sizeof(&p_init_declarator->p_declarator->type, &sz, ctx->options.target);

                if (size_result == ESIZEOF_NONE)
                {
                    //ok
                }
                else if (size_result == ESIZEOF_INCOMPLETE)
                {
                    if (p_init_declarator->p_declarator->type.storage_class_specifier_flags & STORAGE_SPECIFIER_EXTERN)
                    {
                        //this is not a problem for extern variables
                    }
                    else
                    {
                        // clang warning: array 'c' assumed to have one element
                        // gcc "error: storage size of '%s' isn't known"
                        compiler_diagnostic(C_ERROR_STORAGE_SIZE,
                            ctx,
                            p_init_declarator->p_declarator->name_opt, NULL,
                            "storage size of '%s' isn't known",
                            p_init_declarator->p_declarator->name_opt->lexeme);
                    }
                }
                else if (size_result == ESIZEOF_OVERLOW)
                {
                    compiler_diagnostic(C_ERROR_STORAGE_SIZE,
                            ctx,
                            p_init_declarator->p_declarator->name_opt, NULL,
                            "sizeof '%s' is too large",
                            p_init_declarator->p_declarator->name_opt->lexeme);
                }
                else
                {
                    compiler_diagnostic(C_ERROR_STORAGE_SIZE,
                        ctx,
                        p_init_declarator->p_declarator->name_opt, NULL,
                        "storage size of '%s' isn't known",
                        p_init_declarator->p_declarator->name_opt->lexeme);
                }
            }
        }
    }
    catch
    {
        init_declarator_delete(p_init_declarator);
        p_init_declarator = NULL;
    }

    return p_init_declarator;
}

void init_declarator_list_add(struct init_declarator_list* list, struct init_declarator* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void init_declarator_list_destroy(_Dtor struct init_declarator_list* p)
{
    struct init_declarator* _Owner _Opt item = p->head;
    while (item)
    {
        struct init_declarator* _Owner _Opt next = item->next;
        item->next = NULL;
        init_declarator_delete(item);
        item = next;
    }
}

struct init_declarator_list init_declarator_list(struct parser_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers)
{
    /*
    init-declarator-list:
      init-declarator
      init-declarator-list , init-declarator
    */
    struct init_declarator_list init_declarator_list = { 0 };
    struct init_declarator* _Owner _Opt p_init_declarator = NULL;

    try
    {
        p_init_declarator = init_declarator(ctx, p_declaration_specifiers);

        if (p_init_declarator == NULL)
            throw;

        init_declarator_list_add(&init_declarator_list, p_init_declarator);
        p_init_declarator = NULL; /*MOVED*/

        while (ctx->current != NULL && ctx->current->type == ',')
        {
            parser_match(ctx);
            p_init_declarator = init_declarator(ctx, p_declaration_specifiers);
            if (p_init_declarator == NULL)
                throw;

            init_declarator_list_add(&init_declarator_list, p_init_declarator);
            p_init_declarator = NULL; /*MOVED*/
        }
    }
    catch
    {
    }

    return init_declarator_list;
}

void storage_class_specifier_delete(struct storage_class_specifier* _Owner _Opt p)
{
    if (p)
    {
        free(p);
    }
}

struct storage_class_specifier* _Owner _Opt storage_class_specifier(struct parser_ctx* ctx)
{
    struct storage_class_specifier* _Owner _Opt p_storage_class_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_storage_class_specifier = calloc(1, sizeof(struct storage_class_specifier));
        if (p_storage_class_specifier == NULL)
            throw;

        p_storage_class_specifier->token = ctx->current;
        switch (ctx->current->type)
        {
        case TK_KEYWORD_TYPEDEF:
            p_storage_class_specifier->flags = STORAGE_SPECIFIER_TYPEDEF;
            break;
        case TK_KEYWORD_EXTERN:
            p_storage_class_specifier->flags = STORAGE_SPECIFIER_EXTERN;
            break;
        case TK_KEYWORD_CONSTEXPR:

            p_storage_class_specifier->flags = STORAGE_SPECIFIER_CONSTEXPR;
            if (ctx->scopes.tail && ctx->scopes.tail->scope_level == 0)
                p_storage_class_specifier->flags |= STORAGE_SPECIFIER_CONSTEXPR_STATIC;
            break;
        case TK_KEYWORD_STATIC:
            p_storage_class_specifier->flags = STORAGE_SPECIFIER_STATIC;
            break;
        case TK_KEYWORD__THREAD_LOCAL:
            p_storage_class_specifier->flags = STORAGE_SPECIFIER_THREAD_LOCAL;
            break;
        case TK_KEYWORD_AUTO:
            p_storage_class_specifier->flags = STORAGE_SPECIFIER_AUTO;
            break;
        case TK_KEYWORD_REGISTER:
            p_storage_class_specifier->flags = STORAGE_SPECIFIER_REGISTER;
            break;
        default:
            assert(false);
        }

        /*
         TODO
         thread_local may appear with static or extern,
         auto may appear with all the others except typedef138), and
         constexpr may appear with auto, register, or static.
        */

        parser_match(ctx);
    }
    catch
    {
        storage_class_specifier_delete(p_storage_class_specifier);
        p_storage_class_specifier = NULL;
    }

    return p_storage_class_specifier;
}

struct typeof_specifier_argument* _Owner _Opt typeof_specifier_argument(struct parser_ctx* ctx)
{
    struct typeof_specifier_argument* _Owner _Opt new_typeof_specifier_argument = NULL;
    try
    {
        new_typeof_specifier_argument = calloc(1, sizeof(struct typeof_specifier_argument));
        if (new_typeof_specifier_argument == NULL)
            throw;

        if (first_of_type_name(ctx))
        {
            new_typeof_specifier_argument->type_name = type_name(ctx);
        }
        else
        {
            const bool disable_evaluation_copy = ctx->evaluation_is_disabled;
            ctx->evaluation_is_disabled = true;
            new_typeof_specifier_argument->expression = expression(ctx);
            /*restore*/
            ctx->evaluation_is_disabled = disable_evaluation_copy;

            if (new_typeof_specifier_argument->expression == NULL)
                throw;

            // declarator_type_clear_name(new_typeof_specifier_argument->expression->type.declarator_type);
        }
    }
    catch
    {
        typeof_specifier_argument_delete(new_typeof_specifier_argument);
        new_typeof_specifier_argument = NULL;
    }

    return new_typeof_specifier_argument;
}

bool first_of_typeof_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD_TYPEOF ||
        ctx->current->type == TK_KEYWORD_TYPEOF_UNQUAL;
}

struct typeof_specifier* _Owner _Opt  typeof_specifier(struct parser_ctx* ctx)
{
    struct typeof_specifier* _Owner _Opt p_typeof_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_typeof_specifier = calloc(1, sizeof(struct typeof_specifier));
        if (p_typeof_specifier == NULL)
            throw;

        p_typeof_specifier->first_token = ctx->current;

        const bool is_typeof_unqual = ctx->current->type == TK_KEYWORD_TYPEOF_UNQUAL;
        parser_match(ctx);
        if (parser_match_tk(ctx, '(') != 0)
        {
            throw;
        }

        struct typeof_specifier_argument* _Owner _Opt p_typeof_specifier_argument =
            typeof_specifier_argument(ctx);

        if (p_typeof_specifier_argument == NULL)
        {
            throw;
        }

        p_typeof_specifier->typeof_specifier_argument = p_typeof_specifier_argument;

        if (p_typeof_specifier->typeof_specifier_argument->expression)
        {
            p_typeof_specifier->type = type_dup(&p_typeof_specifier->typeof_specifier_argument->expression->type);
        }
        else if (p_typeof_specifier->typeof_specifier_argument->type_name)
        {
            p_typeof_specifier->type = type_dup(&p_typeof_specifier->typeof_specifier_argument->type_name->abstract_declarator->type);
        }

        if (p_typeof_specifier->type.storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
        {
            compiler_diagnostic(W_TYPEOF_ARRAY_PARAMETER, ctx, ctx->current, NULL, "typeof used in array arguments");

            if (type_is_array(&p_typeof_specifier->type))
            {
                struct type t = type_param_array_to_pointer(&p_typeof_specifier->type, ctx->options.null_checks_enabled);
                type_swap(&t, &p_typeof_specifier->type);
                type_destroy(&t);
            }
        }

        if (is_typeof_unqual)
        {
            type_remove_qualifiers(&p_typeof_specifier->type);
        }

        type_visit_to_mark_anonymous(&p_typeof_specifier->type);

        free((void* _Owner)p_typeof_specifier->type.name_opt);
        p_typeof_specifier->type.name_opt = NULL;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_typeof_specifier->last_token = ctx->current;
        if (parser_match_tk(ctx, ')') != 0) throw;
    }
    catch
    {
        typeof_specifier_delete(p_typeof_specifier);
        p_typeof_specifier = NULL;
    }

    return p_typeof_specifier;
}

void typeof_specifier_argument_delete(struct typeof_specifier_argument* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->expression);
        type_name_delete(p->type_name);
        free(p);
    }
}

void typeof_specifier_delete(struct typeof_specifier* _Owner _Opt p)
{
    if (p)
    {
        typeof_specifier_argument_delete(p->typeof_specifier_argument);
        type_destroy(&p->type);
        free(p);
    }
}

void type_specifier_delete(struct type_specifier* _Owner _Opt p)
{
    if (p)
    {
        struct_or_union_specifier_delete(p->struct_or_union_specifier);
        typeof_specifier_delete(p->typeof_specifier);
        enum_specifier_delete(p->enum_specifier);
        atomic_type_specifier_delete(p->atomic_type_specifier);
        free(p);
    }
}


struct attribute* _Owner _Opt extended_decl_modifier_seq(struct parser_ctx* ctx)
{
    //https://learn.microsoft.com/en-us/cpp/cpp/declspec?view=msvc-170
    /*
     extended-decl-modifier:
         align( number )
         allocate(" segname ")
         allocator
         appdomain
         code_seg(" segname ")
         deprecated
         dllimport
         dllexport
         empty_bases
         hybrid_patchable
         jitintrinsic
         naked
         noalias
         noinline
         noreturn
         nothrow
         novtable
         no_sanitize_address
         process
         property( { get=get-func-name | ,put=put-func-name } )
         restrict
         safebuffers
         selectany
         spectre(nomitigation)
         thread
         uuid(" ComObjectGUID ")
    */

    struct attribute* _Owner _Opt p_type_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_type_specifier = calloc(1, sizeof * p_type_specifier);
        if (p_type_specifier == NULL)
            throw;

        p_type_specifier->attribute_token = ctx->current;

        parser_match(ctx);

        if (strcmp(p_type_specifier->attribute_token->lexeme, "align") == 0)
        {
            parser_match(ctx); //(
            int a = atoi(ctx->current->lexeme);
            if (a == 8)
                p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_ALIGN_8_FLAG;
            else if (a == 16)
                p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_ALIGN_16_FLAG;
            else if (a == 32)
                p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_ALIGN_32_FLAG;
            else if (a == 64)
                p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_ALIGN_64_FLAG;

            parser_match(ctx); //number     
            parser_match(ctx); //)            
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "allocate") == 0)
        {
            p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_ALLOCATE_FLAG;
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "allocator") == 0)
        {
            p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_ALLOCATOR_FLAG;
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "appdomain") == 0)
        {
            p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_APPDOMAIN_FLAG;
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "code_seg") == 0)
        {
            p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_CODE_SEG_FLAG;
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "deprecated") == 0)
        {
            p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_DEPRECATED_FLAG;
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "dllimport") == 0)
        {
            p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_DLLIMPORT_FLAG;
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "dllexport") == 0)
        {
            p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_DLLEXPORT_FLAG;
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "hybrid_patchable") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "no_init_all") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "jitintrinsic") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "intrin_type") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "naked") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "noalias") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "noinline") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "noreturn") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "nothrow") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "novtable") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "no_sanitize_address") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "process") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "property") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "restrict") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "safebuffers") == 0)
        {
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "selectany") == 0)
        {
            //https://learn.microsoft.com/en-us/cpp/cpp/selectany?view=msvc-170
            p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_SELECTANY_FLAG;
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "thread") == 0)
        {
            p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_SELECTANY_FLAG;
        }
        else if (strcmp(p_type_specifier->attribute_token->lexeme, "uuid") == 0)
        {
            p_type_specifier->msvc_declspec_flags |= MSVC_DECLSPEC_UUID_FLAG;
        }
        else
        {
            compiler_diagnostic(W_ATTRIBUTES,
                ctx,
                p_type_specifier->attribute_token,
                NULL,
            "unknown '%s'\n", p_type_specifier->attribute_token->lexeme);
        }

        int count = 1;
        while (ctx->current)
        {
            if (ctx->current->type == TK_LEFT_PARENTHESIS)
            {
                parser_match(ctx);
                count++;
            }
            else if (ctx->current->type == TK_RIGHT_PARENTHESIS)
            {
                if (count == 1)
                    break;
                count--;
                parser_match(ctx);
            }
            else
            {
                parser_match(ctx);
            }
        }
    }
    catch
    {
        attribute_delete(p_type_specifier);
        p_type_specifier = NULL;
    }
    return p_type_specifier;
}

struct attribute* _Owner _Opt msvc_declspec(struct parser_ctx* ctx)
{
    //https://learn.microsoft.com/en-us/cpp/cpp/declspec?view=msvc-170
    /*
      __declspec ( extended-decl-modifier-seq )
    */
    struct attribute* _Owner _Opt p_decl_specifier = NULL;
    try
    {
        if (ctx->current->type != TK_KEYWORD_MSVC__DECLSPEC)
            throw;
        parser_match_tk(ctx, TK_KEYWORD_MSVC__DECLSPEC);
        parser_match_tk(ctx, TK_LEFT_PARENTHESIS);
        p_decl_specifier = extended_decl_modifier_seq(ctx);
        parser_match_tk(ctx, TK_RIGHT_PARENTHESIS);
    }
    catch
    {
        attribute_delete(p_decl_specifier);
        p_decl_specifier = NULL;
    }
    return p_decl_specifier;
}

enum msvc_declspec_flags msvc_declspec_sequence_opt(struct parser_ctx* ctx)
{
    enum msvc_declspec_flags msvc_declspec_flags = 0;
    try
    {
        for (;;)
        {
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->type != TK_KEYWORD_MSVC__DECLSPEC)
                return msvc_declspec_flags;

            struct attribute* _Owner _Opt p = msvc_declspec(ctx);
            if (p)
            {
                msvc_declspec_flags |= p->msvc_declspec_flags;
            }
            attribute_delete(p);


        }
    }
    catch
    {

    }
    return msvc_declspec_flags;
}

static void gcc_attribute_argument(struct parser_ctx* ctx)
{
    /*
       attribute-argument:
         identifier
         constant-expression
         string-literal
    */
    if (ctx->current == NULL)
    {
        unexpected_end_of_file(ctx);
        return;
    }

    if (token_is_identifier_or_keyword(ctx->current->type))
    {
        parser_match(ctx);

    }
    else if (ctx->current->type == TK_STRING_LITERAL)
    {
        parser_match(ctx);
    }
    else //constant expressions
    {
        struct expression* expr = constant_expression(ctx, true);
        expression_delete(expr);
    }
}

static void gcc_attribute_argument_list(struct parser_ctx* ctx)
{
    /*
      attribute-argument-list:
          attribute-argument
          attribute-argument-list , attribute-argument
    */

    if (ctx->current == NULL)
    {
        unexpected_end_of_file(ctx);
        return;
    }

    for (;;)
    {
        gcc_attribute_argument(ctx);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            return;
        }

        if (ctx->current->type != ',')
            break;

        parser_match(ctx);
    }
}

static void gcc_attribute(struct parser_ctx* ctx)
{
    /*
     attribute :
         identifier
         identifier()
         identifier(attribute-argument-list)
    */
    if (ctx->current == NULL)
    {
        unexpected_end_of_file(ctx);
        return;
    }

    if (!token_is_identifier_or_keyword(ctx->current->type))
    {
        compiler_diagnostic(C_ERROR_UNEXPECTED,
                          ctx,
                          ctx->current,
                          NULL,
                          "expected identifier");
        return;
    }

    parser_match(ctx); //identifier

    if (ctx->current->type == '(')
    {
        parser_match(ctx); //(
        if (ctx->current->type != ')')
        {
            gcc_attribute_argument_list(ctx);
        }
        parser_match_tk(ctx, ')');
    }

}

static void gcc_attribute_list(struct parser_ctx* ctx)
{
    /*
        attribute-list:
          empty
          attribute
          attribute-list, attribute
    */

    if (ctx->current == NULL)
    {
        unexpected_end_of_file(ctx);
        return;
    }

    if (ctx->current->type == ')')
        return;

    for (;;)
    {
        gcc_attribute(ctx);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            return;
        }

        if (ctx->current->type != ',')
            break;

        parser_match(ctx);
    }
}

void gcc_attribute_specifier_opt(struct parser_ctx* ctx)
{
    /*
    attribute-specifier:
        __attribute__ (( attribute-list ))
    */

    if (ctx->current == NULL || ctx->current->type != TK_KEYWORD_GCC__ATTRIBUTE)
        return;

    parser_match(ctx);
    parser_match_tk(ctx, '(');
    parser_match_tk(ctx, '(');
    gcc_attribute_list(ctx);
    parser_match_tk(ctx, ')');
    parser_match_tk(ctx, ')');
}

struct type_specifier* _Owner _Opt type_specifier(struct parser_ctx* ctx)
{
    /*
     type-specifier:
       void
       char
       short
       int
       long
       float
       double
       signed
       unsigned
       _BitInt ( constant-expression )
       bool                                  C23
       _Complex
       _Decimal32
       _Decimal64
       _Decimal128
       atomic-type-specifier
       struct-or-union-specifier
       enum-specifier
       typedef-name
       typeof-specifier                      C23
    */

    struct type_specifier* _Owner _Opt p_type_specifier = NULL;

    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_type_specifier = calloc(1, sizeof * p_type_specifier);
        if (p_type_specifier == NULL)
            throw;

        switch (ctx->current->type)
        {
        case TK_KEYWORD_VOID:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_VOID;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_CHAR:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_CHAR;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_SHORT:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_SHORT;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_INT:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_INT;
            parser_match(ctx);
            return p_type_specifier;


        case TK_KEYWORD_GCC__BUILTIN_VA_LIST:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_GCC__BUILTIN_VA_LIST;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_MSVC__INT8:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_INT8;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_MSVC__INT16:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_INT16;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_MSVC__INT32:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_INT32;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_MSVC__INT64:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_INT64;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_LONG:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_LONG;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_FLOAT:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_FLOAT;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_DOUBLE:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_DOUBLE;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_SIGNED:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_SIGNED;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_UNSIGNED:

            p_type_specifier->flags = TYPE_SPECIFIER_UNSIGNED;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD__BOOL:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_BOOL;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD__COMPLEX:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_COMPLEX;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD__DECIMAL32:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_DECIMAL32;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD__DECIMAL64:
            p_type_specifier->flags = TYPE_SPECIFIER_DECIMAL64;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD__DECIMAL128:
            p_type_specifier->flags = TYPE_SPECIFIER_DECIMAL128;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        default:
            // Do nothing
            break;
        }

        if (first_of_typeof_specifier(ctx))
        {
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_TYPEOF;
            p_type_specifier->typeof_specifier = typeof_specifier(ctx);
            if (p_type_specifier->typeof_specifier == NULL)
            {
                type_specifier_delete(p_type_specifier);
                return NULL;
            }

        }
        else if (first_of_atomic_type_specifier(ctx))
        {
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_ATOMIC;
            p_type_specifier->atomic_type_specifier = atomic_type_specifier(ctx);
            if (p_type_specifier->atomic_type_specifier == NULL)
            {
                type_specifier_delete(p_type_specifier);
                return NULL;
            }
        }
        else if (first_of_struct_or_union(ctx))
        {
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_STRUCT_OR_UNION;
            p_type_specifier->struct_or_union_specifier = struct_or_union_specifier(ctx);
            if (p_type_specifier->struct_or_union_specifier == NULL)
            {
                type_specifier_delete(p_type_specifier);
                return NULL;
            }
        }
        else if (first_of_enum_specifier(ctx))
        {
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_ENUM;
            p_type_specifier->enum_specifier = enum_specifier(ctx);
            if (p_type_specifier->enum_specifier == NULL)
            {
                type_specifier_delete(p_type_specifier);
                return NULL;
            }
        }
        else if (ctx->current->type == TK_KEYWORD__BITINT)
        {
            //TODO
            type_specifier_delete(p_type_specifier);
            return NULL;
        }
        else if (ctx->current->type == TK_IDENTIFIER)
        {
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_TYPEDEF;

            p_type_specifier->typedef_declarator =
                find_declarator(ctx, ctx->current->lexeme, NULL);

            // Ser chegou aqui já tem que exitir (reaprovecitar?)
            assert(p_type_specifier->typedef_declarator != NULL);

            parser_match(ctx);
        }

    }
    catch
    {
        type_specifier_delete(p_type_specifier);
        p_type_specifier = NULL;
    }
    return p_type_specifier;
}

enum type_specifier_flags get_enum_type_specifier_flags(const struct enum_specifier* p_enum_specifier)
{
    if (p_enum_specifier->specifier_qualifier_list)
    {
        return p_enum_specifier->specifier_qualifier_list->type_specifier_flags;
    }

    if (p_enum_specifier->p_complete_enum_specifier &&
        p_enum_specifier->p_complete_enum_specifier->specifier_qualifier_list)
    {
        return p_enum_specifier->p_complete_enum_specifier->specifier_qualifier_list->type_specifier_flags;
    }
    else if (p_enum_specifier->p_complete_enum_specifier &&
        p_enum_specifier->p_complete_enum_specifier->p_complete_enum_specifier &&
        p_enum_specifier->p_complete_enum_specifier->p_complete_enum_specifier->specifier_qualifier_list)
    {
        return p_enum_specifier->p_complete_enum_specifier->p_complete_enum_specifier->specifier_qualifier_list->type_specifier_flags;
    }

    return TYPE_SPECIFIER_INT;
}

const struct enum_specifier* _Opt get_complete_enum_specifier(const struct enum_specifier* p_enum_specifier)
{
    /*
      The way cake find the complete struct is using one pass.. for this task is uses double indirection.
      Then the result will be there at end of first pass.
      This crazy code finds the complete definition of the struct if exists.
    */
    if (p_enum_specifier->enumerator_list.head)
    {
        /*p_struct_or_union_specifier is complete*/
        return p_enum_specifier;
    }
    else if (p_enum_specifier->p_complete_enum_specifier &&
        p_enum_specifier->p_complete_enum_specifier->enumerator_list.head)
    {
        /*p_struct_or_union_specifier is the first seem tag tag points directly to complete*/
        return p_enum_specifier->p_complete_enum_specifier;
    }
    else if (p_enum_specifier->p_complete_enum_specifier &&
        p_enum_specifier->p_complete_enum_specifier->p_complete_enum_specifier &&
        p_enum_specifier->p_complete_enum_specifier->p_complete_enum_specifier->enumerator_list.head)
    {
        /* all others points to the first seem that points to the complete*/
        return p_enum_specifier->p_complete_enum_specifier->p_complete_enum_specifier;
    }

    return NULL;
}

struct struct_or_union_specifier* _Opt get_complete_struct_or_union_specifier(const struct struct_or_union_specifier* p_struct_or_union_specifier)
{
    /*
      The way cake find the complete struct is using one pass.. for this task is uses double indirection.
      Then the result will be there at end of first pass.
      This crazy code finds the complete definition of the struct if exists.
    */


    if (p_struct_or_union_specifier->member_declaration_list.head)
    {
        /*p_struct_or_union_specifier is complete*/
        return (struct struct_or_union_specifier* _Opt) p_struct_or_union_specifier;
    }
    else if (p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection &&
        p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection->member_declaration_list.head)
    {
        /*p_struct_or_union_specifier is the first seem tag tag points directly to complete*/
        return p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection;
    }
    else if (p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection &&
        p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection->complete_struct_or_union_specifier_indirection &&
        p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection->complete_struct_or_union_specifier_indirection->member_declaration_list.head)
    {
        /* all others points to the first seem that points to the complete*/
        return p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection->complete_struct_or_union_specifier_indirection;
    }

    return NULL;
}

bool struct_or_union_specifier_is_complete(struct struct_or_union_specifier* p_struct_or_union_specifier)
{
    return get_complete_struct_or_union_specifier(p_struct_or_union_specifier) != NULL;
}

struct struct_or_union_specifier* _Owner struct_or_union_specifier_add_ref(struct struct_or_union_specifier* p)
{
    p->has_shared_ownership = true;
    return (struct struct_or_union_specifier* _Owner) p;
}


void struct_or_union_specifier_sink(struct struct_or_union_specifier* _Owner _Opt p) {}

bool struct_or_union_specifier_is_union(const struct struct_or_union_specifier* p)
{
    return p->first_token->type == TK_KEYWORD_UNION;
}

void struct_or_union_specifier_delete(struct struct_or_union_specifier* _Owner _Opt p)
{
    if (p)
    {
        if (p->has_shared_ownership > 0)
        {
            p->has_shared_ownership = false;
            struct_or_union_specifier_sink(p);
            return;
        }

        member_declaration_list_destroy(&p->member_declaration_list);
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        free(p);
    }
}

struct struct_or_union_specifier* _Owner _Opt struct_or_union_specifier(struct parser_ctx* ctx)
{

    struct struct_or_union_specifier* _Owner _Opt p_struct_or_union_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_struct_or_union_specifier = calloc(1, sizeof * p_struct_or_union_specifier);
        if (p_struct_or_union_specifier == NULL)
            throw;

        if (ctx->current->type == TK_KEYWORD_STRUCT ||
            ctx->current->type == TK_KEYWORD_UNION)
        {
            p_struct_or_union_specifier->first_token = ctx->current;
            parser_match(ctx);
        }
        else
        {
            throw;
        }

        p_struct_or_union_specifier->attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);

        struct struct_or_union_specifier* p_first_tag_in_this_scope = NULL;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == TK_IDENTIFIER)
        {
            p_struct_or_union_specifier->tagtoken = ctx->current;
            /*
             Structure, union, and enumeration tags have scope that begins just after the
             appearance of the tag in a type specifier that declares the tag.
            */

            snprintf(p_struct_or_union_specifier->tag_name, sizeof p_struct_or_union_specifier->tag_name, "%s", ctx->current->lexeme);

            struct map_entry* _Opt p_entry = hashmap_find(&ctx->scopes.tail->tags, ctx->current->lexeme);
            if (p_entry)
            {
                /*this tag already exist in this scope*/
                if (p_entry->type == TAG_TYPE_STRUCT_OR_UNION_SPECIFIER)
                {
                    assert(p_entry->data.p_struct_or_union_specifier != NULL);
                    p_first_tag_in_this_scope = p_entry->data.p_struct_or_union_specifier;
                    p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection = p_first_tag_in_this_scope;
                }
                else
                {
                    compiler_diagnostic(C_ERROR_TAG_TYPE_DOES_NOT_MATCH_PREVIOUS_DECLARATION,
                        ctx,
                        ctx->current, NULL,
                        "use of '%s' with tag type that does not match previous declaration.",
                        ctx->current->lexeme);
                }
            }
            else
            {
                /*tag does not exist in the current scope, let search on upper scopes*/
                struct struct_or_union_specifier* _Opt p_first_tag_previous_scopes = find_struct_or_union_specifier(ctx, ctx->current->lexeme);
                if (p_first_tag_previous_scopes == NULL)
                {
                    /*tag not found, so it is the first appearance*/

                    p_struct_or_union_specifier->scope_level = ctx->scopes.tail->scope_level;

                    struct hash_item_set item = { 0 };
                    item.p_struct_or_union_specifier = struct_or_union_specifier_add_ref(p_struct_or_union_specifier);
                    hashmap_set(&ctx->scopes.tail->tags, ctx->current->lexeme, &item);
                    hash_item_set_destroy(&item);
                }
                else
                {
                    /*tag already exists in some scope*/
                    p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection = p_first_tag_previous_scopes;
                }
            }

            parser_match(ctx);
        }
        else
        {
            /*struct without a tag, in this case we make one*/
            snprintf(p_struct_or_union_specifier->tag_name, sizeof p_struct_or_union_specifier->tag_name, "_struct_tag_%d", s_anonymous_struct_count);
            s_anonymous_struct_count++;
            p_struct_or_union_specifier->has_anonymous_tag = true;
            p_struct_or_union_specifier->scope_level = ctx->scopes.tail->scope_level;


            struct hash_item_set item = { 0 };
            item.p_struct_or_union_specifier = struct_or_union_specifier_add_ref(p_struct_or_union_specifier);
            hashmap_set(&ctx->scopes.tail->tags, p_struct_or_union_specifier->tag_name, &item);
            hash_item_set_destroy(&item);
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == '{')
        {
            /*
            this is the complete struct
            */

            struct struct_or_union_specifier* _Opt first = find_struct_or_union_specifier(ctx, p_struct_or_union_specifier->tag_name);

            if (first)
            {
                /*
                   The first tag (will the one at symbol table) will point to the complete struct
                */
                first->complete_struct_or_union_specifier_indirection = p_struct_or_union_specifier;
            }

            if (p_struct_or_union_specifier->tagtoken)
                naming_convention_struct_tag(ctx, p_struct_or_union_specifier->tagtoken);

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            struct token* firsttoken = ctx->current;
            parser_match(ctx);

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->type != '}') /*not official extensions yet..missing sizeof etc*/
            {
#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wmissing-destructor"
                p_struct_or_union_specifier->member_declaration_list = member_declaration_list(ctx, p_struct_or_union_specifier);
#pragma cake diagnostic pop

                //we cannot have an empty struct
                if (p_struct_or_union_specifier->member_declaration_list.head == NULL) throw;
            }

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            p_struct_or_union_specifier->member_declaration_list.first_token = firsttoken;
            p_struct_or_union_specifier->last_token = ctx->current;
            p_struct_or_union_specifier->member_declaration_list.last_token = ctx->current;

            if (parser_match_tk(ctx, '}') != 0)
                throw;
        }
        else
        {
            p_struct_or_union_specifier->last_token = ctx->current;
        }

        struct struct_or_union_specifier* _Opt p_complete =
            get_complete_struct_or_union_specifier(p_struct_or_union_specifier);

        /*check if complete struct is deprecated*/
        if (p_complete)
        {
            if (p_complete->attribute_specifier_sequence_opt &&
                p_complete->attribute_specifier_sequence_opt->attributes_flags & STD_ATTRIBUTE_DEPRECATED)
            {
                if (p_struct_or_union_specifier->tagtoken)
                {
                    // TODO add deprecated message
                    compiler_diagnostic(W_DEPRECATED, ctx, p_struct_or_union_specifier->first_token, NULL, "'%s' is deprecated", p_struct_or_union_specifier->tagtoken->lexeme);
                }
                else
                {
                    compiler_diagnostic(W_DEPRECATED, ctx, p_struct_or_union_specifier->first_token, NULL, "deprecated");
                }
            }
        }
    }
    catch
    {
        struct_or_union_specifier_delete(p_struct_or_union_specifier);
        p_struct_or_union_specifier = NULL;
    }
    return p_struct_or_union_specifier;
}

struct member_declarator* _Owner _Opt member_declarator(
    struct parser_ctx* ctx,
    struct struct_or_union_specifier* p_struct_or_union_specifier, /*not const*/
    const struct specifier_qualifier_list* p_specifier_qualifier_list)
{
    /*
    member-declarator:
     declarator
     declaratoropt : constant-expression
    */
    struct member_declarator* _Owner _Opt p_member_declarator = NULL;
    try
    {
        p_member_declarator = calloc(1, sizeof(struct member_declarator));
        if (p_member_declarator == NULL) throw;

        struct token* _Opt p_token_name = NULL;

        p_member_declarator->declarator = declarator(ctx, p_specifier_qualifier_list, /*declaration_specifiers*/ NULL, false, &p_token_name);
        if (p_member_declarator->declarator == NULL) throw;

        p_member_declarator->declarator->name_opt = p_token_name;
        p_member_declarator->declarator->specifier_qualifier_list = p_specifier_qualifier_list;

#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wmissing-destructor"    
        p_member_declarator->declarator->type = make_type_using_declarator(ctx, p_member_declarator->declarator);
#pragma cake diagnostic pop

        if (type_is_function(&p_member_declarator->declarator->type))
        {
            //A structure or union shall not contain a member with incomplete 
            // or function type 

            struct token* p_token =
                p_member_declarator->declarator->first_token_opt;
            if (p_token == NULL)
                p_token = ctx->current;

            compiler_diagnostic(C_ERROR_FUNCTION_CANNOT_BE_MEMBER,
                ctx,
                p_token,
                NULL,
                "members having a function type are not allowed");

            throw;
        }

        /*extension*/
        if (type_is_owner(&p_member_declarator->declarator->type))
        {
            /*having at least 1 _Owner member, the struct type is _Owner by default*/
            p_struct_or_union_specifier->is_owner = true;
        }

        if (p_member_declarator->declarator->name_opt)
            naming_convention_struct_member(ctx, p_member_declarator->declarator->name_opt, &p_member_declarator->declarator->type);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == ':')
        {
            parser_match(ctx);
            p_member_declarator->constant_expression = constant_expression(ctx, true);
        }
    }
    catch
    {
        member_declarator_delete(p_member_declarator);
        p_member_declarator = NULL;
    }
    return p_member_declarator;
}

void member_declarator_delete(struct member_declarator* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->constant_expression);
        assert(p->next == NULL);
        declarator_delete(p->declarator);
        free(p);
    }
}

void member_declarator_list_add(struct member_declarator_list* list, struct member_declarator* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void member_declarator_list_delete(struct member_declarator_list* _Owner _Opt p)
{
    if (p)
    {
        struct member_declarator* _Owner _Opt item = p->head;
        while (item)
        {
            struct member_declarator* _Owner _Opt next = item->next;
            item->next = NULL;
            member_declarator_delete(item);
            item = next;
        }
        free(p);
    }
}

struct member_declarator_list* _Owner _Opt member_declarator_list(
    struct parser_ctx* ctx,
    struct struct_or_union_specifier* p_struct_or_union_specifier,
    const struct specifier_qualifier_list* p_specifier_qualifier_list)
{
    struct member_declarator_list* _Owner _Opt p_member_declarator_list = calloc(1, sizeof(struct member_declarator_list));
    try
    {
        if (p_member_declarator_list == NULL) throw;

        struct member_declarator* _Opt _Owner p_member_declarator = member_declarator(ctx, p_struct_or_union_specifier, p_specifier_qualifier_list);
        if (p_member_declarator == NULL) throw;

        member_declarator_list_add(p_member_declarator_list, p_member_declarator);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        while (ctx->current->type == ',')
        {
            parser_match(ctx);

            struct member_declarator* _Opt _Owner p_member_declarator2 = member_declarator(ctx, p_struct_or_union_specifier, p_specifier_qualifier_list);
            if (p_member_declarator2 == NULL) throw;

            member_declarator_list_add(p_member_declarator_list, p_member_declarator2);

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }
        }
    }
    catch
    {
        member_declarator_list_delete(p_member_declarator_list);
        p_member_declarator_list = NULL;
    }

    return p_member_declarator_list;
}

void member_declaration_list_add(struct member_declaration_list* list, struct member_declaration* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void member_declaration_list_destroy(_Opt _Dtor struct member_declaration_list* p)
{
    struct member_declaration* _Owner _Opt item = p->head;
    while (item)
    {
        struct member_declaration* _Owner _Opt next = item->next;
        item->next = NULL;
        member_declaration_delete(item);
        item = next;
    }
}

struct member_declaration_list member_declaration_list(struct parser_ctx* ctx, struct struct_or_union_specifier* p_struct_or_union_specifier)
{
    _Opt struct member_declaration_list list = { 0 };
    // member_declaration
    // member_declaration_list member_declaration

    struct member_declaration* _Owner _Opt p_member_declaration = NULL;

    try
    {
        p_member_declaration = member_declaration(ctx, p_struct_or_union_specifier);

        if (p_member_declaration == NULL)
            throw;

        member_declaration_list_add(&list, p_member_declaration);
        p_member_declaration = NULL; /*MOVED*/

        while (ctx->current && ctx->current->type != '}')
        {
            p_member_declaration = member_declaration(ctx, p_struct_or_union_specifier);
            if (p_member_declaration == NULL)
                throw;
            member_declaration_list_add(&list, p_member_declaration);
            p_member_declaration = NULL; /*MOVED*/
        }
    }
    catch
    {
        member_declaration_list_destroy(&list);
        list = (struct member_declaration_list){ 0 };
    }

    return list;
}

void member_declaration_delete(struct member_declaration* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        specifier_qualifier_list_delete(p->specifier_qualifier_list);
        member_declarator_list_delete(p->member_declarator_list_opt);
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence_opt);
        static_assert_declaration_delete(p->static_assert_declaration);
        pragma_declaration_delete(p->pragma_declaration);
        free(p);
    }
}

struct member_declaration* _Owner _Opt member_declaration(struct parser_ctx* ctx,
    struct struct_or_union_specifier* p_struct_or_union_specifier)
{
    struct member_declaration* _Owner _Opt p_member_declaration = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_member_declaration = calloc(1, sizeof(struct member_declaration));
        if (p_member_declaration == NULL)
            throw;

        // attribute_specifier_sequence_opt specifier_qualifier_list member_declarator_list_opt ';'
        // static_assert_declaration
        if (ctx->current->type == TK_KEYWORD__STATIC_ASSERT)
        {
            p_member_declaration->static_assert_declaration = static_assert_declaration(ctx);
        }
        else if (ctx->current->type == TK_PRAGMA)
        {
            p_member_declaration->pragma_declaration = pragma_declaration(ctx);
        }
        else
        {
            p_member_declaration->p_attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);

            p_member_declaration->specifier_qualifier_list = specifier_qualifier_list(ctx);

            if (p_member_declaration->specifier_qualifier_list == NULL)
            {
                throw;
            }

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->type != ';')
            {
                p_member_declaration->member_declarator_list_opt = member_declarator_list(ctx,
                    p_struct_or_union_specifier,
                    p_member_declaration->specifier_qualifier_list);
                if (p_member_declaration->member_declarator_list_opt == NULL) throw;
            }

            if (parser_match_tk(ctx, ';') != 0)
                throw;
        }
    }
    catch
    {
        member_declaration_delete(p_member_declaration);
        p_member_declaration = NULL;
    }
    return p_member_declaration;
}

struct member_declarator* _Opt find_member_declarator(struct member_declaration_list* list,
    const char* name,
    int* p_member_index)
{
    if (list->head == NULL)
        return NULL;

    struct member_declaration* _Opt p_member_declaration = list->head;
    while (p_member_declaration)
    {
        struct member_declarator* _Opt p_member_declarator = NULL;

        if (p_member_declaration->member_declarator_list_opt)
        {
            p_member_declarator = p_member_declaration->member_declarator_list_opt->head;

            while (p_member_declarator)
            {
                if (p_member_declarator->declarator)
                {
                    if (p_member_declarator->declarator->name_opt && strcmp(p_member_declarator->declarator->name_opt->lexeme, name) == 0)
                    {
                        return p_member_declarator;
                    }
                }

                (*p_member_index)++;
                p_member_declarator = p_member_declarator->next;
            }
        }
        else
        {
            if (p_member_declaration->specifier_qualifier_list &&
                p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
            {
                struct struct_or_union_specifier* _Opt p_complete =
                    get_complete_struct_or_union_specifier(p_member_declaration->specifier_qualifier_list->struct_or_union_specifier);

                if (p_complete)
                {
                    p_member_declarator = find_member_declarator(&p_complete->member_declaration_list, name, p_member_index);
                    if (p_member_declarator)
                        return p_member_declarator;
                }
            }

        }

        p_member_declaration = p_member_declaration->next;
    }
    return NULL;
}

static struct member_declarator* _Opt find_member_declarator_by_index_core(struct member_declaration_list* list, int member_index, int* p_count)
{
    if (list->head == NULL)
        return NULL;


    struct member_declaration* _Opt p_member_declaration = list->head;
    while (p_member_declaration)
    {
        struct member_declarator* _Opt p_member_declarator = NULL;

        if (p_member_declaration->member_declarator_list_opt)
        {
            p_member_declarator = p_member_declaration->member_declarator_list_opt->head;

            while (p_member_declarator)
            {
                if (p_member_declarator->declarator)
                {
                    if (member_index == *p_count)
                    {
                        return p_member_declarator;
                    }
                }
                (*p_count)++;
                p_member_declarator = p_member_declarator->next;
            }
        }
        else
        {
            if (p_member_declaration->specifier_qualifier_list &&
                p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
            {
                struct member_declaration_list* p_member_declaration_list =
                    &p_member_declaration->specifier_qualifier_list->struct_or_union_specifier->member_declaration_list;

                p_member_declarator = find_member_declarator_by_index_core(p_member_declaration_list, member_index, p_count);
                if (p_member_declarator)
                    return p_member_declarator;
            }
        }

        p_member_declaration = p_member_declaration->next;
    }
    return NULL;
}

struct member_declarator* _Opt find_member_declarator_by_index(struct member_declaration_list* list, int member_index)
{
    int count = 0;
    return find_member_declarator_by_index_core(list, member_index, &count);
}

static struct object* _Opt find_object_declarator_by_index_core(struct object* p_object0, struct member_declaration_list* list, int member_index, int* p_count)
{
    const struct object* p_object = object_is_reference(p_object0) ? object_get_referenced(p_object0) : p_object0;

    if (list->head == NULL)
        return NULL;

    if (p_object->members == NULL)
    {
        return NULL;
    }

    struct object* _Opt p_member_object = p_object->members;

    struct member_declaration* _Opt p_member_declaration = list->head;
    while (p_member_declaration)
    {
        struct member_declarator* _Opt p_member_declarator = NULL;

        if (p_member_declaration->member_declarator_list_opt)
        {
            p_member_declarator = p_member_declaration->member_declarator_list_opt->head;

            while (p_member_declarator)
            {
                if (p_member_declarator->declarator)
                {
                    if (member_index == *p_count)
                    {
                        return p_member_object;
                    }
                }
                (*p_count)++;
                p_member_declarator = p_member_declarator->next;
                if (p_member_object == NULL)
                {
                    //BUG
                    return NULL;
                }
                p_member_object = p_member_object->next;
            }
        }
        else if (p_member_declaration->specifier_qualifier_list)
        {
            if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
            {
                struct member_declaration_list* p_member_declaration_list =
                    &p_member_declaration->specifier_qualifier_list->struct_or_union_specifier->member_declaration_list;

                struct object* _Opt p_member_object2 = find_object_declarator_by_index_core(p_member_object, p_member_declaration_list, member_index, p_count);
                if (p_member_object2)
                    return p_member_object2;

            }
            p_member_object = p_member_object->next;
        }

        p_member_declaration = p_member_declaration->next;
    }
    return NULL;
}

struct object* _Opt find_object_declarator_by_index(struct object* p_object, struct member_declaration_list* list, int member_index)
{
    int count = 0;
    return find_object_declarator_by_index_core(p_object, list, member_index, &count);
}

void print_specifier_qualifier_list(struct osstream* ss, bool* first, struct specifier_qualifier_list* p_specifier_qualifier_list)
{

    print_type_qualifier_flags(ss, first, p_specifier_qualifier_list->type_qualifier_flags);

    if (p_specifier_qualifier_list->enum_specifier)
    {

        // TODO
        assert(false);
    }
    else if (p_specifier_qualifier_list->struct_or_union_specifier)
    {
        ss_fprintf(ss, "struct %s", p_specifier_qualifier_list->struct_or_union_specifier->tag_name);
    }
    else if (p_specifier_qualifier_list->typedef_declarator)
    {
        if (p_specifier_qualifier_list->typedef_declarator->name_opt)
            print_item(ss, first, p_specifier_qualifier_list->typedef_declarator->name_opt->lexeme);
    }
    else
    {
        print_type_specifier_flags(ss, first, p_specifier_qualifier_list->type_specifier_flags);
    }
}


void specifier_qualifier_list_add(struct specifier_qualifier_list* list, struct type_specifier_qualifier* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void specifier_qualifier_list_delete(struct specifier_qualifier_list* _Owner _Opt p)
{
    if (p)
    {
        struct type_specifier_qualifier* _Owner _Opt item = p->head;
        while (item)
        {
            struct type_specifier_qualifier* _Owner _Opt next = item->next;
            item->next = NULL;
            type_specifier_qualifier_delete(item);
            item = next;
        }

        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence);

        free(p);
    }
}

struct specifier_qualifier_list* _Owner _Opt specifier_qualifier_list(struct parser_ctx* ctx)
{
    struct specifier_qualifier_list* _Owner _Opt p_specifier_qualifier_list = NULL;
    try
    {
        if (!first_of_type_specifier_qualifier(ctx))
        {
            compiler_diagnostic(C_ERROR_MISSING_ENUM_TAG_NAME, ctx, ctx->current, NULL, "type specifier or qualifier expected");
            throw;
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_specifier_qualifier_list = calloc(1, sizeof(struct specifier_qualifier_list));
        if (p_specifier_qualifier_list == NULL)
            throw;

        /*
          type_specifier_qualifier attribute_specifier_sequence_opt
          type_specifier_qualifier specifier_qualifier_list
        */

        p_specifier_qualifier_list->first_token = ctx->current;

        while (ctx->current != NULL &&
            (first_of_type_specifier_qualifier(ctx)))
        {

            if (ctx->current->flags & TK_FLAG_IDENTIFIER_IS_TYPEDEF)
            {
                if (p_specifier_qualifier_list->type_specifier_flags != TYPE_SPECIFIER_NONE)
                {
                    // typedef tem que aparecer sozinho
                    // exemplo Socket eh nome e nao typdef
                    // typedef int Socket;
                    // struct X {int Socket;};
                    break;
                }
            }

            struct type_specifier_qualifier* _Owner _Opt p_type_specifier_qualifier = type_specifier_qualifier(ctx);
            if (p_type_specifier_qualifier == NULL)
            {
                throw;
            }

            if (p_type_specifier_qualifier->type_specifier)
            {
                if (add_specifier(ctx,
                    &p_specifier_qualifier_list->type_specifier_flags,
                    p_type_specifier_qualifier->type_specifier->flags) != 0)
                {
                    type_specifier_qualifier_delete(p_type_specifier_qualifier);
                    throw;
                }

                if (p_type_specifier_qualifier->type_specifier->struct_or_union_specifier)
                {
                    p_specifier_qualifier_list->struct_or_union_specifier = p_type_specifier_qualifier->type_specifier->struct_or_union_specifier;
                }
                else if (p_type_specifier_qualifier->type_specifier->enum_specifier)
                {
                    p_specifier_qualifier_list->enum_specifier = p_type_specifier_qualifier->type_specifier->enum_specifier;
                }
                else if (p_type_specifier_qualifier->type_specifier->typeof_specifier)
                {
                    p_specifier_qualifier_list->typeof_specifier = p_type_specifier_qualifier->type_specifier->typeof_specifier;
                }
                else if (p_type_specifier_qualifier->type_specifier->token->type == TK_IDENTIFIER)
                {
                    p_specifier_qualifier_list->typedef_declarator =
                        find_declarator(ctx,
                            p_type_specifier_qualifier->type_specifier->token->lexeme,
                            NULL);
                }
            }
            else if (p_type_specifier_qualifier->alignment_specifier)
            {
                p_specifier_qualifier_list->alignment_specifier_flags |= p_type_specifier_qualifier->alignment_specifier->flags;
            }
            else if (p_type_specifier_qualifier->type_qualifier)
            {
                p_specifier_qualifier_list->type_qualifier_flags |= p_type_specifier_qualifier->type_qualifier->flags;
            }

            assert(p_specifier_qualifier_list->p_attribute_specifier_sequence == NULL);
            p_specifier_qualifier_list->p_attribute_specifier_sequence = attribute_specifier_sequence_opt(ctx);

            specifier_qualifier_list_add(p_specifier_qualifier_list, p_type_specifier_qualifier);
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        final_specifier(ctx, &p_specifier_qualifier_list->type_specifier_flags);
        struct token* _Opt p_previous_parser_token = previous_parser_token(ctx->current);
        if (p_previous_parser_token == NULL) throw;

        p_specifier_qualifier_list->last_token = p_previous_parser_token;
    }
    catch
    {
        specifier_qualifier_list_delete(p_specifier_qualifier_list);
        p_specifier_qualifier_list = NULL;
    }

    return p_specifier_qualifier_list;
}

void type_qualifier_delete(struct type_qualifier* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        free(p);
    }
}

void type_specifier_qualifier_delete(struct type_specifier_qualifier* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        if (p->type_qualifier)
        {
            assert(p->type_qualifier->next == NULL);
            free(p->type_qualifier);
        }
        alignment_specifier_delete(p->alignment_specifier);

        type_specifier_delete(p->type_specifier);

        //ATENTION LIST?? SEE ABOVE TODO
        //type_qualifier_delete(p->type_qualifier);

        free(p);
    }
}

struct type_specifier_qualifier* _Owner _Opt type_specifier_qualifier(struct parser_ctx* ctx)
{
    struct type_specifier_qualifier* _Owner _Opt type_specifier_qualifier = NULL;
    try
    {
        type_specifier_qualifier = calloc(1, sizeof * type_specifier_qualifier);
        if (type_specifier_qualifier == NULL) throw;

        // type_specifier
        // type_qualifier
        // alignment_specifier
        if (first_of_type_specifier(ctx))
        {
            type_specifier_qualifier->type_specifier = type_specifier(ctx);
            if (type_specifier_qualifier->type_specifier == NULL) throw;
        }
        else if (first_of_type_qualifier(ctx))
        {
            type_specifier_qualifier->type_qualifier = type_qualifier(ctx);
            if (type_specifier_qualifier->type_qualifier == NULL) throw;
        }
        else if (first_of_alignment_specifier(ctx))
        {
            type_specifier_qualifier->alignment_specifier = alignment_specifier(ctx);
            if (type_specifier_qualifier->alignment_specifier == NULL) throw;
        }
        else
        {
            assert(false);
        }
    }
    catch
    {
        type_specifier_qualifier_delete(type_specifier_qualifier);
        type_specifier_qualifier = NULL;
    }
    return type_specifier_qualifier;
}

const struct enumerator* _Opt find_enumerator_by_value(const struct enum_specifier* p_enum_specifier, const struct object* object)
{
    if (p_enum_specifier->enumerator_list.head == NULL)
    {
        return NULL;
    }

    struct enumerator* _Opt p = p_enum_specifier->enumerator_list.head;
    while (p)
    {
        if (object_equal(&p->value, object))
            return p;
        p = p->next;
    }
    return NULL;
}

struct enum_specifier* _Owner enum_specifier_add_ref(struct enum_specifier* p)
{
    p->has_shared_ownership = true;
    return (struct enum_specifier* _Owner)p;
}

void enum_specifier_delete_sink(struct enum_specifier* _Owner _Opt p) {}

void enum_specifier_delete(struct enum_specifier* _Owner _Opt p)
{
    if (p)
    {
        if (p->has_shared_ownership > 0)
        {
            p->has_shared_ownership = false;
            enum_specifier_delete_sink(p);
            return;
        }

        specifier_qualifier_list_delete(p->specifier_qualifier_list);
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        enumerator_list_destroy(&p->enumerator_list);
        free(p);
    }
}

bool enum_specifier_has_fixed_underlying_type(const struct enum_specifier* p_enum_specifier)
{
    return p_enum_specifier->specifier_qualifier_list != NULL;
}

struct enum_specifier* _Owner _Opt enum_specifier(struct parser_ctx* ctx)
{
    /*
     enum-type-specifier:
     : specifier-qualifier-list
    */

    /*
        enum-specifier:

        "enum" attribute-specifier-sequence _Opt identifier _Opt enum-type-specifier _Opt
        { enumerator-list }

        "enum" attribute-specifier-sequence _Opt identifier _Opt enum-type-specifier _Opt
        { enumerator-list , }
        enum identifier enum-type-specifier _Opt
    */

    struct enum_specifier* _Owner _Opt p_enum_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_enum_specifier = calloc(1, sizeof * p_enum_specifier);
        if (p_enum_specifier == NULL)
            throw;

        p_enum_specifier->first_token = ctx->current;
        if (parser_match_tk(ctx, TK_KEYWORD_ENUM) != 0)
            throw;

        p_enum_specifier->attribute_specifier_sequence_opt =
            attribute_specifier_sequence_opt(ctx);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == TK_IDENTIFIER)
        {
            snprintf(p_enum_specifier->tag_name, sizeof p_enum_specifier->tag_name, "%s", ctx->current->lexeme);

            p_enum_specifier->tag_token = ctx->current;
            parser_match(ctx);
        }
        else
        {
            snprintf(p_enum_specifier->tag_name, sizeof p_enum_specifier->tag_name, "_anonymous_struct_%d", s_anonymous_struct_count);
            s_anonymous_struct_count++;
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == ':')
        {
            if (!ctx->inside_generic_association)
            {
                /*C23*/
                parser_match(ctx);
                p_enum_specifier->specifier_qualifier_list = specifier_qualifier_list(ctx);
                if (p_enum_specifier->specifier_qualifier_list == NULL)
                    throw;

                struct type enum_underline_type =
                    make_with_type_specifier_flags(p_enum_specifier->specifier_qualifier_list->type_specifier_flags);

                if (!type_is_integer(&enum_underline_type))
                {
                    type_destroy(&enum_underline_type);
                    compiler_diagnostic(C_ERROR_NON_INTEGRAL_ENUM_TYPE,
                        ctx,
                        p_enum_specifier->specifier_qualifier_list->first_token,
                        NULL,
                        "expected an integer type");

                    throw;
                }
                type_destroy(&enum_underline_type);
            }
            else
            {
            }
        }


        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == '{')
        {
            if (p_enum_specifier->tag_token)
                naming_convention_enum_tag(ctx, p_enum_specifier->tag_token);

            /*points to itself*/
            p_enum_specifier->p_complete_enum_specifier = p_enum_specifier;

            if (parser_match_tk(ctx, '{') != 0)
                throw;

            p_enum_specifier->enumerator_list = enumerator_list(ctx, p_enum_specifier);

            if (p_enum_specifier->enumerator_list.head == NULL)
                throw;

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->type == ',')
            {
                parser_match(ctx);
            }

            if (parser_match_tk(ctx, '}') != 0)
                throw;

            struct hash_item_set item = { 0 };
            item.p_enum_specifier = enum_specifier_add_ref(p_enum_specifier);
            hashmap_set(&ctx->scopes.tail->tags, p_enum_specifier->tag_name, &item);
            p_enum_specifier->p_complete_enum_specifier = p_enum_specifier;
            hash_item_set_destroy(&item);
        }
        else
        {
            struct enum_specifier* _Opt p_existing_enum_specifier = NULL;
            if (p_enum_specifier->tag_token)
            {
                p_existing_enum_specifier = find_enum_specifier(ctx, p_enum_specifier->tag_token->lexeme);
            }
            if (p_existing_enum_specifier)
            {
                //p_existing_enum_specifier->p_complete_enum_specifier = p_enum_specifier;
                //ja existe
                //verificar o caso de ser outro tag no memso escopo
                p_enum_specifier->p_complete_enum_specifier = p_existing_enum_specifier;
            }
            else
            {
                //nao existe lugar nenhum vamos adicionar
                struct hash_item_set item = { 0 };
                item.p_enum_specifier = enum_specifier_add_ref(p_enum_specifier);
                hashmap_set(&ctx->scopes.tail->tags, p_enum_specifier->tag_name, &item);
                p_enum_specifier->p_complete_enum_specifier = p_enum_specifier;
                hash_item_set_destroy(&item);
            }

            //if (!has_identifier)
            //{
              //  compiler_diagnostic(C_ERROR_MISSING_ENUM_TAG_NAME, ctx, ctx->current, "missing enum tag name");
                //throw;
            //}
        }
    }
    catch
    {
        enum_specifier_delete(p_enum_specifier);
        p_enum_specifier = NULL;
    }

    return p_enum_specifier;
}

void enumerator_list_add(struct enumerator_list* list, struct enumerator* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void enumerator_list_destroy(_Dtor struct enumerator_list* p)
{
    struct enumerator* _Owner _Opt item = p->head;
    while (item)
    {
        struct enumerator* _Owner _Opt next = item->next;
        item->next = NULL;
        enumerator_delete(item);
        item = next;
    }
}

struct enumerator_list enumerator_list(struct parser_ctx* ctx, const struct enum_specifier* p_enum_specifier)
{

    /*
       enumerator
        enumerator_list ',' enumerator
     */


    struct object next_enumerator_value = object_make_signed_int(0);

    if (p_enum_specifier->specifier_qualifier_list)
    {
        enum object_value_type vt = type_specifier_to_object_type(p_enum_specifier->specifier_qualifier_list->type_specifier_flags);
        next_enumerator_value = object_cast(vt, &next_enumerator_value);
    }

    struct enumerator_list enumeratorlist = { 0 };
    struct enumerator* _Owner _Opt p_enumerator = NULL;
    try
    {
        p_enumerator = enumerator(ctx, p_enum_specifier, &next_enumerator_value);
        if (p_enumerator == NULL)
            throw;

        enumerator_list_add(&enumeratorlist, p_enumerator);

        while (ctx->current != NULL && ctx->current->type == ',')
        {
            parser_match(ctx); /*pode ter uma , vazia no fim*/

            if (ctx->current && ctx->current->type != '}')
            {
                p_enumerator = enumerator(ctx, p_enum_specifier, &next_enumerator_value);
                if (p_enumerator == NULL)
                    throw;
                enumerator_list_add(&enumeratorlist, p_enumerator);
            }
        }
    }
    catch
    {
        enumerator_list_destroy(&enumeratorlist);
        enumeratorlist.head = NULL;
        enumeratorlist.tail = NULL;
    }

    return enumeratorlist;
}

struct enumerator* _Owner enumerator_add_ref(struct enumerator* p)
{
    p->has_shared_ownership = true;
    return (struct enumerator* _Owner) p;
}


void enumerator_sink(struct enumerator* _Owner _Opt p) {}

void enumerator_delete(struct enumerator* _Owner _Opt p)
{
    if (p)
    {
        if (p->has_shared_ownership > 0)
        {
            p->has_shared_ownership = false;
            enumerator_sink(p);
            return;
        }

        assert(p->next == NULL);
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        expression_delete(p->constant_expression_opt);

        free(p);
    }
}

struct enumerator* _Owner _Opt enumerator(struct parser_ctx* ctx,
    const struct enum_specifier* p_enum_specifier,
    struct object* p_next_enumerator_value)
{
    // TODO VALUE    
    struct enumerator* _Owner _Opt p_enumerator = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_enumerator = calloc(1, sizeof(struct enumerator));
        if (p_enumerator == NULL)
            throw;

        p_enumerator->enum_specifier = p_enum_specifier;
        struct token* name = ctx->current;

        naming_convention_enumerator(ctx, name);

        if (parser_match_tk(ctx, TK_IDENTIFIER) != 0)
            throw;

        p_enumerator->attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);

        p_enumerator->token = name;

        struct hash_item_set item = { 0 };
        item.p_enumerator = enumerator_add_ref(p_enumerator);
        hashmap_set(&ctx->scopes.tail->variables, p_enumerator->token->lexeme, &item);
        hash_item_set_destroy(&item);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == '=')
        {
            parser_match(ctx);
            assert(p_enumerator->constant_expression_opt == NULL);
            p_enumerator->constant_expression_opt = constant_expression(ctx, true);
            if (p_enumerator->constant_expression_opt == NULL) throw;

            if (enum_specifier_has_fixed_underlying_type(p_enum_specifier))
            {

            }
            else
            {
                //if the value is bigger than int the enum whould type must be fixed
            }
            p_enumerator->value = p_enumerator->constant_expression_opt->object;

            //fixes #257
            *p_next_enumerator_value = *object_get_referenced(&p_enumerator->value);

            if (object_increment_value(p_next_enumerator_value) != 0)
            {
                //overflow TODO
            }
        }
        else
        {
            p_enumerator->value = *p_next_enumerator_value;
            if (object_increment_value(p_next_enumerator_value) != 0)
            {
                //overflow
            }
        }
    }
    catch
    {
        enumerator_delete(p_enumerator);
        p_enumerator = NULL;
    }
    return p_enumerator;
}

void alignment_specifier_delete(struct alignment_specifier* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->constant_expression);
        type_name_delete(p->type_name);
        free(p);
    }
}

struct alignment_specifier* _Owner _Opt alignment_specifier(struct parser_ctx* ctx)
{
    struct alignment_specifier* _Owner _Opt alignment_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        alignment_specifier = calloc(1, sizeof * alignment_specifier);

        if (alignment_specifier == NULL)
            throw;

        alignment_specifier->token = ctx->current;
        if (parser_match_tk(ctx, TK_KEYWORD__ALIGNAS) != 0)
            throw;
        if (parser_match_tk(ctx, '(') != 0)
            throw;
        if (first_of_type_name(ctx))
        {
            alignment_specifier->type_name = type_name(ctx);
            if (alignment_specifier->type_name == NULL)
                throw;
        }
        else
        {
            alignment_specifier->constant_expression = constant_expression(ctx, true);
            if (alignment_specifier->constant_expression == NULL)
                throw;
            if (object_has_constant_value(&alignment_specifier->constant_expression->object))
            {
                long a = object_to_signed_long(&alignment_specifier->constant_expression->object);
                if (a == 8)
                    alignment_specifier->flags |= ALIGNMENT_SPECIFIER_8_FLAGS;
                else if (a == 16)
                    alignment_specifier->flags |= ALIGNMENT_SPECIFIER_16_FLAGS;
                else if (a == 32)
                    alignment_specifier->flags |= ALIGNMENT_SPECIFIER_32_FLAGS;
                else if (a == 64)
                    alignment_specifier->flags |= ALIGNMENT_SPECIFIER_64_FLAGS;
                else if (a == 128)
                    alignment_specifier->flags |= ALIGNMENT_SPECIFIER_128_FLAGS;

            }
        }
        if (parser_match_tk(ctx, ')') != 0)
            throw;
    }
    catch
    {
    }
    return alignment_specifier;
}

void atomic_type_specifier_delete(struct atomic_type_specifier* _Owner _Opt p)
{
    if (p)
    {
        type_name_delete(p->type_name);
        free(p);
    }
}

struct atomic_type_specifier* _Owner _Opt atomic_type_specifier(struct parser_ctx* ctx)
{
    //'_Atomic' '(' type_name ')'
    struct atomic_type_specifier* _Owner _Opt p_atomic_type_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_atomic_type_specifier = calloc(1, sizeof * p_atomic_type_specifier);
        if (p_atomic_type_specifier == NULL)
            throw;

        p_atomic_type_specifier->token = ctx->current;
        if (parser_match_tk(ctx, TK_KEYWORD__ATOMIC) != 0)
            throw;
        if (parser_match_tk(ctx, '(') != 0)
            throw;

        struct type_name* _Owner _Opt ptemp = type_name(ctx);
        if (ptemp == NULL)
        {
            throw;
        }

        p_atomic_type_specifier->type_name = ptemp;
        if (parser_match_tk(ctx, ')') != 0)
            throw;
    }
    catch
    {
        atomic_type_specifier_delete(p_atomic_type_specifier);
        p_atomic_type_specifier = NULL;
    }
    return p_atomic_type_specifier;
}


struct type_qualifier* _Owner _Opt type_qualifier(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
    {
        unexpected_end_of_file(ctx);
        return NULL;
    }

    struct type_qualifier* _Owner _Opt p_type_qualifier = calloc(1, sizeof * p_type_qualifier);

    if (p_type_qualifier == NULL)
        return NULL;

    switch (ctx->current->type)
    {
    case TK_KEYWORD_CONST:
        p_type_qualifier->flags = TYPE_QUALIFIER_CONST;
        break;
    case TK_KEYWORD_RESTRICT:
        p_type_qualifier->flags = TYPE_QUALIFIER_RESTRICT;
        break;
    case TK_KEYWORD_VOLATILE:
        p_type_qualifier->flags = TYPE_QUALIFIER_VOLATILE;
        break;
    case TK_KEYWORD__ATOMIC:
        p_type_qualifier->flags = TYPE_QUALIFIER__ATOMIC;
        break;
    case TK_KEYWORD_MSVC__PTR32:
        p_type_qualifier->flags = TYPE_QUALIFIER_MSVC_PTR32;
        break;
    case TK_KEYWORD_MSVC__PTR64:
        p_type_qualifier->flags = TYPE_QUALIFIER_MSVC_PTR64;
        break;

    default:
        // do nothing
        break;
    }

    if (ctx->options.ownership_enabled)
    {
        switch (ctx->current->type)
        {
        case TK_KEYWORD__CTOR:
            p_type_qualifier->flags = TYPE_QUALIFIER_CTOR;
            break;

        case TK_KEYWORD__DTOR:
            p_type_qualifier->flags = TYPE_QUALIFIER_DTOR;
            break;

        case TK_KEYWORD_CAKE_OWNER:
            p_type_qualifier->flags = TYPE_QUALIFIER_OWNER;
            break;

        case TK_KEYWORD_CAKE_VIEW:
            p_type_qualifier->flags = TYPE_QUALIFIER_VIEW;
            break;

        default:
            // do nothing
            break;
        }
    }

    if (ctx->options.null_checks_enabled)
    {
        switch (ctx->current->type)
        {
        case TK_KEYWORD_CAKE_OPT:
            p_type_qualifier->flags = TYPE_QUALIFIER_OPT;
            break;

        default:
            // do nothing
            break;
        }
    }

    p_type_qualifier->token = ctx->current;

    //'const'
    //'restrict'
    //'volatile'
    //'_Atomic'
    parser_match(ctx);
    return p_type_qualifier;
}
//

struct type_qualifier* _Owner _Opt type_qualifier_opt(struct parser_ctx* ctx)
{
    if (first_of_type_qualifier(ctx))
    {
        return type_qualifier(ctx);
    }
    return NULL;
}

void function_specifier_delete(struct function_specifier* _Owner _Opt p)
{
    if (p)
    {
        free(p);
    }
}

struct function_specifier* _Owner _Opt function_specifier(struct parser_ctx* ctx)
{
    struct function_specifier* _Owner _Opt p_function_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }


        p_function_specifier = calloc(1, sizeof * p_function_specifier);
        if (p_function_specifier == NULL)
            throw;

        if (ctx->current->type == TK_KEYWORD__NORETURN)
        {
            compiler_diagnostic(W_STYLE, ctx, ctx->current, NULL, "_Noreturn is deprecated use attributes");
        }

        if (ctx->current->type == TK_KEYWORD_INLINE)
        {
            p_function_specifier->flags |= FUNCTION_SPECIFIER_INLINE;
        }

        p_function_specifier->token = ctx->current;
        parser_match(ctx);
    }
    catch
    {
        function_specifier_delete(p_function_specifier);
        p_function_specifier = NULL;
    }

    return p_function_specifier;
}

struct declarator* _Owner declarator_add_ref(struct declarator* p)
{
    p->has_shared_ownership = true;
    return (struct declarator* _Owner)p;
}

void declarator_sink(struct declarator* _Owner _Opt p) {}

void declarator_delete(struct declarator* _Owner _Opt p)
{
    if (p)
    {
        if (p->has_shared_ownership > 0)
        {
            p->has_shared_ownership = false;
            declarator_sink(p);
            return;
        }

        type_destroy(&p->type);
        direct_declarator_delete(p->direct_declarator);
        pointer_delete(p->pointer);
        free(p);
    }
}

struct declarator* _Owner _Opt declarator(struct parser_ctx* ctx,
    const struct specifier_qualifier_list* _Opt p_specifier_qualifier_list_opt,
    struct declaration_specifiers* _Opt p_declaration_specifiers_opt,
    bool abstract_acceptable,
    struct token** _Opt pp_token_name_opt)
{
    /*
      declarator:
      pointer_opt direct-declarator
    */

    struct declarator* _Owner _Opt p_declarator = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_declarator = calloc(1, sizeof(struct declarator));
        if (p_declarator == NULL) throw;

        p_declarator->first_token_opt = ctx->current;
        p_declarator->pointer = pointer_opt(ctx);
        p_declarator->direct_declarator = direct_declarator(ctx, p_specifier_qualifier_list_opt, p_declaration_specifiers_opt, abstract_acceptable, pp_token_name_opt);
        if (p_declarator->direct_declarator == NULL) throw;

        if (pp_token_name_opt && *pp_token_name_opt)
        {
            free((void*)p_declarator->object.debug_name);
            p_declarator->object.debug_name = strdup((*pp_token_name_opt)->lexeme);
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current != p_declarator->first_token_opt)
        {
            p_declarator->last_token_opt = previous_parser_token(ctx->current);
        }
        else
        {
            /*empty declarator*/
            p_declarator->last_token_opt = p_declarator->first_token_opt;
            p_declarator->first_token_opt = NULL; /*this is the way we can know...first is null*/
        }
    }
    catch
    {
        declarator_delete(p_declarator);
        p_declarator = NULL;
    }


    return p_declarator;
}

const char* _Opt declarator_get_name(struct declarator* p_declarator)
{
    if (p_declarator->direct_declarator)
    {
        if (p_declarator->direct_declarator->name_opt)
            return p_declarator->direct_declarator->name_opt->lexeme;
    }

    return NULL;
}

bool declarator_is_function(struct declarator* p_declarator)
{
    return (p_declarator->direct_declarator &&
        p_declarator->direct_declarator->function_declarator != NULL);
}

struct array_declarator* _Owner _Opt array_declarator(struct direct_declarator* _Owner p_direct_declarator, struct parser_ctx* ctx);
struct function_declarator* _Owner _Opt function_declarator(struct direct_declarator* _Owner p_direct_declarator, struct parser_ctx* ctx);

void function_declarator_delete(struct function_declarator* _Owner _Opt p)
{
    if (p)
    {
        direct_declarator_delete(p->direct_declarator);
        scope_destroy(&p->parameters_scope);
        parameter_type_list_delete(p->parameter_type_list_opt);
        free(p);
    }
}

void direct_declarator_delete(struct direct_declarator* _Owner _Opt p)
{
    if (p)
    {
        declarator_delete(p->declarator);
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence_opt);
        array_declarator_delete(p->array_declarator);
        function_declarator_delete(p->function_declarator);

        free(p);
    }
}

struct direct_declarator* _Owner _Opt direct_declarator(struct parser_ctx* ctx,
    const struct specifier_qualifier_list* _Opt p_specifier_qualifier_list,
    struct declaration_specifiers* _Opt p_declaration_specifiers,
    bool abstract_acceptable,
    struct token** _Opt pp_token_name_opt)
{
    /*
    direct-declarator:
     identifier attribute-specifier-sequence opt
     ( declarator )

     array-declarator attribute-specifier-sequence opt
     function-declarator attribute-specifier-sequence opt
    */


    struct direct_declarator* _Owner _Opt p_direct_declarator = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_direct_declarator = calloc(1, sizeof(struct direct_declarator));
        if (p_direct_declarator == NULL) throw;

        struct token* _Opt p_token_ahead = parser_look_ahead(ctx);
        if (p_token_ahead == NULL)
            throw;

        if (ctx->current->type == TK_KEYWORD_MSVC__STDCALL ||
            ctx->current->type == TK_KEYWORD_MSVC__CDECL ||
            ctx->current->type == TK_KEYWORD_MSVC__FASTCALL)
        {
            /*
              int __fastcall add(int a, int b);
            */
            p_direct_declarator->p_calling_convention = ctx->current;
            parser_match(ctx);
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == TK_IDENTIFIER)
        {
            p_direct_declarator->name_opt = ctx->current;
            if (pp_token_name_opt != NULL)
            {
                *pp_token_name_opt = ctx->current;
            }

            parser_match(ctx);
            p_direct_declarator->p_attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);
        }
        else if (ctx->current->type == '(')
        {
            struct token* _Opt ahead = parser_look_ahead(ctx);
            if (ahead == NULL)
                throw;

            if (!first_of_type_specifier_token(ctx, p_token_ahead) &&
                !first_of_type_qualifier_token(p_token_ahead) &&
                ahead->type != ')' &&
                ahead->type != '...')
            {
                // look ahead para nao confundir (declarator) com parametros funcao ex void (int)
                // or function int ()

                parser_match(ctx);

                struct declarator* _Owner _Opt p_declarator_temp =
                    declarator(ctx,
                        p_specifier_qualifier_list,
                        p_declaration_specifiers,
                        abstract_acceptable,
                        pp_token_name_opt);

                if (p_declarator_temp == NULL)
                    throw;

                p_direct_declarator->declarator = p_declarator_temp;
                parser_match(ctx); //)
            }
        }

        while (ctx->current != NULL &&
            (ctx->current->type == '[' || ctx->current->type == '('))
        {
            struct direct_declarator* _Owner _Opt p_direct_declarator2 = calloc(1, sizeof(struct direct_declarator));
            if (p_direct_declarator2 == NULL) throw;

            if (ctx->current->type == '[')
            {
                p_direct_declarator2->array_declarator = array_declarator(p_direct_declarator, ctx);
                p_direct_declarator = NULL; //MOVED
                if (p_direct_declarator2->array_declarator == NULL)
                {
                    direct_declarator_delete(p_direct_declarator2);
                    throw;
                }
            }
            else
            {
                p_direct_declarator2->function_declarator = function_declarator(p_direct_declarator, ctx);
                p_direct_declarator = NULL; //MOVED
                if (p_direct_declarator2->function_declarator == NULL)
                {
                    direct_declarator_delete(p_direct_declarator2);
                    throw;
                }
            }
            p_direct_declarator = p_direct_declarator2;
            assert(p_direct_declarator->p_attribute_specifier_sequence_opt == NULL);
            p_direct_declarator->p_attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);
        }
    }
    catch
    {
        direct_declarator_delete(p_direct_declarator);
        p_direct_declarator = NULL;
    }

    return p_direct_declarator;
}

void array_declarator_delete(struct array_declarator* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->assignment_expression);
        direct_declarator_delete(p->direct_declarator);
        expression_delete(p->expression);
        type_qualifier_list_delete(p->type_qualifier_list_opt);

        free(p);
    }
}

size_t array_declarator_get_size(const struct array_declarator* p_array_declarator)
{
    if (p_array_declarator->assignment_expression)
    {
        if (object_has_constant_value(&p_array_declarator->assignment_expression->object))
        {
            return (size_t)object_to_unsigned_long_long(&p_array_declarator->assignment_expression->object);
        }
    }
    return 0;
}

struct array_declarator* _Owner _Opt array_declarator(struct direct_declarator* _Owner p_direct_declarator, struct parser_ctx* ctx)
{
    // direct_declarator '['          type_qualifier_list_opt           assignment_expression_opt ']'
    // direct_declarator '[' 'static' type_qualifier_list_opt           assignment_expression     ']'
    // direct_declarator '['          type_qualifier_list      'static' assignment_expression     ']'
    // direct_declarator '['          type_qualifier_list_opt  '*'           ']'

    struct array_declarator* _Owner _Opt p_array_declarator = NULL;
    try
    {
        p_array_declarator = calloc(1, sizeof * p_array_declarator);
        if (p_array_declarator == NULL)
        {
            throw;
        }

        p_array_declarator->direct_declarator = p_direct_declarator;
        p_direct_declarator = NULL; /*MOVED*/

        if (parser_match_tk(ctx, '[') != 0)
            throw;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        bool has_static = false;
        if (ctx->current->type == TK_KEYWORD_STATIC)
        {
            p_array_declarator->static_token_opt = ctx->current;
            parser_match(ctx);
            has_static = true;
        }

        if (first_of_type_qualifier(ctx))
        {
            p_array_declarator->type_qualifier_list_opt = type_qualifier_list(ctx);
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (!has_static)
        {
            if (ctx->current->type == TK_KEYWORD_STATIC)
            {
                parser_match(ctx);
                has_static = true;
            }
        }

        if (has_static)
        {
            // tem que ter..

            const bool evaluation_is_disabled = ctx->evaluation_is_disabled;
            ctx->evaluation_is_disabled = false;
            p_array_declarator->assignment_expression = assignment_expression(ctx);
            /*restore*/
            ctx->evaluation_is_disabled = evaluation_is_disabled;

            if (p_array_declarator->assignment_expression == NULL)
                throw;
        }
        else
        {
            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            // optional
            if (ctx->current->type == '*')
            {
                parser_match(ctx);
            }
            else if (ctx->current->type != ']')
            {
                const bool evaluation_is_disabled = ctx->evaluation_is_disabled;
                ctx->evaluation_is_disabled = false;
                p_array_declarator->assignment_expression = assignment_expression(ctx);

                /*restore*/
                ctx->evaluation_is_disabled = evaluation_is_disabled;

                if (p_array_declarator->assignment_expression == NULL)
                    throw;
            }
            else
            {
            }
        }

        if (parser_match_tk(ctx, ']') != 0)
            throw;
    }
    catch
    {
        array_declarator_delete(p_array_declarator);
        p_array_declarator = NULL;

    }

    direct_declarator_delete(p_direct_declarator);

    return p_array_declarator;
}

struct function_declarator* _Owner _Opt function_declarator(struct direct_declarator* _Owner p_direct_declarator_arg, struct parser_ctx* ctx)
{
    struct direct_declarator* _Owner _Opt p_direct_declarator = p_direct_declarator_arg; //MOVED

    struct function_declarator* _Owner _Opt p_function_declarator = calloc(1, sizeof(struct function_declarator));
    try
    {
        if (p_function_declarator == NULL)
        {
            throw;
        }

        // faz um push da funcion_scope_declarator_list que esta vivendo mais em cima
        // eh feito o pop mais em cima tb.. aqui dentro do decide usar.
        // ctx->funcion_scope_declarator_list->outer_scope = ctx->current_scope;
        // ctx->current_scope = ctx->funcion_scope_declarator_list;
        // direct_declarator '(' parameter_type_list_opt ')'

        p_function_declarator->direct_declarator = p_direct_declarator;
        p_direct_declarator = NULL; /*MOVED*/
        p_function_declarator->parameters_scope.scope_level = ctx->scopes.tail->scope_level + 1;
        p_function_declarator->parameters_scope.variables.capacity = 5;
        p_function_declarator->parameters_scope.tags.capacity = 1;

        if (parser_match_tk(ctx, '(') != 0)
            throw;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type != ')')
        {
            scope_list_push(&ctx->scopes, &p_function_declarator->parameters_scope);
            p_function_declarator->parameter_type_list_opt = parameter_type_list(ctx);
            scope_list_pop(&ctx->scopes);
            if (p_function_declarator->parameter_type_list_opt == NULL)
                throw;
        }
        if (parser_match_tk(ctx, ')') != 0)
            throw;

    }
    catch
    {
        function_declarator_delete(p_function_declarator);
        p_function_declarator = NULL;
    }

    direct_declarator_delete(p_direct_declarator);
    return p_function_declarator;
}

void pointer_delete(struct pointer* _Owner _Opt p)
{
    if (p)
    {
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        type_qualifier_list_delete(p->type_qualifier_list_opt);

        struct pointer* _Owner _Opt item = p->pointer;
        while (item)
        {
            struct pointer* _Owner _Opt next = item->pointer;
            attribute_specifier_sequence_delete(item->attribute_specifier_sequence_opt);
            type_qualifier_list_delete(item->type_qualifier_list_opt);
            free(item);
            item = next;
        }

        free(p);
    }
}

struct pointer* _Owner _Opt pointer_opt(struct parser_ctx* ctx)
{
    struct pointer* _Owner _Opt p = NULL;
    struct pointer* _Owner _Opt p_pointer = NULL;
    try
    {
        struct token* _Opt calling_convention = NULL;
        struct token* _Opt ahead = parser_look_ahead(ctx);
        if (ahead != NULL && ahead->type == '*')
        {
            /*
              typedef void (__fastcall *pf)();
            */
            if (ctx->current->type == TK_KEYWORD_MSVC__STDCALL ||
                ctx->current->type == TK_KEYWORD_MSVC__CDECL ||
                ctx->current->type == TK_KEYWORD_MSVC__FASTCALL)
            {
                calling_convention = ctx->current;
                parser_match(ctx);
            }
        }

        while (ctx->current != NULL && ctx->current->type == '*')
        {
            p_pointer = calloc(1, sizeof(struct pointer));
            if (p_pointer == NULL)
                throw;

            p_pointer->calling_convention = calling_convention;
            calling_convention = NULL;

            p = p_pointer;
            parser_match(ctx);

            p_pointer->attribute_specifier_sequence_opt =
                attribute_specifier_sequence_opt(ctx);

            if (first_of_type_qualifier(ctx))
            {
                assert(ctx->current != NULL);

                if (ctx->current->type == TK_KEYWORD_CAKE_VIEW)
                {
                    compiler_diagnostic(C_ERROR_INVALID_QUALIFIER_FOR_POINTER,
                                ctx,
                                ctx->current,
                                NULL,
                                "invalid qualifier for pointer");
                }
                else
                {
                    p_pointer->type_qualifier_list_opt = type_qualifier_list(ctx);
                }
            }

            while (ctx->current != NULL && ctx->current->type == '*')
            {
                p_pointer->pointer = pointer_opt(ctx);
                if (p_pointer->pointer == NULL)
                    throw;
            }
        }
    }
    catch
    {
    }

    //'*' attribute_specifier_sequence_opt type_qualifier_list_opt
    //'*' attribute_specifier_sequence_opt type_qualifier_list_opt pointer
    return p;
}

void type_qualifier_list_add(struct type_qualifier_list* list, struct type_qualifier* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void type_qualifier_list_delete(struct type_qualifier_list* _Owner _Opt p)
{
    if (p)
    {
        struct type_qualifier* _Owner _Opt item = p->head;
        while (item)
        {
            struct type_qualifier* _Owner _Opt next = item->next;
            item->next = NULL;
            free(item);
            item = next;
        }
        free(p);
    }
}

struct type_qualifier_list* _Owner _Opt type_qualifier_list(struct parser_ctx* ctx)
{
    // type_qualifier
    // type_qualifier_list type_qualifier

    struct type_qualifier_list* _Owner _Opt p_type_qualifier_list = NULL;
    struct type_qualifier* _Owner _Opt p_type_qualifier = NULL;

    try
    {
        p_type_qualifier_list = calloc(1, sizeof(struct type_qualifier_list));
        if (p_type_qualifier_list == NULL)
            throw;

        p_type_qualifier = type_qualifier(ctx);
        if (p_type_qualifier == NULL)
            throw;

        p_type_qualifier_list->flags |= p_type_qualifier->flags;
        type_qualifier_list_add(p_type_qualifier_list, p_type_qualifier);
        p_type_qualifier = NULL; /*MOVED*/

        while (ctx->current != NULL && first_of_type_qualifier(ctx))
        {
            p_type_qualifier = type_qualifier(ctx);
            if (p_type_qualifier == NULL)
                throw;

            p_type_qualifier_list->flags |= p_type_qualifier->flags;
            type_qualifier_list_add(p_type_qualifier_list, p_type_qualifier);
            p_type_qualifier = NULL; /*MOVED*/
        }
    }
    catch
    {
    }

    return p_type_qualifier_list;
}

void parameter_type_list_delete(struct parameter_type_list* _Owner _Opt p)
{
    if (p)
    {
        parameter_list_delete(p->parameter_list);
        free(p);
    }
}

struct parameter_type_list* _Owner _Opt parameter_type_list(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return NULL;

    struct parameter_type_list* _Owner _Opt p_parameter_type_list = calloc(1, sizeof(struct parameter_type_list));

    try
    {
        if (p_parameter_type_list == NULL)
            throw;

        if (ctx->current->type == '...')
        {
            parser_match(ctx);
            // parser_match_tk(ctx, '...');
            p_parameter_type_list->is_var_args = true;
            return p_parameter_type_list;
        }

        // parameter_list
        // parameter_list ',' '...'
        // ...

        p_parameter_type_list->parameter_list = parameter_list(ctx);
        if (p_parameter_type_list->parameter_list == NULL) throw;

        if (p_parameter_type_list->parameter_list->head ==
            p_parameter_type_list->parameter_list->tail)
        {
            if (type_is_void(&p_parameter_type_list->parameter_list->head->declarator->type))
            {
                p_parameter_type_list->is_void = true;
            }
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        /*ja esta saindo com a virgula consumida do parameter_list para evitar ahead*/
        if (ctx->current->type == '...')
        {
            parser_match(ctx);
            // parser_match_tk(ctx, '...');
            p_parameter_type_list->is_var_args = true;
        }
    }
    catch
    {
        parameter_type_list_delete(p_parameter_type_list);
        p_parameter_type_list = NULL;
    }

    return p_parameter_type_list;
}

void parameter_list_add(struct parameter_list* list, struct parameter_declaration* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void parameter_list_delete(struct parameter_list* _Owner _Opt p)
{
    if (p)
    {
        struct parameter_declaration* _Owner _Opt item = p->head;
        while (item)
        {
            struct parameter_declaration* _Owner _Opt next = item->next;
            item->next = NULL;
            parameter_declaration_delete(item);
            item = next;
        }
        free(p);
    }
}

struct parameter_list* _Owner _Opt parameter_list(struct parser_ctx* ctx)
{
    /*
      parameter_list
      parameter_declaration
      parameter_list ',' parameter_declaration
    */
    struct parameter_list* _Owner _Opt p_parameter_list = NULL;
    struct parameter_declaration* _Owner _Opt p_parameter_declaration = NULL;
    try
    {
        p_parameter_list = calloc(1, sizeof(struct parameter_list));
        if (p_parameter_list == NULL)
            throw;

        p_parameter_declaration = parameter_declaration(ctx);
        if (p_parameter_declaration == NULL)
            throw;

        parameter_list_add(p_parameter_list, p_parameter_declaration);
        p_parameter_declaration = NULL; /*MOVED*/

        while (ctx->current != NULL && ctx->current->type == ',')
        {
            parser_match(ctx);

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->type == '...')
            {
                // follow
                break;
            }

            p_parameter_declaration = parameter_declaration(ctx);
            if (p_parameter_declaration == NULL)
                throw;

            parameter_list_add(p_parameter_list, p_parameter_declaration);
            p_parameter_declaration = NULL; /*MOVED*/
        }
    }
    catch
    {
        parameter_list_delete(p_parameter_list);
        p_parameter_list = NULL;
    }
    return p_parameter_list;
}

void parameter_declaration_delete(struct parameter_declaration* _Owner _Opt p)
{
    if (p)
    {
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        declaration_specifiers_delete(p->declaration_specifiers);
        declarator_delete(p->declarator);

        assert(p->next == NULL);
        free(p);
    }
}

struct parameter_declaration* _Owner _Opt parameter_declaration(struct parser_ctx* ctx)
{


    struct parameter_declaration* _Owner _Opt p_parameter_declaration = calloc(1, sizeof(struct parameter_declaration));
    try
    {
        if (p_parameter_declaration == NULL)
            throw;

        p_parameter_declaration->attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);

        struct declaration_specifiers* _Owner _Opt p_declaration_specifiers =
            declaration_specifiers(ctx, STORAGE_SPECIFIER_PARAMETER | STORAGE_SPECIFIER_BLOCK_SCOPE);

        if (p_declaration_specifiers == NULL)
        {
            throw;
        }

        if (p_parameter_declaration->attribute_specifier_sequence_opt)
        {
            if (p_parameter_declaration->attribute_specifier_sequence_opt->attributes_flags & CAKE_ATTRIBUTE_CTOR)
            {
                p_declaration_specifiers->type_qualifier_flags |= TYPE_QUALIFIER_CTOR;
            }
            else if (p_parameter_declaration->attribute_specifier_sequence_opt->attributes_flags & CAKE_ATTRIBUTE_DTOR)
            {
                p_declaration_specifiers->type_qualifier_flags |= TYPE_QUALIFIER_DTOR;
            }
        }
        p_parameter_declaration->declaration_specifiers = p_declaration_specifiers;


        struct token* _Opt p_token_name = NULL;

        p_parameter_declaration->declarator = declarator(ctx,
            /*specifier_qualifier_list*/ NULL,
            p_parameter_declaration->declaration_specifiers,
            true /*can be abstract*/,
            &p_token_name);

        if (p_parameter_declaration->declarator == NULL) throw;

        p_parameter_declaration->declarator->name_opt = p_token_name;
        p_parameter_declaration->declarator->declaration_specifiers = p_parameter_declaration->declaration_specifiers;

#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wmissing-destructor"        
        p_parameter_declaration->declarator->type = make_type_using_declarator(ctx, p_parameter_declaration->declarator);
#pragma cake diagnostic pop

        if (p_parameter_declaration->declarator->type.storage_class_specifier_flags & STORAGE_SPECIFIER_TYPEDEF)
        {
        }
        else
        {
            int er = make_object(&p_parameter_declaration->declarator->type, &p_parameter_declaration->declarator->object);
            if (er != 0)
            {
                //compiler_diagnostic(C_ERROR_STRUCT_IS_INCOMPLETE, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "incomplete struct/union type");
                throw;
            }
        }

        if (p_parameter_declaration->declarator->name_opt)
        {
            free((void*)p_parameter_declaration->declarator->object.debug_name);
            p_parameter_declaration->declarator->object.debug_name = strdup(p_parameter_declaration->declarator->name_opt->lexeme);
        }

        object_set_any(&p_parameter_declaration->declarator->object);


        if (p_parameter_declaration->attribute_specifier_sequence_opt)
        {
            p_parameter_declaration->declarator->type.attributes_flags |=
                p_parameter_declaration->attribute_specifier_sequence_opt->attributes_flags;
        }

        p_parameter_declaration->declarator->type.storage_class_specifier_flags |= STORAGE_SPECIFIER_PARAMETER;

        if (p_parameter_declaration->declarator->name_opt)
            naming_convention_parameter(ctx, p_parameter_declaration->declarator->name_opt, &p_parameter_declaration->declarator->type);

        // coloca o pametro no escpo atual que deve apontar para escopo paramtros
        //  da funcao .
        //
        // assert ctx->current_scope->variables parametrosd
        if (p_parameter_declaration->declarator->name_opt)
        {
            struct hash_item_set item = { 0 };
            item.p_declarator = declarator_add_ref(p_parameter_declaration->declarator);

            assert(p_parameter_declaration->declarator->name_opt != NULL); //add_ref will not change that

            // parametro void nao te name
            hashmap_set(&ctx->scopes.tail->variables,
                p_parameter_declaration->declarator->name_opt->lexeme,
                &item);

            // print_scope(ctx->current_scope);
            hash_item_set_destroy(&item);
        }
    }
    catch
    {
        parameter_declaration_delete(p_parameter_declaration);
        p_parameter_declaration = NULL;
    }

    return p_parameter_declaration;
}

struct specifier_qualifier_list* _Owner _Opt copy(struct declaration_specifiers* p_declaration_specifiers)
{
    struct specifier_qualifier_list* _Owner _Opt p_specifier_qualifier_list = calloc(1, sizeof(struct specifier_qualifier_list));

    try
    {
        if (p_specifier_qualifier_list == NULL)
            throw;

        p_specifier_qualifier_list->type_qualifier_flags = p_declaration_specifiers->type_qualifier_flags;
        p_specifier_qualifier_list->type_specifier_flags = p_declaration_specifiers->type_specifier_flags;

        struct declaration_specifier* _Opt p_declaration_specifier = p_declaration_specifiers->head;

        while (p_declaration_specifier)
        {
            if (p_declaration_specifier->type_specifier_qualifier)
            {
                struct type_specifier_qualifier* _Owner _Opt p_specifier_qualifier = calloc(1, sizeof(struct type_specifier_qualifier));

                if (p_specifier_qualifier == NULL)
                {
                    throw;
                }

                if (p_declaration_specifier->type_specifier_qualifier->type_qualifier)
                {
                    struct type_qualifier* _Owner _Opt p_type_qualifier = calloc(1, sizeof(struct type_qualifier));
                    if (p_type_qualifier == NULL)
                    {
                        type_specifier_qualifier_delete(p_specifier_qualifier);
                        throw;
                    }

                    p_type_qualifier->flags = p_declaration_specifier->type_specifier_qualifier->type_qualifier->flags;

                    p_type_qualifier->token = p_declaration_specifier->type_specifier_qualifier->type_qualifier->token;
                    p_specifier_qualifier->type_qualifier = p_type_qualifier;
                }
                else if (p_declaration_specifier->type_specifier_qualifier->type_specifier)
                {
                    struct type_specifier* _Owner _Opt p_type_specifier = calloc(1, sizeof(struct type_specifier));
                    if (p_type_specifier == NULL)
                    {
                        type_specifier_qualifier_delete(p_specifier_qualifier);
                        throw;
                    }

                    p_type_specifier->flags = p_declaration_specifier->type_specifier_qualifier->type_specifier->flags;

                    // todo
                    assert(p_declaration_specifier->type_specifier_qualifier->type_specifier->struct_or_union_specifier == NULL);

                    p_type_specifier->token = p_declaration_specifier->type_specifier_qualifier->type_specifier->token;
                    p_specifier_qualifier->type_specifier = p_type_specifier;
                }

                specifier_qualifier_list_add(p_specifier_qualifier_list, p_specifier_qualifier);
            }
            p_declaration_specifier = p_declaration_specifier->next;
        }
    }
    catch
    {
        specifier_qualifier_list_delete(p_specifier_qualifier_list);
        p_specifier_qualifier_list = NULL;
    }

    return p_specifier_qualifier_list;
}

void print_declarator(struct osstream* ss, struct declarator* p_declarator, bool is_abstract);

void print_direct_declarator(struct osstream* ss, struct direct_declarator* p_direct_declarator, bool is_abstract)
{
    if (p_direct_declarator->declarator)
    {
        ss_fprintf(ss, "(");
        print_declarator(ss, p_direct_declarator->declarator, is_abstract);
        ss_fprintf(ss, ")");
    }

    if (p_direct_declarator->name_opt && !is_abstract)
    {
        // Se is_abstract for true é pedido para nao imprimir o nome do indentificador
        ss_fprintf(ss, "%s", p_direct_declarator->name_opt->lexeme);
    }

    if (p_direct_declarator->function_declarator)
    {
        assert(p_direct_declarator->function_declarator->direct_declarator != NULL);

        print_direct_declarator(ss, p_direct_declarator->function_declarator->direct_declarator, is_abstract);

        ss_fprintf(ss, "(");
        struct parameter_declaration* _Opt p_parameter_declaration =
            p_direct_declarator->function_declarator->parameter_type_list_opt ? p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head : NULL;

        while (p_parameter_declaration)
        {
            if (p_parameter_declaration != p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head)
                ss_fprintf(ss, ",");

            print_declaration_specifiers(ss, p_parameter_declaration->declaration_specifiers);
            ss_fprintf(ss, " ");

            if (p_parameter_declaration->declarator)
                print_declarator(ss, p_parameter_declaration->declarator, is_abstract);

            p_parameter_declaration = p_parameter_declaration->next;
        }
        //... TODO
        ss_fprintf(ss, ")");
    }
    if (p_direct_declarator->array_declarator)
    {
        // TODO
        ss_fprintf(ss, "[]");
    }
}

const struct declarator* _Opt declarator_get_function_definition(const struct declarator* declarator)
{
    const struct declarator* _Opt p_function_defined = NULL;
    if (declarator->function_body)
    {
        p_function_defined = declarator;
    }

    if (!p_function_defined &&
        declarator->p_complete_declarator &&
        declarator->p_complete_declarator->function_body)
    {
        p_function_defined = declarator->p_complete_declarator;
    }

    if (!p_function_defined &&
        declarator->p_complete_declarator &&
        declarator->p_complete_declarator->p_complete_declarator &&
        declarator->p_complete_declarator->p_complete_declarator->function_body)
    {
        p_function_defined = declarator->p_complete_declarator->p_complete_declarator;
    }

    assert(p_function_defined == NULL || (p_function_defined && p_function_defined->function_body));
    return p_function_defined;
}

enum type_specifier_flags declarator_get_type_specifier_flags(const struct declarator* p)
{
    if (p->declaration_specifiers)
        return p->declaration_specifiers->type_specifier_flags;
    if (p->specifier_qualifier_list)
        return p->specifier_qualifier_list->type_specifier_flags;
    return 0;
}

void print_declarator(struct osstream* ss, struct declarator* p_declarator, bool is_abstract)
{
    bool first = true;
    if (p_declarator->pointer)
    {
        struct pointer* _Opt p = p_declarator->pointer;
        while (p)
        {
            if (p->type_qualifier_list_opt)
            {
                print_type_qualifier_flags(ss, &first, p->type_qualifier_list_opt->flags);
            }
            ss_fprintf(ss, "*");
            p = p->pointer;
        }
    }
    if (p_declarator->direct_declarator)
        print_direct_declarator(ss, p_declarator->direct_declarator, is_abstract);
}

void print_type_name(struct osstream* ss, struct type_name* p)
{
    bool first = true;
    print_specifier_qualifier_list(ss, &first, p->specifier_qualifier_list);
    print_declarator(ss, p->abstract_declarator, true);
}

void type_name_delete(struct type_name* _Owner _Opt p)
{
    if (p)
    {
        specifier_qualifier_list_delete(p->specifier_qualifier_list);
        type_destroy(&p->type);
        declarator_delete(p->abstract_declarator);
        free(p);
    }
}

struct type_name* _Owner _Opt type_name(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return NULL;

    struct type_name* _Owner _Opt p_type_name = calloc(1, sizeof(struct type_name));
    try
    {
        if (p_type_name == NULL) throw;

        p_type_name->first_token = ctx->current;

        struct specifier_qualifier_list* _Owner _Opt p_specifier_qualifier_list =
            specifier_qualifier_list(ctx);

        if (p_specifier_qualifier_list == NULL)
        {
            throw;
        }

        p_type_name->specifier_qualifier_list = p_specifier_qualifier_list;

        struct declarator* _Owner _Opt p_declarator = declarator(ctx,
            p_type_name->specifier_qualifier_list, //??
            /*declaration_specifiers*/ NULL,
            true /*DEVE SER TODO*/,
            NULL);

        if (p_declarator == NULL)
            throw;

        p_type_name->abstract_declarator = p_declarator;

        p_type_name->abstract_declarator->specifier_qualifier_list = p_type_name->specifier_qualifier_list;

#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wmissing-destructor"    
        p_type_name->abstract_declarator->type = make_type_using_declarator(ctx, p_type_name->abstract_declarator);
#pragma cake diagnostic pop

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->prev == NULL)
            throw;

        p_type_name->last_token = ctx->current->prev;
        p_type_name->type = type_dup(&p_type_name->abstract_declarator->type);

    }
    catch
    {
        type_name_delete(p_type_name);
        p_type_name = NULL;
    }

    return p_type_name;
}

void braced_initializer_delete(struct braced_initializer* _Owner _Opt p)
{
    if (p)
    {
        initializer_list_delete(p->initializer_list);
        free(p);
    }
}

struct braced_initializer* _Owner _Opt braced_initializer(struct parser_ctx* ctx)
{
    /*
     { }
     { initializer-list }
     { initializer-list , }
    */

    struct braced_initializer* _Owner _Opt p_bracket_initializer_list = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_bracket_initializer_list = calloc(1, sizeof(struct braced_initializer));

        if (p_bracket_initializer_list == NULL)
            throw;

        p_bracket_initializer_list->first_token = ctx->current;
        if (parser_match_tk(ctx, '{') != 0)
            throw;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type != '}')
        {
            p_bracket_initializer_list->initializer_list = initializer_list(ctx);
        }
        if (parser_match_tk(ctx, '}') != 0)
            throw;
    }
    catch
    {
        braced_initializer_delete(p_bracket_initializer_list);
        p_bracket_initializer_list = NULL;
    }
    return p_bracket_initializer_list;
}

void initializer_delete(struct initializer* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->assignment_expression);
        braced_initializer_delete(p->braced_initializer);
        free(p);
    }
}

struct initializer* _Owner _Opt initializer(struct parser_ctx* ctx)
{
    /*
    initializer:
      assignment-expression
      braced-initializer
    */

    struct initializer* _Owner _Opt p_initializer = NULL;

    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_initializer = calloc(1, sizeof(struct initializer));
        if (p_initializer == NULL)
            throw;

        p_initializer->first_token = ctx->current;

        if (ctx->current->type == '{')
        {
            p_initializer->braced_initializer = braced_initializer(ctx);
            if (p_initializer->braced_initializer == NULL) throw;
        }
        else
        {
            p_initializer->assignment_expression = assignment_expression(ctx);
            if (p_initializer->assignment_expression == NULL) throw;
        }
    }
    catch
    {
        initializer_delete(p_initializer);
        p_initializer = NULL;
    }
    return p_initializer;
}

void defer_list_add(struct defer_list* list, struct defer_list_item* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void defer_list_destroy(_Dtor struct defer_list* p)
{

    struct defer_list_item* _Owner _Opt item = p->head;
    while (item)
    {
        struct defer_list_item* _Owner _Opt next = item->next;
        item->next = NULL;
        free(item);
        item = next;
    }
    free(p);

}


void initializer_list_add(struct initializer_list* list, struct initializer_list_item* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void initializer_list_item_delete(struct initializer_list_item* _Owner _Opt p)
{
    if (p)
    {
        designation_delete(p->designation);
        initializer_delete(p->initializer);
        free(p);
    }
}

void initializer_list_delete(struct initializer_list* _Owner _Opt p)
{
    if (p)
    {
        struct initializer_list_item* _Owner _Opt item = p->head;
        while (item)
        {
            struct initializer_list_item* _Owner _Opt next = item->next;
            item->next = NULL;
            initializer_list_item_delete(item);
            item = next;
        }
        free(p);
    }
}
struct initializer_list* _Owner _Opt initializer_list(struct parser_ctx* ctx)
{
    /*
    initializer-list:
       designation _Opt initializer
       initializer-list , designation _Opt initializer
    */

    struct initializer_list* _Owner _Opt p_initializer_list = NULL;

    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            return NULL;
        }


        p_initializer_list = calloc(1, sizeof(struct initializer_list));
        if (p_initializer_list == NULL)
            throw;

        p_initializer_list->first_token = ctx->current;


        struct initializer_list_item* _Owner _Opt p_initializer_list_item = calloc(1, sizeof * p_initializer_list_item);
        if (p_initializer_list_item == NULL)
            throw;


        struct designation* _Owner _Opt p_designation = NULL;
        if (first_of_designator(ctx))
        {
            p_designation = designation(ctx);
            if (p_designation == NULL)
                throw;
            p_initializer_list_item->designation = p_designation;
        }

        struct initializer* _Owner _Opt p_initializer = initializer(ctx);

        if (p_initializer == NULL)
        {
            designation_delete(p_designation);
            throw;
        }

        p_initializer_list_item->initializer = p_initializer;


        initializer_list_add(p_initializer_list, p_initializer_list_item);
        p_initializer_list_item = NULL; //MOVED
        //p_initializer_list->size++;

        while (ctx->current != NULL && ctx->current->type == ',')
        {
            parser_match(ctx);

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->type == '}')
                break; // follow

            p_initializer_list_item = calloc(1, sizeof * p_initializer_list_item);
            if (p_initializer_list_item == NULL)
                throw;

            struct designation* _Owner _Opt p_designation2 = NULL;
            if (first_of_designator(ctx))
            {
                p_designation2 = designation(ctx);
                if (p_designation2 == NULL)
                    throw;
            }
            p_initializer_list_item->designation = p_designation2;

            struct initializer* _Owner _Opt p_initializer2 = initializer(ctx);
            if (p_initializer2 == NULL)
            {
                designation_delete(p_designation2);
                throw;
            }
            p_initializer_list_item->initializer = p_initializer2;

            initializer_list_add(p_initializer_list, p_initializer_list_item);
            p_initializer_list_item = NULL; //MOVED
            p_initializer_list->size++;
        }
    }
    catch
    {
        initializer_list_delete(p_initializer_list);
        p_initializer_list = NULL;
    }
    return p_initializer_list;
}

void designation_delete(struct designation* _Owner _Opt p)
{
    if (p)
    {
        designator_list_delete(p->designator_list);
        free(p);
    }
}

struct designation* _Owner _Opt designation(struct parser_ctx* ctx)
{
    // designator_list '='
    struct designation* _Owner _Opt p_designation = NULL;
    try
    {
        p_designation = calloc(1, sizeof(struct designation));
        if (p_designation == NULL)
            throw;

        struct designator_list* _Owner _Opt p_designator_list = designator_list(ctx);

        if (p_designator_list == NULL)
            throw;

        p_designation->designator_list = p_designator_list;

        if (parser_match_tk(ctx, '=') != 0)
            throw;
    }
    catch
    {
        designation_delete(p_designation);
        p_designation = NULL;
    }
    return p_designation;
}


void designator_list_add(struct designator_list* list, struct designator* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void designator_list_delete(struct designator_list* _Owner _Opt p)
{
    if (p)
    {
        struct designator* _Owner _Opt  item = p->head;
        while (item)
        {
            struct designator* _Owner _Opt next = item->next;
            item->next = NULL;
            designator_delete(item);
            item = next;
        }
        free(p);
    }
}

struct designator_list* _Owner _Opt designator_list(struct parser_ctx* ctx)
{
    // designator
    // designator_list designator
    struct designator_list* _Owner _Opt p_designator_list = NULL;
    struct designator* _Owner _Opt p_designator = NULL;
    try
    {
        p_designator_list = calloc(1, sizeof(struct designator_list));
        if (p_designator_list == NULL)
            throw;

        p_designator = designator(ctx);
        if (p_designator == NULL)
            throw;
        designator_list_add(p_designator_list, p_designator);
        p_designator = NULL; /*MOVED*/

        while (ctx->current != NULL && first_of_designator(ctx))
        {
            p_designator = designator(ctx);
            if (p_designator == NULL)
                throw;
            designator_list_add(p_designator_list, p_designator);
            p_designator = NULL; /*MOVED*/
        }
    }
    catch
    {
        designator_list_delete(p_designator_list);
        p_designator_list = NULL;
    }

    return p_designator_list;
}

void designator_delete(struct designator* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        expression_delete(p->constant_expression_opt);
        free(p);
    }
}

struct designator* _Owner _Opt designator(struct parser_ctx* ctx)
{
    //'[' constant_expression ']'
    //'.' identifier
    struct designator* _Owner _Opt p_designator = NULL;

    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_designator = calloc(1, sizeof(struct designator));
        if (p_designator == NULL)
            throw;

        if (ctx->current->type == '[')
        {
            if (parser_match_tk(ctx, '[') != 0)
                throw;
            p_designator->constant_expression_opt = constant_expression(ctx, true);
            if (parser_match_tk(ctx, ']') != 0)
                throw;
        }
        else if (ctx->current->type == '.')
        {
            parser_match(ctx);

            p_designator->token = ctx->current;
            if (parser_match_tk(ctx, TK_IDENTIFIER) != 0)
                throw;
        }
    }
    catch
    {
        designator_delete(p_designator);
        p_designator = NULL;
    }
    return p_designator;
}

void static_assert_declaration_delete(struct static_assert_declaration* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->constant_expression);
        free(p);
    }
}

void pragma_declaration_delete(struct pragma_declaration* _Owner _Opt p)
{
    if (p)
    {
        free(p);
    }
}

void execute_pragma(struct parser_ctx* ctx, struct pragma_declaration* p_pragma, bool on_flow_analysis)
{
    struct token* _Opt p_pragma_token = p_pragma->first_token;

    if (p_pragma_token->type != TK_PRAGMA)
    {
        assert(false);
        return;
    }

    p_pragma_token = pragma_match(p_pragma_token);

    if (p_pragma_token &&
        (strcmp(p_pragma_token->lexeme, "CAKE") == 0 ||
            strcmp(p_pragma_token->lexeme, "cake") == 0))
    {
        p_pragma_token = pragma_match(p_pragma_token);
    }

    if (p_pragma_token && strcmp(p_pragma_token->lexeme, "diagnostic") == 0)
    {
        p_pragma_token = pragma_match(p_pragma_token);

        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "push") == 0)
        {
            // #pragma GCC diagnostic push
            if (ctx->options.diagnostic_stack.top_index <
                sizeof(ctx->options.diagnostic_stack) / sizeof(ctx->options.diagnostic_stack.stack[0]))
            {
                ctx->options.diagnostic_stack.top_index++;
                ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] =
                    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index - 1];
            }
            p_pragma_token = p_pragma_token->next;
        }
        else if (p_pragma_token && strcmp(p_pragma_token->lexeme, "pop") == 0)
        {
            // #pragma CAKE diagnostic pop
            if (ctx->options.diagnostic_stack.top_index > 0)
            {
                ctx->options.diagnostic_stack.top_index--;
            }
            p_pragma_token = pragma_match(p_pragma_token);
        }
        else if (p_pragma_token &&
            (strcmp(p_pragma_token->lexeme, "error") == 0 ||
                strcmp(p_pragma_token->lexeme, "warning") == 0 ||
                strcmp(p_pragma_token->lexeme, "note") == 0 ||
                strcmp(p_pragma_token->lexeme, "ignored") == 0))
        {
            const bool is_error = strcmp(p_pragma_token->lexeme, "error") == 0;
            const bool is_warning = strcmp(p_pragma_token->lexeme, "warning") == 0;
            const bool is_note = strcmp(p_pragma_token->lexeme, "note") == 0;

            p_pragma_token = pragma_match(p_pragma_token);

            if (p_pragma_token && p_pragma_token->type == TK_STRING_LITERAL)
            {

                unsigned long long w = get_warning_bit_mask(p_pragma_token->lexeme + 1 /*+ 2*/);

                ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
                ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
                ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

                if (is_error)
                    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors |= w;
                else if (is_warning)
                    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings |= w;
                else if (is_note)
                    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes |= w;
            }
        }
        else if (p_pragma_token &&
            (strcmp(p_pragma_token->lexeme, "check") == 0))
        {
            p_pragma_token = pragma_match(p_pragma_token);

            if (p_pragma_token && p_pragma_token->type == TK_STRING_LITERAL)
            {
                enum diagnostic_id id = get_warning(p_pragma_token->lexeme + 1);
                //warnings errors are removed on demand..

                if ((!on_flow_analysis && get_diagnostic_phase(id) != 2) ||
                    (on_flow_analysis && get_diagnostic_phase(id) == 2))
                {
                    bool found = false;
                    for (int i = 0;
                         i < (int)(sizeof(ctx->p_report->last_diagnostics_ids) / sizeof(ctx->p_report->last_diagnostics_ids[0]));
                         i++)
                    {
                        if (ctx->p_report->last_diagnostics_ids[i] == 0) break;

                        if (ctx->p_report->last_diagnostics_ids[i] == id)
                        {
                            // lets remove this error/warning/info from the final report.
                            found = true;
                            int t =
                                get_diagnostic_type(&ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index],
                                    id);
                            if (t == 3)
                                ctx->p_report->error_count--;
                            else if (t == 2)
                                ctx->p_report->warnings_count--;
                            else if (t == 1)
                                ctx->p_report->info_count--;

                            break;
                        }
                    }

                    if (!found)
                    {
                        //is fatal error?
                        //fatal errors are kept here and checked at end
                        ctx->p_report->fatal_error_expected = atoi(p_pragma_token->lexeme + 3);

                        compiler_diagnostic(C_ERROR_UNEXPECTED, ctx, p_pragma_token, NULL, "pragma check failed");
                    }
                }
            }
        }
        else
        {
            compiler_diagnostic(C_ERROR_UNEXPECTED, ctx, p_pragma_token, NULL, "unknown pragma");
        }
    }
    else if (p_pragma_token && strcmp(p_pragma_token->lexeme, "nullable") == 0)
    {
        //see
        //https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references
        p_pragma_token = pragma_match(p_pragma_token);

        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "enable") == 0)
        {
            unsigned long long w = NULLABLE_DISABLE_REMOVED_WARNINGS;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings |= w;
            ctx->options.null_checks_enabled = true;
            ctx->options.flow_analysis = true; //also enable flow analysis
        }
        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "disable") == 0)
        {
            unsigned long long w = NULLABLE_DISABLE_REMOVED_WARNINGS;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;


            // Dereference warnings : Disabled
            // Assignment warnings : Disabled
            // Pointer types : All are nullable
            ctx->options.null_checks_enabled = false;
        }
    }
    else if (p_pragma_token && strcmp(p_pragma_token->lexeme, "ownership") == 0)
    {
        //see
        //https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references
        p_pragma_token = pragma_match(p_pragma_token);

        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "enable") == 0)
        {
            unsigned long long w = OWNERSHIP_DISABLE_REMOVED_WARNINGS;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings |= w;

            ctx->options.ownership_enabled = true;
            ctx->options.flow_analysis = true; //also enable flow analysis

        }
        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "disable") == 0)
        {
            unsigned long long w = OWNERSHIP_DISABLE_REMOVED_WARNINGS;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

            ctx->options.ownership_enabled = false;
        }
    }
    else if (p_pragma_token && strcmp(p_pragma_token->lexeme, "flow") == 0)
    {
        p_pragma_token = pragma_match(p_pragma_token);

        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "enable") == 0)
        {
            ctx->options.flow_analysis = true;
        }
        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "disable") == 0)
        {
            ctx->options.flow_analysis = false;
        }
    }
    else if (p_pragma_token && strcmp(p_pragma_token->lexeme, "safety") == 0)
    {
        p_pragma_token = pragma_match(p_pragma_token);

        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "enable") == 0)
        {
            unsigned long long w = NULLABLE_DISABLE_REMOVED_WARNINGS | OWNERSHIP_DISABLE_REMOVED_WARNINGS;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings |= w;
            ctx->options.null_checks_enabled = true;
            ctx->options.flow_analysis = true; //also enable flow analysis

            ctx->options.ownership_enabled = true;
        }
        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "disable") == 0)
        {
            unsigned long long w = NULLABLE_DISABLE_REMOVED_WARNINGS | OWNERSHIP_DISABLE_REMOVED_WARNINGS;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

            ctx->options.null_checks_enabled = false;
            ctx->options.ownership_enabled = false;
            ctx->options.flow_analysis = false;
        }
    }
}

struct pragma_declaration* _Owner _Opt pragma_declaration(struct parser_ctx* ctx)
{
    struct pragma_declaration* _Owner _Opt p_pragma_declaration = NULL;
    try
    {
        if (ctx->current == NULL || ctx->current->type != TK_PRAGMA)
        {
            assert(false);
            throw;
        }

        p_pragma_declaration = calloc(1, sizeof(struct pragma_declaration));
        if (p_pragma_declaration == NULL)
            throw;

        p_pragma_declaration->first_token = ctx->current;
        parser_match(ctx);

        while (ctx->current && ctx->current->type != TK_PRAGMA_END)
        {
            ctx->current = ctx->current->next;
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_pragma_declaration->last_token = ctx->current;
        parser_match(ctx);
    }
    catch
    {
    }
    if (p_pragma_declaration)
        execute_pragma(ctx, p_pragma_declaration, false);

    return p_pragma_declaration;
}

struct static_assert_declaration* _Owner _Opt static_assert_declaration(struct parser_ctx* ctx)
{

    /*
     static_assert-declaration:
      "static_assert" ( constant-expression , string-literal ) ;
      "static_assert" ( constant-expression ) ;
    */

    struct static_assert_declaration* _Owner _Opt p_static_assert_declaration = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_static_assert_declaration = calloc(1, sizeof(struct static_assert_declaration));
        if (p_static_assert_declaration == NULL)
            throw;

        p_static_assert_declaration->first_token = ctx->current;
        struct token* position = ctx->current;

        parser_match(ctx);

        if (parser_match_tk(ctx, '(') != 0)
            throw;

        /*
         When flow analysis is enabled static assert is evaluated there
        */
        bool show_error_if_not_constant = false;
        if (p_static_assert_declaration->first_token->type == TK_KEYWORD__STATIC_ASSERT)
        {
            show_error_if_not_constant = true;
        }

        if (ctx->options.flow_analysis)
            show_error_if_not_constant = false;

        struct expression* _Owner _Opt p_constant_expression = constant_expression(ctx, show_error_if_not_constant);
        if (p_constant_expression == NULL)
            throw;

        p_static_assert_declaration->constant_expression = p_constant_expression;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == ',')
        {
            parser_match(ctx);
            p_static_assert_declaration->string_literal_opt = ctx->current;
            if (parser_match_tk(ctx, TK_STRING_LITERAL) != 0)
                throw;
        }

        if (parser_match_tk(ctx, ')') != 0)
            throw;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_static_assert_declaration->last_token = ctx->current;
        if (parser_match_tk(ctx, ';') != 0)
            throw;

        if (position->type == TK_KEYWORD__STATIC_ASSERT)
        {
            if (object_has_constant_value(&p_static_assert_declaration->constant_expression->object) &&
                !object_to_bool(&p_static_assert_declaration->constant_expression->object))
            {
                if (p_static_assert_declaration->string_literal_opt)
                {
                    compiler_diagnostic(C_ERROR_STATIC_ASSERT_FAILED, ctx, position, NULL, "static_assert failed %s\n",
                        p_static_assert_declaration->string_literal_opt->lexeme);
                }
                else
                {
                    compiler_diagnostic(C_ERROR_STATIC_ASSERT_FAILED, ctx, position, NULL, "static_assert failed");
                }
            }
        }
    }
    catch
    {
    }

    return p_static_assert_declaration;
}

void attribute_specifier_sequence_add(struct attribute_specifier_sequence* list, struct attribute_specifier* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void attribute_specifier_sequence_delete(struct attribute_specifier_sequence* _Owner _Opt p)
{
    if (p)
    {
        struct attribute_specifier* _Owner _Opt item = p->head;
        while (item)
        {
            struct attribute_specifier* _Owner _Opt next = item->next;
            item->next = NULL;
            attribute_specifier_delete(item);
            item = next;
        }
        free(p);
    }
}

struct attribute_specifier_sequence* _Owner _Opt attribute_specifier_sequence_opt(struct parser_ctx* ctx)
{
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == TK_KEYWORD_MSVC__DECLSPEC)
        {
            //parser_match(ctx);
            p_attribute_specifier_sequence = calloc(1, sizeof(struct attribute_specifier_sequence));
            if (p_attribute_specifier_sequence == NULL)
                throw;

            p_attribute_specifier_sequence->first_token = ctx->current;
            p_attribute_specifier_sequence->msvc_declspec_flags |= msvc_declspec_sequence_opt(ctx);
            return  p_attribute_specifier_sequence;
        }

        if (ctx->current->type == TK_KEYWORD_GCC__ATTRIBUTE)
        {
            p_attribute_specifier_sequence = calloc(1, sizeof(struct attribute_specifier_sequence));
            if (p_attribute_specifier_sequence == NULL)
                throw;

            p_attribute_specifier_sequence->first_token = ctx->current;
            gcc_attribute_specifier_opt(ctx);
            return  p_attribute_specifier_sequence;
        }

        if (first_of_attribute_specifier(ctx))
        {
            p_attribute_specifier_sequence = calloc(1, sizeof(struct attribute_specifier_sequence));
            if (p_attribute_specifier_sequence == NULL)
                throw;

            p_attribute_specifier_sequence->first_token = ctx->current;

            while (ctx->current != NULL &&
                first_of_attribute_specifier(ctx))
            {
                struct attribute_specifier* _Owner _Opt p_attribute_specifier = attribute_specifier(ctx);
                if (p_attribute_specifier == NULL)
                    throw;

                p_attribute_specifier_sequence->attributes_flags |=
                    p_attribute_specifier->attribute_list->attributes_flags;

                attribute_specifier_sequence_add(p_attribute_specifier_sequence, p_attribute_specifier);
            }

            if (ctx->previous == NULL)
                throw;

            p_attribute_specifier_sequence->last_token = ctx->previous;
        }
    }
    catch
    {
        attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
        p_attribute_specifier_sequence = NULL;
    }

    return p_attribute_specifier_sequence;
}

static struct attribute_specifier_sequence* _Owner _Opt attribute_specifier_sequence(struct parser_ctx* ctx)
{
    // attribute_specifier_sequence_opt attribute_specifier
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence = NULL;
    try
    {
        p_attribute_specifier_sequence = calloc(1, sizeof(struct attribute_specifier_sequence));
        if (p_attribute_specifier_sequence == NULL)
            throw;

        while (first_of_attribute_specifier(ctx))
        {
            struct attribute_specifier* _Owner _Opt p_attribute_specifier = attribute_specifier(ctx);
            if (p_attribute_specifier == NULL) throw;

            attribute_specifier_sequence_add(p_attribute_specifier_sequence, p_attribute_specifier);
        }
    }
    catch
    {
        attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
        p_attribute_specifier_sequence = NULL;
    }

    return p_attribute_specifier_sequence;
}

void attribute_specifier_delete(struct attribute_specifier* _Owner _Opt p)
{
    if (p)
    {
        attribute_list_delete(p->attribute_list);
        assert(p->next == NULL);
        free(p);
    }
}

struct attribute_specifier* _Owner _Opt attribute_specifier(struct parser_ctx* ctx)
{
    struct attribute_specifier* _Owner _Opt p_attribute_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_attribute_specifier = calloc(1, sizeof(struct attribute_specifier));
        if (p_attribute_specifier == NULL)
            throw;

        p_attribute_specifier->first_token = ctx->current;

        //'[' '[' attribute_list ']' ']'
        if (parser_match_tk(ctx, '[') != 0)
            throw;
        if (parser_match_tk(ctx, '[') != 0)
            throw;

        struct attribute_list* _Owner _Opt p_attribute_list = attribute_list(ctx);

        if (p_attribute_list == NULL)
            throw;

        p_attribute_specifier->attribute_list = p_attribute_list;
        if (parser_match_tk(ctx, ']') != 0)
            throw;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_attribute_specifier->last_token = ctx->current;
        if (parser_match_tk(ctx, ']') != 0)
            throw;
    }
    catch
    {
        attribute_specifier_delete(p_attribute_specifier);
        p_attribute_specifier = NULL;
    }
    return p_attribute_specifier;
}

void attribute_delete(struct attribute* _Owner _Opt p)
{
    if (p)
    {
        attribute_argument_clause_delete(p->attribute_argument_clause);
        assert(p->next == NULL);
        free(p);
    }
}

void attribute_list_add(struct attribute_list* list, struct attribute* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void attribute_list_destroy(_Dtor struct attribute_list* p)
{
    struct attribute* _Owner _Opt item = p->head;
    while (item)
    {
        struct attribute* _Owner _Opt next = item->next;
        item->next = NULL;
        attribute_delete(item);
        item = next;
    }
}

void attribute_list_delete(struct attribute_list* _Owner _Opt p)
{
    if (p)
    {
        attribute_list_destroy(p);
        free(p);
    }
}

struct attribute_list* _Owner _Opt attribute_list(struct parser_ctx* ctx)
{
    struct attribute_list* _Owner _Opt p_attribute_list = NULL;
    try
    {
        p_attribute_list = calloc(1, sizeof(struct attribute_list));
        if (p_attribute_list == NULL)
            throw;

        //
        // attribute_list ',' attribute_opt
        while (ctx->current != NULL && (first_of_attribute(ctx) ||
            ctx->current->type == ','))
        {
            if (first_of_attribute(ctx))
            {
                struct attribute* _Owner _Opt p_attribute = attribute(ctx);
                if (p_attribute == NULL) throw;

                p_attribute_list->attributes_flags |= p_attribute->attributes_flags;
                attribute_list_add(p_attribute_list, p_attribute);
            }

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->type == ',')
            {
                parser_match(ctx);
            }
        }
    }
    catch
    {
        attribute_list_delete(p_attribute_list);
        p_attribute_list = NULL;
    }

    return p_attribute_list;
}

bool first_of_attribute(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    if (ctx->current->type == TK_IDENTIFIER)
        return true;

    if (is_keyword(ctx->current->lexeme) != 0)
        return true;

    return false;
}
enum attribute_flags attribute_token(struct parser_ctx* ctx)
{
    enum attribute_flags attribute_flags = 0;

    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        struct token* attr_token = ctx->current;

        bool is_standard_attribute = false;
        if (strcmp(attr_token->lexeme, "deprecated") == 0)
        {
            is_standard_attribute = true;
            attribute_flags = STD_ATTRIBUTE_DEPRECATED;
        }
        else if (strcmp(attr_token->lexeme, "fallthrough") == 0)
        {
            is_standard_attribute = true;
        }
        else if (strcmp(attr_token->lexeme, "maybe_unused") == 0)
        {
            is_standard_attribute = true;
            attribute_flags = STD_ATTRIBUTE_MAYBE_UNUSED;
        }
        else if (strcmp(attr_token->lexeme, "noreturn") == 0)
        {
            is_standard_attribute = true;
            attribute_flags = STD_ATTRIBUTE_NORETURN;
        }
        else if (strcmp(attr_token->lexeme, "reproducible") == 0)
        {
            is_standard_attribute = true;
            attribute_flags = STD_ATTRIBUTE_REPRODUCIBLE;
        }
        else if (strcmp(attr_token->lexeme, "unsequenced") == 0)
        {
            is_standard_attribute = true;
            attribute_flags = STD_ATTRIBUTE_UNSEQUENCED;
        }
        else if (strcmp(attr_token->lexeme, "nodiscard") == 0)
        {
            is_standard_attribute = true;
            attribute_flags = STD_ATTRIBUTE_NODISCARD;
        }
        else if (strcmp(attr_token->lexeme, "dtor") == 0)
        {
            is_standard_attribute = true;
            attribute_flags = CAKE_ATTRIBUTE_DTOR;
        }
        else if (strcmp(attr_token->lexeme, "ctor") == 0)
        {
            is_standard_attribute = true;
            attribute_flags = CAKE_ATTRIBUTE_CTOR;
        }

        const bool is_cake_attr = strcmp(attr_token->lexeme, "cake") == 0;

        if (token_is_identifier_or_keyword(ctx->current->type))
        {
            parser_match(ctx);
        }
        else
        {
            compiler_diagnostic(C_ERROR_UNEXPECTED_TOKEN, ctx, attr_token, NULL, "expected identifier");
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == '::')
        {
            parser_match(ctx);
            if (is_cake_attr)
            {
                compiler_diagnostic(W_ATTRIBUTES, ctx, attr_token, NULL, "warning '%s' is not an cake attribute", ctx->current->lexeme);
            }

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (token_is_identifier_or_keyword(ctx->current->type))
            {
                parser_match(ctx);
            }
            else
            {
                compiler_diagnostic(C_ERROR_UNEXPECTED_TOKEN, ctx, attr_token, NULL, "expected identifier");
            }
        }
        else
        {
            /*
             * Each implementation should choose a distinctive name for the attribute prefix in an attribute
             * prefixed token. Implementations should not define attributes without an attribute prefix unless it is
             * a standard attribute as specified in this document.
             */
            if (!is_standard_attribute)
            {
                compiler_diagnostic(W_ATTRIBUTES, ctx, attr_token, NULL, "warning '%s' is not an standard attribute", attr_token->lexeme);
            }
        }
    }
    catch
    {

    }

    return attribute_flags;
}


struct attribute* _Owner _Opt attribute(struct parser_ctx* ctx)
{
    struct attribute* _Owner _Opt p_attribute = NULL;
    try
    {
        p_attribute = calloc(1, sizeof(struct attribute));
        if (p_attribute == NULL)
            throw;

        enum attribute_flags attribute_flags = attribute_token(ctx);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_attribute->attributes_flags |= attribute_flags;
        if (ctx->current->type == '(') // first
        {
            struct attribute_argument_clause* _Owner _Opt  p_attribute_argument_clause =
                attribute_argument_clause(ctx);
            if (p_attribute_argument_clause == NULL)
                throw;
            p_attribute->attribute_argument_clause = p_attribute_argument_clause;
        }
    }
    catch
    {
        attribute_delete(p_attribute);
        p_attribute = NULL;
    }
    return p_attribute;
}

void attribute_argument_clause_delete(struct attribute_argument_clause* _Owner _Opt p)
{
    if (p)
    {
        balanced_token_sequence_delete(p->p_balanced_token_sequence);
        free(p);
    }
}

struct attribute_argument_clause* _Owner _Opt  attribute_argument_clause(struct parser_ctx* ctx)
{
    struct attribute_argument_clause* _Owner _Opt p_attribute_argument_clause = calloc(1, sizeof(struct attribute_argument_clause));
    try
    {
        if (p_attribute_argument_clause == NULL)
            throw;

        //'(' balanced_token_sequence_opt ')'
        if (parser_match_tk(ctx, '(') != 0)
            throw;
        p_attribute_argument_clause->p_balanced_token_sequence = balanced_token_sequence_opt(ctx);
        if (parser_match_tk(ctx, ')') != 0)
            throw;
    }
    catch
    {
        attribute_argument_clause_delete(p_attribute_argument_clause);
        p_attribute_argument_clause = NULL;
    }
    return p_attribute_argument_clause;
}

void balanced_token_sequence_delete(struct balanced_token_sequence* _Owner _Opt p)
{
    if (p)
    {
        struct balanced_token* _Owner _Opt item = p->head;
        while (item)
        {
            struct balanced_token* _Owner _Opt  next = item->next;
            free(item);
            item = next;
        }
        free(p);
    }
}

struct balanced_token_sequence* _Owner _Opt balanced_token_sequence_opt(struct parser_ctx* ctx)
{
    struct balanced_token_sequence* _Owner _Opt p_balanced_token_sequence = calloc(1, sizeof(struct balanced_token_sequence));
    try
    {
        if (p_balanced_token_sequence == NULL)
            throw;

        // balanced_token
        // balanced_token_sequence balanced_token
        int count1 = 0;
        int count2 = 0;
        int count3 = 0;
        for (; ctx->current;)
        {
            if (ctx->current->type == '(')
                count1++;
            else if (ctx->current->type == '[')
                count2++;
            else if (ctx->current->type == '{')
                count3++;
            else if (ctx->current->type == ')')
            {
                if (count1 == 0)
                {
                    // parser_match(ctx);
                    break;
                }
                count1--;
            }
            else if (ctx->current->type == '[')
                count2--;
            else if (ctx->current->type == '{')
                count3--;
            parser_match(ctx);
        }
        if (count2 != 0)
        {
            compiler_diagnostic(C_ERROR_ATTR_UNBALANCED, ctx, ctx->current, NULL, "expected ']' before ')'");
        }
        if (count3 != 0)
        {
            compiler_diagnostic(C_ERROR_ATTR_UNBALANCED, ctx, ctx->current, NULL, "expected '}' before ')'");
        }
    }
    catch
    {
        balanced_token_sequence_delete(p_balanced_token_sequence);
        p_balanced_token_sequence = NULL;
    }
    return p_balanced_token_sequence;
}

void statement_delete(struct statement* _Owner _Opt p)
{
    if (p)
    {
        labeled_statement_delete(p->labeled_statement);
        unlabeled_statement_delete(p->unlabeled_statement);
        free(p);
    }
}

struct statement* _Owner _Opt statement(struct parser_ctx* ctx)
{
    struct statement* _Owner _Opt p_statement = calloc(1, sizeof(struct statement));
    try
    {
        if (p_statement == NULL)
            throw;

        if (first_of_labeled_statement(ctx))
        {
            p_statement->labeled_statement = labeled_statement(ctx);
            if (p_statement->labeled_statement == NULL)
                throw;
        }
        else
        {
            p_statement->unlabeled_statement = unlabeled_statement(ctx);
            if (p_statement->unlabeled_statement == NULL)
                throw;
        }
    }
    catch
    {
        statement_delete(p_statement);
        p_statement = NULL;
    }
    return p_statement;
}

struct primary_block* _Owner _Opt primary_block(struct parser_ctx* ctx)
{
    assert(ctx->current != NULL);
    struct primary_block* _Owner _Opt p_primary_block = calloc(1, sizeof(struct primary_block));
    try
    {
        if (p_primary_block == NULL)
            throw;

        if (first_of_compound_statement(ctx))
        {
            p_primary_block->compound_statement = compound_statement(ctx);
            if (p_primary_block->compound_statement == NULL)
                throw;
        }
        else if (first_of_selection_statement(ctx))
        {
            p_primary_block->selection_statement = selection_statement(ctx);
            if (p_primary_block->selection_statement == NULL)
                throw;
        }
        else if (first_of_iteration_statement(ctx))
        {
            p_primary_block->iteration_statement = iteration_statement(ctx);
            if (p_primary_block->iteration_statement == NULL)
                throw;
        }
        else if (ctx->current->type == TK_KEYWORD_DEFER)
        {
            p_primary_block->defer_statement = defer_statement(ctx);
            if (p_primary_block->defer_statement == NULL)
                throw;
        }
        else if (ctx->current->type == TK_KEYWORD_CAKE_TRY)
        {
            p_primary_block->try_statement = try_statement(ctx);
            if (p_primary_block->try_statement == NULL)
                throw;
        }
        else
        {
            compiler_diagnostic(C_ERROR_UNEXPECTED_TOKEN, ctx, ctx->current, NULL, "unexpected token");
        }
    }
    catch
    {
        primary_block_delete(p_primary_block);
        p_primary_block = NULL;
    }
    return p_primary_block;
}

struct secondary_block* _Owner _Opt secondary_block(struct parser_ctx* ctx)
{
    struct secondary_block* _Owner _Opt p_secondary_block = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        check_open_brace_style(ctx, ctx->current);

        p_secondary_block = calloc(1, sizeof(struct secondary_block));
        if (p_secondary_block == NULL)
            throw;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_secondary_block->first_token = ctx->current;

        struct statement* _Owner _Opt p_statement = statement(ctx);
        if (p_statement == NULL)
            throw;

        p_secondary_block->statement = p_statement;

        if (ctx->previous == NULL)
            throw;

        p_secondary_block->last_token = ctx->previous;

        check_close_brace_style(ctx, p_secondary_block->last_token);
    }
    catch
    {
        secondary_block_delete(p_secondary_block);
        p_secondary_block = NULL;
    }
    return p_secondary_block;
}

bool unlabeled_statement_ends_with_jump(struct unlabeled_statement* p_unlabeled_statement)
{
    struct expression* _Opt p_expression = NULL;

    if (p_unlabeled_statement->expression_statement)
    {
        p_expression = p_unlabeled_statement->expression_statement->expression_opt;
    }
    else if (p_unlabeled_statement->jump_statement)
    {
        return true;
    }
    else if (p_unlabeled_statement->primary_block &&
        p_unlabeled_statement->primary_block->compound_statement &&
        p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail &&
        p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement &&
        p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement->expression_statement)
    {
        p_expression =
            p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement->expression_statement->expression_opt;
    }

    if (p_expression)
    {
        return p_expression->type.attributes_flags & STD_ATTRIBUTE_NORETURN;
    }

    if (p_unlabeled_statement->primary_block &&
        p_unlabeled_statement->primary_block->compound_statement &&
        p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail &&
        p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement)
    {
        return
            p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement->jump_statement != NULL;
    }

    return false;
}

bool secondary_block_ends_with_jump(struct secondary_block* _Opt p_secondary_block)
{
    if (p_secondary_block &&
        p_secondary_block->statement->unlabeled_statement)
    {
        return unlabeled_statement_ends_with_jump(p_secondary_block->statement->unlabeled_statement);
    }
    return false;
}

void secondary_block_delete(struct secondary_block* _Owner _Opt p)
{
    if (p)
    {
        statement_delete(p->statement);
        free(p);
    }
}

void primary_block_delete(struct primary_block* _Owner _Opt p)
{
    if (p)
    {
        compound_statement_delete(p->compound_statement);
        defer_statement_delete(p->defer_statement);
        iteration_statement_delete(p->iteration_statement);
        selection_statement_delete(p->selection_statement);
        try_statement_delete(p->try_statement);
        free(p);
    }
}

static bool first_of_primary_block(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    if (first_of_compound_statement(ctx) ||
        first_of_selection_statement(ctx) ||
        first_of_iteration_statement(ctx) ||
        ctx->current->type == TK_KEYWORD_DEFER /*extension*/ ||
        ctx->current->type == TK_KEYWORD_CAKE_TRY /*extension*/
        )
    {
        return true;
    }
    return false;
}

void unlabeled_statement_delete(struct unlabeled_statement* _Owner _Opt p)
{
    if (p)
    {
        expression_statement_delete(p->expression_statement);
        jump_statement_delete(p->jump_statement);
        primary_block_delete(p->primary_block);
        free(p);
    }
}

struct unlabeled_statement* _Owner _Opt unlabeled_statement(struct parser_ctx* ctx)
{
    /*
     unlabeled-statement:
       expression-statement
       attribute-specifier-sequence _Opt primary-block
       attribute-specifier-sequence _Opt jump-statement
    */
    struct unlabeled_statement* _Owner _Opt p_unlabeled_statement = calloc(1, sizeof(struct unlabeled_statement));
    try
    {
        if (p_unlabeled_statement == NULL)
            throw;

        if (first_of_primary_block(ctx))
        {
            p_unlabeled_statement->primary_block = primary_block(ctx);
            if (p_unlabeled_statement->primary_block == NULL)
                throw;
        }
        else if (first_of_jump_statement(ctx))
        {
            p_unlabeled_statement->jump_statement = jump_statement(ctx);
            if (p_unlabeled_statement->jump_statement == NULL)
                throw;
        }
        else
        {
            p_unlabeled_statement->expression_statement = expression_statement(ctx, false);
            if (p_unlabeled_statement->expression_statement == NULL)
                throw;

            if (p_unlabeled_statement->expression_statement->expression_opt)
            {
                if (!type_is_void(&p_unlabeled_statement->expression_statement->expression_opt->type) &&
                    type_is_nodiscard(&p_unlabeled_statement->expression_statement->expression_opt->type) &&
                    p_unlabeled_statement->expression_statement->expression_opt->type.storage_class_specifier_flags & STORAGE_SPECIFIER_FUNCTION_RETURN)
                {

                    if (p_unlabeled_statement->expression_statement->expression_opt->first_token->level == 0)
                    {
                        compiler_diagnostic(W_ATTRIBUTES, ctx,
                            p_unlabeled_statement->expression_statement->expression_opt->first_token, NULL,
                            "ignoring return value of function declared with 'nodiscard' attribute");
                    }
                }
                if (type_is_owner(&p_unlabeled_statement->expression_statement->expression_opt->type) &&
                    p_unlabeled_statement->expression_statement->expression_opt->type.storage_class_specifier_flags & STORAGE_SPECIFIER_FUNCTION_RETURN)
                {

                    if (p_unlabeled_statement->expression_statement->expression_opt->first_token->level == 0)
                    {
                        compiler_diagnostic(W_ATTRIBUTES, ctx,
                            p_unlabeled_statement->expression_statement->expression_opt->first_token, NULL,
                            "ignoring the result of _Owner type ");
                    }
                }
            }
            if (p_unlabeled_statement->expression_statement->expression_opt &&
                p_unlabeled_statement->expression_statement->expression_opt->expression_type == POSTFIX_FUNCTION_CALL)
            {
            }
            else
            {
                /*
                 *  The objective here is to detect expression with not effect
                 *  a == b; etc
                 */
                if (p_unlabeled_statement != NULL &&
                    p_unlabeled_statement->jump_statement == NULL &&
                    p_unlabeled_statement->expression_statement != NULL &&
                    p_unlabeled_statement->expression_statement->expression_opt &&
                    !type_is_void(&p_unlabeled_statement->expression_statement->expression_opt->type) &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != ASSIGNMENT_EXPRESSION_ASSIGN &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != POSTFIX_FUNCTION_CALL &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != POSTFIX_INCREMENT &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != POSTFIX_DECREMENT &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != UNARY_EXPRESSION_INCREMENT &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != UNARY_EXPRESSION_DECREMENT &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != UNARY_DECLARATOR_ATTRIBUTE_EXPR &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != UNARY_EXPRESSION_ASSERT)
                {
                    if (ctx->current &&
                        ctx->current->level == 0)
                    {
#if 0
                        //too many false..alerts.
                        //make list of for sure ...
                        compiler_diagnostic(W_UNUSED_VALUE,
                            ctx,
                            p_unlabeled_statement->expression_statement->expression_opt->first_token,
                            "expression not used");
#endif
                    }
                }
            }
        }
    }
    catch
    {
        unlabeled_statement_delete(p_unlabeled_statement);
        p_unlabeled_statement = NULL;
    }

    return p_unlabeled_statement;
}

void label_delete(struct label* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->constant_expression);
        free(p);
    }
}

struct label* _Owner _Opt label(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return NULL;

    struct label* _Owner _Opt p_label = calloc(1, sizeof(struct label));
    try
    {
        if (p_label == NULL)
            throw;

        p_label->label_id = ctx->label_id++;

        p_label->p_first_token = ctx->current;

        if (ctx->current->type == TK_IDENTIFIER)
        {
            struct label_list_item* _Opt p_label_list_item =
                label_list_find(&ctx->label_list, ctx->current->lexeme);

            if (p_label_list_item == NULL)
            {
                struct label_list_item* _Owner _Opt p_label_list_item_new = calloc(1, sizeof * p_label_list_item_new);
                if (p_label_list_item_new)
                {
                    p_label_list_item_new->p_defined = ctx->current;
                    label_list_push(&ctx->label_list, p_label_list_item_new);
                }
            }
            else
            {
                if (p_label_list_item->p_defined)
                {
                    //already defined
                    compiler_diagnostic(C_ERROR_DUPLICATED_LABEL, ctx, ctx->current, NULL, "duplicated label '%s'", ctx->current->lexeme);
                    compiler_diagnostic(W_NOTE, ctx, p_label_list_item->p_defined, NULL, "previous definition of '%s'", ctx->current->lexeme);
                }
                else
                {
                    p_label_list_item->p_defined = ctx->current;
                }
            }

            p_label->p_identifier_opt = ctx->current;
            parser_match(ctx);
            if (parser_match_tk(ctx, ':') != 0)
                throw;
        }
        else if (ctx->current->type == TK_KEYWORD_CASE)
        {

            if (ctx->p_current_selection_statement == NULL ||
                ctx->p_current_selection_statement->condition == NULL)
            {
                //unexpected because we are in case
                throw;
            }


            parser_match(ctx);
            p_label->constant_expression = constant_expression(ctx, true);
            if (p_label->constant_expression == NULL)
                throw;

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->type == '...')
            {
                parser_match(ctx);
                p_label->constant_expression_end = constant_expression(ctx, true);
                if (p_label->constant_expression_end == NULL)
                    throw;
                /*
                n3550.pdf
                If the arithmetic value of the first constant expression is
                greater than the one of the second, the range
                described by the constant range expression is empty.
                */

                struct label* _Opt p_existing_label = case_label_list_find_range(&ctx->p_current_selection_statement->label_list,
                    &p_label->constant_expression->object,
                    &p_label->constant_expression_end->object);


                if (p_existing_label)
                {  //we have a case with a single value that is inside this begin...end
                    char str1[50];
                    object_to_str(&p_label->constant_expression->object, 50, str1);

                    char str2[50];
                    object_to_str(&p_label->constant_expression_end->object, 50, str2);


                    //current range x existing range
                    //current range x existing single value

                    compiler_diagnostic(C_ERROR_DUPLICATED_CASE,
                            ctx,
                            p_label->constant_expression->first_token, NULL,
                            "case '%s' ... '%s' is duplicating values", str1, str2);

                    assert(p_label->constant_expression != NULL); //because case have values
                    compiler_diagnostic(W_LOCATION,
                        ctx,
                        p_existing_label->constant_expression->first_token, NULL, "previous case");
                }
            }
            else
            {
                struct label* _Opt p_existing_label = case_label_list_find(&ctx->p_current_selection_statement->label_list, &p_label->constant_expression->object);
                if (p_existing_label)
                {

                    //current single value x existing single value
                    //current single value x existing range
                    char str[50];
                    object_to_str(&p_label->constant_expression->object, 50, str);

                    compiler_diagnostic(C_ERROR_DUPLICATED_CASE,
                            ctx,
                            p_label->constant_expression->first_token, NULL,
                            "duplicate case '%s'", str);

                    assert(p_label->constant_expression != NULL); //because case have values
                    compiler_diagnostic(W_LOCATION,
                        ctx,
                        p_existing_label->constant_expression->first_token, NULL, "previous declaration");
                }
            }

            if (parser_match_tk(ctx, ':') != 0)
                throw;

            case_label_list_push(&ctx->p_current_selection_statement->label_list, p_label);

            if (ctx->p_current_selection_statement &&
                ctx->p_current_selection_statement->condition &&
                ctx->p_current_selection_statement->condition->expression)
            {
                if (type_is_enum(&ctx->p_current_selection_statement->condition->expression->type))
                {
                    if (type_is_enum(&p_label->constant_expression->type))
                    {
                        check_diferent_enuns(ctx,
                                    p_label->constant_expression->first_token,
                                    p_label->constant_expression,
                                    ctx->p_current_selection_statement->condition->expression,
                                    "mismatch in enumeration types");
                    }
                    else
                    {
                        //enum and something else...
                    }
                }

                if (ctx->p_current_selection_statement == NULL)
                {
                    //unexpected because we have case inside switch
                    throw;
                }

                const struct enum_specifier* _Opt p_enum_specifier = NULL;

                if (ctx->p_current_selection_statement->condition &&
                    ctx->p_current_selection_statement->condition->expression &&
                    ctx->p_current_selection_statement->condition->expression->type.enum_specifier)
                {
                    p_enum_specifier = get_complete_enum_specifier(ctx->p_current_selection_statement->condition->expression->type.enum_specifier);
                }

                if (p_enum_specifier)
                {
                    const struct enumerator* _Opt p_enumerator = find_enumerator_by_value(p_enum_specifier, &p_label->constant_expression->object);
                    if (p_enumerator == NULL)
                    {
                        char str[50];
                        object_to_str(&p_label->constant_expression->object, 50, str);

                        compiler_diagnostic(W_ENUN_CONVERSION,
                                        ctx,
                                        p_label->constant_expression->first_token, NULL,
                                        "case value '%s' not in enumerated type 'enum %s'",
                                        str,
                                        p_enum_specifier->tag_name);
                    }
                    else
                    {

                    }
                }
            }

        }
        else if (ctx->current->type == TK_KEYWORD_DEFAULT)
        {
            struct label* _Opt p_existing_default_label = case_label_list_find_default(&ctx->p_current_selection_statement->label_list);

            if (p_existing_default_label)
            {
                compiler_diagnostic(C_ERROR_MULTIPLE_DEFAULT_LABELS_IN_ONE_SWITCH,
                    ctx,
                    p_label->p_first_token,
                    NULL,
                    "multiple default labels in one switch");

                compiler_diagnostic(W_NOTE,
                    ctx,
                    p_existing_default_label->p_first_token,
                    NULL,
                    "previous default");

                throw;
            }

            parser_match(ctx);
            if (parser_match_tk(ctx, ':') != 0)
                throw;

            case_label_list_push(&ctx->p_current_selection_statement->label_list, p_label);
        }
        // attribute_specifier_sequence_opt identifier ':'
        // attribute_specifier_sequence_opt 'case' constant_expression ':'
        // attribute_specifier_sequence_opt 'default' ':'
    }
    catch
    {
        label_delete(p_label);
        p_label = NULL;
    }
    return p_label;
}


struct label* _Opt case_label_list_find_default(const struct case_label_list* list)
{
    struct label* _Opt p = list->head;
    while (p)
    {
        if (p->p_first_token->type == TK_KEYWORD_DEFAULT)
            return p;
        p = p->next;
    }
    return NULL;
}


struct label* _Opt case_label_list_find_range(const struct case_label_list* list, const struct object* begin, const struct object* end)
{
    struct label* _Opt p = list->head;
    while (p)
    {
        if (p->constant_expression_end == NULL)
        {
            if (object_greater_than_or_equal(&p->constant_expression->object, begin) &&
                object_smaller_than_or_equal(&p->constant_expression_end->object, end))
            {
                return p;
            }
        }
        else
        {
            //range with range intersection
            if (object_smaller_than_or_equal(&p->constant_expression->object, end) &&
                object_smaller_than_or_equal(begin, &p->constant_expression_end->object))
                return p;
        }
        p = p->next;
    }
    return NULL;
}

struct label* _Opt case_label_list_find(const struct case_label_list* list, const struct object* object)
{
    struct label* _Opt p = list->head;
    while (p)
    {
        if (p->constant_expression_end == NULL)
        {
            if (object_equal(&p->constant_expression->object, object))
                return p;
        }
        else
        {
            if (object_greater_than_or_equal(object, &p->constant_expression->object) &&
                object_smaller_than_or_equal(object, &p->constant_expression_end->object))
                return p;
        }
        p = p->next;
    }
    return NULL;
}

void case_label_list_push(struct case_label_list* list, struct label* pnew)
{
    if (list->head == NULL)
    {
        list->head = pnew;
        list->tail = pnew;
    }
    else
    {
        assert(list->tail != NULL);
        list->tail->next = pnew;
        list->tail = pnew;
    }
}

void labeled_statement_delete(struct labeled_statement* _Owner _Opt p)
{
    if (p)
    {
        label_delete(p->label);
        statement_delete(p->statement);
        free(p);
    }
}

struct labeled_statement* _Owner _Opt labeled_statement(struct parser_ctx* ctx)
{
    struct labeled_statement* _Owner _Opt p_labeled_statement = calloc(1, sizeof(struct labeled_statement));
    try
    {
        if (p_labeled_statement == NULL)
            throw;

        // label statement
        struct label* _Owner _Opt p_label = label(ctx);

        if (p_label == NULL)
            throw;

        p_labeled_statement->label = p_label;

        struct statement* _Owner _Opt p_statement = statement(ctx);
        if (p_statement == NULL)
            throw;

        p_labeled_statement->statement = p_statement;
    }
    catch
    {
        labeled_statement_delete(p_labeled_statement);
        p_labeled_statement = NULL;
    }
    return p_labeled_statement;
}

void compound_statement_delete(struct compound_statement* _Owner _Opt p)
{
    if (p)
    {
        block_item_list_destroy(&p->block_item_list);
        free(p);
    }
}

struct compound_statement* _Owner _Opt compound_statement(struct parser_ctx* ctx)
{

    struct scope block_scope = { .variables.capacity = 10 };

    //'{' block_item_list_opt '}'
    struct compound_statement* _Owner _Opt p_compound_statement = NULL;

    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_compound_statement = calloc(1, sizeof(struct compound_statement));

        if (p_compound_statement == NULL)
            throw;

        p_compound_statement->diagnostic_flags = ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index];

        scope_list_push(&ctx->scopes, &block_scope);

        p_compound_statement->first_token = ctx->current;
        if (parser_match_tk(ctx, '{') != 0)
            throw;

        if (ctx->current == NULL)
        {
            compiler_diagnostic(C_ERROR_UNEXPECTED_TOKEN, ctx, ctx->input_list.tail, NULL, "unexpected end of file");
            throw;
        }

        if (ctx->current->type != '}')
        {
            bool berror = false;
            p_compound_statement->block_item_list = block_item_list(ctx, &berror);
            if (berror)
                throw;
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_compound_statement->last_token = ctx->current;
        if (parser_match_tk(ctx, '}') != 0)
            throw;

        // TODO ver quem nao foi usado.

        for (int i = 0; i < block_scope.variables.capacity; i++)
        {
            if (block_scope.variables.table == NULL)
                continue;
            struct map_entry* _Opt entry = block_scope.variables.table[i];
            while (entry)
            {

                if (entry->type != TAG_TYPE_DECLARATOR &&
                    entry->type != TAG_TYPE_INIT_DECLARATOR)
                {
                    entry = entry->next;
                    continue;
                }

                struct declarator* _Opt p_declarator = NULL;
                struct init_declarator* _Opt p_init_declarator = NULL;
                if (entry->type == TAG_TYPE_INIT_DECLARATOR)
                {
                    assert(entry->data.p_init_declarator != NULL);
                    p_init_declarator = entry->data.p_init_declarator;
                    p_declarator = p_init_declarator->p_declarator;
                }
                else
                {
                    p_declarator = entry->data.p_declarator;
                }

                if (p_declarator)
                {

                    if (!type_is_maybe_unused(&p_declarator->type) &&
                        p_declarator->num_uses == 0)
                    {
                        if (p_declarator->name_opt && p_declarator->name_opt->token_origin->level == 0)
                        {
                            compiler_diagnostic(W_UNUSED_VARIABLE,
                                ctx,
                                p_declarator->name_opt, NULL,
                                "'%s': unreferenced declarator",
                                p_declarator->name_opt->lexeme);
                        }
                    }
                }

                entry = entry->next;
            }
        }
    }
    catch
    {
        compound_statement_delete(p_compound_statement);
        p_compound_statement = NULL;
    }

    scope_list_pop(&ctx->scopes);

    scope_destroy(&block_scope);

    return p_compound_statement;
}

void block_item_list_add(struct block_item_list* list, struct block_item* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;

}

void block_item_list_destroy(_Dtor struct block_item_list* list)
{
    struct block_item* _Owner _Opt item = list->head;
    while (item)
    {
        struct block_item* _Owner _Opt next = item->next;
        item->next = NULL;
        block_item_delete(item);
        item = next;
    }
}

struct block_item_list block_item_list(struct parser_ctx* ctx, bool* error)
{
    /*
      block_item_list:
      block_item
      block_item_list block_item
    */
    *error = false;
    struct block_item_list block_item_list = { 0 };
    struct block_item* _Owner _Opt p_block_item = NULL;
    try
    {
        p_block_item = block_item(ctx);
        if (p_block_item == NULL)
            throw;

        block_item_list_add(&block_item_list, p_block_item);

        p_block_item = NULL; /*MOVED*/

        while (ctx->current != NULL && ctx->current->type != '}') // follow
        {
            p_block_item = block_item(ctx);
            if (p_block_item == NULL)
                throw;
            block_item_list_add(&block_item_list, p_block_item);
            p_block_item = NULL; /*MOVED*/
        }
    }
    catch
    {
        *error = true;
    }

    return block_item_list;
}

void block_item_delete(struct block_item* _Owner _Opt p)
{
    if (p)
    {
        declaration_delete(p->declaration);
        label_delete(p->label);
        unlabeled_statement_delete(p->unlabeled_statement);
        assert(p->next == NULL);
        free(p);
    }
}

struct block_item* _Owner _Opt block_item(struct parser_ctx* ctx)
{
    //   declaration
    //     unlabeled_statement
    //   label


    struct block_item* _Owner _Opt p_block_item = NULL;

    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_block_item = calloc(1, sizeof(struct block_item));
        if (p_block_item == NULL)
            throw;

        /*
         * Attributes can be first of declaration, labels etc..
         * so it is better to parse it in advance.
         */
        struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt =
            attribute_specifier_sequence_opt(ctx);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);
            throw;
        }

        p_block_item->first_token = ctx->current;

        if (ctx->current->type == TK_KEYWORD__ASM)
        { /*
       asm-block:
       __asm assembly-instruction ;_Opt
       __asm { assembly-instruction-list } ;_Opt

   assembly-instruction-list:
       assembly-instruction ;_Opt
       assembly-instruction ; assembly-instruction-list ;_Opt
       */

            parser_match(ctx);

            if (ctx->current == NULL)
            {
                attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->type == '{')
            {
                parser_match(ctx);

                while (ctx->current && ctx->current->type != '}')
                {
                    parser_match(ctx);
                }

                parser_match(ctx);
            }
            else
            {

                while (ctx->current && ctx->current->type != TK_NEWLINE)
                {
                    ctx->current = ctx->current->next;
                }

                parser_match(ctx);
            }

            if (ctx->current == NULL)
            {
                attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);
                unexpected_end_of_file(ctx);
                throw;
            }

            if (ctx->current->type == ';')
                parser_match(ctx);
        }
        else if (first_of_declaration_specifier(ctx) ||
            first_of_static_assert_declaration(ctx) ||
            first_of_pragma_declaration(ctx))
        {
            p_block_item->declaration = declaration(ctx, p_attribute_specifier_sequence_opt, STORAGE_SPECIFIER_BLOCK_SCOPE, false);
            if (p_block_item->declaration == NULL)
                throw;
            p_attribute_specifier_sequence_opt = NULL; /*MOVED*/

            struct init_declarator* _Opt p = p_block_item->declaration->init_declarator_list.head;
            while (p)
            {
                if (p->p_declarator->name_opt)
                {
                    naming_convention_local_var(ctx, p->p_declarator->name_opt, &p->p_declarator->type);
                }
                p = p->next;
            }
        }
        else if (first_of_label(ctx))
        {
            // so identifier confunde com expression
            p_block_item->label = label(ctx);
            if (p_block_item->label == NULL)
            {
                attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);
                throw;
            }
        }
        else
        {
            p_block_item->unlabeled_statement = unlabeled_statement(ctx);
            if (p_block_item->unlabeled_statement == NULL)
            {
                attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);
                throw;
            }
        }
        /*
                                               declaration-specifiers init-declarator-list_opt;
                  attribute-specifier-sequence declaration-specifiers init-declarator-list;
                  static_assert-declaration attribute_declaration
        */
        /*
        unlabeled-statement:
         expression-statement
         attribute-specifier-sequenceopt compound-statement
         attribute-specifier-sequenceopt selection-statement
         attribute-specifier-sequenceopt iteration-statement
         attribute-specifier-sequenceopt jump-statement

        label:
        attribute-specifier-sequenceopt identifier :
        attribute-specifier-sequenceopt case constant-expression :
        attribute-specifier-sequenceopt default :
        */

        attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);
    }
    catch
    {
        block_item_delete(p_block_item);
        p_block_item = NULL;
    }
    return p_block_item;
}

void try_statement_delete(struct try_statement* _Owner _Opt p)
{
    if (p)
    {
        secondary_block_delete(p->catch_secondary_block_opt);
        secondary_block_delete(p->secondary_block);
        free(p);
    }
}

struct try_statement* _Owner _Opt try_statement(struct parser_ctx* ctx)
{
    struct try_statement* _Owner _Opt p_try_statement = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_try_statement = calloc(1, sizeof(struct try_statement));

        if (p_try_statement == NULL)
            throw;

        p_try_statement->first_token = ctx->current;

        assert(ctx->current->type == TK_KEYWORD_CAKE_TRY);
        const struct try_statement* _Opt try_statement_copy_opt = ctx->p_current_try_statement_opt;
        ctx->p_current_try_statement_opt = p_try_statement;

        p_try_statement->catch_label_id = ctx->label_id++;


        if (parser_match_tk(ctx, TK_KEYWORD_CAKE_TRY) != 0)
            throw;

#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wmissing-destructor"    

        struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);
        if (p_secondary_block == NULL) throw;

        p_try_statement->secondary_block = p_secondary_block;
#pragma cake diagnostic pop

        /*restores the previous one*/
        ctx->p_current_try_statement_opt = try_statement_copy_opt;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == TK_KEYWORD_CAKE_CATCH)
        {
            p_try_statement->catch_token_opt = ctx->current;
            parser_match(ctx);

            assert(p_try_statement->catch_secondary_block_opt == NULL);


            p_try_statement->catch_secondary_block_opt = secondary_block(ctx);
            if (p_try_statement->catch_secondary_block_opt == NULL) throw;

        }
        if (ctx->previous == NULL)
            throw;

        p_try_statement->last_token = ctx->previous;
    }
    catch
    {
        try_statement_delete(p_try_statement);
        p_try_statement = NULL;
    }
    return p_try_statement;
}

void selection_statement_delete(struct selection_statement* _Owner _Opt p)
{
    if (p)
    {
        secondary_block_delete(p->secondary_block);
        secondary_block_delete(p->else_secondary_block_opt);

        condition_delete(p->condition);
        init_statement_delete(p->p_init_statement);
        free(p);
    }
}

struct selection_statement* _Owner _Opt selection_statement(struct parser_ctx* ctx)
{
    /*
    selection-statement: //C23
        "if" ( expression ) secondary-block
        "if" ( expression ) secondary-block else secondary-block
        "switch" ( expression ) secondary-block
    */

    /* Extension

    selection-statement: C2Y?
       "if" ( init-statement _Opt condition ) secondary-block
       "if" ( init-statement _Opt condition ) secondary-block "else" secondary-block
       switch ( init-statement _Opt condition ) secondary-block
    */

    struct scope if_scope = { 0 };
    scope_list_push(&ctx->scopes, &if_scope);

    struct selection_statement* _Owner _Opt p_selection_statement = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_selection_statement = calloc(1, sizeof(struct selection_statement));

        if (p_selection_statement == NULL)
        {
            throw;
        }

        p_selection_statement->label_id = ctx->label_id++;
        p_selection_statement->first_token = ctx->current;

        const bool is_if = (ctx->current->type == TK_KEYWORD_IF);
        if (ctx->current->type == TK_KEYWORD_IF ||
            ctx->current->type == TK_KEYWORD_SWITCH)
        {
            parser_match(ctx);
        }
        else
        {
            throw;
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (!(ctx->current->flags & TK_FLAG_MACRO_EXPANDED) && !style_has_one_space(ctx->current))
        {
            compiler_diagnostic(W_STYLE, ctx, ctx->current, NULL, "one space");
        }

        p_selection_statement->open_parentesis_token = ctx->current;


        if (parser_match_tk(ctx, '(') != 0)
            throw;

        /*
           init-statement and condition are  almost the same.
           the diference is that init-statement has ;
        */
        p_selection_statement->p_init_statement = init_statement(ctx, true);

        if (p_selection_statement->p_init_statement == NULL)
            throw;

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type == ';')
        {
            /*
              We only know if we are at init-statement if we find ;
            */

            //  fixing the last_token            
            if (p_selection_statement->p_init_statement->p_simple_declaration)
                p_selection_statement->p_init_statement->p_simple_declaration->last_token = ctx->current;
            else if (p_selection_statement->p_init_statement->p_expression_statement)
                p_selection_statement->p_init_statement->p_simple_declaration->last_token = ctx->current;

            parser_match(ctx);
            p_selection_statement->condition = condition(ctx);
        }
        else if (ctx->current->type == ')')
        {
            /*
              We only know if we are at init-statement if we find ;
              In this case it is NOT.
              So we copy parts of init-statement to condition
            */

            /*ignore that init_statement*/
            p_selection_statement->condition = calloc(1, sizeof * p_selection_statement->condition);
            if (p_selection_statement->condition == NULL)
                throw;

            //steal expression
            if (p_selection_statement->p_init_statement->p_expression_statement &&
                p_selection_statement->p_init_statement->p_expression_statement->expression_opt)
            {
                p_selection_statement->condition->first_token = p_selection_statement->p_init_statement->p_expression_statement->expression_opt->first_token;
                p_selection_statement->condition->last_token = p_selection_statement->p_init_statement->p_expression_statement->expression_opt->last_token;

                p_selection_statement->condition->expression =
                    p_selection_statement->p_init_statement->p_expression_statement->expression_opt;
                p_selection_statement->p_init_statement->p_expression_statement->expression_opt = NULL;
            }

            if (p_selection_statement->p_init_statement->p_simple_declaration)
            {
                p_selection_statement->condition->first_token = p_selection_statement->p_init_statement->p_simple_declaration->first_token;
                p_selection_statement->condition->last_token = p_selection_statement->p_init_statement->p_simple_declaration->last_token;

                if (p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.head !=
                    p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.tail)
                {
                    //tODO only 1
                    assert(false);
                    throw;
                }
                p_selection_statement->condition->p_init_declarator =
                    p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.head;

                p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.head = NULL;
                p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.tail = NULL;

                p_selection_statement->condition->p_declaration_specifiers =
                    p_selection_statement->p_init_statement->p_simple_declaration->p_declaration_specifiers;
                p_selection_statement->p_init_statement->p_simple_declaration->p_declaration_specifiers = NULL;
            }


            init_statement_delete(p_selection_statement->p_init_statement);
            p_selection_statement->p_init_statement = NULL;
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_selection_statement->close_parentesis_token = ctx->current;
        if (parser_match_tk(ctx, ')') != 0)
            throw;

        //if (object_has_constant_value(&p_selection_statement->init_statement_expression->object))
        //{
            //compiler_diagnostic(W_CONDITIONAL_IS_CONSTANT, ctx, p_selection_statement->init_statement_expression->first_token, "conditional expression is constant");
        //}

        if (!is_if && p_selection_statement && p_selection_statement->condition)
        {
            if (type_is_bool(&p_selection_statement->condition->expression->type) ||
                type_is_essential_bool(&p_selection_statement->condition->expression->type))
            {
                compiler_diagnostic(W_SWITCH,
                            ctx,
                            p_selection_statement->condition->first_token,
                            NULL,
                            "switch condition has boolean value"); //[-Wswitch-bool]
            }
        }

        const struct selection_statement* _Opt previous = ctx->p_current_selection_statement;
        ctx->p_current_selection_statement = p_selection_statement;

        struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);

        if (p_secondary_block == NULL)
        {
            throw;
        }

        if (p_secondary_block->statement->unlabeled_statement &&
            p_secondary_block->statement->unlabeled_statement->expression_statement &&
            p_secondary_block->statement->unlabeled_statement->expression_statement->expression_opt == NULL)
        {
            compiler_diagnostic(W_SWITCH,
                            ctx,
                            p_secondary_block->first_token,
                            NULL,
                            "empty controlled statement found; is this the intent?");

        }


        assert(p_selection_statement->secondary_block == NULL);
        p_selection_statement->secondary_block = p_secondary_block;

        if (p_selection_statement->first_token->type == TK_KEYWORD_SWITCH)
        {
            //switch of enum without default, then we check if all items were used
            if (case_label_list_find_default(&p_selection_statement->label_list) == NULL)
            {
                const struct enum_specifier* _Opt p_enum_specifier = NULL;

                if (ctx->p_current_selection_statement &&
                    ctx->p_current_selection_statement->condition &&
                    ctx->p_current_selection_statement->condition->expression &&
                    ctx->p_current_selection_statement->condition->expression->type.enum_specifier)
                {
                    p_enum_specifier = get_complete_enum_specifier(ctx->p_current_selection_statement->condition->expression->type.enum_specifier);
                }

                if (p_enum_specifier)
                {
                    struct enumerator* _Opt p = p_enum_specifier->enumerator_list.head;
                    while (p)
                    {
                        struct label* _Opt p_used = case_label_list_find(&p_selection_statement->label_list, &p->value);

                        if (p_used == NULL)
                        {
                            compiler_diagnostic(W_SWITCH,
                                ctx,
                                ctx->current, NULL,
                                "enumeration '%s' not handled in switch", p->token->lexeme);
                        }
                        p = p->next;
                    }
                }
            }
        }

        ctx->p_current_selection_statement = previous;




        if (is_if && ctx->current && ctx->current->type == TK_KEYWORD_ELSE)
        {
            p_selection_statement->else_token_opt = ctx->current;
            parser_match(ctx);
            assert(p_selection_statement->else_secondary_block_opt == NULL);

            struct secondary_block* _Owner _Opt p_secondary_block2 = secondary_block(ctx);
            if (p_secondary_block2 == NULL) throw;

            p_selection_statement->else_secondary_block_opt = p_secondary_block2;
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        struct token* _Opt p_tk = previous_parser_token(ctx->current);
        if (p_tk == NULL)
        {
            throw;
        }

        p_selection_statement->last_token = p_tk;
    }
    catch
    {
        selection_statement_delete(p_selection_statement);
        p_selection_statement = NULL;
    }
    scope_list_pop(&ctx->scopes);
    scope_destroy(&if_scope);

    return p_selection_statement;
}

struct defer_statement* _Owner _Opt defer_statement(struct parser_ctx* ctx)
{
    struct defer_statement* _Owner _Opt p_defer_statement = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type != TK_KEYWORD_DEFER)
            throw;

        p_defer_statement = calloc(1, sizeof(struct defer_statement));

        if (p_defer_statement == NULL)
            throw;

        p_defer_statement->first_token = ctx->current;
        parser_match(ctx);

        const struct defer_statement* _Opt p_previous_defer_statement_opt =
            ctx->p_current_defer_statement_opt;

        ctx->p_current_defer_statement_opt = p_defer_statement;

        struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);
        if (p_secondary_block == NULL) throw;

        p_defer_statement->secondary_block = p_secondary_block;
        if (ctx->previous == NULL) throw;

        p_defer_statement->last_token = ctx->previous;

        ctx->p_current_defer_statement_opt = p_previous_defer_statement_opt;
    }
    catch
    {
        defer_statement_delete(p_defer_statement);
        p_defer_statement = NULL;
    }
    return p_defer_statement;
}

void iteration_statement_delete(struct iteration_statement* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->expression0);
        expression_delete(p->expression1);
        expression_delete(p->expression2);
        declaration_delete(p->declaration);
        secondary_block_delete(p->secondary_block);
        free(p);
    }
}

struct iteration_statement* _Owner _Opt iteration_statement(struct parser_ctx* ctx)
{
    /*
    iteration-statement:
      while ( expression ) statement
      do statement while ( expression ) ;
      for ( expressionopt ; expressionopt ; expressionopt ) statement
      for ( declaration expressionopt ; expressionopt ) statement
    */
    struct iteration_statement* _Owner _Opt p_iteration_statement = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_iteration_statement = calloc(1, sizeof(struct iteration_statement));

        if (p_iteration_statement == NULL)
            throw;

        p_iteration_statement->first_token = ctx->current;
        if (ctx->current->type == TK_KEYWORD_DO)
        {
            parser_match(ctx);

            struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);
            if (p_secondary_block == NULL) throw;

            p_iteration_statement->secondary_block = p_secondary_block;

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            p_iteration_statement->second_token = ctx->current;

            if (parser_match_tk(ctx, TK_KEYWORD_WHILE) != 0)
                throw;
            if (parser_match_tk(ctx, '(') != 0)
                throw;

            p_iteration_statement->expression1 = expression(ctx);
            if (parser_match_tk(ctx, ')') != 0)
                throw;
            if (parser_match_tk(ctx, ';') != 0)
                throw;
        }
        else if (ctx->current->type == TK_KEYWORD_WHILE)
        {
            parser_match(ctx);
            if (parser_match_tk(ctx, '(') != 0)
                throw;

            p_iteration_statement->expression1 = expression(ctx);
            if (parser_match_tk(ctx, ')') != 0)
                throw;
            struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);
            if (p_secondary_block == NULL) throw;
            p_iteration_statement->secondary_block = p_secondary_block;
        }
        else if (ctx->current->type == TK_KEYWORD_FOR)
        {
            parser_match(ctx);
            if (parser_match_tk(ctx, '(') != 0)
                throw;
            if (first_of_declaration_specifier(ctx))
            {
                struct scope for_scope = { 0 };
                scope_list_push(&ctx->scopes, &for_scope);

                p_iteration_statement->declaration = declaration(ctx, NULL, STORAGE_SPECIFIER_BLOCK_SCOPE, false);

                if (ctx->current == NULL)
                {

                    unexpected_end_of_file(ctx);

                    scope_list_pop(&ctx->scopes);
                    scope_destroy(&for_scope);
                    throw;
                }

                if (ctx->current->type != ';')
                {
                    p_iteration_statement->expression1 = expression(ctx);
                    if (p_iteration_statement->expression1 == NULL)
                    {
                        scope_list_pop(&ctx->scopes);
                        scope_destroy(&for_scope);
                        throw;
                    }
                }

                if (parser_match_tk(ctx, ';') != 0)
                {
                    scope_list_pop(&ctx->scopes);
                    scope_destroy(&for_scope);
                    throw;
                }

                if (ctx->current == NULL)
                {

                    unexpected_end_of_file(ctx);

                    scope_list_pop(&ctx->scopes);
                    scope_destroy(&for_scope);
                    throw;
                }

                if (ctx->current->type != ')')
                    p_iteration_statement->expression2 = expression(ctx);

                if (parser_match_tk(ctx, ')') != 0)
                {
                    scope_list_pop(&ctx->scopes);
                    scope_destroy(&for_scope);
                    throw;
                }

                struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);
                if (p_secondary_block == NULL)
                {
                    scope_list_pop(&ctx->scopes);
                    scope_destroy(&for_scope);
                    throw;
                }

                p_iteration_statement->secondary_block = p_secondary_block;

                scope_list_pop(&ctx->scopes);

                scope_destroy(&for_scope);
            }
            else
            {
                /*
                 *   int i;
                 *   for (i = 0; i < 10; i++)
                 *   {
                 *   }
                 */

                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    throw;
                }

                if (ctx->current->type != ';')
                    p_iteration_statement->expression0 = expression(ctx);
                if (parser_match_tk(ctx, ';') != 0)
                    throw;

                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    throw;
                }

                if (ctx->current->type != ';')
                    p_iteration_statement->expression1 = expression(ctx);

                if (parser_match_tk(ctx, ';') != 0)
                    throw;

                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    throw;
                }

                if (ctx->current->type != ')')
                    p_iteration_statement->expression2 = expression(ctx);

                if (parser_match_tk(ctx, ')') != 0)
                    throw;

                if (ctx->current == NULL)
                {
                    unexpected_end_of_file(ctx);
                    throw;
                }

                struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);
                if (p_secondary_block == NULL) throw;

                p_iteration_statement->secondary_block = p_secondary_block;
            }
        }
    }
    catch
    {
        iteration_statement_delete(p_iteration_statement);
        p_iteration_statement = NULL;
    }
    return p_iteration_statement;
}

void jump_statement_delete(struct jump_statement* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->expression_opt);
        free(p);
    }
}

struct jump_statement* _Owner _Opt jump_statement(struct parser_ctx* ctx)
{
    /*
      jump-statement:
            goto identifier ;
            continue ;
            break ;
            return expressionopt ;
    */

    /*
       throw; (extension)
    */

    struct jump_statement* _Owner _Opt p_jump_statement = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_jump_statement = calloc(1, sizeof(struct jump_statement));

        if (p_jump_statement == NULL)
            throw;

        p_jump_statement->first_token = ctx->current;

        if (ctx->current->type == TK_KEYWORD_GOTO)
        {
            parser_match(ctx);

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            struct label_list_item* _Opt p_label_list_item =
                label_list_find(&ctx->label_list, ctx->current->lexeme);

            if (p_label_list_item == NULL)
            {
                struct label_list_item* _Owner _Opt p_label_list_item_new = calloc(1, sizeof * p_label_list_item_new);
                if (p_label_list_item_new)
                {
                    p_label_list_item_new->p_last_usage = ctx->current;
                    label_list_push(&ctx->label_list, p_label_list_item_new);
                }
            }
            else
            {
                p_label_list_item->p_last_usage = ctx->current;
            }

            p_jump_statement->label = ctx->current;
            if (parser_match_tk(ctx, TK_IDENTIFIER) != 0)
                throw;
        }
        else if (ctx->current->type == TK_KEYWORD_CONTINUE)
        {
            parser_match(ctx);
        }
        else if (ctx->current->type == TK_KEYWORD_BREAK)
        {
            parser_match(ctx);
        }
        else if (ctx->current->type == TK_KEYWORD_CAKE_THROW)
        {
            if (ctx->p_current_try_statement_opt == NULL)
            {
                compiler_diagnostic(C_ERROR_THROW_STATEMENT_NOT_WITHIN_TRY_BLOCK, ctx, ctx->current, NULL, "throw statement not within try block");
            }
            else
            {
                p_jump_statement->label_id = ctx->p_current_try_statement_opt->catch_label_id;
            }

            parser_match(ctx);
        }
        else if (ctx->current->type == TK_KEYWORD_RETURN)
        {
            if (ctx->p_current_defer_statement_opt != NULL)
            {
                compiler_diagnostic(C_ERROR_RETURN_CANNOT_BE_USED_INSIDE_DEFER,
                             ctx,
                             ctx->current,
                             NULL,
                             "%s",
                             "return cannot be used inside defer statement");
                throw;
            }

            const struct token* const p_return_token = ctx->current;
            parser_match(ctx);

            if (ctx->current == NULL)
            {
                unexpected_end_of_file(ctx);
                throw;
            }

            /*
                     * Check is return type is compatible with function return
                     */
            struct type return_type =
                get_function_return_type(&ctx->p_current_function_opt->type);

            if (ctx->current->type != ';')
            {
                p_jump_statement->expression_opt = expression(ctx);

                if (p_jump_statement->expression_opt)
                {
                    if (type_is_void(&return_type))
                    {
                        const char* func_name =
                            ctx->p_current_function_opt->name_opt ?
                            ctx->p_current_function_opt->name_opt->lexeme :
                            "unnamed";

                        compiler_diagnostic(C_ERROR_VOID_FUNCTION_SHOULD_NOT_RETURN_VALUE,
                            ctx,
                            p_return_token, NULL,
                            "void function '%s' should not return a value",
                            func_name);
                    }
                    else
                    {
                        check_assigment(ctx,
                            &return_type,
                            p_jump_statement->expression_opt,
                            ASSIGMENT_TYPE_RETURN);
                    }
                }
            }
            else
            {
                if (!type_is_void(&return_type))
                {
                    const char* func_name =
                        ctx->p_current_function_opt->name_opt ?
                        ctx->p_current_function_opt->name_opt->lexeme :
                        "unnamed";

                    compiler_diagnostic(C_ERROR_NON_VOID_FUNCTION_SHOULD_RETURN_VALUE,
                        ctx,
                        p_return_token, NULL,
                        "non void function '%s' should return a value",
                        func_name);
                }
            }
            type_destroy(&return_type);
        }
        else
        {
            assert(false);
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_jump_statement->last_token = ctx->current;
        if (parser_match_tk(ctx, ';') != 0)
            throw;
    }
    catch
    {
        jump_statement_delete(p_jump_statement);
        p_jump_statement = NULL;
    }
    return p_jump_statement;
}

void expression_statement_delete(struct expression_statement* _Owner _Opt p)
{
    if (p)
    {
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence_opt);
        expression_delete(p->expression_opt);
        free(p);
    }
}

struct expression_statement* _Owner _Opt  expression_statement(struct parser_ctx* ctx, bool ignore_semicolon)
{
    struct expression_statement* _Owner _Opt p_expression_statement = calloc(1, sizeof(struct expression_statement));
    try
    {
        /*
         expression-statement:
           expression _Opt ;
           attribute-specifier-sequence expression ;
        */
        if (p_expression_statement == NULL)
            throw;

        p_expression_statement->p_attribute_specifier_sequence_opt =
            attribute_specifier_sequence_opt(ctx);

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        if (ctx->current->type != ';')
        {
            p_expression_statement->expression_opt = expression(ctx);
            if (p_expression_statement->expression_opt == NULL)
                throw;
        }

        if (!ignore_semicolon && parser_match_tk(ctx, ';') != 0)
            throw;
    }
    catch
    {
        expression_statement_delete(p_expression_statement);
        p_expression_statement = NULL;
    }
    return p_expression_statement;
}

void declaration_list_add(struct declaration_list* list, struct declaration* _Owner p_declaration)
{
    if (list->head == NULL)
    {
        list->head = p_declaration;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_declaration;
    }
    list->tail = p_declaration;
}

void simple_declaration_delete(struct simple_declaration* _Owner _Opt p_simple_declaration)
{
    if (p_simple_declaration)
    {
        declaration_specifiers_delete(p_simple_declaration->p_declaration_specifiers);
        init_declarator_list_destroy(&p_simple_declaration->init_declarator_list);
        attribute_specifier_sequence_delete(p_simple_declaration->p_attribute_specifier_sequence_opt);

        free(p_simple_declaration);
    }
}

void condition_delete(struct condition* _Owner _Opt p_condition)
{
    if (p_condition)
    {
        init_declarator_delete(p_condition->p_init_declarator);
        expression_delete(p_condition->expression);

        attribute_specifier_sequence_delete(p_condition->p_attribute_specifier_sequence_opt);
        declaration_specifiers_delete(p_condition->p_declaration_specifiers);
        free(p_condition);
    }
}

struct condition* _Owner _Opt condition(struct parser_ctx* ctx)
{
    /*
    condition :
       expression
       attribute-specifier-seq opt decl-specifier-seq declarator initializer
    */
    struct condition* _Owner _Opt p_condition = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        p_condition = calloc(1, sizeof * p_condition);
        if (p_condition == NULL)
            throw;

        p_condition->first_token = ctx->current;
        if (first_of_declaration_specifier(ctx))
        {
            p_condition->p_attribute_specifier_sequence_opt = attribute_specifier_sequence(ctx);

            p_condition->p_declaration_specifiers = declaration_specifiers(ctx, STORAGE_SPECIFIER_BLOCK_SCOPE);
            if (p_condition->p_declaration_specifiers == NULL)
                throw;

            struct init_declarator* _Owner _Opt p_init_declarator =
                init_declarator(ctx, p_condition->p_declaration_specifiers);

            if (p_init_declarator == NULL)
                throw;

            p_condition->p_init_declarator = p_init_declarator;
        }
        else
        {
            p_condition->expression = expression(ctx);
            if (p_condition->expression == NULL)
                throw;
        }

        if (ctx->current == NULL)
        {
            unexpected_end_of_file(ctx);
            throw;
        }

        struct token* _Opt previous = previous_parser_token(ctx->current);

        if (previous)
        {
            //shoult never be null
            p_condition->last_token = previous;
        }
    }
    catch
    {
        condition_delete(p_condition);
        p_condition = NULL;
    }
    return p_condition;
}

void init_statement_delete(struct init_statement* _Owner _Opt p_init_statement)
{
    if (p_init_statement)
    {
        expression_statement_delete(p_init_statement->p_expression_statement);
        simple_declaration_delete(p_init_statement->p_simple_declaration);
        free(p_init_statement);
    }
}

struct init_statement* _Owner _Opt init_statement(struct parser_ctx* ctx, bool ignore_semicolon)
{
    /*
       expression-statement
       simple-declaration
    */
    struct init_statement* _Owner _Opt p_init_statement = NULL;
    try
    {
        p_init_statement = calloc(1, sizeof * p_init_statement);

        if (p_init_statement == NULL)
            throw;

        if (first_of_declaration_specifier(ctx))
        {
            p_init_statement->p_simple_declaration = simple_declaration(ctx, NULL, ignore_semicolon);
        }
        else
        {
            p_init_statement->p_expression_statement = expression_statement(ctx, ignore_semicolon);
        }
    }
    catch
    {
        init_statement_delete(p_init_statement);
        p_init_statement = NULL;
    }
    return p_init_statement;
}

void declaration_delete(struct declaration* _Owner _Opt p)
{
    if (p)
    {

        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence_opt);
        static_assert_declaration_delete(p->static_assert_declaration);

        declaration_specifiers_delete(p->declaration_specifiers);

        compound_statement_delete(p->function_body);
        pragma_declaration_delete(p->pragma_declaration);

        init_declarator_list_destroy(&p->init_declarator_list);
        assert(p->next == NULL);
        free(p);
    }
}

void declaration_list_destroy(_Dtor struct declaration_list* list)
{
    struct declaration* _Owner _Opt p = list->head;
    while (p)
    {
        struct declaration* _Owner _Opt next = p->next;
        p->next = NULL;
        declaration_delete(p);
        p = next;
    }
}

static void check_unused_static_declarators(struct parser_ctx* ctx, struct declaration_list* declaration_list)
{
    struct declaration* _Opt p = declaration_list->head;
    while (p)
    {
        if (p->declaration_specifiers &&
            p->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_STATIC)
        {
            if (p->init_declarator_list.head &&
                p->init_declarator_list.head->p_declarator)
            {
                struct map_entry* _Opt p_entry = find_variables(ctx, p->init_declarator_list.head->p_declarator->name_opt->lexeme, NULL);
                if (p_entry && (p_entry->type == TAG_TYPE_DECLARATOR || p_entry->type == TAG_TYPE_INIT_DECLARATOR))
                {
                    /*
                       Consider
                       static void f();
                       static void f(){}
                       int main(){
                         f();
                       }
                       num_uses if incremented only at the pointer returned by find_variables
                    */
                    struct declarator* p_declarator_local = NULL;
                    if (p_entry->type == TAG_TYPE_INIT_DECLARATOR)
                    {
                        p_declarator_local = p_entry->data.p_init_declarator->p_declarator;
                    }
                    else
                    {
                        p_declarator_local = p_entry->data.p_declarator;

                    }
                    int num_uses = p_declarator_local->num_uses;
                    if (num_uses == 0)
                    {
                        if (type_is_function(&p->init_declarator_list.head->p_declarator->type))
                        {
                            compiler_diagnostic(W_UNUSED_FUNCTION,
                            ctx,
                            p->init_declarator_list.head->p_declarator->name_opt,
                            NULL,
                            "warning: static function '%s' not used.",
                            p->init_declarator_list.head->p_declarator->name_opt->lexeme);
                        }
                        else
                        {
                            compiler_diagnostic(W_UNUSED_VARIABLE,
                            ctx,
                            p->init_declarator_list.head->p_declarator->name_opt,
                            NULL,
                            "warning: '%s' not used.",
                            p->init_declarator_list.head->p_declarator->name_opt->lexeme);
                        }
                    }
                }
            }
        }
        p = p->next;
    }
}

struct declaration* _Owner _Opt external_declaration(struct parser_ctx* ctx)
{
    /*
     function_definition
     declaration
     */
    return function_definition_or_declaration(ctx);
}

struct declaration_list translation_unit(struct parser_ctx* ctx, bool* berror)
{
    *berror = false;
    struct declaration_list declaration_list = { 0 };
    /*
      translation_unit:
      external_declaration
      translation_unit external_declaration
    */
    try
    {
        while (ctx->current != NULL)
        {
            struct declaration* _Owner _Opt p = external_declaration(ctx);
            if (p == NULL)
                throw;
            declaration_list_add(&declaration_list, p);
        }

        check_unused_static_declarators(ctx, &declaration_list);
    }
    catch
    {
        *berror = true;
    }
    return declaration_list;
}



struct label_list_item* _Opt label_list_find(struct label_list* list, const char* label_name)
{
    struct label_list_item* _Opt item = list->head;
    while (item)
    {
        if (item->p_defined && strcmp(item->p_defined->lexeme, label_name) == 0)
        {
            return item;
        }
        else if (item->p_last_usage && strcmp(item->p_last_usage->lexeme, label_name) == 0)
        {
            return item;
        }

        item = item->next;
    }
    return NULL;
}

void label_list_swap(struct label_list* a, struct label_list* b)
{
    struct label_list temp = *a;
    *a = *b;
    *b = temp;
}
void label_list_clear(struct label_list* list)
{
    struct label_list_item* _Owner _Opt item = list->head;
    while (item)
    {
        struct label_list_item* _Owner _Opt next = item->next;
        item->next = NULL;
        free(item);
        item = next;
    }
    list->head = NULL;
    list->tail = NULL;
}

void label_list_push(struct label_list* list, struct label_list_item* _Owner pitem)
{
    if (list->head == NULL)
    {
        list->head = pitem;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = pitem;
    }
    list->tail = pitem;
}


void check_labels(struct parser_ctx* ctx)
{
    struct label_list_item* _Opt item = ctx->label_list.head;
    while (item)
    {
        if (item->p_defined == NULL && item->p_last_usage != NULL)
        {
            compiler_diagnostic(C_ERROR_LABEL_NOT_DEFINED, ctx, item->p_last_usage, NULL, "label '%s' used but not defined", item->p_last_usage->lexeme);
        }
        else if (item->p_defined != NULL && item->p_last_usage == NULL)
        {
            compiler_diagnostic(W_UNUSED_LABEL, ctx, item->p_defined, NULL, "label '%s' defined but not used", item->p_defined->lexeme);
        }
        item = item->next;
    }
}

struct compound_statement* _Owner _Opt function_body(struct parser_ctx* ctx)
{

    /*
     * Used to give an unique index (inside the function)
     * for try-catch blocks
     */

    const struct try_statement* _Opt p_current_try_statement_opt = ctx->p_current_try_statement_opt;
    ctx->p_current_try_statement_opt = NULL;

    int label_id = ctx->label_id;
    ctx->label_id = 0; /*reset*/

    const struct defer_statement* _Opt p_current_defer_statement_opt = ctx->p_current_defer_statement_opt;
    ctx->p_current_defer_statement_opt = NULL;

    const struct selection_statement* _Opt p_current_selection_statement = ctx->p_current_selection_statement;
    ctx->p_current_selection_statement = NULL;

    struct label_list label_list = { 0 };
    label_list_swap(&label_list, &ctx->label_list);

    struct compound_statement* _Owner _Opt p_compound_statement = compound_statement(ctx);
    if (p_compound_statement)
    {
        check_labels(ctx);
    }

    label_list_swap(&label_list, &ctx->label_list);

    ctx->label_id = label_id;
    ctx->p_current_try_statement_opt = p_current_try_statement_opt;
    ctx->p_current_defer_statement_opt = p_current_defer_statement_opt;
    ctx->p_current_selection_statement = p_current_selection_statement;

    label_list_clear(&label_list);

    return p_compound_statement;
}

struct declaration_list parse(struct parser_ctx* ctx, struct token_list* list, bool* berror)
{
    *berror = false;
    s_anonymous_struct_count = 0;
    struct declaration_list l = { 0 };
    struct scope file_scope = { 0 };
    try
    {
        scope_list_push(&ctx->scopes, &file_scope);
        ctx->input_list = *list;
        ctx->current = ctx->input_list.head;
        parser_skip_blanks(ctx);

        bool local_error = false;
        l = translation_unit(ctx, &local_error);
        if (local_error)
            throw;
    }
    catch
    {
        *berror = true;
    }
    scope_destroy(&file_scope);

    return l;
}

int fill_preprocessor_options(int argc, const char** argv, struct preprocessor_ctx* prectx)
{
    /*first loop used to collect options*/
    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] != '-')
            continue;

        if (argv[i][1] == 'I')
        {
            include_dir_add(&prectx->include_dir, argv[i] + 2);
            continue;
        }
        if (argv[i][1] == 'D')
        {
            char buffer[200] = { 0 };
            snprintf(buffer, sizeof buffer, "#define %s \n", argv[i] + 2);

            /*TODO make it more precise*/
            char* p = &buffer[7];
            while (*p)
            {
                if (*p == '=')
                {
                    *p = ' ';
                    break;
                }
                p++;
            }

            struct tokenizer_ctx tctx = { 0 };
            struct token_list l1 = tokenizer(&tctx, buffer, "", 0, TK_FLAG_NONE);
            struct token_list r = preprocessor(prectx, &l1, 0);
            token_list_destroy(&l1);
            token_list_destroy(&r);
            continue;
        }
    }
    return 0;
}

#ifdef _WIN32

WINBASEAPI unsigned long WINAPI GetEnvironmentVariableA(const char* name,
char* buffer,
unsigned long size);

#endif

void append_msvc_include_dir(struct preprocessor_ctx* prectx)
{

#ifdef _WIN32
    char env[2000] = { 0 };
    int n = GetEnvironmentVariableA("INCLUDE", env, sizeof(env));

    if (n > 0)
    {

        const char* p = env;
        for (;;)
        {
            if (*p == '\0')
            {
                break;
            }
            char filename_local[500] = { 0 };
            int count = 0;
            while (*p != '\0' && (*p != ';' && *p != '\n'))
            {
                filename_local[count] = *p;
                p++;
                count++;
            }
            filename_local[count] = 0;
            if (count > 0)
            {
                strcat(filename_local, "/");
                include_dir_add(&prectx->include_dir, filename_local);
            }
            if (*p == '\0')
            {
                break;
            }
            p++;
        }
    }
#endif
}


int generate_config_file(const char* configpath)
{
    FILE* _Owner _Opt outfile = NULL;
    int error = 0;
    try
    {
        outfile = fopen(configpath, "w");
        if (outfile == NULL)
        {
            printf("Cannot open the file '%s' for writing.\n", configpath);
            error = errno;
            throw;
        }

        fprintf(outfile, "//This was generated by running cake -autoconfig \n");


#ifdef __linux__

        fprintf(outfile, "This file was generated reading the output of\n");
        fprintf(outfile, "//echo | gcc -v -E - 2>&1\n");
        fprintf(outfile, "\n");

        char path[400] = { 0 };
        char* command = "echo | gcc -v -E - 2>&1";
        int in_include_section = 0;

        // Open the command for reading
        FILE* fp = popen(command, "r");
        if (fp == NULL)
        {
            fprintf(stderr, "Failed to run command\n");
            error = errno;
            throw;
        }

        // Read the output a line at a time
        while (fgets(path, sizeof(path), fp) != NULL)
        {
            // Check if we are in the "#include <...> search starts here:" section
            if (strstr(path, "#include <...> search starts here:") != NULL)
            {
                in_include_section = 1;
                continue;
            }
            // Check if we have reached the end of the include section
            if (in_include_section && strstr(path, "End of search list.") != NULL)
            {
                break;
            }
            // Print the include directories
            if (in_include_section)
            {
                const char* p = path;
                while (*p == ' ') p++;

                int len = strlen(path);
                if (path[len - 1] == '\n')
                    path[len - 1] = '\0';

                fprintf(outfile, "#pragma dir \"%s\"\n", p);
            }
        }

        fprintf(outfile, "\n");

        // Close the command stream
        pclose(fp);

#endif

#ifdef _WIN32
        char env[2000] = { 0 };
        int n = GetEnvironmentVariableA("INCLUDE", env, sizeof(env));

        if (n <= 0)
        {
            printf("INCLUDE not found.\nPlease, run cake -autoconfig inside visual studio command prompty.\n");
            error = 1;
            throw;
        }

        fprintf(outfile, "//This file was generated reading the variable INCLUDE inside Visual Studio Command Prompt.\n");
        fprintf(outfile, "//echo %%INCLUDE%% \n");

        const char* p = env;
        for (;;)
        {
            if (*p == '\0')
            {
                break;
            }
            char filename_local[500] = { 0 };
            int count = 0;
            while (*p != '\0' && (*p != ';' && *p != '\n'))
            {
                filename_local[count] = *p;
                p++;
                count++;
            }
            filename_local[count] = 0;
            if (count > 0)
            {
                strcat(filename_local, "/");
                char* pch = filename_local;
                while (*pch)
                {
                    if (*pch == '\\')
                        *pch = '/';
                    pch++;
                }

                fprintf(outfile, "#pragma dir \"%s\"\n", filename_local);
            }
            if (*p == '\0')
            {
                break;
            }
            p++;
        }
#endif
    }
    catch
    {
    }
    if (outfile)
        fclose(outfile);

    if (error == 0)
    {
        printf("file '%s'\n", configpath);
        printf("successfully generated\n");
    }
    return error;
}

int compile_one_file(const char* file_name,
    struct options* options,
    const char* out_file_name,
    int argc,
    const char** argv,
    struct report* report)
{
    printf("%s\n", file_name);
    struct preprocessor_ctx prectx = { 0 };
    prectx.options = *options;
    prectx.macros.capacity = 5000;

    add_standard_macros(&prectx);

    if (include_config_header(&prectx, file_name) != 0)
    {
        //cakeconfig.h is optional               
    }
    // print_all_macros(&prectx);

    struct ast ast = { 0 };

    const char* _Owner _Opt s = NULL;

    _Opt struct parser_ctx ctx = { 0 };

    struct tokenizer_ctx tctx = { 0 };
    struct token_list tokens = { 0 };

    ctx.options = *options;
    ctx.p_report = report;
    char* _Owner _Opt content = NULL;

    try
    {
        //-D , -I etc..
        if (fill_preprocessor_options(argc, argv, &prectx) != 0)
        {
            throw;
        }

        prectx.options = *options;
        append_msvc_include_dir(&prectx);

        content = read_file(file_name, true /*append new line*/);
        if (content == NULL)
        {
            report->error_count++;
            printf("file not found '%s'\n", file_name);
            throw;
        }

        if (options->sarif_output)
        {
            char sarif_file_name[260] = { 0 };
            if (options->sarifpath[0] != '\0')
            {
                mkdir(options->sarifpath, 0777);
                snprintf(sarif_file_name, sizeof sarif_file_name, "%s/%s.cake.sarif", options->sarifpath, basename(file_name));
            }
            else
            {
                snprintf(sarif_file_name, sizeof sarif_file_name, "%s.cake.sarif", file_name);
            }

            ctx.sarif_file = (FILE * _Owner _Opt) fopen(sarif_file_name, "w");
            if (ctx.sarif_file)
            {
                const char* begin_sarif =
                    "{\n"
                    "  \"version\": \"2.1.0\",\n"
                    "  \"$schema\": \"https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.5.json\",\n"
                    "  \"runs\": [\n"
                    "    {\n"
                    "      \"results\": [\n"
                    "\n";

                fprintf(ctx.sarif_file, "%s", begin_sarif);
            }
            else
            {
                report->error_count++;
                printf("cannot open Sarif output file '%s'\n", sarif_file_name);
                throw;
            }
        }

        tokens = tokenizer(&tctx, content, file_name, 0, TK_FLAG_NONE);

        if (tctx.n_errors > 0)
            throw;

        if (options->dump_tokens)
        {
            print_tokens(tokens.head);
        }

        prectx.options.diagnostic_stack.stack[prectx.options.diagnostic_stack.top_index].notes |= (1ULL << W_NOTE);
        ast.token_list = preprocessor(&prectx, &tokens, 0);

        report->warnings_count += prectx.n_warnings;
        report->error_count += prectx.n_errors;

        if (prectx.n_errors > 0)
        {
            throw;
        }

        if (options->dump_pptokens)
        {
            if (ast.token_list.head != NULL)
                print_tokens(ast.token_list.head);
        }

        if (options->preprocess_only)
        {
            const char* _Owner _Opt s2 = print_preprocessed_to_string2(ast.token_list.head);
            printf("%s", s2);
            free((void* _Owner _Opt)s2);
        }
        else
        {
            bool berror = false;
            ast.declaration_list = parse(&ctx, &ast.token_list, &berror);
            if (berror || report->error_count > 0)
                throw;

            if (!options->no_output)
            {

                struct osstream ss = { 0 };
                struct d_visit_ctx ctx2 = { 0 };
                ctx2.ast = ast;
                ctx2.options = ctx.options;
                d_visit(&ctx2, &ss);
                s = ss.c_str; //MOVE
                d_visit_ctx_destroy(&ctx2);

                FILE* _Owner _Opt outfile = fopen(out_file_name, "w");
                if (outfile)
                {
                    if (s)
                        fprintf(outfile, "%s", s);

                    fclose(outfile);
                }
                else
                {
                    report->error_count++;
                    printf("cannot open output file '%s' - %s\n", out_file_name, get_posix_error_message(errno));
                    throw;
                }
            }
        }

        if (ctx.sarif_file)
        {

#define SARIF_FOOTER                                                             \
    "      ],\n"                                                        \
    "      \"tool\": {\n"                                               \
    "        \"driver\": {\n"                                           \
    "          \"name\": \"cake\",\n"                                   \
    "          \"fullName\": \"cake code analysis\",\n"                 \
    "          \"version\": \"" CAKE_VERSION  "\",\n"                   \
    "          \"informationUri\": \"https://https://github.com/thradams/cake\"\n" \
    "        }\n"                                                       \
    "      }\n"                                                         \
    "    }\n"                                                           \
    "  ]\n"                                                             \
    "}\n"                                                               \
    "\n"
            fprintf(ctx.sarif_file, "%s", SARIF_FOOTER);
            fclose(ctx.sarif_file);
            ctx.sarif_file = NULL;
        }
    }
    catch
    {
        // printf("Error %s\n", error->message);
    }

    if (ctx.options.test_mode)
    {
        //lets check if the generated file is the expected
        char buf[MYMAX_PATH] = { 0 };
        snprintf(buf, sizeof buf, "%s.out", file_name);

        char* _Owner _Opt content_expected = read_file(buf, false /*append new line*/);
        if (content_expected)
        {
            if (s && strcmp(content_expected, s) != 0)
            {
                printf("different");
                report->error_count++;
            }
            free(content_expected);
        }

        if (report->fatal_error_expected != 0)
        {
            if (report->last_diagnostics_ids[0] == report->fatal_error_expected)
            {
                report->error_count--;
            }
        }
        if (report->error_count > 0 || report->warnings_count > 0)
        {

            printf("-------------------------------------------\n");
            printf("%s", content);
            printf("\n-------------------------------------------\n");
            printf(LIGHTRED "TEST FAILED" RESET " : error=%d, warnings=%d\n", report->error_count, report->warnings_count);
            printf("\n\n");
            report->test_failed++;
        }
        else
        {

            report->test_succeeded++;
            printf(LIGHTGREEN "TEST OK\n" RESET);
        }
    }

    token_list_destroy(&tokens);

    parser_ctx_destroy(&ctx);
    free((void* _Owner _Opt)s);
    free(content);
    ast_destroy(&ast);
    preprocessor_ctx_destroy(&prectx);

    return report->error_count > 0;
}

static int compile_many_files(const char* file_name,
    struct options* options,
    const char* out_file_name,
    int argc,
    const char** argv,
    struct report* report)
{
    const char* const file_name_name = basename(file_name);
    const char* _Opt const file_name_extension = strrchr((char*)file_name_name, '.');

    if (file_name_extension == NULL)
    {
        assert(false);
    }

    int num_files = 0;

    char path[MYMAX_PATH] = { 0 };
    snprintf(path, sizeof path, "%s", file_name);
    dirname(path);
    DIR* _Owner _Opt dir = opendir(path);

    if (dir == NULL)
    {
        return errno;
    }

    struct dirent* _Opt dp;
    while ((dp = readdir(dir)) != NULL)
    {
        if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
        {
            /* skip self and parent */
            continue;
        }

        char fromlocal[257] = { 0 };
        snprintf(fromlocal, sizeof fromlocal, "%s/%s", "", dp->d_name);

        if (dp->d_type & DT_DIR)
        {

        }
        else
        {
            const char* const file_name_iter = basename(dp->d_name);
            const char* _Opt const file_extension = strrchr((char*)file_name_iter, '.');

            if (file_name_extension &&
                file_extension &&
                strcmp(file_name_extension, file_extension) == 0)
            {
                //Fixes the output file name replacing the current name
                char out_file_name_final[MYMAX_PATH] = { 0 };
                strcpy(out_file_name_final, out_file_name);
                dirname(out_file_name_final);
                strcat(out_file_name_final, "/");
                strcat(out_file_name_final, file_name_iter);

                char in_file_name_final[MYMAX_PATH] = { 0 };
                strcpy(in_file_name_final, file_name);
                dirname(in_file_name_final);
                strcat(in_file_name_final, "/");
                strcat(in_file_name_final, file_name_iter);


                struct report report_local = { 0 };
                report_local.test_mode = report->test_mode;
                compile_one_file(in_file_name_final,
                                 options,
                                 out_file_name_final,
                                 argc,
                                 argv,
                                 &report_local);


                report->fatal_error_expected = report_local.fatal_error_expected;
                report->error_count += report_local.error_count;
                report->warnings_count += report_local.warnings_count;
                report->info_count += report_local.info_count;
                report->test_succeeded += report_local.test_succeeded;
                report->test_failed += report_local.test_failed;
                num_files++;
            }
        }
    }

    closedir(dir);
    return num_files;
}

static void longest_common_path(int argc, const char** argv, char root_dir[MYMAX_PATH])
{
    /*
     find the longest common path
    */
    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] == '-')
            continue;

        char fullpath_i[MYMAX_PATH] = { 0 };
        realpath(argv[i], fullpath_i);
        strcpy(root_dir, fullpath_i);
        dirname(root_dir);

        for (int k = 0; k < MYMAX_PATH; k++)
        {
            const char ch = fullpath_i[k];
            for (int j = 2; j < argc; j++)
            {
                if (argv[j][0] == '-')
                    continue;

                char fullpath_j[MYMAX_PATH] = { 0 };
                realpath(argv[j], fullpath_j);
                if (fullpath_j[k] != ch)
                {
                    strncpy(root_dir, fullpath_j, k);
                    root_dir[k] = '\0';
                    dirname(root_dir);
                    goto exit;
                }
            }
            if (ch == '\0')
                break;
        }
    }
exit:;
}

static int create_multiple_paths(const char* root, const char* outdir)
{
    /*
       This function creates all dirs (folder1, forder2 ..) after root
       root   : C:/folder
       outdir : C:/folder/folder1/folder2 ...
    */
#if !defined __EMSCRIPTEN__
    const char* p = outdir + strlen(root) + 1;
    for (;;)
    {
        if (*p != '\0' && *p != '/' && *p != '\\')
        {
            p++;
            continue;
        }

        char temp[MYMAX_PATH] = { 0 };
        strncpy(temp, outdir, p - outdir);

        int er = mkdir(temp, 0777);
        if (er != 0)
        {
            er = errno;
            if (er != EEXIST)
            {
                printf("error creating output folder '%s' - %s\n", temp, get_posix_error_message(er));
                return er;
            }
        }
        if (*p == '\0')
            break;
        p++;
    }
    return 0;
#else
    return -1;
#endif
}

int compile(int argc, const char** argv, struct report* report)
{
    struct options options = { 0 };
    if (fill_options(&options, argc, argv) != 0)
    {
        return 1;
    }
    
    
    char executable_path[MAX_PATH - sizeof(CAKE_CFG_FNAME)] = { 0 };
    get_self_path(executable_path, sizeof(executable_path));
    dirname(executable_path);
    char cakeconfig_path[MAX_PATH] = { 0 };
    snprintf(cakeconfig_path, sizeof cakeconfig_path, "%s" CAKE_CFG_FNAME, executable_path);

    if (options.auto_config) //-autoconfig
    {
        report->ignore_this_report = true;
        return generate_config_file(cakeconfig_path);
    }

    report->test_mode = options.test_mode;

    clock_t begin_clock = clock();
    int no_files = 0;

    char root_dir[MYMAX_PATH] = { 0 };

    if (!options.no_output)
    {
        longest_common_path(argc, argv, root_dir);
    }

    const int root_dir_len = strlen(root_dir);

    /*second loop to compile each file*/
    for (int i = 1; i < argc; i++)
    {
        if (strcmp(argv[i], "-o") == 0 ||
            strcmp(argv[i], "-sarif-path") == 0)
        {
            //consumes next
            i++;
            continue;
        }

        if (argv[i][0] == '-')
            continue;

        no_files++;
        char output_file[MYMAX_PATH] = { 0 };

        if (!options.no_output)
        {
            if (no_files == 1 && options.output[0] != '\0')
            {
                /*
                   -o outputname
                   works when we compile just one file
                */
                strcat(output_file, options.output);
            }
            else
            {
                char fullpath[MYMAX_PATH] = { 0 };
                realpath(argv[i], fullpath);

                strcpy(output_file, root_dir);
                strcat(output_file, "/out");

                strcat(output_file, fullpath + root_dir_len);

                char outdir[MYMAX_PATH] = { 0 };
                strcpy(outdir, output_file);
                dirname(outdir);
                if (create_multiple_paths(root_dir, outdir) != 0)
                {
                    return 1;
                }
            }
        }

        char fullpath[MYMAX_PATH] = { 0 };
        realpath(argv[i], fullpath);

        const char* file_extension = basename(fullpath);

        if (file_extension[0] == '*')
        {
            no_files--; //does not count *.c 
            no_files += compile_many_files(fullpath, &options, output_file, argc, argv, report);
        }
        else
        {
            struct report report_local = { 0 };
            compile_one_file(fullpath, &options, output_file, argc, argv, &report_local);

            report->fatal_error_expected = report_local.fatal_error_expected;
            report->error_count += report_local.error_count;
            report->warnings_count += report_local.warnings_count;
            report->info_count += report_local.info_count;
            report->test_succeeded += report_local.test_succeeded;
            report->test_failed += report_local.test_failed;
        }
    }

    clock_t end_clock = clock();
    double cpu_time_used = ((double)(end_clock - begin_clock)) / CLOCKS_PER_SEC;
    report->no_files = no_files;
    report->cpu_time_used_sec = cpu_time_used;
    return 0;
}

struct ast get_ast(struct options* options,
    const char* filename,
    const char* source,
    struct report* report)
{
    struct ast ast = { 0 };
    struct tokenizer_ctx tctx = { 0 };

    struct token_list list = tokenizer(&tctx, source, filename, 0, TK_FLAG_NONE);

    struct preprocessor_ctx prectx = { 0 };

    _Opt struct parser_ctx ctx = { 0 };
    ctx.p_report = report;

    try
    {
        prectx.options = *options;
        prectx.macros.capacity = 5000;

        add_standard_macros(&prectx);

        ast.token_list = preprocessor(&prectx, &list, 0);
        if (prectx.n_errors != 0)
            throw;

        ctx.options = *options;

        bool berror = false;
        ast.declaration_list = parse(&ctx, &ast.token_list, &berror);
        if (berror)
            throw;
    }
    catch
    {
    }
    parser_ctx_destroy(&ctx);
    token_list_destroy(&list);
    preprocessor_ctx_destroy(&prectx);

    return ast;
}

/*
* given a string s, produce argv by modifying the input string
* return argc
*/
int strtoargv(char* s, int n, const char* argv[/*n*/])
{
    int argvc = 0;
    char* p = s;
    while (*p)
    {
        while (*p == ' ')
            p++;
        if (*p == 0)
            break;
        argv[argvc] = p;
        argvc++;
        while (*p != ' ' && *p != '\0')
            p++;
        if (*p == 0)
            break;
        *p = 0;
        p++;
        if (argvc >= n)
            break; /*nao tem mais lugares*/
    }
    return argvc;
}

const char* _Owner _Opt compile_source(const char* pszoptions, const char* content, struct report* report)
{
    const char* argv[100] = { 0 };
    char string[200] = { 0 };
    snprintf(string, sizeof string, "exepath %s", pszoptions);

    const int argc = strtoargv(string, 10, argv);

    const char* _Owner _Opt s = NULL;

    struct preprocessor_ctx prectx = { 0 };
    struct ast ast = { 0 };
    struct options options = { .input = LANGUAGE_CAK };


    try
    {
        if (fill_options(&options, argc, argv) != 0)
        {
            throw;
        }

        prectx.options = options;
        add_standard_macros(&prectx);

        if (options.preprocess_only)
        {
            struct tokenizer_ctx tctx = { 0 };
            struct token_list tokens = tokenizer(&tctx, content, "c:/main.c", 0, TK_FLAG_NONE);

            struct token_list token_list = preprocessor(&prectx, &tokens, 0);
            if (prectx.n_errors == 0)
            {
                s = print_preprocessed_to_string2(token_list.head);
            }

            token_list_destroy(&tokens);
            token_list_destroy(&token_list);
        }
        else
        {
            ast = get_ast(&options, "c:/main.c", content, report);
            if (report->error_count > 0)
                throw;


            struct osstream ss = { 0 };
            struct d_visit_ctx ctx2 = { 0 };
            ctx2.ast = ast;
            ctx2.options = options;
            d_visit(&ctx2, &ss);
            s = ss.c_str; //MOVED                
            //ss.c_str = NULL;
            //ss_close(&ss);
            d_visit_ctx_destroy(&ctx2);


        }
    }
    catch
    {
    }

    preprocessor_ctx_destroy(&prectx);

    ast_destroy(&ast);

    return s;
}

char* _Owner _Opt CompileText(const char* pszoptions, const char* content)
{
    /*
      This function is called by the web playground
    */
    printf(WHITE "Cake " CAKE_VERSION RESET "\n");
    printf(WHITE "cake %s main.c\n", pszoptions);
    struct report report = { 0 };
    return (char* _Owner _Opt)compile_source(pszoptions, content, &report);
}

void ast_destroy(_Dtor struct ast* ast)
{
    token_list_destroy(&ast->token_list);
    declaration_list_destroy(&ast->declaration_list);
}

static bool is_all_upper(const char* text)
{
    const char* p = text;
    while (*p)
    {
        if (*p != toupper(*p))
        {
            return false;
        }
        p++;
    }
    return true;
}

static bool is_snake_case(const char* text)
{
    if (!(*text >= 'a' && *text <= 'z'))
    {
        return false;
    }

    while (*text)
    {
        if ((*text >= 'a' && *text <= 'z') ||
            *text == '_' ||
            (*text >= '0' && *text <= '9'))

        {
            // ok
        }
        else
            return false;
        text++;
    }

    return true;
}

static bool is_camel_case(const char* text)
{
    if (!(*text >= 'a' && *text <= 'z'))
    {
        return false;
    }

    while (*text)
    {
        if ((*text >= 'a' && *text <= 'z') ||
            (*text >= 'A' && *text <= 'Z') ||
            (*text >= '0' && *text <= '9'))
        {
            // ok
        }
        else
            return false;
        text++;
    }

    return true;
}

static bool is_pascal_case(const char* text)
{
    if (!(text[0] >= 'A' && text[0] <= 'Z'))
    {
        /*first letter uppepr case*/
        return false;
    }

    while (*text)
    {
        if ((*text >= 'a' && *text <= 'z') ||
            (*text >= 'A' && *text <= 'Z') ||
            (*text >= '0' && *text <= '9'))
        {
            // ok
        }
        else
            return false;
        text++;
    }

    return true;
}

/*
 * This naming conventions are not ready yet...
 * but not dificult to implement.maybe options to choose style
 */
void naming_convention_struct_tag(struct parser_ctx* ctx, struct token* token)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (ctx->options.style == STYLE_CAKE)
    {
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic(W_STYLE, ctx, token, NULL, "use snake_case for struct/union tags");
        }
    }
    else if (ctx->options.style == STYLE_MICROSOFT)
    {
        if (!is_pascal_case(token->lexeme))
        {
            compiler_diagnostic(W_STYLE, ctx, token, NULL, "use camelCase for struct/union tags");
        }
    }
}

void naming_convention_enum_tag(struct parser_ctx* ctx, struct token* token)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (ctx->options.style == STYLE_CAKE)
    {
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic(W_STYLE, ctx, token, NULL, "use snake_case for enum tags");
        }
    }
    else if (ctx->options.style == STYLE_MICROSOFT)
    {
        if (!is_pascal_case(token->lexeme))
        {
            compiler_diagnostic(W_STYLE, ctx, token, NULL, "use PascalCase for enum tags");
        }
    }
}

void naming_convention_function(struct parser_ctx* ctx, struct token* token)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (ctx->options.style == STYLE_CAKE)
    {
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic(W_STYLE, ctx, token, NULL, "use snake_case for functions");
        }
    }
    else if (ctx->options.style == STYLE_MICROSOFT)
    {
        if (!is_pascal_case(token->lexeme))
        {
            compiler_diagnostic(W_STYLE, ctx, token, NULL, "use PascalCase for functions");
        }
    }
}

void naming_convention_global_var(struct parser_ctx* ctx, struct token* token, struct type* type, enum storage_class_specifier_flags storage)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (!type_is_function_or_function_pointer(type))
    {
        if (storage & STORAGE_SPECIFIER_STATIC)
        {
            if (type_is_const(type))
            {
                //all upper
            }
            else
            {
                if (token->lexeme[0] != 's' || token->lexeme[1] != '_')
                {
                    compiler_diagnostic(W_STYLE, ctx, token, NULL, "use prefix s_ for static global variables");
                }
            }
        }
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic(W_STYLE, ctx, token, NULL, "use snake_case global variables");
        }
    }
}

void naming_convention_local_var(struct parser_ctx* ctx, struct token* token, struct type* type)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (ctx->options.style == STYLE_CAKE)
    {
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic(W_STYLE, ctx, token, NULL, "use snake_case for local variables");
        }
    }
    else if (ctx->options.style == STYLE_MICROSOFT)
    {
        if (!is_camel_case(token->lexeme))
        {
            compiler_diagnostic(W_STYLE, ctx, token, NULL, "use camelCase for local variables");
        }
    }
}

void naming_convention_enumerator(struct parser_ctx* ctx, struct token* token)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (!is_all_upper(token->lexeme))
    {
        compiler_diagnostic(W_STYLE, ctx, token, NULL, "use UPPERCASE for enumerators");
    }
}

void naming_convention_struct_member(struct parser_ctx* ctx, struct token* token, struct type* type)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (!is_snake_case(token->lexeme))
    {
        compiler_diagnostic(W_STYLE, ctx, token, NULL, "use snake_case for struct members");
    }
}

void naming_convention_parameter(struct parser_ctx* ctx, struct token* token, struct type* type)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (!is_snake_case(token->lexeme))
    {
        compiler_diagnostic(W_STYLE, ctx, token, NULL, "use snake_case for arguments");
    }
}

static struct object* _Opt find_first_subobject_old(struct type* p_type_not_used, struct object* p_object, struct type* p_type_out, bool* sub_object_of_union)
{
    p_object = (struct object* _Opt) object_get_referenced(p_object);

    if (p_object->members == NULL)
    {
        *sub_object_of_union = false;

        struct type t = type_dup(&p_object->type);
        type_swap(&t, p_type_out);
        type_destroy(&t);

        return p_object; //tODO
    }

    *sub_object_of_union = type_is_union(&p_object->type);
    struct type t = type_dup(&p_object->members->type);
    type_swap(&t, p_type_out);
    type_destroy(&t);

    return p_object->members; //tODO
}

static struct object* _Opt find_first_subobject(struct type* p_type_not_used, struct object* p_object, struct type* p_type_out, bool* sub_object_of_union)
{
    return find_first_subobject_old(p_type_not_used, p_object, p_type_out, sub_object_of_union);
}

static struct object* _Opt find_last_suboject_of_suboject_old(struct type* p_type_not_used, struct object* p_object, struct type* p_type_out)
{
    p_object = (struct object* _Opt) object_get_referenced(p_object);

    if (p_object->members == NULL)
    {
        struct type t = type_dup(&p_object->type);
        type_swap(&t, p_type_out);
        type_destroy(&t);
        return p_object; //tODO
    }

    struct object* _Opt it = p_object->members;

    while (it)
    {
        if (it->next == NULL)
            return find_last_suboject_of_suboject_old(p_type_not_used, it, p_type_out);

        it = it->next;
    }

    struct type t = type_dup(&p_object->type);
    type_swap(&t, p_type_out);
    type_destroy(&t);


    return p_object;
}

static struct object* _Opt find_last_suboject_of_suboject(struct type* p_type_not_used, struct object* p_object, struct type* p_type_out)
{
    return find_last_suboject_of_suboject_old(p_type_not_used, p_object, p_type_out);
}


static struct object* _Opt find_next_subobject_old(struct type* p_top_object_not_used,
    struct object* current_object,
    struct object* it,
    struct type* p_type_out,
    bool* sub_object_of_union)
{
    type_clear(p_type_out);

    if (it == NULL)
        return NULL;


    if (it->members)
    {
        *sub_object_of_union = type_is_union(&it->type);

        it = it->members;

        struct type t = type_dup(&it->type);
        type_swap(&t, p_type_out);
        type_destroy(&t);

        return it;
    }

    for (;;)
    {
        if (it == NULL)
            break;

        struct object* next = it->next;

        if (next != NULL)
        {
            if (it->parent)
                *sub_object_of_union = type_is_union(&it->parent->type);
            it = next;
            break;
        }

        it = it->parent;
    }

    if (it != NULL)
    {
        struct type t = type_dup(&it->type);
        type_swap(&t, p_type_out);
        type_destroy(&t);
    }

    return it;
}


static struct object* _Opt find_next_subobject(struct type* p_top_object_not_used,
    struct object* current_object,
    struct object* it,
    struct type* p_type_out,
    bool* sub_object_of_union)
{
    return find_next_subobject_old(p_top_object_not_used,
    current_object,
    it,
    p_type_out,
    sub_object_of_union);
}
struct find_object_result
{
    struct object* _Opt object;
    struct type type;
};

static bool find_next_subobject_core(const struct type* p_type, struct object* obj, struct object* subobj, struct find_object_result* result)
{
    try
    {
        if (type_is_scalar(p_type))
        {
            if (result->object != NULL)
            {
                result->object = obj;
                result->type = type_dup(p_type);
                return true;
            }

        }

        if (subobj == obj)
        {
            result->object = obj;
            return false;
        }

        if (type_is_array(p_type))
        {
            struct type item_type = get_array_item_type(p_type);
            struct object* _Opt it = obj->members;
            for (; it; it = it->next)
            {
                if (find_next_subobject_core(&item_type, it, subobj, result))
                {
                    type_destroy(&item_type);
                    return true;
                }
            }
            type_destroy(&item_type);
            return false;
        }

        if (p_type->struct_or_union_specifier)
        {
            struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
                get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

            if (p_struct_or_union_specifier == NULL)
            {
                //incomplete
                throw;
            }


            if (subobj == obj)
            {
                result->object = obj;
                //continua para achar o proximo
            }

            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;

            struct object* _Opt member_object = obj->members;

            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (find_next_subobject_core(&p_member_declarator->declarator->type, member_object, subobj, result))
                            {
                                return true;
                            }

                            member_object = member_object->next;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else if (p_member_declaration->specifier_qualifier_list != NULL)
                {
                    if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;


                        if (find_next_subobject_core(&t, member_object, subobj, result))
                        {
                            return true;
                        }

                        type_destroy(&t);
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
        }
    }
    catch
    {
    }
    return false;
}

static struct object* _Opt find_designated_subobject(struct parser_ctx* ctx,
    struct type* p_current_object_type,
    struct object* current_object,
    struct designator* p_designator,
    bool is_constant,
    struct type* p_type_out2,
    bool not_error)
{
    try
    {
        if (type_is_struct_or_union(p_current_object_type))
        {
            assert(p_current_object_type->struct_or_union_specifier);

            struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
                get_complete_struct_or_union_specifier(p_current_object_type->struct_or_union_specifier);

            if (p_struct_or_union_specifier == NULL)
            {
                throw;
            }

            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;

            struct member_declarator* _Opt p_member_declarator = NULL;

            const char* name = p_designator->token->lexeme;
            struct object* _Opt p_member_object = current_object->members;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    p_member_declarator = p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_member_declarator->declarator->name_opt &&
                                strcmp(p_member_declarator->declarator->name_opt->lexeme, name) == 0)
                            {
                                if (p_designator->next != NULL)
                                    return find_designated_subobject(ctx, &p_member_declarator->declarator->type, p_member_object, p_designator->next, is_constant, p_type_out2, false);
                                else
                                {
                                    struct type t = type_dup(&p_member_declarator->declarator->type);
                                    type_swap(&t, p_type_out2);
                                    type_destroy(&t);

                                    return p_member_object;
                                }
                            }
                        }
                        p_member_object = p_member_object->next;
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else if (p_member_declaration->specifier_qualifier_list)
                {
                    if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct struct_or_union_specifier* _Opt p_complete =
                            get_complete_struct_or_union_specifier(p_member_declaration->specifier_qualifier_list->struct_or_union_specifier);

                        if (p_complete)
                        {
                            struct type t = { 0 };
                            t.category = TYPE_CATEGORY_ITSELF;
                            t.struct_or_union_specifier = p_complete;
                            t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                            struct object* _Opt p = find_designated_subobject(ctx,
                                                                         &t,
                                                                         p_member_object,
                                                                         p_designator,
                                                                         is_constant,
                                                                         p_type_out2,
                                                                         true);
                            if (p)
                            {
                                type_destroy(&t);
                                return p;
                            }
                            p_member_object = p_member_object->next;
                            type_destroy(&t);
                        }
                    }
                }
                else
                {
                    //static_assert pragma...
                }
                p_member_declaration = p_member_declaration->next;
            }

            if (!not_error)
            {
                compiler_diagnostic(
                                              C_ERROR_STRUCT_MEMBER_NOT_FOUND,
                                              ctx,
                                              p_designator->token,
                                              NULL,
                                              "member '%s' not found in '%s'", name, p_struct_or_union_specifier->tag_name);
            }
            return NULL;
        }
        else if (type_is_array(p_current_object_type))
        {
            const bool compute_array_size = p_current_object_type->array_num_elements_expression == NULL;
            long long index = -1;
            long long max_index = -1;
            struct type array_item_type = get_array_item_type(p_current_object_type);

            struct object* _Opt member_obj = current_object->members;

            if (p_designator->constant_expression_opt)
            {
                index = object_to_signed_long_long(&p_designator->constant_expression_opt->object);

                if (index > max_index)
                {
                    max_index = index;
                    if (compute_array_size)
                    {
                        member_obj = object_extend_array_to_index(&array_item_type, current_object, max_index, is_constant);
                    }
                }

                member_obj = object_get_member(current_object, index);
                if (member_obj == NULL)
                {
                    if (index < 0)
                    {
                        compiler_diagnostic(
                                                  C_ERROR_STRUCT_MEMBER_NOT_FOUND,
                                                  ctx,
                                                  p_designator->constant_expression_opt->first_token,
                                                  NULL,
                                                  "array designator value '%d' is negative", index);
                    }
                    else if (index > p_current_object_type->num_of_elements)
                    {
                        compiler_diagnostic(
                                                  C_ERROR_STRUCT_MEMBER_NOT_FOUND,
                                                  ctx,
                                                  p_designator->constant_expression_opt->first_token,
                                                  NULL,
                                                  "array index '%d' in initializer exceeds array bounds", index);
                    }

                    type_destroy(&array_item_type);
                    return NULL;
                }


                if (p_designator->next != NULL)
                {
                    struct object* _Opt p =
                        find_designated_subobject(ctx, &array_item_type, member_obj, p_designator->next, is_constant, p_type_out2, false);

                    type_destroy(&array_item_type);
                    return p;
                }
                else
                {
                    type_swap(p_type_out2, &array_item_type);
                    type_destroy(&array_item_type);
                }

                return member_obj;
            }
            else
            {
                //oops
            }
            type_destroy(&array_item_type);
        }
    }
    catch
    {

    }
    return NULL;
}

int initializer_init_new(struct parser_ctx* ctx,
                        struct type* p_type, /*in (in/out for arrays [])*/
                        struct object* object, /*in (in/out for arrays [])*/
                        struct initializer* initializer, /*rtocar para initializer item??*/
                        bool is_constant,
                        bool requires_constant_initialization);

static struct initializer_list_item* _Opt find_innner_initializer_list_item(struct braced_initializer* braced_initializer)
{
    assert(braced_initializer->initializer_list);

    struct initializer_list_item* _Opt p_initializer_list_item = braced_initializer->initializer_list->head;

    while (p_initializer_list_item->initializer->braced_initializer)
    {
        //int i = {{1}};
        p_initializer_list_item = p_initializer_list_item->initializer->braced_initializer->initializer_list->head;

        if (p_initializer_list_item == NULL)
        {
            assert(false);
            return NULL;
        }

        if (p_initializer_list_item->next == NULL)
            return p_initializer_list_item;

        p_initializer_list_item = p_initializer_list_item->next;
    }

    return p_initializer_list_item;
}

NODISCARD
static int braced_initializer_new(struct parser_ctx* ctx,
                                  struct type* p_current_object_type,
                                  struct object* current_object,
                                  struct braced_initializer* braced_initializer,
                                  bool is_constant,
                                  bool requires_constant_initialization)
{
    try
    {
        if (braced_initializer->initializer_list == NULL)
        {
            object_default_initialization(current_object, is_constant);
            return 0;
        }

        if (!type_is_union(p_current_object_type))
        {
            object_default_initialization(current_object, is_constant);
        }

        if (type_is_scalar(p_current_object_type))
        {
            struct initializer_list_item* _Opt p_initializer_list_item =
                find_innner_initializer_list_item(braced_initializer);

            if (p_initializer_list_item == NULL)
            {
                return 0;
            }

            if (p_initializer_list_item->initializer->assignment_expression != NULL)
            {
                if (object_set(ctx,
                    current_object, p_initializer_list_item->initializer->assignment_expression,
                    &p_initializer_list_item->initializer->assignment_expression->object,
                    is_constant,
                    requires_constant_initialization) != 0)
                {
                    throw;
                }
            }

            p_initializer_list_item = p_initializer_list_item->next;

            if (p_initializer_list_item != NULL)
            {
                compiler_diagnostic(W_TO_MANY_INITIALIZERS,
                                            ctx,
                                            p_initializer_list_item->initializer->first_token,
                                            NULL,
                                            "warning: excess elements in initializer");
            }
            return 0;
        }


        //TODO Array char

        struct object* const _Opt parent_copy = current_object->parent;
        current_object->parent = NULL; //to be only here
        struct initializer_list_item* _Opt p_initializer_list_item = braced_initializer->initializer_list->head;
        int array_to_expand_index = -1;
        int array_to_expand_max_index = -1;
        bool compute_array_size = false;
        struct type array_item_type = { 0 };
        if (type_is_array(p_current_object_type))
        {
            array_item_type = get_array_item_type(p_current_object_type);
            compute_array_size = p_current_object_type->array_num_elements_expression == NULL;
            if (type_is_char(&array_item_type))
            {
                struct initializer_list_item* _Opt p_initializer_list_item2 = find_innner_initializer_list_item(braced_initializer);
                if (p_initializer_list_item2 == NULL)
                {
                    type_destroy(&array_item_type);
                    return 0;
                }
                if (p_initializer_list_item2->initializer->assignment_expression != NULL)
                {
                    if (p_initializer_list_item2->initializer->assignment_expression->expression_type == PRIMARY_EXPRESSION_STRING_LITERAL)
                    {
                        size_t num_of_elements =
                            p_initializer_list_item2->initializer->assignment_expression->type.num_of_elements;

                        if (compute_array_size)
                        {
                            object_extend_array_to_index(&array_item_type, current_object, num_of_elements - 1, is_constant);
                        }

                        if (object_set(ctx,
                            current_object,
                            p_initializer_list_item2->initializer->assignment_expression,
                            &p_initializer_list_item2->initializer->assignment_expression->object,
                            is_constant,
                            requires_constant_initialization) != 0)
                        {
                            type_destroy(&array_item_type);
                            throw;
                        }
                        //current_object->type2.num_of_elements = num_of_elements;
                        p_current_object_type->num_of_elements = num_of_elements;

                        //printf("\n");
                        //object_print_to_debug(current_object);
                        type_destroy(&array_item_type);
                        return 0;
                    }
                }
            }
        }

        struct object* _Opt p_subobject = NULL;

        for (;;)
        {
            bool is_subobject_of_union = false;
            struct type subobject_type = { 0 };

            if (p_initializer_list_item == NULL)
            {
                break;
            }

            if (p_initializer_list_item->designation)
            {
                if (compute_array_size)
                {
                    array_to_expand_index = object_to_signed_long_long(&p_initializer_list_item->designation->designator_list->head->constant_expression_opt->object);

                    if (array_to_expand_index > array_to_expand_max_index)
                        array_to_expand_max_index = array_to_expand_index;

                    object_extend_array_to_index(&array_item_type, current_object, array_to_expand_max_index, is_constant);
                }
                is_subobject_of_union = type_is_union(&subobject_type);
                p_subobject = find_designated_subobject(ctx, p_current_object_type, current_object, p_initializer_list_item->designation->designator_list->head, is_constant, &subobject_type, false);
                if (p_subobject == NULL)
                {
                    // already have the error, need not say that it was not consumed
                    p_initializer_list_item = p_initializer_list_item->next;
                    type_destroy(&subobject_type);
                    break;
                }
            }
            else
            {
                if (compute_array_size)
                {

                    struct object* _Opt po = find_next_subobject(p_current_object_type, current_object, p_subobject, &subobject_type, &is_subobject_of_union);
                    if (po == NULL)
                    {
                        array_to_expand_index++;
                        if (array_to_expand_index > array_to_expand_max_index)
                            array_to_expand_max_index = array_to_expand_index;

                        object_extend_array_to_index(&array_item_type, current_object, array_to_expand_max_index, is_constant);
                    }
                }

                if (p_subobject == NULL)
                {

                    p_subobject = find_first_subobject(p_current_object_type, current_object, &subobject_type, &is_subobject_of_union);
                }
                else
                {
                    p_subobject = find_next_subobject(p_current_object_type, current_object, p_subobject, &subobject_type, &is_subobject_of_union);
                }
            }

            if (p_subobject == NULL)
            {
                type_destroy(&subobject_type);
                break;
            }



            if (p_initializer_list_item->initializer->braced_initializer)
            {
                if (braced_initializer_new(ctx,
                    &subobject_type,
                    p_subobject,
                    p_initializer_list_item->initializer->braced_initializer,
                    is_constant,
                    requires_constant_initialization) != 0)
                {
                    type_destroy(&array_item_type);
                    type_destroy(&subobject_type);
                    throw;
                }

                struct type t = { 0 };

                is_subobject_of_union = type_is_union(&subobject_type);
                p_subobject = find_last_suboject_of_suboject(&subobject_type, p_subobject, &t);
                type_swap(&t, &subobject_type);
                type_destroy(&t);
            }
            else if (p_initializer_list_item->initializer->assignment_expression)
            {
                bool entire_object_initialized = false;

                if (type_is_array_of_char(&subobject_type) &&
                    p_initializer_list_item->initializer->assignment_expression->expression_type == PRIMARY_EXPRESSION_STRING_LITERAL)
                {
                    /*
                    struct X { int i; char text[4]; };
                    constexpr struct X x = {1, "abc"};
                    */
                    entire_object_initialized = true;
                }
                else if (type_is_array(&subobject_type))
                {
                    while (type_is_array(&subobject_type))
                    {
                        /*
                          struct X { int i[2]; };
                          int a[2]={};
                          struct  X b = { a };    //error
                        */
                        //sub_object_of_union = false;
                        p_subobject = find_next_subobject(p_current_object_type, current_object, p_subobject, &subobject_type, &is_subobject_of_union);
                    }
                }
                else if (type_is_struct_or_union(&subobject_type))
                {
                    if (type_is_struct_or_union(&p_initializer_list_item->initializer->assignment_expression->type))
                    {
                        //mesmo tipo
                        entire_object_initialized = true;
                    }
                    else
                    {
                        p_subobject = find_next_subobject(p_current_object_type, current_object, p_subobject, &subobject_type, &is_subobject_of_union);
                    }
                }

                if (object_set(ctx,
                    p_subobject,
                    p_initializer_list_item->initializer->assignment_expression,
                    &p_initializer_list_item->initializer->assignment_expression->object,
                    is_constant,
                    requires_constant_initialization) != 0)
                {
                    type_destroy(&array_item_type);
                    type_destroy(&subobject_type);
                    throw;
                }


                if (is_subobject_of_union)
                {
                    assert(p_subobject);
                    assert(p_subobject->parent);
                    struct type t = { 0 };
                    is_subobject_of_union = true;
                    p_subobject = find_last_suboject_of_suboject(&p_subobject->parent->type,
                                                                 p_subobject->parent,
                                                                 &t);
                    type_swap(&t, &subobject_type);
                    type_destroy(&t);
                    if (p_subobject)
                    {
                        type_destroy(&subobject_type);
                        subobject_type = type_dup(&p_subobject->type);
                    }

                }
                else if (entire_object_initialized)
                {
                    assert(p_subobject);

                    struct type t = { 0 };
                    is_subobject_of_union = type_is_union(p_current_object_type);
                    p_subobject = find_last_suboject_of_suboject(&subobject_type, p_subobject, &t);
                    type_swap(&t, &subobject_type);
                    type_destroy(&t);
                    if (p_subobject)
                    {
                        type_destroy(&subobject_type);
                        subobject_type = type_dup(&p_subobject->type);
                    }
                }
            }
            p_initializer_list_item = p_initializer_list_item->next;
            type_destroy(&subobject_type);
        }

        if (p_initializer_list_item != NULL)
        {
            compiler_diagnostic(W_TO_MANY_INITIALIZERS,
                                        ctx,
                                        p_initializer_list_item->initializer->first_token,
                                        NULL,
                                        "warning: excess elements in initializer");

        }
        if (compute_array_size)
        {
            current_object->type.num_of_elements = array_to_expand_max_index + 1;
            p_current_object_type->num_of_elements = array_to_expand_max_index + 1;
        }

        current_object->parent = parent_copy; //restore
        type_destroy(&array_item_type);
    }
    catch
    {
        return 1;
    }

    return 0;
}

int initializer_init_new(struct parser_ctx* ctx,
                        struct type* p_type,
                        struct object* object, /*in (in/out for arrays [])*/
                        struct initializer* initializer, /*rtocar para initializer item??*/
                        bool is_constant,
                        bool requires_constant_initialization)
{
    try
    {
        if (initializer->assignment_expression != NULL)
        {
            //types must be compatible
            if (object_set(ctx,
                object,
                initializer->assignment_expression,
                &initializer->assignment_expression->object,
                is_constant,
                requires_constant_initialization) != 0)
            {
                throw;
            }
        }
        else if (initializer->braced_initializer)
        {
            if (braced_initializer_new(ctx,
                p_type,
                object,
                initializer->braced_initializer,
                is_constant,
                requires_constant_initialization) != 0)
            {
                throw;
            }
        }
    }
    catch
    {
        return 1;
    }

    return 0;
}

/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable




#include <stdint.h>

/*
              NULL
                |
            [function] (NULL <- child0 <- last_child)
                |
              [try]  (NULL <- child0 <- last_child)
                |
tail_block-> [while] (NULL <- child0 <- last_child)

*/

struct defer_defer_scope
{
    //things must called at end of scope
    struct declarator* _Opt declarator; // declarator
    struct defer_statement* _Opt defer_statement; // defer

    //statements for controlling where jump like break, throw stop.

    struct try_statement* _Opt p_try_statement; //try
    struct selection_statement* _Opt p_selection_statement; //if switch
    struct iteration_statement* _Opt p_iteration_statement; //for do while
    struct statement* _Opt p_statement;//
    struct compound_statement* _Opt p_compound_statement;
    struct compound_statement* _Opt p_function_body;
    struct secondary_block* _Opt p_secondary_block;
    struct primary_block* _Opt p_primary_block;

    struct defer_defer_scope* _Owner _Opt last_child; /**/
    struct defer_defer_scope* _Owner _Opt previous;
};

void defer_visit_declaration(struct defer_visit_ctx* ctx, struct declaration* p_declaration);
static void defer_visit_declarator(struct defer_visit_ctx* ctx, struct declarator* p_declarator);
static void defer_visit_init_declarator_list(struct defer_visit_ctx* ctx, struct init_declarator_list* p_init_declarator_list);;
static void defer_visit_secondary_block(struct defer_visit_ctx* ctx, struct secondary_block* p_secondary_block);
static bool defer_find_label_unlabeled_statement(struct defer_visit_ctx* ctx, struct unlabeled_statement* p_unlabeled_statement, const char* label);
static void defer_visit_statement(struct defer_visit_ctx* ctx, struct statement* p_statement);

static void defer_visit_block_item(struct defer_visit_ctx* ctx, struct block_item* p_block_item);
static void defer_visit_compound_statement(struct defer_visit_ctx* ctx, struct compound_statement* p_compound_statement);
static bool defer_find_label_statement(struct defer_visit_ctx* ctx, struct statement* statement, const char* label);

struct defer_visit_objects {
    struct defer_defer_scope* current_block;
    struct defer_defer_scope* next_child;
};

static struct defer_defer_scope* _Opt defer_visit_ctx_push_tail_block(struct defer_visit_ctx* ctx)
{
    struct defer_defer_scope* _Owner _Opt p_block = calloc(1, sizeof * p_block);
    if (p_block)
    {
        p_block->previous = ctx->tail_block;
        ctx->tail_block = p_block;
    }
    else
    {
        //ops
    }
    return ctx->tail_block;
}

static struct defer_defer_scope* _Opt defer_visit_ctx_push_child(struct defer_visit_ctx* ctx)
{
    if (ctx->tail_block == NULL)
        return NULL;

    struct defer_defer_scope* _Owner _Opt child = calloc(1, sizeof * child);
    if (child)
    {
        child->previous = ctx->tail_block->last_child;
        ctx->tail_block->last_child = child;
    }
    else
    {
        //ops
    }
    return ctx->tail_block->last_child;
}

static void defer_defer_scope_delete_one(struct defer_defer_scope* _Owner p)
{
    struct defer_defer_scope* _Owner p_block = p;
    struct defer_defer_scope* _Owner _Opt child = p_block->last_child;

    while (child != NULL)
    {
        struct defer_defer_scope* _Owner _Opt previous = child->previous;
        child->previous = NULL;
        defer_defer_scope_delete_one(child);
        child = previous;
    }
    assert(p_block->previous == NULL);
    free(p_block);
}

static void defer_visit_ctx_pop_tail_block(struct defer_visit_ctx* ctx)
{
    if (ctx->tail_block)
    {
        struct defer_defer_scope* _Owner _Opt previous = ctx->tail_block->previous;
        ctx->tail_block->previous = NULL;
        defer_defer_scope_delete_one(ctx->tail_block);
        ctx->tail_block = previous;
    }
}

static void defer_exit_block_visit(struct defer_visit_ctx* ctx,
    struct defer_defer_scope* deferblock,
    struct token* position_token,
    struct defer_list* p_defer_list)
{
    try
    {
        struct defer_defer_scope* _Opt deferchild = deferblock->last_child;
        while (deferchild != NULL)
        {
            if (deferchild->defer_statement)
            {
                struct defer_list_item* _Opt _Owner p_item = calloc(1, sizeof * p_item);
                if (p_item == NULL)
                    throw;

                p_item->defer_statement = deferchild->defer_statement;
                defer_list_add(p_defer_list, p_item);

                defer_visit_secondary_block(ctx, deferchild->defer_statement->secondary_block);
            }
            else if (deferchild->declarator)
            {
                struct defer_list_item* _Opt _Owner p_item = calloc(1, sizeof * p_item);
                if (p_item == NULL)
                    throw;

                p_item->declarator = deferchild->declarator;
                defer_list_add(p_defer_list, p_item);
                //const char* name = p_declarator->name_opt ? p_declarator->name_opt->lexeme : "?";
            }
            deferchild = deferchild->previous;
        }
    }
    catch
    {
    }
}

static void defer_check_all_defer_until_try(struct defer_visit_ctx* ctx, struct defer_defer_scope* deferblock,
    struct token* position_token,
    struct defer_list* p_defer_list)
{
    struct defer_defer_scope* _Opt p_defer = deferblock;
    while (p_defer != NULL)
    {
        defer_exit_block_visit(ctx, p_defer, position_token, p_defer_list);

        if (p_defer->p_try_statement)
        {
            break;
        }

        p_defer = p_defer->previous;
    }
}

static bool defer_find_label_block_item_list(struct defer_visit_ctx* ctx, struct block_item_list* p_block_item, const char* label)
{
    struct block_item* _Opt block_item = p_block_item->head;
    while (block_item)
    {
        if (block_item->label &&
            block_item->label->p_identifier_opt &&
            strcmp(block_item->label->p_identifier_opt->lexeme, label) == 0)
        {
            return true;
        }
        else if (block_item->unlabeled_statement)
        {
            if (defer_find_label_unlabeled_statement(ctx, block_item->unlabeled_statement, label))
            {
                return true;
            }
        }

        block_item = block_item->next;
    }

    return false;
}

static bool defer_find_label_unlabeled_statement(struct defer_visit_ctx* ctx, struct unlabeled_statement* p_unlabeled_statement, const char* label)
{
    if (p_unlabeled_statement->primary_block)
    {
        if (p_unlabeled_statement->primary_block->compound_statement)
        {
            if (defer_find_label_block_item_list(ctx,
                &p_unlabeled_statement->primary_block->compound_statement->block_item_list,
                label))
            {
                return true;
            }
        }
        else if (p_unlabeled_statement->primary_block->selection_statement)
        {
            if (defer_find_label_statement(ctx, p_unlabeled_statement->primary_block->selection_statement->secondary_block->statement, label))
            {
                return true;
            }
            if (p_unlabeled_statement->primary_block->selection_statement->else_secondary_block_opt)
            {
                if (defer_find_label_statement(ctx, p_unlabeled_statement->primary_block->selection_statement->else_secondary_block_opt->statement, label))
                {
                    return true;
                }
            }
        }
        else if (p_unlabeled_statement->primary_block->try_statement)
        {
            if (defer_find_label_statement(ctx, p_unlabeled_statement->primary_block->try_statement->secondary_block->statement, label))
            {
                return true;
            }
            if (p_unlabeled_statement->primary_block->try_statement->catch_secondary_block_opt)
            {
                if (defer_find_label_statement(ctx, p_unlabeled_statement->primary_block->try_statement->catch_secondary_block_opt->statement, label))
                {
                    return true;
                }
            }
        }
        else if (p_unlabeled_statement->primary_block->iteration_statement)
        {
            if (defer_find_label_statement(ctx, p_unlabeled_statement->primary_block->iteration_statement->secondary_block->statement, label))
            {
                return true;
            }
        }
    }
    return false;
}

static bool defer_find_label_statement(struct defer_visit_ctx* ctx, struct statement* statement, const char* label)
{
    if (statement->labeled_statement &&
        statement->labeled_statement->label->p_identifier_opt)
    {
        if (/*statement->labeled_statement->label &&*/
            strcmp(statement->labeled_statement->label->p_identifier_opt->lexeme, label) == 0)
        {
            return true;
        }
    }
    else if (statement->unlabeled_statement)
    {
        if (defer_find_label_unlabeled_statement(ctx, statement->unlabeled_statement, label))
            return true;
    }
    return false;
}

static bool defer_find_label_scope(struct defer_visit_ctx* ctx, struct defer_defer_scope* deferblock, const char* label)
{
    if (deferblock->p_iteration_statement)
    {
        if (defer_find_label_statement(ctx, deferblock->p_iteration_statement->secondary_block->statement, label))
            return true;
    }
    else if (deferblock->p_selection_statement)
    {
        if (defer_find_label_statement(ctx, deferblock->p_selection_statement->secondary_block->statement, label))
            return true;

        if (deferblock->p_selection_statement->else_secondary_block_opt)
        {
            if (defer_find_label_statement(ctx, deferblock->p_selection_statement->else_secondary_block_opt->statement, label))
                return true;
        }
    }
    else if (deferblock->p_try_statement)
    {
        if (defer_find_label_statement(ctx, deferblock->p_try_statement->secondary_block->statement, label))
            return true;

        if (deferblock->p_try_statement->catch_secondary_block_opt)
        {
            if (defer_find_label_statement(ctx, deferblock->p_try_statement->catch_secondary_block_opt->statement, label))
                return true;
        }
    }
    else if (deferblock->p_statement)
    {
        if (defer_find_label_statement(ctx, deferblock->p_statement, label))
            return true;
    }
    else if (deferblock->p_function_body)
    {
        if (defer_find_label_block_item_list(ctx,
            &deferblock->p_function_body->block_item_list,
            label))
        {
            return true;
        }
    }
    else if (deferblock->p_compound_statement)
    {
        if (defer_find_label_block_item_list(ctx,
            &deferblock->p_compound_statement->block_item_list,
            label))
        {
            return true;
        }
    }
    return false;
}

static void defer_check_all_defer_until_label(struct defer_visit_ctx* ctx,
    struct defer_defer_scope* deferblock,
    const char* label,
    struct token* position_token,
    struct defer_list* p_defer_list)
{
    /*
    * We need to know how many scopes we exited until we found the label.
    * To do this, we look in the current scope for where the goto appears.
    * If the label is not directly in this scope or within some internal scope
    * No, we print the defers because we are exiting the scope and going to the scope
    * above. So we repeat this at each scope exit, printing the defer.
    */
    struct defer_defer_scope* _Opt p_defer = deferblock;

    while (p_defer != NULL)
    {
        if (!defer_find_label_scope(ctx, p_defer, label))
        {
            defer_exit_block_visit(ctx, p_defer, position_token, p_defer_list);
        }
        else
        {
            break;
        }
        p_defer = p_defer->previous;
    }
}

static void defer_check_all_defer_until_iter(struct defer_visit_ctx* ctx,
    struct defer_defer_scope* deferblock,
    struct token* position_token,
    struct defer_list* p_defer_list)
{
    struct defer_defer_scope* _Opt p_defer = deferblock;
    while (p_defer != NULL)
    {
        defer_exit_block_visit(ctx, p_defer, position_token, p_defer_list);
        if (p_defer->p_iteration_statement)
        {
            break;
        }
        p_defer = p_defer->previous;
    }
}

static void defer_exit_iteration_or_switch_statement_visit(struct defer_visit_ctx* ctx,
    struct defer_defer_scope* deferblock,
    struct token* position_token,
    struct defer_list* p_defer_list)
{
    struct defer_defer_scope* _Opt p_defer = deferblock;
    while (p_defer != NULL)
    {
        defer_exit_block_visit(ctx, p_defer, position_token, p_defer_list);

        if (p_defer->p_iteration_statement)
        {
            //break using in for,do , while
            break;
        }

        if (p_defer->p_selection_statement &&
            p_defer->p_selection_statement->first_token->type == TK_KEYWORD_SWITCH)
        {
            //break switch case
            break;
        }

        p_defer = p_defer->previous;
    }
}

static void defer_exit_function_visit(struct defer_visit_ctx* ctx,
    struct defer_defer_scope* deferblock,
    struct token* position_token,
    struct defer_list* p_defer_list)
{
    struct defer_defer_scope* _Opt p_defer = deferblock;
    while (p_defer != NULL)
    {
        defer_exit_block_visit(ctx, p_defer, position_token, p_defer_list);
        p_defer = p_defer->previous;
    }
}

static void defer_visit_secondary_block(struct defer_visit_ctx* ctx, struct secondary_block* p_secondary_block)
{
    defer_visit_statement(ctx, p_secondary_block->statement);
}

static void defer_visit_defer_statement(struct defer_visit_ctx* ctx, struct defer_statement* p_defer_statement)
{
    struct defer_defer_scope* _Opt p_defer = defer_visit_ctx_push_child(ctx);
    if (p_defer)
    {
        p_defer->defer_statement = p_defer_statement;
    }
}

static void defer_visit_init_declarator(struct defer_visit_ctx* ctx, struct init_declarator* p_init_declarator)
{
    defer_visit_declarator(ctx, p_init_declarator->p_declarator);
}

static void defer_visit_simple_declaration(struct defer_visit_ctx* ctx, struct simple_declaration* p_simple_declaration)
{
    defer_visit_init_declarator_list(ctx, &p_simple_declaration->init_declarator_list);
}

static void defer_visit_if_statement(struct defer_visit_ctx* ctx, struct selection_statement* p_selection_statement)
{
    struct defer_defer_scope* _Opt p_defer = defer_visit_ctx_push_tail_block(ctx);
    if (p_defer == NULL)
        return;

    p_defer->p_selection_statement = p_selection_statement;


    if (p_selection_statement->p_init_statement &&
        p_selection_statement->p_init_statement->p_simple_declaration)
        defer_visit_simple_declaration(ctx, p_selection_statement->p_init_statement->p_simple_declaration);

    if (p_selection_statement->condition &&
        p_selection_statement->condition->p_init_declarator)
    {
        defer_visit_init_declarator(ctx, p_selection_statement->condition->p_init_declarator);
    }

    assert(p_selection_statement->first_token->type == TK_KEYWORD_IF);

    defer_visit_secondary_block(ctx, p_selection_statement->secondary_block);

    if (p_selection_statement->else_secondary_block_opt)
    {
        defer_visit_secondary_block(ctx, p_selection_statement->else_secondary_block_opt);
    }

    defer_exit_block_visit(ctx, p_defer, p_selection_statement->last_token, &p_selection_statement->defer_list);
    defer_visit_ctx_pop_tail_block(ctx);
}

static void defer_visit_try_statement(struct defer_visit_ctx* ctx, struct try_statement* p_try_statement)
{
    try
    {
        struct secondary_block* _Opt catch_secondary_block_old = ctx->catch_secondary_block_opt;

        ctx->catch_secondary_block_opt = p_try_statement->catch_secondary_block_opt;

        struct defer_defer_scope* _Opt p_defer = defer_visit_ctx_push_tail_block(ctx);
        if (p_defer == NULL)
        {
            //TODO restore
            throw;
        }

        p_defer->p_try_statement = p_try_statement;

        defer_visit_secondary_block(ctx, p_try_statement->secondary_block);

        if (p_try_statement->catch_secondary_block_opt)
        {
            defer_visit_secondary_block(ctx, p_try_statement->catch_secondary_block_opt);
        }

        //defer_exit_block_visit(ctx, p_defer, p_try_statement->secondary_block->last_token, p_defer_list);
        defer_visit_ctx_pop_tail_block(ctx);
        ctx->catch_secondary_block_opt = catch_secondary_block_old; //restore
    }
    catch
    {
    }
}

static void defer_visit_switch_statement(struct defer_visit_ctx* ctx, struct selection_statement* p_selection_statement)
{
    struct defer_defer_scope* _Opt p_defer = defer_visit_ctx_push_tail_block(ctx);
    if (p_defer == NULL)
    {
        return;
    }
    p_defer->p_selection_statement = p_selection_statement;
    defer_visit_secondary_block(ctx, p_selection_statement->secondary_block);
    defer_exit_block_visit(ctx, p_defer, p_selection_statement->secondary_block->last_token, &p_selection_statement->defer_list);
    defer_visit_ctx_pop_tail_block(ctx);
}

static void defer_visit_selection_statement(struct defer_visit_ctx* ctx, struct selection_statement* p_selection_statement)
{
    if (p_selection_statement->first_token->type == TK_KEYWORD_IF)
    {
        defer_visit_if_statement(ctx, p_selection_statement);
    }
    else if (p_selection_statement->first_token->type == TK_KEYWORD_SWITCH)
    {
        defer_visit_switch_statement(ctx, p_selection_statement);
    }
    else
        assert(false);
}

static void defer_visit_block_item_list(struct defer_visit_ctx* ctx, struct block_item_list* p_block_item_list)
{
    struct block_item* _Opt p_block_item = p_block_item_list->head;
    while (p_block_item)
    {
        defer_visit_block_item(ctx, p_block_item);
        p_block_item = p_block_item->next;
    }
}

static void defer_visit_compound_statement(struct defer_visit_ctx* ctx, struct compound_statement* p_compound_statement)
{
    struct defer_defer_scope* _Opt p_defer = defer_visit_ctx_push_tail_block(ctx);
    if (p_defer == NULL)
    {
        return;
    }
    p_defer->p_compound_statement = p_compound_statement;

    defer_visit_block_item_list(ctx, &p_compound_statement->block_item_list);

    defer_exit_block_visit(ctx, p_defer, p_compound_statement->last_token, &p_compound_statement->defer_list);

    defer_visit_ctx_pop_tail_block(ctx);
}

static void defer_visit_do_while_statement(struct defer_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    assert(p_iteration_statement->first_token->type == TK_KEYWORD_DO);
    //const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;
    try
    {
        struct defer_defer_scope* _Opt p_defer = defer_visit_ctx_push_tail_block(ctx);
        if (p_defer == NULL) throw;
        p_defer->p_iteration_statement = p_iteration_statement;
        defer_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
        defer_exit_block_visit(ctx, p_defer, p_iteration_statement->secondary_block->last_token, &p_iteration_statement->defer_list);
        defer_visit_ctx_pop_tail_block(ctx);
    }
    catch
    {
    }
}

static void defer_visit_while_statement(struct defer_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    assert(p_iteration_statement->first_token->type == TK_KEYWORD_WHILE);

    if (p_iteration_statement->expression1 == NULL)
        return;

    struct defer_defer_scope* _Opt p_defer = defer_visit_ctx_push_tail_block(ctx);
    if (p_defer == NULL)
    {
        return;
    }

    p_defer->p_iteration_statement = p_iteration_statement;

    defer_visit_secondary_block(ctx, p_iteration_statement->secondary_block);

    defer_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
    defer_exit_block_visit(ctx, p_defer, p_iteration_statement->secondary_block->last_token, &p_iteration_statement->defer_list);
    defer_visit_ctx_pop_tail_block(ctx);
}

static void defer_visit_for_statement(struct defer_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    assert(p_iteration_statement->first_token->type == TK_KEYWORD_FOR);

    try
    {
        if (p_iteration_statement->declaration &&
            p_iteration_statement->declaration->init_declarator_list.head)
        {
            defer_visit_init_declarator_list(ctx, &p_iteration_statement->declaration->init_declarator_list);
        }

        struct defer_defer_scope* _Opt p_defer = defer_visit_ctx_push_tail_block(ctx);
        if (p_defer == NULL)
            throw;

        p_defer->p_iteration_statement = p_iteration_statement;
        defer_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
        defer_visit_ctx_pop_tail_block(ctx);

        const bool b_secondary_block_ends_with_jump =
            secondary_block_ends_with_jump(p_iteration_statement->secondary_block);

        /*we visit again*/
        if (!b_secondary_block_ends_with_jump)
        {
            struct defer_defer_scope* _Opt p_defer2 = defer_visit_ctx_push_tail_block(ctx);
            if (p_defer2 == NULL) throw;

            p_defer2->p_iteration_statement = p_iteration_statement;
            defer_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
            defer_exit_block_visit(ctx, p_defer2, p_iteration_statement->secondary_block->last_token, &p_iteration_statement->defer_list);
            defer_visit_ctx_pop_tail_block(ctx);
        }
    }
    catch
    {
    }

}

static void defer_visit_iteration_statement(struct defer_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    switch (p_iteration_statement->first_token->type)
    {
    case  TK_KEYWORD_WHILE:
        defer_visit_while_statement(ctx, p_iteration_statement);
        break;
    case TK_KEYWORD_DO:
        defer_visit_do_while_statement(ctx, p_iteration_statement);
        break;
    case TK_KEYWORD_FOR:
        defer_visit_for_statement(ctx, p_iteration_statement);
        break;
    default:
        assert(false);
        break;
    }
}

static void defer_visit_jump_statement(struct defer_visit_ctx* ctx, struct jump_statement* p_jump_statement)
{
    assert(ctx->tail_block != NULL);

    try
    {
        if (p_jump_statement->first_token->type == TK_KEYWORD_CAKE_THROW)
        {
            defer_check_all_defer_until_try(ctx, ctx->tail_block, p_jump_statement->first_token, &p_jump_statement->defer_list);
        }
        else if (p_jump_statement->first_token->type == TK_KEYWORD_RETURN)
        {
            defer_exit_function_visit(ctx, ctx->tail_block, p_jump_statement->first_token, &p_jump_statement->defer_list);
        }
        else if (p_jump_statement->first_token->type == TK_KEYWORD_CONTINUE)
        {
            defer_check_all_defer_until_iter(ctx, ctx->tail_block, p_jump_statement->first_token, &p_jump_statement->defer_list);
        }
        else if (p_jump_statement->first_token->type == TK_KEYWORD_BREAK)
        {
            defer_exit_iteration_or_switch_statement_visit(ctx, ctx->tail_block, p_jump_statement->first_token, &p_jump_statement->defer_list);
        }
        else if (p_jump_statement->first_token->type == TK_KEYWORD_GOTO)
        {
            assert(p_jump_statement->label != NULL);
            defer_check_all_defer_until_label(ctx,
                ctx->tail_block,
                p_jump_statement->label->lexeme,
                p_jump_statement->first_token,
                &p_jump_statement->defer_list);
        }
        else
        {
            assert(false);
        }
    }
    catch
    {
    }
}

static void defer_visit_labeled_statement(struct defer_visit_ctx* ctx, struct labeled_statement* p_labeled_statement)
{
    defer_visit_statement(ctx, p_labeled_statement->statement);
}

static void defer_visit_primary_block(struct defer_visit_ctx* ctx, struct primary_block* p_primary_block)
{
    if (p_primary_block->defer_statement)
    {
        defer_visit_defer_statement(ctx, p_primary_block->defer_statement);
    }
    else if (p_primary_block->compound_statement)
    {
        defer_visit_compound_statement(ctx, p_primary_block->compound_statement);
    }
    else if (p_primary_block->iteration_statement)
    {
        defer_visit_iteration_statement(ctx, p_primary_block->iteration_statement);
    }
    else if (p_primary_block->selection_statement)
    {
        defer_visit_selection_statement(ctx, p_primary_block->selection_statement);
    }
    else if (p_primary_block->try_statement)
    {
        defer_visit_try_statement(ctx, p_primary_block->try_statement);
    }
}

static void defer_visit_expression(struct defer_visit_ctx* ctx, struct expression* p_expression)
{
    /*
        Literal functions need to build defer_list
    */

    if (p_expression->condition_expr)
    {
        defer_visit_expression(ctx, p_expression->condition_expr);
    }

    if (p_expression->left)
    {
        defer_visit_expression(ctx, p_expression->left);
    }

    if (p_expression->right)
    {
        defer_visit_expression(ctx, p_expression->right);
    }

    switch (p_expression->expression_type)
    {
    case POSTFIX_EXPRESSION_FUNCTION_LITERAL:
    {
        assert(p_expression->compound_statement != NULL);

        //TODO missing parameters of literal functions
        //without it static analysis will not work
        defer_visit_compound_statement(ctx, p_expression->compound_statement);
        //assert(ctx->tail_block == NULL);
        //struct defer_defer_scope* _Opt p_defer = defer_visit_ctx_push_tail_block(ctx);
        //if (p_defer == NULL)
        //{
          //  return;
        //}
        //p_defer->p_function_body = p_declaration->function_body;

        //defer_visit_typen(ctx, p_declaration);
        //assert(p_declaration->function_body != NULL); //defer_visit_declaration does not change this

        //parameters
        //if (ctx->tail_block)
        //{
          //  defer_exit_block_visit(ctx,
          //      ctx->tail_block,
          //      p_expression->compound_statement->last_token,
          //      &p_expression->defer_list);
        //}

        //defer_visit_ctx_pop_tail_block(ctx);
    }
    break;
    default:
        break;
    }
}
static void defer_visit_expression_statement(struct defer_visit_ctx* ctx, struct expression_statement* p_expression_statement)
{
    if (p_expression_statement->expression_opt)
        defer_visit_expression(ctx, p_expression_statement->expression_opt);
}

static void defer_visit_unlabeled_statement(struct defer_visit_ctx* ctx, struct unlabeled_statement* p_unlabeled_statement)
{
    if (p_unlabeled_statement->primary_block)
    {
        defer_visit_primary_block(ctx, p_unlabeled_statement->primary_block);
    }
    else if (p_unlabeled_statement->expression_statement)
    {
        defer_visit_expression_statement(ctx, p_unlabeled_statement->expression_statement);
    }
    else if (p_unlabeled_statement->jump_statement)
    {
        defer_visit_jump_statement(ctx, p_unlabeled_statement->jump_statement);
    }
    else
    {
        assert(false);
    }
}

static void defer_visit_statement(struct defer_visit_ctx* ctx, struct statement* p_statement)
{
    if (p_statement->labeled_statement)
    {
        defer_visit_labeled_statement(ctx, p_statement->labeled_statement);
    }
    else if (p_statement->unlabeled_statement)
    {
        defer_visit_unlabeled_statement(ctx, p_statement->unlabeled_statement);
    }
}

static void defer_visit_block_item(struct defer_visit_ctx* ctx, struct block_item* p_block_item)
{
    if (p_block_item->declaration)
    {
        defer_visit_declaration(ctx, p_block_item->declaration);
    }
    else if (p_block_item->unlabeled_statement)
    {
        defer_visit_unlabeled_statement(ctx, p_block_item->unlabeled_statement);
    }
    else if (p_block_item->label)
    {
    }
}

static void defer_visit_direct_declarator(struct defer_visit_ctx* ctx, struct direct_declarator* p_direct_declarator)
{
    if (p_direct_declarator->function_declarator)
    {
        struct parameter_declaration* _Opt parameter = NULL;

        if (p_direct_declarator->function_declarator->parameter_type_list_opt &&
            p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list)
        {
            parameter = p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head;
        }

        ctx->parameter_list++;

        while (parameter)
        {
            if (parameter->declarator)
            {
                defer_visit_declarator(ctx, parameter->declarator);
            }

            parameter = parameter->next;
        }

        ctx->parameter_list--;
    }
    else if (p_direct_declarator->array_declarator)
    {
    }
}

static void defer_visit_declarator(struct defer_visit_ctx* ctx, struct declarator* p_declarator)
{
    try
    {
        if (ctx->tail_block &&
            p_declarator->type.category != TYPE_CATEGORY_FUNCTION)
        {
            if (ctx->parameter_list > 1)
            {
                /*
                 The objective here is to avoid including the arguments
                 of function pointers inside the scope.
                 Sample
                 void x_destroy(void (*f)(void * _Owner p))
                 We add f but not p.
                */
                return;
            }

            struct defer_defer_scope* _Opt p_defer = defer_visit_ctx_push_child(ctx);
            if (p_defer == NULL) throw;
            p_defer->declarator = p_declarator;
        }

        if (p_declarator->direct_declarator)
        {
            defer_visit_direct_declarator(ctx, p_declarator->direct_declarator);
        }
    }
    catch
    {
    }
}

static void defer_visit_init_declarator_list(struct defer_visit_ctx* ctx, struct init_declarator_list* p_init_declarator_list)
{
    struct init_declarator* _Opt p_init_declarator = p_init_declarator_list->head;
    while (p_init_declarator)
    {
        defer_visit_init_declarator(ctx, p_init_declarator);
        p_init_declarator = p_init_declarator->next;
    }
}

void defer_visit_declaration(struct defer_visit_ctx* ctx, struct declaration* p_declaration)
{
    if (p_declaration->init_declarator_list.head)
    {
        defer_visit_init_declarator_list(ctx, &p_declaration->init_declarator_list);
    }

    if (p_declaration->function_body)
    {
        defer_visit_compound_statement(ctx, p_declaration->function_body);
    }
}

void defer_start_visit_declaration(struct defer_visit_ctx* ctx, struct declaration* p_declaration)
{
    if (p_declaration->function_body)
    {
        assert(ctx->tail_block == NULL);
        struct defer_defer_scope* _Opt p_defer = defer_visit_ctx_push_tail_block(ctx);
        if (p_defer == NULL)
        {
            return;
        }
        p_defer->p_function_body = p_declaration->function_body;

        defer_visit_declaration(ctx, p_declaration);
        assert(p_declaration->function_body != NULL); //defer_visit_declaration does not change this

        //parameters
        if (ctx->tail_block)
        {
            defer_exit_block_visit(ctx,
                ctx->tail_block,
                p_declaration->function_body->last_token,
                &p_declaration->defer_list); //maybe use the same defer_list from body??
        }

        defer_visit_ctx_pop_tail_block(ctx);
    }
    else
    {
        struct defer_defer_scope* _Opt p_defer = defer_visit_ctx_push_tail_block(ctx);
        if (p_defer == NULL)
        {
            return;
        }
        defer_visit_declaration(ctx, p_declaration);
        defer_visit_ctx_pop_tail_block(ctx);
    }
}

void defer_visit_ctx_destroy(_Dtor struct defer_visit_ctx* p)
{
    assert(p->tail_block == NULL);
}




#pragma safety enable

#if SIZE_MAX > UINT_MAX
#define SIZE_T_TYPE_STR "unsigned long long"
#else
#define SIZE_T_TYPE_STR "unsigned int"
#endif

#define CAKE_PREFIX_FOR_CODE_GENERATION "__Ck" 


static void print_initializer(struct d_visit_ctx* ctx,
    struct osstream* oss,
    struct init_declarator* p_init_declarator,
    bool bstatic);

void d_visit_ctx_destroy(_Dtor struct d_visit_ctx* ctx)
{
    hashmap_destroy(&ctx->tag_names);
    hashmap_destroy(&ctx->structs_map);
    hashmap_destroy(&ctx->file_scope_declarator_map);
    ss_close(&ctx->block_scope_declarators);
    ss_close(&ctx->add_this_before);
    ss_close(&ctx->add_this_before_external_decl);
    ss_close(&ctx->add_this_after_external_decl);
}

static struct struct_or_union_specifier* _Opt get_complete_struct_or_union_specifier2(struct struct_or_union_specifier* p_struct_or_union_specifier)
{
    struct struct_or_union_specifier* _Opt p_complete =
        get_complete_struct_or_union_specifier(p_struct_or_union_specifier);
    if (p_complete == NULL)
        p_complete = p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection;
    return p_complete;
}

struct struct_entry;

struct struct_entry_list
{
    struct struct_entry** _Owner _Opt data;
    int size;
    int capacity;
};



struct struct_entry
{
    bool done;
    struct struct_or_union_specifier* p_struct_or_union_specifier;
    struct struct_entry_list dependencies;
    struct struct_entry* _Opt next;
};

void struct_entry_delete(struct struct_entry* _Opt _Owner p)
{
    if (p)
    {
        free(p->dependencies.data);
        free(p);
    }
}

int struct_entry_list_reserve(struct struct_entry_list* p, int n)
{
    if (n > p->capacity)
    {
        if ((size_t)n > (SIZE_MAX / (sizeof(p->data[0]))))
        {
            return EOVERFLOW;
        }

        void* _Owner _Opt pnew = realloc(p->data, n * sizeof(p->data[0]));
        if (pnew == NULL) return ENOMEM;
        static_set(p->data, "moved");
        p->data = pnew;
        p->capacity = n;
    }
    return 0;
}

int struct_entry_list_push_back(struct struct_entry_list* p, struct struct_entry* book)
{
    if (p->size == INT_MAX)
    {
        return EOVERFLOW;
    }

    if (p->size + 1 > p->capacity)
    {
        int new_capacity = 0;
        if (p->capacity > (INT_MAX - p->capacity / 2))
        {
            /*overflow*/
            new_capacity = INT_MAX;
        }
        else
        {
            new_capacity = p->capacity + p->capacity / 2;
            if (new_capacity < p->size + 1)
            {
                new_capacity = p->size + 1;
            }
        }

        int error = struct_entry_list_reserve(p, new_capacity);
        if (error != 0)
        {
            return error;
        }
    }



    p->data[p->size] = book; /*VIEW*/
    p->size++;

    return 0;
}

static void d_visit_function_body(struct d_visit_ctx* ctx,
    struct osstream* oss,
    const struct declarator* function_definition);

static void object_print_constant_initialization(struct d_visit_ctx* ctx, struct osstream* ss, const struct object* object, bool* first);
static void d_visit_secondary_block(struct d_visit_ctx* ctx, struct osstream* oss, struct secondary_block* p_secondary_block);
static void d_visit_init_declarator(struct d_visit_ctx* ctx, struct osstream* oss, struct init_declarator* p_init_declarator, enum function_specifier_flags function_specifier_flags, enum storage_class_specifier_flags storage_class_specifier_flags);
static void d_visit_init_declarator_list(struct d_visit_ctx* ctx, struct osstream* oss, struct init_declarator_list* p_init_declarator_list, enum function_specifier_flags function_specifier_flags, enum storage_class_specifier_flags storage_class_specifier_flags);
static void d_visit_compound_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct compound_statement* p_compound_statement);
static void d_visit_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct statement* p_statement);
static void d_visit_unlabeled_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct unlabeled_statement* p_unlabeled_statement);
static void object_print_non_constant_initialization(struct d_visit_ctx* ctx, struct osstream* ss, const struct object* object, const char* declarator_name, bool all);

static void d_print_type_core(struct d_visit_ctx* ctx, struct osstream* ss, const struct type* p_type0, const char* _Opt name_opt);
static void d_print_type(struct d_visit_ctx* ctx,
    struct osstream* ss,
    const struct type* p_type,
    const char* _Opt name_opt);

static void print_identation_core(struct osstream* ss, int indentation)
{
    for (int i = 0; i < indentation; i++)
    {
        ss_fprintf(ss, "    ");
    }
}

static void print_identation(const struct d_visit_ctx* ctx, struct osstream* oss)
{
    for (int i = 0; i < ctx->indentation; i++)
    {
        ss_fprintf(oss, "    ");
    }
}


static void il_print_defer_new(struct d_visit_ctx* ctx, struct osstream* oss, struct defer_list_item* p_item)
{
    if (p_item->defer_statement == NULL)
        return;

    d_visit_secondary_block(ctx, oss, p_item->defer_statement->secondary_block);
}

static int il_defer_count(struct defer_list* p_defer_list)
{
    int count = 0;
    struct defer_list_item* _Opt p_item = p_defer_list->head;
    while (p_item)
    {
        if (p_item->defer_statement) count++;
        p_item = p_item->next;
    }
    return count;
}

static void il_print_defer_list(struct d_visit_ctx* ctx, struct osstream* oss, struct defer_list* p_defer_list)
{
    struct defer_list_item* _Opt p_item = p_defer_list->head;
    while (p_item)
    {
        il_print_defer_new(ctx, oss, p_item);
        p_item = p_item->next;
    }
}

static void object_print_value(struct osstream* ss, const struct object* a)
{
    a = object_get_referenced(a);

    switch (a->value_type)
    {

    case TYPE_BOOL:
        //ss_fprintf(ss, "((unsigned char) %s)", a->value.bool_value ? "1" : "0");
        ss_fprintf(ss, "%d", a->value.bool_value ? 1 : 0);
        break;

    case TYPE_SIGNED_CHAR:

        //ss_fprintf(ss, "((signed char)%d)", (int)a->value.signed_char_value);
        ss_fprintf(ss, "%d", (int)a->value.signed_char_value);
        break;


    case TYPE_UNSIGNED_CHAR:
        //ss_fprintf(ss, "((unsigned char)%d)", (int)a->value.unsigned_char_value);
        ss_fprintf(ss, "%d", (int)a->value.unsigned_char_value);
        break;


    case TYPE_SIGNED_SHORT:
        //        ss_fprintf(ss, "((short)%d)", a->value.signed_short_value);
        ss_fprintf(ss, "%d", a->value.signed_short_value);
        break;

    case TYPE_UNSIGNED_SHORT:
        //ss_fprintf(ss, "((unsigned short) %d)", a->value.unsigned_short_value);
        ss_fprintf(ss, "%d", a->value.unsigned_short_value);
        break;

    case TYPE_SIGNED_INT:
        ss_fprintf(ss, "%d", a->value.signed_int_value);
        break;

    case TYPE_UNSIGNED_INT:
        ss_fprintf(ss, "%u", a->value.unsigned_int_value);
        ss_fprintf(ss, "U");
        break;
    case TYPE_SIGNED_LONG:
        ss_fprintf(ss, "%ld", a->value.signed_long_value);
        ss_fprintf(ss, "L");
        break;
    case TYPE_UNSIGNED_LONG:
        ss_fprintf(ss, "%lu", a->value.unsigned_long_value);
        ss_fprintf(ss, "UL");
        break;
    case TYPE_SIGNED_LONG_LONG:
        ss_fprintf(ss, "%lld", a->value.signed_long_long_value);
        ss_fprintf(ss, "LL");
        break;
    case TYPE_UNSIGNED_LONG_LONG:
        ss_fprintf(ss, "%llu", a->value.unsigned_long_long_value);
        ss_fprintf(ss, "ULL");
        break;
    case TYPE_FLOAT:
        ss_fprintf(ss, "%f", a->value.float_value);
        ss_fprintf(ss, "f");
        break;
    case TYPE_DOUBLE:
        ss_fprintf(ss, "%lf", a->value.double_value);
        break;
    case TYPE_LONG_DOUBLE:
        ss_fprintf(ss, "%Lf", a->value.long_double_value);
        ss_fprintf(ss, "L");
        break;
    }

}


static void d_visit_expression(struct d_visit_ctx* ctx, struct osstream* oss, struct expression* p_expression);

static void expression_to_bool_value(struct d_visit_ctx* ctx, struct osstream* oss, struct expression* p_expression)
{
    if (object_has_constant_value(&p_expression->object))
    {
        if (object_to_bool(&p_expression->object))
        {
            ss_fprintf(oss, "1");
        }
        else
        {
            ss_fprintf(oss, "0");
        }
    }
    else
    {
        if (type_is_bool(&p_expression->type))
        {
            d_visit_expression(ctx, oss, p_expression);
        }
        else
        {
            ss_fprintf(oss, "!!(");
            d_visit_expression(ctx, oss, p_expression);
            ss_fprintf(oss, ")");
        }
    }
}

static struct member_declarator* _Opt find_member_declarator_by_index2(struct member_declaration_list* list,
    int member_index,
    char name[100],
    int* p_count)
{
    if (list->head == NULL)
        return NULL;

    int no_name_index = 0;

    struct member_declaration* _Opt p_member_declaration = list->head;
    while (p_member_declaration)
    {
        struct member_declarator* _Opt p_member_declarator = NULL;

        if (p_member_declaration->member_declarator_list_opt)
        {
            p_member_declarator = p_member_declaration->member_declarator_list_opt->head;

            while (p_member_declarator)
            {
                if (p_member_declarator->declarator)
                {
                    if (member_index == *p_count)
                    {
                        snprintf(name, 100, "%s", p_member_declarator->declarator->name_opt->lexeme);
                        return p_member_declarator;
                    }
                }
                (*p_count)++;
                p_member_declarator = p_member_declarator->next;
            }
        }
        else if (p_member_declaration->specifier_qualifier_list)
        {
            if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
            {
                struct struct_or_union_specifier* _Opt p_complete =
                    get_complete_struct_or_union_specifier(p_member_declaration->specifier_qualifier_list->struct_or_union_specifier);


                if (p_complete)
                {
                    char mname[100] = { 0 };
                    p_member_declarator = find_member_declarator_by_index2(&p_complete->member_declaration_list, member_index, mname, p_count);
                    if (p_member_declarator)
                    {
                        snprintf(name, 100, "__m%d.%s", no_name_index++, mname);
                        return p_member_declarator;
                    }
                }
            }
        }

        p_member_declaration = p_member_declaration->next;
    }
    return NULL;
}

static int find_member_name(const struct type* p_type, int index, char name[100])
{
    if (!type_is_struct_or_union(p_type))
        return 1;

    assert(p_type->struct_or_union_specifier != NULL);

    struct struct_or_union_specifier* _Opt p_complete =
        get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

    if (p_complete)
    {
        int count = 0;
        struct member_declarator* _Opt p =
            find_member_declarator_by_index2(&p_complete->member_declaration_list, index, name, &count);
        if (p)
        {
            return 0;//p->declarator->name_opt->lexeme;
        }
    }
    return 1;
}

static int il_visit_literal_string2(struct token* current, struct osstream* oss)
{

    const bool has_u8_prefix =
        current->lexeme[0] == 'u' && current->lexeme[1] == '8';

    const bool has_wide_prefix =
        current->lexeme[0] == 'L';

    unsigned char* psz = (unsigned char*)(current->lexeme + 0);
    if (has_u8_prefix)
    {
        psz = (unsigned char*)(current->lexeme + 2 + 1);
    }
    else if (has_wide_prefix)
    {
        psz = (unsigned char*)(current->lexeme + 1 + 1);
    }
    else
    {
        psz = (unsigned char*)(current->lexeme + 1);
    }

    while (*psz)
    {
        if (*(psz + 1) == '\0')
            break;

        if (*psz >= 128)
        {
            ss_fprintf(oss, "\\x%x", *psz);
        }
        else
        {
            ss_fprintf(oss, "%c", *psz);
        }
        psz++;
    }


    return 0;
}

static void il_print_string(struct token* first_token, struct token* last_token, struct osstream* oss)
{
    bool opened = false;

    struct token* _Opt ptk = first_token;
    do
    {
        if (ptk == NULL)
            break;

        if ((ptk->flags & TK_FLAG_FINAL) &&
            ptk->type == TK_STRING_LITERAL)
        {
            if (!opened)
            {
                if (ptk->lexeme[0] == 'L')
                    ss_fprintf(oss, "L");
                ss_fprintf(oss, "\"");
                opened = true;
            }
            il_visit_literal_string2(ptk, oss);
        }

        if (ptk == last_token)
            break;

        ptk = ptk->next;
    } while (ptk);
    ss_fprintf(oss, "\"");

}

static const char* get_op_by_expression_type(enum expression_type type)
{
    switch (type)
    {
    case ASSIGNMENT_EXPRESSION_ASSIGN:
        return "=";
    case ASSIGNMENT_EXPRESSION_PLUS_ASSIGN:
        return "+=";
    case ASSIGNMENT_EXPRESSION_MINUS_ASSIGN:
        return "-=";
    case ASSIGNMENT_EXPRESSION_MULTI_ASSIGN:
        return "*=";
    case ASSIGNMENT_EXPRESSION_DIV_ASSIGN:
        return "/=";
    case ASSIGNMENT_EXPRESSION_MOD_ASSIGN:
        return "%=";
    case ASSIGNMENT_EXPRESSION_SHIFT_LEFT_ASSIGN:
        return "<<=";
    case ASSIGNMENT_EXPRESSION_SHIFT_RIGHT_ASSIGN:
        return ">>=";
    case ASSIGNMENT_EXPRESSION_AND_ASSIGN:
        return "&=";
    case ASSIGNMENT_EXPRESSION_OR_ASSIGN:
        return "|=";
    case ASSIGNMENT_EXPRESSION_NOT_ASSIGN:
        return "^=";
    default:
        break;
    }
    assert(false);
    return "";
}

static void d_visit_expression(struct d_visit_ctx* ctx, struct osstream* oss, struct expression* p_expression)
{

    if (object_has_constant_value(&p_expression->object))
    {
        object_print_value(oss, &p_expression->object);
        return;
    }

    switch (p_expression->expression_type)
    {
    case EXPRESSION_TYPE_INVALID:
        assert(false);
        break;

    case PRIMARY_EXPRESSION__FUNC__:
    {
        assert(ctx->p_current_function_opt);

        char func_name[200] = { 0 };
        char name[100] = { 0 };
        if (ctx->p_current_function_opt->name_opt)
        {
            snprintf(func_name, sizeof func_name, "%s", ctx->p_current_function_opt->name_opt->lexeme);
            snprintf(name, sizeof(name), "__cake_func_%s", func_name);
        }
        else
        {
            snprintf(func_name, sizeof func_name, "unnamed");
            snprintf(name, sizeof(name), "__cake_func_%p", ctx->p_current_function_opt);
        }



        if (!ctx->is__func__predefined_identifier_added)
        {
            assert(ctx->p_current_function_opt);

            ctx->is__func__predefined_identifier_added = true;
            ss_fprintf(&ctx->add_this_before_external_decl, "static const char %s[] = \"%s\";\n", name, func_name);
        }
        ss_fprintf(oss, "%s", name);

    }
    break;

    case PRIMARY_EXPRESSION_DECLARATOR:
    {
        assert(p_expression->declarator != NULL);

        const char* declarator_name = "";
        if (p_expression->declarator->name_opt)
            declarator_name = p_expression->declarator->name_opt->lexeme;

        const bool is_function = type_is_function(&p_expression->declarator->type);
        bool is_local_function_definition = false;
        if (is_function)
        {
            is_local_function_definition =
                p_expression->type.storage_class_specifier_flags & STORAGE_SPECIFIER_BLOCK_SCOPE &&
                p_expression->declarator->function_body != NULL;
        }

        const bool is_static =
            p_expression->declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_STATIC;

        const bool is_inline =
            p_expression->declarator->declaration_specifiers->function_specifier_flags & FUNCTION_SPECIFIER_INLINE;

        const bool is_extern = p_expression->type.storage_class_specifier_flags & STORAGE_SPECIFIER_EXTERN;

        const bool is_local =
            (!is_static && !is_extern) &&
            p_expression->type.storage_class_specifier_flags & STORAGE_SPECIFIER_BLOCK_SCOPE;

        if (is_function)
        {
            ss_fprintf(oss, "%s", p_expression->declarator->name_opt->lexeme);

            struct map_entry* _Opt p = hashmap_find(&ctx->file_scope_declarator_map, declarator_name);
            if (p == NULL)
            {
                /*first time we see it*/

                struct hash_item_set i = { 0 };
                i.number = 1;
                hashmap_set(&ctx->file_scope_declarator_map, declarator_name, &i);
                hash_item_set_destroy(&i);

                struct osstream ss = { 0 };

                if ((is_inline || is_local_function_definition) && !is_static)
                {
                    ss_fprintf(&ss, "static ");
                }
                d_print_type(ctx, &ss, &p_expression->type, declarator_name);
                ss_fprintf(&ctx->add_this_before_external_decl, "%s", ss.c_str);
                ss_fprintf(&ctx->add_this_before_external_decl, ";\n");


                assert(p_expression->declarator != NULL);

                const struct declarator* _Opt p_function_defined
                    = declarator_get_function_definition(p_expression->declarator);

                if (p_function_defined && (is_static || is_inline || is_local_function_definition))
                {
                    //We need to find the function..

                    struct osstream local3 = { 0 };
                    struct osstream local4 = { 0 };
                    d_print_type(ctx, &local4, &p_function_defined->type, declarator_name);

                    if (!is_static)
                        ss_fprintf(&local3, "static ");

                    ss_fprintf(&local3, "%s\n", local4.c_str);

                    d_visit_function_body(ctx, &local3, p_function_defined);

                    assert(ss.c_str);
                    assert(oss->c_str);

                    ss_fprintf(&ctx->add_this_after_external_decl, "\n");
                    ss_fprintf(&ctx->add_this_after_external_decl, "%s", local3.c_str);

                    ss_close(&local3);
                    ss_close(&local4);
                }

                ss_close(&ss);
            }
        }
        else if (is_local)
        {
            ss_fprintf(oss, "%s", p_expression->declarator->name_opt->lexeme);
        }
        else
        {

            /*
               local static declarators are generated on-demand.
            */

            void* _Opt p = hashmap_find(&ctx->file_scope_declarator_map, declarator_name);
            if (p == NULL)
            {
                /*
                  first time, let´s generate it
                */

                /*
                   insert in a map to avoid generating it again
                */
                struct hash_item_set i = { 0 };
                i.number = 1;
                hashmap_set(&ctx->file_scope_declarator_map, declarator_name, &i);

                assert(p_expression->declarator);
                assert(p_expression->declarator->name_opt);


                struct osstream ss = { 0 };

                d_print_type(ctx, &ss, &p_expression->type, declarator_name);

                if (p_expression->p_init_declarator &&
                    p_expression->p_init_declarator->initializer)
                {
                    print_initializer(ctx, &ss, p_expression->p_init_declarator, true);
                    assert(ss.c_str);
                    ss_fprintf(&ctx->add_this_before_external_decl, "%s\n", ss.c_str);
                }
                else
                {
                    assert(ss.c_str);
                    ss_fprintf(&ctx->add_this_before_external_decl, "%s;\n", ss.c_str);
                }

                ss_close(&ss);
                hash_item_set_destroy(&i);
            }


            ss_fprintf(oss, "%s", p_expression->declarator->name_opt->lexeme);
        }

    }
    break;

    case PRIMARY_EXPRESSION_STRING_LITERAL:
        il_print_string(p_expression->first_token, p_expression->last_token, oss);
        break;

    case PRIMARY_EXPRESSION_ENUMERATOR:
    case PRIMARY_EXPRESSION_CHAR_LITERAL:
    case PRIMARY_EXPRESSION_NUMBER:
    case PRIMARY_EXPRESSION_PREDEFINED_CONSTANT:
        object_print_value(oss, &p_expression->object);
        break;

    case PRIMARY_EXPRESSION_PARENTESIS:
        assert(p_expression->right != NULL);
        ss_fprintf(oss, "(");
        d_visit_expression(ctx, oss, p_expression->right);
        ss_fprintf(oss, ")");
        break;

    case PRIMARY_EXPRESSION_GENERIC:
        assert(p_expression->generic_selection != NULL);

        if (p_expression->generic_selection->p_view_selected_expression)
        {
            d_visit_expression(ctx, oss, p_expression->generic_selection->p_view_selected_expression);
        }
        break;

    case UNARY_EXPRESSION_GCC__BUILTIN_OFFSETOF:
        ss_fprintf(oss, "__builtin_offsetof(");

        if (p_expression->type_name)
        {
            d_print_type(ctx, oss, &p_expression->type_name->type, NULL);
        }
        ss_fprintf(oss, ", ");
        ss_fprintf(oss, "%s", p_expression->offsetof_member_designator->lexeme);
        ss_fprintf(oss, ")");
        break;

    case UNARY_EXPRESSION_GCC__BUILTIN_VA_START:
        assert(p_expression->left != NULL);

        if (p_expression->right != NULL)
        {
            ss_fprintf(oss, "__builtin_va_start(");
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, ", ");
            d_visit_expression(ctx, oss, p_expression->right);
            ss_fprintf(oss, ")");
        }
        else
        {
            //first argument is optional in C23
            ss_fprintf(oss, "__builtin_c23_va_start(");
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, ")");
            //TODO to convert to C89 we need to insert the first parameter
            //at the caller and at the implementation
            //ss_fprintf(oss, ", __first_va_arg");            
        }
        break;

    case UNARY_EXPRESSION_GCC__BUILTIN_VA_END:
        assert(p_expression->left != NULL);
        ss_fprintf(oss, "__builtin_va_end(");
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, ")");
        break;

    case UNARY_EXPRESSION_GCC__BUILTIN_VA_COPY:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);

        ss_fprintf(oss, "__builtin_va_copy(");
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, ", ");
        d_visit_expression(ctx, oss, p_expression->right);
        ss_fprintf(oss, ")");
        break;

    case UNARY_EXPRESSION_GCC__BUILTIN_VA_ARG:
        assert(p_expression->left != NULL);

        ss_fprintf(oss, "__builtin_va_arg(");
        d_visit_expression(ctx, oss, p_expression->left);

        if (p_expression->type_name)
        {
            ss_fprintf(oss, ", ");
            d_print_type(ctx, oss, &p_expression->type_name->type, NULL);
        }
        ss_fprintf(oss, ")");
        break;

    case POSTFIX_DOT:
    {
        assert(p_expression->left != NULL);

        d_visit_expression(ctx, oss, p_expression->left);

        char name[100] = { 0 };
        int r = find_member_name(&p_expression->left->type, p_expression->member_index, name);
        if (r == 0)
        {
            ss_fprintf(oss, ".%s", name);
        }
    }
    break;

    case POSTFIX_ARROW:
    {
        assert(p_expression->left != NULL);


        d_visit_expression(ctx, oss, p_expression->left);
        {
            struct type t = type_remove_pointer(&p_expression->left->type);

            char name[100] = { 0 };
            int r = find_member_name(&t, p_expression->member_index, name);
            if (r == 0)
            {
                ss_fprintf(oss, "->%s", name);
            }
            type_destroy(&t);
        }
    }
    break;


    case POSTFIX_INCREMENT:
        assert(p_expression->left != NULL);

        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, "++");
        break;

    case POSTFIX_DECREMENT:
        assert(p_expression->left != NULL);

        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, "--");
        break;

    case POSTFIX_ARRAY:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);

        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, "[");
        d_visit_expression(ctx, oss, p_expression->right);
        ss_fprintf(oss, "]");
        break;

    case POSTFIX_FUNCTION_CALL:
    {
        assert(p_expression->left != NULL);


        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, "(");
        struct argument_expression* _Opt arg = p_expression->argument_expression_list.head;
        while (arg)
        {
            //TODO convert int to bool parameter
            d_visit_expression(ctx, oss, arg->expression);
            if (arg->next)
                ss_fprintf(oss, ", ");
            arg = arg->next;
        }
        ss_fprintf(oss, ")");
    }
    break;

    case UNARY_EXPRESSION_ADDRESSOF:

        assert(p_expression->right != NULL);
        ss_fprintf(oss, "&");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case POSTFIX_EXPRESSION_FUNCTION_LITERAL:
    {
        assert(p_expression->type_name != NULL);

        char name[100] = { 0 };
        snprintf(name, sizeof(name), CAKE_PREFIX_FOR_CODE_GENERATION "%d_flit", ctx->cake_declarator_number++);

        print_identation_core(&ctx->add_this_before, ctx->indentation);

        struct osstream lambda = { 0 };
        ss_fprintf(&lambda, "static ");
        d_print_type(ctx, &lambda, &p_expression->type, name);
        ss_fprintf(&lambda, "\n");
        int current_indentation = ctx->indentation;
        ctx->indentation = 0;
        assert(p_expression->compound_statement != NULL);

        const struct declarator* _Opt p_current_function_opt = ctx->p_current_function_opt;
        ctx->p_current_function_opt = p_expression->type_name->abstract_declarator;

        d_visit_compound_statement(ctx, &lambda, p_expression->compound_statement);
        ctx->indentation = current_indentation;
        ctx->p_current_function_opt = p_current_function_opt;

        assert(lambda.c_str);
        ss_fprintf(&ctx->add_this_before_external_decl, "%s\n", lambda.c_str);
        ss_fprintf(oss, "%s", name);
        ss_close(&lambda);
    }
    break;


    case POSTFIX_EXPRESSION_COMPOUND_LITERAL:
    {
        char name[100] = { 0 };
        snprintf(name, sizeof(name), CAKE_PREFIX_FOR_CODE_GENERATION "%d_compound_lit", ctx->cake_declarator_number++);



        if (ctx->is_local)
        {
            struct osstream local = { 0 };
            ss_swap(&ctx->block_scope_declarators, &local);
            print_identation_core(&local, ctx->indentation);
            d_print_type(ctx, &local, &p_expression->type, name);
            ss_fprintf(&local, ";\n", name);
            ss_fprintf(&ctx->block_scope_declarators, "%s", local.c_str);

            ss_clear(&local);

            //bool first = true;
            object_print_non_constant_initialization(ctx, &local, &p_expression->object, name, true);

            assert(local.c_str);
            ss_fprintf(&ctx->add_this_before, "%s", local.c_str);
            ss_close(&local);
            ss_fprintf(oss, "%s", name);
        }
        else
        {
            struct osstream local = { 0 };
            print_identation_core(&local, ctx->indentation);
            d_print_type(ctx, &local, &p_expression->type, name);
            bool first = true;
            ss_fprintf(&local, " = {");
            object_print_constant_initialization(ctx, &local, &p_expression->object, &first);
            ss_fprintf(&local, "};\n");
            ss_fprintf(&ctx->add_this_before, "%s", local.c_str);
            ss_close(&local);
            ss_fprintf(oss, "%s", name);

        }
    }
    break;

    case UNARY_EXPRESSION_SIZEOF_EXPRESSION:
        object_print_value(oss, &p_expression->object);
        break;

    case UNARY_EXPRESSION_SIZEOF_TYPE:
        object_print_value(oss, &p_expression->object);
        break;

    case UNARY_EXPRESSION_ALIGNOF_EXPRESSION:
    case UNARY_EXPRESSION_ALIGNOF_TYPE:
    case UNARY_EXPRESSION_COUNTOF:
        object_print_value(oss, &p_expression->object);
        break;

    case UNARY_EXPRESSION_CONSTEVAL:
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case UNARY_EXPRESSION_INCREMENT:
        assert(p_expression->right != NULL);
        ss_fprintf(oss, "++");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case UNARY_EXPRESSION_DECREMENT:
        assert(p_expression->right != NULL);
        ss_fprintf(oss, "--");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case UNARY_EXPRESSION_NOT:
        assert(p_expression->right != NULL);
        ss_fprintf(oss, "!");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case UNARY_EXPRESSION_BITNOT:
        assert(p_expression->right != NULL);
        ss_fprintf(oss, "~");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case UNARY_EXPRESSION_NEG:

        assert(p_expression->right != NULL);
        ss_fprintf(oss, "-");
        d_visit_expression(ctx, oss, p_expression->right);
        break;
    case UNARY_EXPRESSION_PLUS:

        assert(p_expression->right != NULL);
        ss_fprintf(oss, "+");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case UNARY_EXPRESSION_CONTENT:

        assert(p_expression->right != NULL);
        ss_fprintf(oss, "*");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case UNARY_EXPRESSION_ASSERT:
        break;

    case ADDITIVE_EXPRESSION_MINUS:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " - ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case ADDITIVE_EXPRESSION_PLUS:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " + ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case MULTIPLICATIVE_EXPRESSION_MULT:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " * ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;
    case MULTIPLICATIVE_EXPRESSION_DIV:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " / ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case MULTIPLICATIVE_EXPRESSION_MOD:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, "%s", " % ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;


    case EXPRESSION_EXPRESSION:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, ", ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;


    case ASSIGNMENT_EXPRESSION_ASSIGN:

        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);

        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " %s ", get_op_by_expression_type(p_expression->expression_type));

        if (type_is_bool(&p_expression->left->type))
        {
            expression_to_bool_value(ctx, oss, p_expression->right);
        }
        else
        {
            d_visit_expression(ctx, oss, p_expression->right);
        }

        break;

    case ASSIGNMENT_EXPRESSION_PLUS_ASSIGN:
    case ASSIGNMENT_EXPRESSION_MINUS_ASSIGN:
    case ASSIGNMENT_EXPRESSION_MULTI_ASSIGN:
    case ASSIGNMENT_EXPRESSION_DIV_ASSIGN:
    case ASSIGNMENT_EXPRESSION_MOD_ASSIGN:
    case ASSIGNMENT_EXPRESSION_SHIFT_LEFT_ASSIGN:
    case ASSIGNMENT_EXPRESSION_SHIFT_RIGHT_ASSIGN:
    case ASSIGNMENT_EXPRESSION_AND_ASSIGN:
    case ASSIGNMENT_EXPRESSION_OR_ASSIGN:
    case ASSIGNMENT_EXPRESSION_NOT_ASSIGN:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " %s ", get_op_by_expression_type(p_expression->expression_type));
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case CAST_EXPRESSION:
    {
        assert(p_expression->left != NULL);

        struct osstream local2 = { 0 };
        d_print_type(ctx, &local2, &p_expression->type, NULL);
        ss_fprintf(oss, "(%s)", local2.c_str);
        ss_close(&local2);
        d_visit_expression(ctx, oss, p_expression->left);
    }
    break;

    case SHIFT_EXPRESSION_RIGHT:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " >> ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case SHIFT_EXPRESSION_LEFT:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " << ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case RELATIONAL_EXPRESSION_BIGGER_THAN:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " > ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case RELATIONAL_EXPRESSION_LESS_THAN:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);

        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " < ");
        d_visit_expression(ctx, oss, p_expression->right);

        break;
    case EQUALITY_EXPRESSION_EQUAL:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " == ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case EQUALITY_EXPRESSION_NOT_EQUAL:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " != ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case AND_EXPRESSION:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " & ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case EXCLUSIVE_OR_EXPRESSION:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " ^ ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case INCLUSIVE_OR_EXPRESSION:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " | ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " <= ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " >= ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case LOGICAL_AND_EXPRESSION:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " && ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case LOGICAL_OR_EXPRESSION:
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " || ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;

    case UNARY_EXPRESSION_TRAITS:
    case UNARY_EXPRESSION_IS_SAME:
    case UNARY_DECLARATOR_ATTRIBUTE_EXPR:
        break;

    case CONDITIONAL_EXPRESSION:
        assert(p_expression->condition_expr != NULL);
        assert(p_expression->left != NULL);
        assert(p_expression->right != NULL);

        d_visit_expression(ctx, oss, p_expression->condition_expr);
        ss_fprintf(oss, " ? ");
        d_visit_expression(ctx, oss, p_expression->left);
        ss_fprintf(oss, " : ");
        d_visit_expression(ctx, oss, p_expression->right);
        break;
    }
}


static void d_visit_declaration(struct d_visit_ctx* ctx, struct osstream* oss, struct declaration* p_declaration);


static void d_visit_expression_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct expression_statement* p_expression_statement)
{

    ss_clear(&ctx->add_this_before);
    struct osstream local = { 0 };

    print_identation(ctx, &local);
    if (p_expression_statement->expression_opt)
        d_visit_expression(ctx, &local, p_expression_statement->expression_opt);


    if (ctx->add_this_before.size > 0)
    {
        ss_fprintf(oss, "%s", ctx->add_this_before.c_str);
        ss_clear(&ctx->add_this_before);

    }

    ss_fprintf(oss, "%s;\n", local.c_str);
    ss_close(&local);
}

static void d_visit_jump_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct jump_statement* p_jump_statement)
{
    if (p_jump_statement->first_token->type == TK_KEYWORD_CAKE_THROW)
    {
        il_print_defer_list(ctx, oss, &p_jump_statement->defer_list);
        print_identation(ctx, oss);
        ss_fprintf(oss, "goto _CKL%d;/*throw*/\n", p_jump_statement->label_id);
    }
    else if (p_jump_statement->first_token->type == TK_KEYWORD_RETURN)
    {
        struct type return_type = get_function_return_type(&ctx->p_current_function_opt->type);

        //if the return does not have expression, or if it returns a constant
        //we know that is safe do execute defer before returning
        const bool constant_expression_or_void =
            p_jump_statement->expression_opt == NULL ||
            object_has_constant_value(&p_jump_statement->expression_opt->object) ||
            il_defer_count(&p_jump_statement->defer_list) == 0;

        if (constant_expression_or_void)
        {
            il_print_defer_list(ctx, oss, &p_jump_statement->defer_list);
            print_identation(ctx, oss);
            ss_fprintf(oss, "return");

            if (p_jump_statement->expression_opt)
            {
                ss_fprintf(oss, " ");

                if (type_is_bool(&return_type))
                {
                    expression_to_bool_value(ctx, oss, p_jump_statement->expression_opt);
                }
                else
                {
                    d_visit_expression(ctx, oss, p_jump_statement->expression_opt);
                }
            }
            ss_fprintf(oss, ";\n");
        }
        else
        {
            //Interleaved return like in
            //
            // int f() {
            //    int i = 1;
            //    defer { i = 0; }
            //    return i++;
            // }

            char name[100] = { 0 };
            snprintf(name, sizeof name, CAKE_PREFIX_FOR_CODE_GENERATION "%d_tmp", ctx->cake_declarator_number++);


            print_identation(ctx, oss);
            d_print_type(ctx, oss, &return_type, name);
            ss_fprintf(oss, " = ");
            if (p_jump_statement->expression_opt)
            {
                if (type_is_bool(&return_type))
                {
                    expression_to_bool_value(ctx, oss, p_jump_statement->expression_opt);
                }
                else
                {
                    d_visit_expression(ctx, oss, p_jump_statement->expression_opt);
                }
            }
            ss_fprintf(oss, ";\n");

            il_print_defer_list(ctx, oss, &p_jump_statement->defer_list);
            print_identation(ctx, oss);

            ss_fprintf(oss, "return %s;\n", name);
        }

        type_destroy(&return_type);
    }
    else if (p_jump_statement->first_token->type == TK_KEYWORD_BREAK ||
        p_jump_statement->first_token->type == TK_KEYWORD_CONTINUE)
    {
        il_print_defer_list(ctx, oss, &p_jump_statement->defer_list);
        print_identation(ctx, oss);

        if (p_jump_statement->first_token->type == TK_KEYWORD_BREAK)
        {
            if (ctx->break_reference.p_selection_statement)
            {
                ss_fprintf(oss, "goto _CKL%d; /*break*/\n\n", ctx->break_reference.p_selection_statement->label_id);
            }
            else
            {
                ss_fprintf(oss, "break;\n");
            }
        }
        else
        {
            ss_fprintf(oss, "continue;\n");
        }
    }
    else if (p_jump_statement->first_token->type == TK_KEYWORD_GOTO)
    {
        il_print_defer_list(ctx, oss, &p_jump_statement->defer_list);
        print_identation(ctx, oss);
        ss_fprintf(oss, "goto %s;\n", p_jump_statement->label->lexeme);
    }
    else
    {
        assert(false);
    }
}

static void d_visit_label(struct d_visit_ctx* ctx, struct osstream* oss, struct label* p_label);

static void d_visit_labeled_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct labeled_statement* p_labeled_statement)
{
    assert(p_labeled_statement->label != NULL);

    d_visit_label(ctx, oss, p_labeled_statement->label);


    d_visit_statement(ctx, oss, p_labeled_statement->statement);
}

static void d_visit_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct statement* p_statement)
{
    if (p_statement->labeled_statement)
    {
        d_visit_labeled_statement(ctx, oss, p_statement->labeled_statement);
    }
    else if (p_statement->unlabeled_statement)
    {
        d_visit_unlabeled_statement(ctx, oss, p_statement->unlabeled_statement);
    }
}

static void d_visit_secondary_block(struct d_visit_ctx* ctx, struct osstream* oss, struct secondary_block* p_secondary_block)
{
    d_visit_statement(ctx, oss, p_secondary_block->statement);
}

static void d_visit_iteration_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct iteration_statement* p_iteration_statement)
{
    struct break_reference old = ctx->break_reference;
    ctx->break_reference.p_iteration_statement = p_iteration_statement;
    ctx->break_reference.p_selection_statement = NULL;

    print_identation(ctx, oss);
    if (p_iteration_statement->first_token->type == TK_KEYWORD_WHILE)
    {
        ss_fprintf(oss, "while ("); //one statement per line

        if (p_iteration_statement->expression1)
            d_visit_expression(ctx, oss, p_iteration_statement->expression1);

        ss_fprintf(oss, ")\n");
        d_visit_secondary_block(ctx, oss, p_iteration_statement->secondary_block);
    }
    else if (p_iteration_statement->first_token->type == TK_KEYWORD_DO)
    {
        ss_fprintf(oss, "do\n");

        d_visit_secondary_block(ctx, oss, p_iteration_statement->secondary_block);

        print_identation(ctx, oss);
        ss_fprintf(oss, "while (");

        assert(p_iteration_statement->expression1 != NULL);
        d_visit_expression(ctx, oss, p_iteration_statement->expression1);


        ss_fprintf(oss, ");\n");
    }
    else if (p_iteration_statement->first_token->type == TK_KEYWORD_FOR)
    {
        if (p_iteration_statement->declaration)
        {
            ss_fprintf(oss, "{\n");
            ctx->indentation++;

            struct osstream block_scope_declarators = { 0 };
            ss_swap(&block_scope_declarators, &ctx->block_scope_declarators);

            struct osstream local = { 0 };
            d_visit_declaration(ctx, &local, p_iteration_statement->declaration);

            if (ctx->block_scope_declarators.c_str)
            {
                ss_fprintf(oss, "%s", ctx->block_scope_declarators.c_str);
                ss_fprintf(oss, "\n");
            }

            if (local.c_str)
                ss_fprintf(oss, "%s", local.c_str);

            ss_swap(&block_scope_declarators, &ctx->block_scope_declarators);


            print_identation(ctx, oss);
            ss_fprintf(oss, "for (");
            ss_close(&block_scope_declarators);
            ss_close(&local);

        }
        else if (p_iteration_statement->expression0)
        {
            ss_fprintf(oss, "for (");
            d_visit_expression(ctx, oss, p_iteration_statement->expression0);
        }
        else
        {
            ss_fprintf(oss, "for (");
        }

        ss_fprintf(oss, "; ");

        if (p_iteration_statement->expression1)
            d_visit_expression(ctx, oss, p_iteration_statement->expression1);

        ss_fprintf(oss, "; ");

        if (p_iteration_statement->expression2)
            d_visit_expression(ctx, oss, p_iteration_statement->expression2);

        ss_fprintf(oss, ")\n");

        d_visit_secondary_block(ctx, oss, p_iteration_statement->secondary_block);

        if (p_iteration_statement->declaration)
        {
            ctx->indentation--;
            print_identation(ctx, oss);
            ss_fprintf(oss, "}\n");
        }
    }

    //restore
    ctx->break_reference = old;
}

static void d_visit_simple_declaration(struct d_visit_ctx* ctx, struct osstream* oss, struct simple_declaration* p_simple_declaration)
{
    d_visit_init_declarator_list(ctx, oss, &p_simple_declaration->init_declarator_list, false, false);
}

static void d_visit_init_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct init_statement* p_init_statement)
{
    if (p_init_statement->p_expression_statement)
        d_visit_expression_statement(ctx, oss, p_init_statement->p_expression_statement);
    if (p_init_statement->p_simple_declaration)
        d_visit_simple_declaration(ctx, oss, p_init_statement->p_simple_declaration);
}

static void d_visit_condition(struct d_visit_ctx* ctx, struct osstream* oss, struct condition* p_condition)
{
    if (p_condition->p_init_declarator)
        d_visit_init_declarator(ctx, oss, p_condition->p_init_declarator, false, false);

    if (p_condition->expression)
        d_visit_expression(ctx, oss, p_condition->expression);
}

static bool is_compound_statement(struct secondary_block* p_secondary_block)
{
    assert(p_secondary_block->statement != NULL);

    if (p_secondary_block->statement->unlabeled_statement &&
        p_secondary_block->statement->unlabeled_statement->primary_block &&
        p_secondary_block->statement->unlabeled_statement->primary_block->compound_statement)
    {
        return true;
    }

    return false;
}

static void d_visit_selection_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct selection_statement* p_selection_statement)
{
    print_identation(ctx, oss);
    if (p_selection_statement->first_token->type == TK_KEYWORD_SWITCH)
    {
        struct break_reference old = ctx->break_reference;
        ctx->break_reference.p_iteration_statement = NULL;
        ctx->break_reference.p_selection_statement = p_selection_statement;
        assert(p_selection_statement->condition != NULL);

        struct osstream ss = { 0 };


        ss_fprintf(&ss, "/*switch*/\n");
        print_identation(ctx, &ss);
        ss_fprintf(&ss, "{\n");
        ctx->indentation++;


        char name[100] = { 0 };
        snprintf(name, sizeof(name), CAKE_PREFIX_FOR_CODE_GENERATION "%d_temp", ctx->cake_declarator_number++);

        print_identation(ctx, &ss);
        ss_fprintf(&ss, "register ");
        d_print_type(ctx, &ss, &p_selection_statement->condition->expression->type, name);

        ss_fprintf(&ss, " = ");

        assert(p_selection_statement->condition != NULL);
        d_visit_condition(ctx, &ss, p_selection_statement->condition);
        ss_fprintf(&ss, ";\n");

        struct label* _Opt p_label = p_selection_statement->label_list.head;
        struct label* _Opt p_label_default = NULL;
        while (p_label)
        {

            if (p_label->p_first_token->type == TK_KEYWORD_DEFAULT)
            {
                p_label_default = p_label;
            }
            else
            {
                print_identation(ctx, &ss);
                if (p_label->constant_expression_end == NULL)
                {
                    char str[50] = { 0 };
                    object_to_str(&p_label->constant_expression->object, 50, str);
                    ss_fprintf(&ss, "if (%s == %s) goto _CKL%d; /*case %s*/\n", name, str, p_label->label_id, str);

                }
                else
                {
                    char str_begin[50] = { 0 };
                    object_to_str(&p_label->constant_expression->object, 50, str_begin);
                    char str_end[50] = { 0 };
                    object_to_str(&p_label->constant_expression_end->object, 50, str_end);
                    ss_fprintf(&ss, "if (%s >= %s && %s <= %s) goto _CKL%d; /*case %s ... %s*/\n", name, str_begin, name, str_end, p_label->label_id, str_begin, str_end);
                }
            }

            p_label = p_label->next;
        }

        print_identation(ctx, &ss);

        if (p_label_default)
        {
            ss_fprintf(&ss, "goto _CKL%d;/*default*/\n", p_label_default->label_id);
        }
        else
        {
            ss_fprintf(&ss, "goto _CKL%d;\n", p_selection_statement->label_id);
        }

        ss_fprintf(&ss, "\n");

        d_visit_secondary_block(ctx, &ss, p_selection_statement->secondary_block);

        print_identation(ctx, &ss);
        ss_fprintf(&ss, "_CKL%d:;\n", ctx->break_reference.p_selection_statement->label_id);

        ctx->indentation--;
        print_identation(ctx, &ss);
        ss_fprintf(&ss, "}\n");

        ss_fprintf(oss, "%s", ss.c_str);
        ss_close(&ss);
        //restore
        ctx->break_reference = old;
    }
    else if (p_selection_statement->first_token->type == TK_KEYWORD_IF)
    {
        bool addclose = false;
        if (p_selection_statement->p_init_statement)
        {
            ss_fprintf(oss, "{\n");
            addclose = true;
            ctx->indentation++;
            struct osstream block_scope_declarators = { 0 };
            ss_swap(&block_scope_declarators, &ctx->block_scope_declarators);

            struct osstream local2 = { 0 };

            print_identation(ctx, &local2);
            d_visit_init_statement(ctx, &local2, p_selection_statement->p_init_statement);

            if (ctx->block_scope_declarators.c_str)
            {
                ss_fprintf(oss, "%s", ctx->block_scope_declarators.c_str);
                ss_fprintf(oss, "\n");
            }

            ss_fprintf(oss, "%s", local2.c_str);
            ss_close(&local2);
            print_identation(ctx, oss);
            ss_swap(&block_scope_declarators, &ctx->block_scope_declarators);
            ss_close(&block_scope_declarators);
        }

        if (p_selection_statement->condition)
        {
            if (p_selection_statement->condition->p_init_declarator)
            {
                ss_fprintf(oss, "{\n");
                ctx->indentation++;
                addclose = true;
                struct osstream block_scope_declarators = { 0 };
                ss_swap(&block_scope_declarators, &ctx->block_scope_declarators);


                struct osstream local2 = { 0 };
                print_identation(ctx, &local2);
                d_visit_init_declarator(ctx, &local2, p_selection_statement->condition->p_init_declarator, false, false);

                if (ctx->block_scope_declarators.c_str)
                {
                    ss_fprintf(oss, "%s", ctx->block_scope_declarators.c_str);
                    ss_fprintf(oss, "\n");
                }

                ss_fprintf(oss, "%s", local2.c_str);
                ss_close(&local2);
                ss_swap(&block_scope_declarators, &ctx->block_scope_declarators);

                print_identation(ctx, oss);
                ss_fprintf(oss, "if (");
                ss_fprintf(oss, "%s", p_selection_statement->condition->p_init_declarator->p_declarator->name_opt->lexeme);
                ss_fprintf(oss, ")\n");
                ss_close(&block_scope_declarators);
            }
            else if (p_selection_statement->condition->expression)
            {
                ss_fprintf(oss, "if (");
                d_visit_expression(ctx, oss, p_selection_statement->condition->expression);
                ss_fprintf(oss, ")\n");
            }

        }

        assert(p_selection_statement->secondary_block != NULL);

        if (is_compound_statement(p_selection_statement->secondary_block))
        {
            d_visit_secondary_block(ctx, oss, p_selection_statement->secondary_block);
        }
        else
        {
            print_identation(ctx, oss);
            ss_fprintf(oss, "{\n");
            ctx->indentation++;
            d_visit_secondary_block(ctx, oss, p_selection_statement->secondary_block);
            ctx->indentation--;
            print_identation(ctx, oss);
            ss_fprintf(oss, "}\n");
        }

        if (p_selection_statement->else_secondary_block_opt)
        {
            print_identation(ctx, oss);
            ss_fprintf(oss, "else\n");

            if (is_compound_statement(p_selection_statement->else_secondary_block_opt))
            {
                d_visit_secondary_block(ctx, oss, p_selection_statement->else_secondary_block_opt);
            }
            else
            {
                print_identation(ctx, oss);
                ss_fprintf(oss, "{\n");
                ctx->indentation++;
                d_visit_secondary_block(ctx, oss, p_selection_statement->else_secondary_block_opt);
                ctx->indentation--;
                print_identation(ctx, oss);
                ss_fprintf(oss, "}\n");
            }
        }

        if (addclose)
        {
            ctx->indentation--;
            print_identation(ctx, oss);
            ss_fprintf(oss, "}\n");

        }
    }
}

static void d_visit_try_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct try_statement* p_try_statement)
{
    print_identation(ctx, oss);
    ss_fprintf(oss, "if (1) /*try*/\n");

    d_visit_secondary_block(ctx, oss, p_try_statement->secondary_block);

    print_identation(ctx, oss);
    ss_fprintf(oss, "else _CKL%d: /*catch*/ \n", p_try_statement->catch_label_id);

    if (p_try_statement->catch_secondary_block_opt)
    {
        d_visit_secondary_block(ctx, oss, p_try_statement->catch_secondary_block_opt);
    }
}

static void d_visit_primary_block(struct d_visit_ctx* ctx, struct osstream* oss, struct primary_block* p_primary_block)
{
    if (p_primary_block->defer_statement)
    {
        //visit_defer_statement(ctx, p_primary_block->defer_statement);
    }
    else if (p_primary_block->compound_statement)
    {
        d_visit_compound_statement(ctx, oss, p_primary_block->compound_statement);
    }
    else if (p_primary_block->iteration_statement)
    {
        d_visit_iteration_statement(ctx, oss, p_primary_block->iteration_statement);
    }
    else if (p_primary_block->selection_statement)
    {
        d_visit_selection_statement(ctx, oss, p_primary_block->selection_statement);
    }
    else if (p_primary_block->try_statement)
    {
        d_visit_try_statement(ctx, oss, p_primary_block->try_statement);
    }

}

static void d_visit_unlabeled_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct unlabeled_statement* p_unlabeled_statement)
{
    if (p_unlabeled_statement->primary_block)
    {
        d_visit_primary_block(ctx, oss, p_unlabeled_statement->primary_block);
    }
    else if (p_unlabeled_statement->expression_statement)
    {
        d_visit_expression_statement(ctx, oss, p_unlabeled_statement->expression_statement);
    }
    else if (p_unlabeled_statement->jump_statement)
    {
        d_visit_jump_statement(ctx, oss, p_unlabeled_statement->jump_statement);
    }
    else
    {
        assert(false);
    }
}

static void d_visit_label(struct d_visit_ctx* ctx, struct osstream* oss, struct label* p_label)
{
    if (p_label->p_first_token->type == TK_KEYWORD_CASE)
    {
        print_identation(ctx, oss);
        ss_fprintf(oss, "_CKL%d:", p_label->label_id);

        char str[50] = { 0 };
        object_to_str(&p_label->constant_expression->object, 50, str);
        if (p_label->constant_expression_end == NULL)
        {
            ss_fprintf(oss, " /*case %s*/ ", str);
        }
        else
        {
            char str2[50] = { 0 };
            object_to_str(&p_label->constant_expression_end->object, 50, str2);
            ss_fprintf(oss, " /*case %s ... %s*/ ", str, str2);
        }

        ss_fprintf(oss, "\n");
    }
    else if (p_label->p_first_token->type == TK_IDENTIFIER)
    {
        print_identation(ctx, oss);
        ss_fprintf(oss, "%s:\n", p_label->p_first_token->lexeme);
    }
    else if (p_label->p_first_token->type == TK_KEYWORD_DEFAULT)
    {
        print_identation(ctx, oss);
        ss_fprintf(oss, "_CKL%d: /*default*/ \n", p_label->label_id);
    }

}

static void d_visit_block_item(struct d_visit_ctx* ctx, struct osstream* oss, struct block_item* p_block_item)
{
    struct osstream ss0 = { 0 };
    ss_swap(oss, &ss0);

    ss_clear(&ctx->add_this_before);

    if (p_block_item->declaration)
    {
        d_visit_declaration(ctx, oss, p_block_item->declaration);
    }
    else if (p_block_item->unlabeled_statement)
    {
        d_visit_unlabeled_statement(ctx, oss, p_block_item->unlabeled_statement);
    }
    else if (p_block_item->label)
    {
        d_visit_label(ctx, oss, p_block_item->label);
    }

    if (ctx->add_this_before.size > 0)
    {
        ss_fprintf(&ss0, "%s", ctx->add_this_before.c_str);
        ss_clear(&ctx->add_this_before);

    }
    if (oss->c_str)
    {
        ss_fprintf(&ss0, "%s", oss->c_str);
    }
    ss_swap(oss, &ss0);
    ss_close(&ss0);
}

static void d_visit_block_item_list(struct d_visit_ctx* ctx, struct osstream* oss, struct block_item_list* p_block_item_list)
{
    struct block_item* _Opt p_block_item = p_block_item_list->head;
    while (p_block_item)
    {
        d_visit_block_item(ctx, oss, p_block_item);
        p_block_item = p_block_item->next;
    }
}


static void d_visit_compound_statement(struct d_visit_ctx* ctx, struct osstream* oss, struct compound_statement* p_compound_statement)
{
    bool is_local = ctx->is_local;
    ctx->is_local = true;

    struct osstream block_scope_declarators = { 0 };
    ss_swap(&ctx->block_scope_declarators, &block_scope_declarators);

    struct osstream local = { 0 };

    ctx->indentation++;
    d_visit_block_item_list(ctx, &local, &p_compound_statement->block_item_list);


    bool ends_with_jump = false;

    if (p_compound_statement->block_item_list.tail &&
        p_compound_statement->block_item_list.tail->unlabeled_statement &&
        p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement != NULL)
    {
        ends_with_jump = true;
    }

    if (!ends_with_jump)
        il_print_defer_list(ctx, &local, &p_compound_statement->defer_list);

    ctx->indentation--;

    print_identation(ctx, oss);
    ss_fprintf(oss, "{\n");

    if (ctx->block_scope_declarators.c_str)
    {
        ss_fprintf(oss, "%s", ctx->block_scope_declarators.c_str);
        ss_fprintf(oss, "\n");
    }

    if (local.c_str)
        ss_fprintf(oss, "%s", local.c_str);

    print_identation(ctx, oss);
    ss_fprintf(oss, "}\n");
    ctx->is_local = is_local; //restore
    ss_swap(&ctx->block_scope_declarators, &block_scope_declarators);
    ss_close(&block_scope_declarators);
    ss_close(&local);
}

static void d_visit_function_body(struct d_visit_ctx* ctx,
    struct osstream* oss,
    const struct declarator* function_definition)
{
    if (function_definition->function_body == NULL)
    {
        assert(false);
        return;
    }
    int indentation = ctx->indentation;
    ctx->indentation = 0;
    const struct declarator* _Opt previous_func = ctx->p_current_function_opt;
    ctx->p_current_function_opt = function_definition;
    d_visit_compound_statement(ctx, oss, function_definition->function_body);
    ctx->p_current_function_opt = previous_func;//restore
    ctx->indentation = indentation; //restore
}

static void register_struct_types_and_functions(struct d_visit_ctx* ctx, const struct type* p_type0)
{
    try
    {
        const struct type* _Opt p_type = p_type0;

        while (p_type)
        {
            switch (p_type->category)
            {
            case TYPE_CATEGORY_ITSELF:
            {
                if (p_type->struct_or_union_specifier)
                {
                    struct struct_or_union_specifier* _Opt p_complete =
                        get_complete_struct_or_union_specifier2(p_type->struct_or_union_specifier);


                    if (p_complete)
                    {
                        char name[100] = { 0 };
                        snprintf(name, sizeof name, "%p", (void*)p_complete);

                        struct map_entry* _Opt p = hashmap_find(&ctx->structs_map, name);
                        if (p == NULL)
                        {
                            //vamos ver se ja existe alguma com o mesmo tag?
                            //se existir vamos mudar o tagname desta nova adicinando um numero.

                            struct map_entry* _Opt p_name = hashmap_find(&ctx->tag_names, p_complete->tag_name);
                            if (p_name != NULL)
                            {
                                //ja existe uma com este nome
                                char new_name[100] = { 0 };
                                snprintf(new_name, sizeof name, "%s%d", p_complete->tag_name, ctx->cake_tag_count++);
                                snprintf(p_complete->tag_name, sizeof p_complete->tag_name, "%s", new_name);

                                struct hash_item_set i = { 0 };
                                i.number = 1;
                                hashmap_set(&ctx->tag_names, new_name, &i);
                                hash_item_set_destroy(&i);
                            }
                            else
                            {
                                struct hash_item_set i = { 0 };
                                i.number = 1;
                                hashmap_set(&ctx->tag_names, p_complete->tag_name, &i);
                                hash_item_set_destroy(&i);
                            }

                            _Opt struct struct_entry* _Opt _Owner p_struct_entry = calloc(1, sizeof * p_struct_entry);
                            if (p_struct_entry == NULL)
                                throw;

                            p_struct_entry->p_struct_or_union_specifier = p_complete;

                            {
                                struct hash_item_set i = { 0 };
                                i.p_struct_entry = p_struct_entry;
                                hashmap_set(&ctx->structs_map, name, &i);
                                hash_item_set_destroy(&i);
                            }

                            struct member_declaration* _Opt member_declaration =
                                p_complete->member_declaration_list.head;

                            while (member_declaration)
                            {
                                struct member_declarator* _Opt member_declarator = NULL;

                                if (member_declaration->member_declarator_list_opt)
                                {
                                    member_declarator = member_declaration->member_declarator_list_opt->head;
                                    while (member_declarator)
                                    {
                                        if (member_declarator->declarator)
                                        {
                                            if (type_is_struct_or_union(&member_declarator->declarator->type))
                                            {
                                                assert(member_declarator->declarator->type.struct_or_union_specifier != NULL);

                                                struct struct_or_union_specifier* _Opt p_complete_member =
                                                    get_complete_struct_or_union_specifier(member_declarator->declarator->type.struct_or_union_specifier);

                                                if (p_complete_member == NULL)
                                                    throw;

                                                char name2[100] = { 0 };
                                                snprintf(name2, sizeof name2, "%p", (void*)p_complete_member);

                                                register_struct_types_and_functions(ctx, &member_declarator->declarator->type);
                                                struct map_entry* _Opt p2 = hashmap_find(&ctx->structs_map, name2);
                                                if (p2 != NULL)
                                                {
                                                    assert(p2->data.p_struct_entry != NULL);
                                                    struct_entry_list_push_back(&p_struct_entry->dependencies, p2->data.p_struct_entry);
                                                }
                                            }
                                            if (type_is_array(&member_declarator->declarator->type))
                                            {
                                                struct type t = get_array_item_type(&member_declarator->declarator->type);
                                                if (type_is_struct_or_union(&t))
                                                {
                                                    assert(t.struct_or_union_specifier != NULL);

                                                    struct struct_or_union_specifier* _Opt p_complete_member =
                                                        p_complete_member = get_complete_struct_or_union_specifier(t.struct_or_union_specifier);

                                                    char name2[100] = { 0 };
                                                    snprintf(name2, sizeof name2, "%p", (void* _Opt)p_complete_member);

                                                    register_struct_types_and_functions(ctx, &t);
                                                    struct map_entry* _Opt p2 = hashmap_find(&ctx->structs_map, name2);
                                                    if (p2 != NULL)
                                                    {
                                                        assert(p2->data.p_struct_entry != NULL);
                                                        struct_entry_list_push_back(&p_struct_entry->dependencies, p2->data.p_struct_entry);
                                                    }
                                                }
                                                else
                                                {
                                                    register_struct_types_and_functions(ctx, &member_declarator->declarator->type);
                                                }
                                                type_destroy(&t);
                                            }
                                            else
                                            {
                                                register_struct_types_and_functions(ctx, &member_declarator->declarator->type);
                                            }
                                        }
                                        member_declarator = member_declarator->next;
                                    }
                                }
                                else if (member_declaration->specifier_qualifier_list != NULL)
                                {
                                    if (member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                                    {
                                        struct type t = { 0 };
                                        t.category = TYPE_CATEGORY_ITSELF;
                                        t.struct_or_union_specifier = member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                                        //char buffer[200] = { 0 };
                                        //snprintf(buffer, sizeof buffer, ".%s", name);

                                        if (type_is_struct_or_union(&t))
                                        {
                                            struct struct_or_union_specifier* _Opt p_complete_member =
                                                p_complete_member = get_complete_struct_or_union_specifier(t.struct_or_union_specifier);

                                            char name2[100] = { 0 };
                                            snprintf(name2, sizeof name2, "%p", (void* _Opt)p_complete_member);

                                            register_struct_types_and_functions(ctx, &t);
                                            struct map_entry* _Opt p2 = hashmap_find(&ctx->structs_map, name2);
                                            if (p2 != NULL)
                                            {
                                                assert(p2->data.p_struct_entry != NULL);
                                                struct_entry_list_push_back(&p_struct_entry->dependencies, p2->data.p_struct_entry);
                                            }
                                        }
                                        if (type_is_array(&t))
                                        {
                                            struct type t2 = get_array_item_type(&t);
                                            if (type_is_struct_or_union(&t2))
                                            {
                                                struct struct_or_union_specifier* _Opt p_complete_member =
                                                    p_complete_member = get_complete_struct_or_union_specifier(t.struct_or_union_specifier);

                                                if (p_complete_member == NULL)
                                                {
                                                    type_destroy(&t2);
                                                    throw;
                                                }

                                                char name2[100] = { 0 };
                                                snprintf(name2, sizeof name2, "%p", (void*)p_complete_member);

                                                register_struct_types_and_functions(ctx, &t);
                                                struct map_entry* _Opt p2 = hashmap_find(&ctx->structs_map, name2);
                                                if (p2 != NULL)
                                                {
                                                    assert(p2->data.p_struct_entry != NULL);
                                                    struct_entry_list_push_back(&p_struct_entry->dependencies, p2->data.p_struct_entry);
                                                }
                                            }
                                            else
                                            {
                                                register_struct_types_and_functions(ctx, &t);
                                            }
                                            type_destroy(&t2);
                                        }
                                        else
                                        {
                                            register_struct_types_and_functions(ctx, &t);
                                        }

                                        type_destroy(&t);
                                    }
                                }

                                member_declaration = member_declaration->next;
                            }
                        }
                    }
                }
                else
                {
                }
            }
            break;

            case TYPE_CATEGORY_FUNCTION:
            {
                struct param* _Opt pa = p_type->params.head;
                while (pa)
                {
                    register_struct_types_and_functions(ctx, &pa->type);
                    pa = pa->next;
                }
            }
            break;

            case TYPE_CATEGORY_ARRAY:
            case TYPE_CATEGORY_POINTER:

                break;
            }
            p_type = p_type->next;
        }
    }
    catch
    {
    }
}

static void d_print_type_core(struct d_visit_ctx* ctx,
    struct osstream* ss,
    const struct type* p_type0,
    const char* _Opt name_opt)
{
    const struct type* _Opt p_type = p_type0;

    while (p_type)
    {
        switch (p_type->category)
        {
        case TYPE_CATEGORY_ITSELF:
        {
            struct osstream local = { 0 };
            bool first = true;

            if (p_type->struct_or_union_specifier)
            {
                if (struct_or_union_specifier_is_union(p_type->struct_or_union_specifier))
                    ss_fprintf(&local, "union %s", p_type->struct_or_union_specifier->tag_name);
                else
                    ss_fprintf(&local, "struct %s", p_type->struct_or_union_specifier->tag_name);
            }
            else if (p_type->enum_specifier)
            {
                enum type_specifier_flags enum_type_specifier_flags =
                    get_enum_type_specifier_flags(p_type->enum_specifier);

                print_type_specifier_flags(&local, &first, enum_type_specifier_flags);
            }
            else if (p_type->type_specifier_flags & TYPE_SPECIFIER_BOOL)
            {
                ss_fprintf(&local, "unsigned char ");
            }
            else
            {
                print_type_alignment_flags(&local, &first, p_type->alignment_specifier_flags, ctx->options.target);
                print_msvc_declspec(&local, &first, p_type->msvc_declspec_flags);
                print_type_specifier_flags(&local, &first, p_type->type_specifier_flags);
            }

            if (name_opt) /*flow loop bug*/
            {
                if (first)
                {
                    ss_fprintf(ss, " ");
                    first = false;
                }
                ss_fprintf(ss, "%s", name_opt);
                name_opt = NULL;
            }

            struct osstream local2 = { 0 };
            if (ss->c_str)
                ss_fprintf(&local2, "%s %s", local.c_str, ss->c_str);
            else
                ss_fprintf(&local2, "%s", local.c_str);

            ss_swap(ss, &local2);
            //ss_close(&local);
            ss_close(&local2);
            ss_close(&local);
        }

        break;
        case TYPE_CATEGORY_ARRAY:


            if (name_opt)
            {
                //if (first)
                //{
                  //  ss_fprintf(ss, " ");
                    //first = false;
                //}
                ss_fprintf(ss, "%s", name_opt);
                name_opt = NULL;
            }

            ss_fprintf(ss, "[");

            bool b = true;


            //print_type_qualifier_flags(ss, &b, p_type->type_qualifier_flags);

            if (p_type->num_of_elements > 0)
            {
                if (!b)
                    ss_fprintf(ss, " ");

                ss_fprintf(ss, "%zu", p_type->num_of_elements);
            }
            else
            {
                //vlz
            }
            ss_fprintf(ss, "]");

            break;

        case TYPE_CATEGORY_FUNCTION:

            if (name_opt)
            {
                //if (first)
                //{
                  //  ss_fprintf(ss, " ");
                    //first = false;
                //}
                if (p_type->attributes_flags & CAKE_ATTRIBUTE_STDCALL)
                {
                    ss_fprintf(ss, "__stdcall ");
                }
                else if (p_type->attributes_flags & CAKE_ATTRIBUTE_FASTCALL)
                {
                    ss_fprintf(ss, "__fastcall ");
                }
                else if (p_type->attributes_flags & CAKE_ATTRIBUTE_CDECL)
                {
                    ss_fprintf(ss, "__cdecl ");
                }
                ss_fprintf(ss, "%s", name_opt);
                name_opt = NULL;
            }
            ss_fprintf(ss, "(");

            struct param* _Opt pa = p_type->params.head;

            while (pa)
            {
                struct osstream sslocal = { 0 };
                struct osstream local2 = { 0 };
                d_print_type_core(ctx, &local2, &pa->type, pa->type.name_opt);

                ss_fprintf(&sslocal, "%s", local2.c_str);
                ss_fprintf(ss, "%s", sslocal.c_str);
                if (pa->next)
                    ss_fprintf(ss, ", ");
                ss_close(&sslocal);
                pa = pa->next;
                ss_close(&local2);
            }

            if (p_type->params.is_var_args)
            {
                if (p_type->params.head)
                    ss_fprintf(ss, ", ");
                ss_fprintf(ss, "...");
            }

            ss_fprintf(ss, ")");


            break;

        case TYPE_CATEGORY_POINTER:
        {
            struct osstream local = { 0 };
            if (p_type->next && (
                (p_type->next->category == TYPE_CATEGORY_FUNCTION ||
                    p_type->next->category == TYPE_CATEGORY_ARRAY)))
            {
                ss_fprintf(&local, "(");
            }

            if (p_type->attributes_flags & CAKE_ATTRIBUTE_STDCALL)
            {
                ss_fprintf(&local, "__stdcall ");
            }
            else if (p_type->attributes_flags & CAKE_ATTRIBUTE_FASTCALL)
            {
                ss_fprintf(&local, "__fastcall ");
            }
            else if (p_type->attributes_flags & CAKE_ATTRIBUTE_CDECL)
            {
                ss_fprintf(&local, "__cdecl ");
            }

            ss_fprintf(&local, "*");
            bool first = false;

            if (name_opt)
            {
                if (!first)
                {
                    ss_fprintf(ss, " ");
                }
                ss_fprintf(ss, "%s", name_opt);
                name_opt = NULL;
                first = false;
            }

            if (ss->c_str)
                ss_fprintf(&local, "%s", ss->c_str);

            if (p_type->next &&
                (p_type->next->category == TYPE_CATEGORY_FUNCTION ||
                    p_type->next->category == TYPE_CATEGORY_ARRAY))
            {
                ss_fprintf(&local, ")", ss->c_str);
            }

            ss_swap(ss, &local);
            ss_close(&local);

        }
        break;
        }

        p_type = p_type->next;

    }
}

static void d_print_type(struct d_visit_ctx* ctx,
    struct osstream* ss,
    const struct type* p_type,
    const char* _Opt name_opt)
{

    //Register structs

    register_struct_types_and_functions(ctx, p_type);

    struct osstream local = { 0 };


    d_print_type_core(ctx,
    &local,
    p_type,
    name_opt);


    if (p_type->storage_class_specifier_flags & STORAGE_SPECIFIER_EXTERN)
        ss_fprintf(ss, "extern ");

    if (p_type->storage_class_specifier_flags & STORAGE_SPECIFIER_STATIC)
    {
        ss_fprintf(ss, "static ");
    }

    if (p_type->storage_class_specifier_flags & STORAGE_SPECIFIER_THREAD_LOCAL)
    {
        if (ctx->options.target == TARGET_DEFAULT)
        {
#ifdef _MSC_VER
            ss_fprintf(ss, "__declspec(thread) ");
#elif __GNUC__
            ss_fprintf(ss, "__thread ");
#endif
        }
        else if (ctx->options.target == TARGET_X86_MSVC ||
                 ctx->options.target == TARGET_X64_MSVC)
        {
            ss_fprintf(ss, "__declspec(thread) ");
        }
        else if (ctx->options.target == TARGET_X86_X64_GCC)
        {
            ss_fprintf(ss, "__thread ");
        }
    }

    ss_fprintf(ss, "%s", local.c_str);

    ss_close(&local);
}

//return true se todas as expressoes constantes sao 0, as nao constantes nao sao consideradas
static bool is_all_zero(const struct object* object)
{
    if (object_is_reference(object))
    {
        object = object_get_referenced(object);
    }

    if (object->members != NULL)
    {
        struct object* _Opt member = object->members;
        while (member)
        {
            if (!is_all_zero(member))
                return false;
            member = member->next;
        }
    }

    if (object->p_init_expression)
    {
        if (object_has_constant_value(&object->p_init_expression->object))
        {
            if (object_to_bool(&object->p_init_expression->object) != 0)
            {
                return false;
            }
        }
        else
            return false;
    }

    return true;
}


static void object_print_constant_initialization(struct d_visit_ctx* ctx, struct osstream* ss, const struct object* object, bool* first)
{
    if (object_is_reference(object))
    {
        object = object_get_referenced(object);
    }


    if (object->p_init_expression &&
        object->p_init_expression->expression_type == PRIMARY_EXPRESSION_STRING_LITERAL)
    {
        if (!(*first))
            ss_fprintf(ss, ", ");

        *first = false;

        il_print_string(object->p_init_expression->first_token, object->p_init_expression->last_token, ss);
        return;
    }

    if (object->members != NULL)
    {
        if (type_is_union(&object->type))
        {
            //In c89 only the first member can be initialized
            //we could make the first member be array of unsigned int
            //then initialize it
            struct object* _Opt member = object->members;
            object_print_constant_initialization(ctx, ss, member, first);
        }
        else
        {
            struct object* _Opt member = object->members;
            while (member)
            {
                object_print_constant_initialization(ctx, ss, member, first);
                member = member->next;
            }
        }
    }
    else
    {
        if (!(*first))
            ss_fprintf(ss, ", ");

        *first = false;

        if (object->p_init_expression)
        {
            if (object_has_constant_value(&object->p_init_expression->object))
            {
                object_print_value(ss, &object->p_init_expression->object);
            }
            else if (object->p_init_expression->expression_type == PRIMARY_EXPRESSION_STRING_LITERAL)
            {
                //literals also can be used in c89 initializers
                il_print_string(object->p_init_expression->first_token, object->p_init_expression->last_token, ss);

            }
            else
            {
                ss_fprintf(ss, "0"); /*provisory*/
            }
        }
        else
        {
            ss_fprintf(ss, "0");
        }
    }
}

static void object_print_non_constant_initialization(struct d_visit_ctx* ctx,
    struct osstream* ss,
    const struct object* object,
    const char* declarator_name,
    bool all)
{

    if (object_is_reference(object))
    {
        object = object_get_referenced(object);
    }

    if (object->members != NULL)
    {
        if (type_is_union(&object->type))
        {
            //In c89 only the first member can be initialized
            struct object* _Opt member = object->members;

            if (member->p_init_expression &&
                object_has_constant_value(&member->p_init_expression->object) &&
                !all)
            {
                //already initialized
            }
            else
            {
                //TODO external declarations bug
                /*
                */
                while (member)
                {
                    if (member->p_init_expression)
                    {
                        //object_print_non_constant_initialization(ctx, ss, member, declarator_name);
                        print_identation_core(ss, ctx->indentation);
                        ss_fprintf(ss, "%s%s = ", declarator_name, member->debug_name);
                        struct osstream local = { 0 };
                        d_visit_expression(ctx, &local, member->p_init_expression);
                        ss_fprintf(ss, "%s", local.c_str);
                        ss_fprintf(ss, ";\n");
                        ss_close(&local);
                        break;
                    }
                    else if (all)
                    {
                        print_identation_core(ss, ctx->indentation);
                        ss_fprintf(ss, "%s%s = 0;\n", declarator_name, member->debug_name);
                    }
                    member = member->next;
                }
            }
        }
        else
        {
            if (object->p_init_expression &&
                object->p_init_expression->expression_type == PRIMARY_EXPRESSION_STRING_LITERAL &&
                type_is_array(&object->type))
            {
                //char b[] = "abc";
                print_identation_core(ss, ctx->indentation);
                ss_fprintf(ss, "_cake_memcpy(%s%s, ", declarator_name, object->debug_name);
                struct osstream local = { 0 };
                d_visit_expression(ctx, &local, object->p_init_expression);
                ss_fprintf(ss, "%s, %d", local.c_str, object->type.num_of_elements);

                ss_fprintf(ss, ");\n");
                ss_close(&local);
                ctx->memcpy_used = true;
            }
            else
            {
                struct object* _Opt member = object->members;
                while (member)
                {
                    object_print_non_constant_initialization(ctx, ss, member, declarator_name, all);
                    member = member->next;
                }
            }
        }
    }
    else
    {
        if (object->p_init_expression)
        {
            if (!all)
            {
                if (object->p_init_expression->expression_type == PRIMARY_EXPRESSION_STRING_LITERAL)
                {
                    //skip
                }
                else if (!object_has_constant_value(&object->p_init_expression->object))
                {
                    print_identation_core(ss, ctx->indentation);
                    ss_fprintf(ss, "%s%s = ", declarator_name, object->debug_name);
                    struct osstream local = { 0 };
                    d_visit_expression(ctx, &local, object->p_init_expression);
                    ss_fprintf(ss, "%s", local.c_str);
                    ss_fprintf(ss, ";\n");
                    ss_close(&local);
                }
            }
            else
            {
                print_identation_core(ss, ctx->indentation);
                ss_fprintf(ss, "%s%s = ", declarator_name, object->debug_name);
                struct osstream local = { 0 };
                d_visit_expression(ctx, &local, object->p_init_expression);
                ss_fprintf(ss, "%s", local.c_str);
                ss_fprintf(ss, ";\n");
                ss_close(&local);
            }
        }
        else if (all)
        {
            print_identation_core(ss, ctx->indentation);
            ss_fprintf(ss, "%s%s = 0;\n", declarator_name, object->debug_name);
        }
    }
}


static void print_initializer(struct d_visit_ctx* ctx,
    struct osstream* oss,
    struct init_declarator* p_init_declarator,
    bool bstatic)
{
    assert(p_init_declarator->initializer != NULL);

    try
    {
        const bool is_local = ctx->is_local;

        if (p_init_declarator->initializer->assignment_expression)
        {
            if (is_local && !bstatic)
            {
                if (p_init_declarator->initializer->assignment_expression->expression_type == PRIMARY_EXPRESSION_STRING_LITERAL &&
                    type_is_array(&p_init_declarator->p_declarator->type))
                {
                    print_identation_core(oss, ctx->indentation);
                    ss_fprintf(oss, "_cake_memcpy(%s, ", p_init_declarator->p_declarator->name_opt->lexeme);
                    struct osstream local = { 0 };
                    d_visit_expression(ctx, &local, p_init_declarator->initializer->assignment_expression);
                    ss_fprintf(oss, "%s, %d", local.c_str, p_init_declarator->p_declarator->type.num_of_elements);

                    ss_fprintf(oss, ");\n");
                    ss_close(&local);
                    ctx->memcpy_used = true;
                }
                else
                {
                    //ss_fprintf(oss, ";\n");
                    print_identation_core(oss, ctx->indentation);
                    ss_fprintf(oss, "%s%s = ", p_init_declarator->p_declarator->name_opt->lexeme, "");

                    if (type_is_bool(&p_init_declarator->p_declarator->type))
                    {
                        expression_to_bool_value(ctx, oss, p_init_declarator->initializer->assignment_expression);
                    }
                    else
                    {
                        d_visit_expression(ctx, oss, p_init_declarator->initializer->assignment_expression);
                    }
                    ss_fprintf(oss, ";\n");
                }
            }
            else
            {
                ss_fprintf(oss, " = ");//, p_init_declarator->p_declarator->name_opt->lexeme, "");
                d_visit_expression(ctx, oss, p_init_declarator->initializer->assignment_expression);
                ss_fprintf(oss, ";\n");
            }
        }
        else
        {
            if (p_init_declarator->initializer->braced_initializer)
            {
                if (p_init_declarator->initializer->braced_initializer->initializer_list &&
                    p_init_declarator->initializer->braced_initializer->initializer_list->head)
                {
                    if (is_all_zero(&p_init_declarator->p_declarator->object))
                    {
                        if (is_local && !bstatic)
                        {
                            size_t sz = 0;
                            if (type_get_sizeof(&p_init_declarator->p_declarator->type, &sz, ctx->options.target) != 0)
                            {
                                throw;
                            }

                            // ss_fprintf(oss, ";\n");
                            print_identation_core(oss, ctx->indentation);
                            ss_fprintf(oss, "_cake_zmem(&%s, %zu);\n",
                            p_init_declarator->p_declarator->name_opt->lexeme,
                            sz);
                            ctx->zero_mem_used = true;
                        }
                        else
                        {
                            ss_fprintf(oss, " = ");
                            ss_fprintf(oss, "{0};\n");
                        }
                    }
                    else
                    {

                        bool first = true;
                        if (!is_local || bstatic)
                        {
                            ss_fprintf(oss, " = ");
                            ss_fprintf(oss, "{");
                            object_print_constant_initialization(ctx, oss, &p_init_declarator->p_declarator->object, &first);
                            ss_fprintf(oss, "}");
                            ss_fprintf(oss, ";\n");
                        }
                        else
                        {
                            //ss_fprintf(oss, ";\n");
                            object_print_non_constant_initialization(ctx, oss, &p_init_declarator->p_declarator->object, p_init_declarator->p_declarator->name_opt->lexeme, true);
                        }
                    }
                }
                else
                {
                    if (is_local && !bstatic)
                    {
                        size_t sz = 0;
                        if (type_get_sizeof(&p_init_declarator->p_declarator->type, &sz, ctx->options.target) != 0)
                        {
                            throw;
                        }

                        //ss_fprintf(oss, ";\n");
                        print_identation_core(oss, ctx->indentation);
                        ss_fprintf(oss, "_cake_zmem(&%s, %zu);\n",
                        p_init_declarator->p_declarator->name_opt->lexeme,
                        sz);
                        ctx->zero_mem_used = true;
                    }
                    else
                    {
                        ss_fprintf(oss, " = ");
                        ss_fprintf(oss, "{0};\n");
                    }
                    //ss_fprintf(oss, "{0};\n");
                }
            }
        }
    }
    catch
    {
    }
}


static void d_visit_init_declarator(struct d_visit_ctx* ctx,
    struct osstream* oss0,
    struct init_declarator* p_init_declarator,
    enum function_specifier_flags function_specifier_flags,
    enum storage_class_specifier_flags storage_class_specifier_flags)
{
    try
    {
        const char* declarator_name = "";
        if (p_init_declarator->p_declarator->name_opt)
            declarator_name = p_init_declarator->p_declarator->name_opt->lexeme;

        const bool is_function = type_is_function(&p_init_declarator->p_declarator->type);
        const bool is_inline = (function_specifier_flags & FUNCTION_SPECIFIER_INLINE);

        const bool is_block_scope = (storage_class_specifier_flags & STORAGE_SPECIFIER_BLOCK_SCOPE);
        const bool is_typedef = (storage_class_specifier_flags & STORAGE_SPECIFIER_TYPEDEF);
        const bool is_extern = (storage_class_specifier_flags & STORAGE_SPECIFIER_EXTERN);

        const bool is_function_body = p_init_declarator->p_declarator->function_body != NULL;

        if (is_typedef)
            return;
        const bool is_static = (storage_class_specifier_flags & STORAGE_SPECIFIER_STATIC);

        /*
         int i;               | !is_extern !is_block_scope !is_is_inline !is_static !is_function !is_function_body   |  action = ACTION_DECLARE;
         {int i;           }  | !is_extern  is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_DECLARE;
         extern void f() {}   |  is_extern !is_block_scope !is_inline !is_static  is_function  is_function_body   |  action = ACTION_DECLARE;
         void f() {}          | !is_extern !is_block_scope !is_inline !is_static  is_function  is_function_body   |  action = ACTION_DECLARE;
         static int i;        | !is_extern !is_block_scope !is_inline  is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         extern int i;        |  is_extern !is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         void f();            |  is_extern !is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         extern void f();     |  is_extern !is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         inline void f();     |  is_extern !is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         static void f();     |  is_extern !is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         inline void f() {}   |  is_extern !is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         static void f() {}   |  is_extern !is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         {extern int i;    }  |  is_extern  is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         {void f();        }  |  is_extern  is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         {extern void f(); }  |  is_extern  is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         {static int i;    }  |                                                                                   |  action = ACTION_ON_DEMAND_;/rename
         {inline void f() {}} |  |                                                                                |  action = ACTION_ON_DEMAND_;/rename
         {static void f() {}} |                                                                                   |  action = ACTION_ON_DEMAND_;/rename
         {inline void f();  } |  is_extern  is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         {static void f();  } |  is_extern  is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;
         {void f() {}       } |  is_extern  is_block_scope !is_inline !is_static !is_function !is_function_body   |  action = ACTION_ON_DEMAND_;/rename
         {extern void f() {}} |  is_extern  is_block_scope !is_inline !is_static !is_function !is_function_body   |  error
        */


        if (!is_extern && !is_block_scope && !is_inline && !is_static && !is_function && !is_function_body)
        {
            //int i;

            struct hash_item_set i = { 0 };
            i.number = 1;
            hashmap_set(&ctx->file_scope_declarator_map, p_init_declarator->p_declarator->name_opt->lexeme, &i);

            struct osstream ss = { 0 };
            d_print_type(ctx, &ss,
               &p_init_declarator->p_declarator->type,
               p_init_declarator->p_declarator->name_opt->lexeme
            );

            ss_fprintf(oss0, "%s", ss.c_str);

            if (p_init_declarator->initializer)
            {
                print_initializer(ctx, oss0, p_init_declarator, true);
            }
            else
                ss_fprintf(oss0, ";\n");

            ss_close(&ss);
            return;
        }
        else if (!is_extern && is_block_scope && !is_inline && !is_static && !is_function && !is_function_body)
        {
            //{ int i; }
            struct osstream ss = { 0 };
            d_print_type(ctx, &ss,
              &p_init_declarator->p_declarator->type,
              p_init_declarator->p_declarator->name_opt->lexeme);

            print_identation(ctx, &ctx->block_scope_declarators);

            ss_fprintf(&ctx->block_scope_declarators, "%s;\n", ss.c_str);
            ss_close(&ss);

            if (p_init_declarator->initializer)
            {
                //print_identation(ctx, &ctx->block_scope_declarators);

                print_initializer(ctx, oss0, p_init_declarator, false);
            }

            return;
        }
        else if (!is_block_scope && !is_inline && !is_static && is_function && is_function_body)
        {
            // extern void f() {} 
            //        void f() {} 
            //action = ACTION_DECLARE;
            struct osstream ss = { 0 };
            d_print_type(ctx, &ss,
               &p_init_declarator->p_declarator->type,
               p_init_declarator->p_declarator->name_opt->lexeme);

            struct hash_item_set i = { 0 };
            i.number = 1;
            hashmap_set(&ctx->file_scope_declarator_map, p_init_declarator->p_declarator->name_opt->lexeme, &i);

            ss_fprintf(&ss, "\n");
            d_visit_function_body(ctx, &ss, p_init_declarator->p_declarator);
            ss_fprintf(&ss, "\n");

            ss_fprintf(oss0, "%s\n", ss.c_str);
            ss_close(&ss);
            return;
        }
        else
        {
            bool rename_declarator = false;
            if (!is_extern && is_block_scope && !is_inline && is_static && !is_function && !is_function_body)
            {
                //{ static int i; }
                rename_declarator = true;
            }
            else if (!is_extern && is_block_scope && is_inline && !is_static && is_function && is_function_body)
            {
                //{inline void f() {}}

                rename_declarator = true;
            }
            else if (!is_extern && is_block_scope && !is_inline && is_static && is_function && is_function_body)
            {
                //{static void f() {}}
                rename_declarator = true;
            }
            else if (!is_extern && is_block_scope && !is_inline && !is_static && is_function && is_function_body)
            {
                //{void f() {}       }
                rename_declarator = true;
            }

            if (rename_declarator)
            {
                char name[100] = { 0 };
                snprintf(name, sizeof(name),
                    CAKE_PREFIX_FOR_CODE_GENERATION "%d_%s",
                    ctx->cake_declarator_number++,
                    p_init_declarator->p_declarator->name_opt->lexeme
                );

                free(p_init_declarator->p_declarator->name_opt->lexeme);
                p_init_declarator->p_declarator->name_opt->lexeme = strdup(name);
            }
            return;
        }
    }
    catch
    {
    }
}

static void d_visit_init_declarator_list(struct d_visit_ctx* ctx,
    struct osstream* oss,
    struct init_declarator_list* p_init_declarator_list,
    enum function_specifier_flags function_specifier_flags,
    enum storage_class_specifier_flags storage_class_specifier_flags)
{
    struct init_declarator* _Opt p_init_declarator = p_init_declarator_list->head;

    while (p_init_declarator)
    {
        d_visit_init_declarator(ctx, oss, p_init_declarator, function_specifier_flags, storage_class_specifier_flags);
        p_init_declarator = p_init_declarator->next;
    }
}


static void d_visit_declaration(struct d_visit_ctx* ctx, struct osstream* oss, struct declaration* p_declaration)
{
    if (p_declaration->init_declarator_list.head)
    {
        assert(p_declaration->declaration_specifiers != NULL);

        enum storage_class_specifier_flags storage_class_specifier_flags =
            p_declaration->declaration_specifiers->storage_class_specifier_flags;

        enum function_specifier_flags function_specifier_flags =
            p_declaration->declaration_specifiers->function_specifier_flags;

        d_visit_init_declarator_list(ctx, oss, &p_declaration->init_declarator_list, function_specifier_flags, storage_class_specifier_flags);
    }
}

static void print_complete_struct(struct d_visit_ctx* ctx, struct osstream* ss, struct struct_or_union_specifier* p_struct_or_union_specifier)
{
    try
    {
        struct struct_or_union_specifier* _Opt p_complete =
            get_complete_struct_or_union_specifier2(p_struct_or_union_specifier);

        if (p_complete == NULL)
            throw;

        struct member_declaration* _Opt member_declaration =
            p_complete->member_declaration_list.head;

        if (struct_or_union_specifier_is_union(p_complete))
        {
            ss_fprintf(ss, "union %s", p_complete->tag_name);
        }
        else
        {
            ss_fprintf(ss, "struct %s", p_complete->tag_name);
        }

        if (p_complete->member_declaration_list.head)
        {
            ss_fprintf(ss, " ");
            ss_fprintf(ss, "{\n");
        }

        int no_name_index = 0;

        while (member_declaration)
        {
            struct member_declarator* _Opt member_declarator = NULL;

            if (member_declaration->member_declarator_list_opt)
            {
                member_declarator = member_declaration->member_declarator_list_opt->head;

                while (member_declarator)
                {
                    if (member_declarator->declarator &&
                        member_declarator->declarator->name_opt)
                    {
                        ss_fprintf(ss, "    ");

                        if (type_is_array(&member_declarator->declarator->type) &&
                            member_declarator->declarator->type.num_of_elements == 0)
                        {
                            //Flexible array members - we print as [1] instead 
                            // of [0] or []
                            //sizeof is not used in generated code, so this will not cause 
                            //problems
                            member_declarator->declarator->type.num_of_elements = 1;

                            d_print_type(ctx,
                             ss,
                             &member_declarator->declarator->type,
                             member_declarator->declarator->name_opt->lexeme);

                            member_declarator->declarator->type.num_of_elements = 0; //restore
                        }
                        else
                        {
                            d_print_type(ctx,
                                ss,
                                &member_declarator->declarator->type,
                                member_declarator->declarator->name_opt->lexeme);
                        }
                        ss_fprintf(ss, ";\n");
                    }
                    member_declarator = member_declarator->next;
                }
            }
            else if (member_declaration->specifier_qualifier_list != NULL)
            {
                if (member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                {
                    struct type t = { 0 };
                    t.category = TYPE_CATEGORY_ITSELF;
                    t.struct_or_union_specifier = member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                    t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                    char name[100] = { 0 };
                    snprintf(name, sizeof name, "__m%d", no_name_index++);
                    ss_fprintf(ss, "    ");
                    d_print_type(ctx, ss, &t, name);
                    ss_fprintf(ss, ";\n");
                    type_destroy(&t);
                }
            }


            member_declaration = member_declaration->next;
        }
        if (p_complete->member_declaration_list.head)
            ss_fprintf(ss, "};\n\n");
        else
            ss_fprintf(ss, ";\n");
    }
    catch
    {
    }
}

void print_complete_structs(struct d_visit_ctx* ctx, struct osstream* ss, struct struct_entry* p_struct_entry)
{
    if (p_struct_entry->done)
        return;

    for (int i = 0; i < p_struct_entry->dependencies.size; i++)
    {
        struct struct_entry* p_struct_entry_item = p_struct_entry->dependencies.data[i];
        print_complete_structs(ctx, ss, p_struct_entry_item);
    }

    if (!p_struct_entry->done)
    {
        p_struct_entry->done = true;
        struct osstream local = { 0 };
        print_complete_struct(ctx, &local, p_struct_entry->p_struct_or_union_specifier);
        if (local.c_str)
            ss_fprintf(ss, local.c_str);
        ss_close(&local);
    }
}

void d_visit(struct d_visit_ctx* ctx, struct osstream* oss)
{
    struct osstream declarations = { 0 };

    ss_fprintf(oss, "// Cake %s target=%s\n", CAKE_VERSION, target_to_string(ctx->options.target));

    ctx->indentation = 0;
    struct declaration* _Opt p_declaration = ctx->ast.declaration_list.head;
    while (p_declaration)
    {
        ss_clear(&ctx->add_this_after_external_decl);
        ss_clear(&ctx->add_this_before_external_decl);


        struct osstream declaration = { 0 };
        d_visit_declaration(ctx, &declaration, p_declaration);


        if (ctx->add_this_before.size > 0)
        {
            ss_fprintf(oss, "%s", ctx->add_this_before.c_str);
            ss_clear(&ctx->add_this_before);

        }
        if (ctx->add_this_before_external_decl.size > 0)
        {
            ss_fprintf(&declarations, "%s\n", ctx->add_this_before_external_decl.c_str);
            ss_clear(&ctx->add_this_before_external_decl);
        }
        if (declaration.size > 0)
            ss_fprintf(&declarations, "%s", declaration.c_str);

        if (ctx->add_this_after_external_decl.c_str)
            ss_fprintf(&declarations, "%s", ctx->add_this_after_external_decl.c_str);

        ss_close(&declaration);

        p_declaration = p_declaration->next;
    }

#if 0
    const char* str
        =
        "/* Generated by Cake - C89 compliant source code \n"
        "   PREVIEW - WORK IN PROGRESS \n"
        "*/\n\n";

    ss_fprintf(oss, "%s", str);
#endif


    for (int i = 0; i < ctx->structs_map.capacity; i++)
    {
        struct map_entry* _Opt entry = ctx->structs_map.table[i];
        while (entry)
        {
            assert(entry->data.p_struct_entry != NULL);
            print_complete_structs(ctx, oss, entry->data.p_struct_entry);
            entry = entry->next;
        }
    }
    ss_fprintf(oss, "\n");

    if (ctx->zero_mem_used)
    {
        const char* str =
            "static void _cake_zmem(void *dest, register " SIZE_T_TYPE_STR " len)\n"
            "{\n"
            "  register unsigned char *ptr = (unsigned char*)dest;\n"
            "  while (len-- > 0) *ptr++ = 0;\n"
            "}\n\n";
        ss_fprintf(oss, "%s", str);
    }

    if (ctx->memcpy_used)
    {
        const char* str =
            "static void _cake_memcpy(void * dest, const void * src, " SIZE_T_TYPE_STR " n)\n"
            "{\n"
            "  char *csrc = (char *)src;\n"
            "  char *cdest = (char *)dest;\n"
            "  " SIZE_T_TYPE_STR " i; \n"
            "  for (i = 0; i < n; i++) cdest[i] = csrc[i]; \n"
            "}\n\n";
        ss_fprintf(oss, "%s", str);
    }


    if (declarations.c_str)
    {
        ss_fprintf(oss, "%s", declarations.c_str);
    }


    ss_close(&declarations);
}


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable


struct object_visitor
{
    int member_index;
    struct type* p_type;
    struct flow_object* p_object;
};

unsigned int s_visit_number = 1; //creates a unique number
_Opt struct flow_object* _Opt arena_new_object(struct flow_visit_ctx* ctx);

bool flow_object_is_not_null(const struct flow_object* p)
{
    enum flow_state e = p->current.state;
    return (
             !(e & FLOW_OBJECT_STATE_NULL) &&
             ((e & FLOW_OBJECT_STATE_NOT_NULL) || (e & FLOW_OBJECT_STATE_MOVED))
           );

}

bool flow_object_can_be_not_null_or_moved(const struct flow_object* p)
{
    enum flow_state e = p->current.state;
    return (e & FLOW_OBJECT_STATE_NOT_NULL) ||
        (e & FLOW_OBJECT_STATE_MOVED);
}

bool flow_object_is_null(const struct flow_object* p)
{
    enum flow_state e = p->current.state;
    return ((e & FLOW_OBJECT_STATE_NULL) &&
           !(e & FLOW_OBJECT_STATE_NOT_NULL) &&
           !(e & FLOW_OBJECT_STATE_MOVED));
}

bool flow_object_is_zero(const struct flow_object* p)
{
    enum flow_state e = p->current.state;
    return ((e & FLOW_OBJECT_STATE_ZERO) &&
            !(e & FLOW_OBJECT_STATE_NOT_ZERO));
}

bool flow_object_is_not_zero(const struct flow_object* p)
{
    enum flow_state e = p->current.state;
    return (!(e & FLOW_OBJECT_STATE_ZERO) &&
           (e & FLOW_OBJECT_STATE_NOT_ZERO));
}


bool flow_object_can_be_zero(const struct flow_object* p)
{
    enum flow_state e = p->current.state;

    return (e & FLOW_OBJECT_STATE_ZERO);
}

bool flow_object_can_be_moved(const struct flow_object* p)
{
    enum flow_state e = p->current.state;

    return (e & FLOW_OBJECT_STATE_MOVED);
}

bool flow_object_can_be_null(const struct flow_object* p)
{
    enum flow_state e = p->current.state;

    return (e & FLOW_OBJECT_STATE_NULL);
}

bool flow_object_is_uninitialized(const struct flow_object* p)
{
    enum flow_state e = p->current.state;
    return e == FLOW_OBJECT_STATE_UNINITIALIZED;
}

bool flow_object_can_be_uninitialized(const struct flow_object* p)
{
    enum flow_state e = p->current.state;
    return (e & FLOW_OBJECT_STATE_UNINITIALIZED);
}

bool flow_object_can_have_its_lifetime_ended(const struct flow_object* p)
{
    enum flow_state e = p->current.state;
    return (e & FLOW_OBJECT_STATE_LIFE_TIME_ENDED);
}


static void object_state_to_string_core(enum flow_state e)
{
    bool first = true;

    printf("\"");
    if (e & FLOW_OBJECT_STATE_UNINITIALIZED)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("uninitialized");
    }

    if (e & FLOW_OBJECT_STATE_NOT_NULL)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("not-null");
    }

    if (e & FLOW_OBJECT_STATE_NULL)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("null");
    }

    if (e & FLOW_OBJECT_STATE_ZERO)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("zero");
    }

    if (e & FLOW_OBJECT_STATE_NOT_ZERO)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("not-zero");
    }


    if (e & FLOW_OBJECT_STATE_LIFE_TIME_ENDED)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("lifetime-ended");
    }

    if (e & FLOW_OBJECT_STATE_MOVED)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("moved");
    }

    printf("\"");

}

void flow_object_state_delete(struct flow_object_state* _Owner _Opt p)
{
    if (p)
    {
        objects_view_destroy(&p->alternatives);
        assert(p->next == NULL);
        free(p);
    }
}
void flow_object_state_copy(struct flow_object_state* to, const struct flow_object_state* from)
{
    to->state = from->state;
    to->pointed = from->pointed;
    objects_view_copy(&to->alternatives, &from->alternatives);
}

void flow_object_print_state(struct flow_object* p)
{
    object_state_to_string_core(p->current.state);
}

void object_state_set_item_print(struct flow_object_state* item)
{
    object_state_to_string_core(item->state);
}

bool flow_object_is_expansible(const struct flow_object* _Opt p_object)
{
    return (p_object &&
            p_object->current.state != FLOW_OBJECT_STATE_NULL &&
                p_object->current.state != FLOW_OBJECT_STATE_UNINITIALIZED &&
                p_object->current.pointed == 0);
}

void flow_object_expand_pointer(struct flow_visit_ctx* ctx, struct type* p_type, struct flow_object* p_object)
{
    assert(type_is_pointer_or_array(p_type));

    if (flow_object_is_expansible(p_object))
    {
        const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

        struct type t2 = type_remove_pointer(p_type);
        if (!type_is_void(&t2))
        {
            struct flow_object* _Opt p_object2 = make_flow_object(ctx, &t2, p_object->p_declarator_origin, p_object->p_expression_origin);
            if (p_object2)
            {
                const bool is_nullable = type_is_opt(&t2, nullable_enabled);
                flow_object_set_unknown(&t2, is_nullable, p_object2, nullable_enabled);
                object_set_pointer(p_object, p_object2);////obj.pointed2 = p_object;
                flow_object_push_states_from(p_object, p_object2);
            }
            else
            {
                //ops
            }
        }
        type_destroy(&t2);
    }
}

void flow_object_swap(struct flow_object* a, struct flow_object* b)
{
    struct flow_object temp = *a;
    *a = *b;
    *b = temp;
}

void flow_object_delete(struct flow_object* _Owner _Opt p)
{
    if (p)
    {
        flow_object_destroy(p);
        free(p);
    }
}
int objects_view_reserve(struct flow_objects_view* p, int n);
void object_set_pointer(struct flow_object* p_object, struct flow_object* p_object2)
{
    p_object->current.pointed = p_object2;
}

void flow_object_destroy(_Dtor struct flow_object* p)
{
    objects_view_destroy(&p->members);

    struct flow_object_state* _Owner _Opt p_flow_object_state = p->current.next;
    while (p_flow_object_state)
    {
        struct flow_object_state* _Owner _Opt temp = p_flow_object_state->next;
        p_flow_object_state->next = NULL;
        flow_object_state_delete(p_flow_object_state);
        p_flow_object_state = temp;
    }
    objects_view_destroy(&p->current.alternatives);
}

void flow_object_update_current(struct flow_object* p)
{
    if (p->current.alternatives.size > 0)
    {
        p->current.state = 0;
        for (int i = 0; i < p->current.alternatives.size; i++)
        {
            //infinite recursion?
            flow_object_update_current(p->current.alternatives.data[i]);
            p->current.state |= p->current.alternatives.data[i]->current.state;
        }
    }
}

void flow_object_set_current_state_to_can_be_null(struct flow_object* p)
{
    p->current.state |= FLOW_OBJECT_STATE_NULL;
}

void flow_object_set_current_state_to_is_null(struct flow_object* p)
{
    p->current.state = FLOW_OBJECT_STATE_NULL;
    if (p->current.alternatives.size > 0)
    {
        for (int i = 0; i < p->current.alternatives.size; i++)
        {
            flow_object_set_current_state_to_can_be_null(p->current.alternatives.data[i]);
        }
    }
}

int flow_object_add_state(struct flow_object* p, struct flow_object_state* _Owner pnew)
{
    assert(pnew->next == NULL);
    pnew->next = p->current.next;
    p->current.next = pnew;
    return 0;
}





void objects_view_destroy(_Dtor struct flow_objects_view* p)
{
    free(p->data);
}


int objects_view_reserve(struct flow_objects_view* p, int n)
{
    if (n > p->capacity)
    {
        if ((size_t)n > (SIZE_MAX / (sizeof(p->data[0]))))
        {
            return EOVERFLOW;
        }

        void* _Owner _Opt pnew = realloc(p->data, n * sizeof(p->data[0]));
        if (pnew == NULL) return ENOMEM;

        static_set(p->data, "moved"); //p->data was moved to pnew

        p->data = pnew;
        p->capacity = n;
    }
    return 0;
}


int objects_view_push_back(struct flow_objects_view* p, struct flow_object* p_object)
{
    if (p->size == INT_MAX)
    {
        return EOVERFLOW;
    }

    if (p->size + 1 > p->capacity)
    {
        int new_capacity = 0;
        if (p->capacity > (INT_MAX - p->capacity / 2))
        {
            /*overflow*/
            new_capacity = INT_MAX;
        }
        else
        {
            new_capacity = p->capacity + p->capacity / 2;
            if (new_capacity < p->size + 1)
            {
                new_capacity = p->size + 1;
            }
        }

        int error = objects_view_reserve(p, new_capacity);
        if (error != 0)
        {
            return error;
        }
    }

    p->data[p->size] = p_object;


    p->size++;

    return 0;
}

void objects_view_clear(struct flow_objects_view* p)
{
    p->size = 0;
}

void objects_view_merge(struct flow_objects_view* dest, const struct flow_objects_view* source)
{
    for (int i = 0; i < source->size; i++)
    {
        if (!objects_view_find(dest, source->data[i]))
        {
            objects_view_push_back(dest, source->data[i]);
        }
    }
}

void objects_view_copy(struct flow_objects_view* dest, const struct flow_objects_view* source)
{
    objects_view_reserve(dest, source->size);
    for (int i = 0; i < source->size; i++)
    {
        dest->data[i] = source->data[i];
    }
    dest->size = source->size;
}

bool objects_view_find(const struct flow_objects_view* p, const struct flow_object* p_object)
{
    for (int i = 0; i < p->size; i++)
    {
        if (p->data[i] == p_object)
            return true;
    }
    return false;
}
void flow_objects_destroy(_Dtor struct flow_objects* p)
{
    for (int i = 0; i < p->size; i++)
    {
        flow_object_delete(p->data[i]);
    }
    free(p->data);
}

void flow_objects_clear(struct flow_objects* p)
{
    for (int i = 0; i < p->size; i++)
    {
        flow_object_delete(p->data[i]);
    }
    p->size = 0;
}

int objects_reserve(struct flow_objects* p, int n)
{
    if (n > p->capacity)
    {
        if ((size_t)n > (SIZE_MAX / (sizeof(p->data[0]))))
        {
            return EOVERFLOW;
        }

        void* _Owner _Opt pnew = realloc(p->data, n * sizeof(p->data[0]));
        if (pnew == NULL) return ENOMEM;

        static_set(p->data, "moved"); //p->data was moved to pnew

        p->data = pnew;
        p->capacity = n;
    }
    return 0;
}

const struct flow_object* _Opt flow_objects_find(const struct flow_objects* p_objects, const struct flow_object* object)
{
    for (int i = 0; i < p_objects->size; i++)
    {
        if (p_objects->data[i] == object)
            return object;
    }
    return NULL;
}

int flow_objects_push_back(struct flow_objects* p, struct flow_object* _Owner p_object)
{
    if (p->size == INT_MAX)
    {
        flow_object_delete(p_object);
        return EOVERFLOW;
    }

    if (p->size + 1 > p->capacity)
    {
        int new_capacity = 0;
        if (p->capacity > (INT_MAX - p->capacity / 2))
        {
            /*overflow*/
            new_capacity = INT_MAX;
        }
        else
        {
            new_capacity = p->capacity + p->capacity / 2;
            if (new_capacity < p->size + 1)
            {
                new_capacity = p->size + 1;
            }
        }

        int error = objects_reserve(p, new_capacity);
        if (error != 0)
        {
            flow_object_delete(p_object);
            return error;
        }
        assert(p->data != NULL);
    }

    p->data[p->size] = p_object; /*moved*/


    p->size++;

    return 0;
}
struct object_name_list
{
    const char* name;
    struct object_name_list* _Opt previous;
};

bool has_name(const char* name, struct object_name_list* list)
{
    struct object_name_list* _Opt p = list;

    while (p)
    {
        if (strcmp(p->name, name) == 0)
        {
            return true;
        }
        p = p->previous;
    }
    return false;
}

struct flow_object* _Opt make_object_core(struct flow_visit_ctx* ctx,
    struct type* p_type,
    struct object_name_list* list,
    const struct declarator* _Opt p_declarator_opt,
    const struct expression* _Opt p_expression_origin)
{
    //assert((p_declarator_opt == NULL) != (p_expression_origin == NULL));
    if (p_declarator_opt == NULL)
    {
        //assert(p_expression_origin != NULL);
    }
    if (p_expression_origin == NULL)
    {
        // assert(p_declarator_opt != NULL);
    }


    struct flow_object* _Opt p_object = arena_new_object(ctx);

    try
    {
        if (p_object == NULL) throw;

        p_object->p_expression_origin = p_expression_origin;
        p_object->p_declarator_origin = p_declarator_opt;

        if (p_type->struct_or_union_specifier)
        {
            struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
                get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

            if (p_struct_or_union_specifier)
            {
                p_object->current.state = FLOW_OBJECT_STATE_NOT_APPLICABLE;

                struct member_declaration* _Opt p_member_declaration =
                    p_struct_or_union_specifier->member_declaration_list.head;

                struct object_name_list l = {
                  .name = p_struct_or_union_specifier->tag_name,
                  .previous = list
                };


                //int member_index = 0;
                while (p_member_declaration)
                {
                    if (p_member_declaration->member_declarator_list_opt)
                    {
                        struct member_declarator* _Opt p_member_declarator =
                            p_member_declaration->member_declarator_list_opt->head;

                        while (p_member_declarator)
                        {
                            if (p_member_declarator->declarator)
                            {
                                char* _Opt tag = NULL;
                                if (p_member_declarator->declarator->type.struct_or_union_specifier)
                                {
                                    tag = p_member_declarator->declarator->type.struct_or_union_specifier->tag_name;
                                }
                                else if (p_member_declarator->declarator->type.next &&
                                    p_member_declarator->declarator->type.next->struct_or_union_specifier)
                                {
                                    tag = p_member_declarator->declarator->type.next->struct_or_union_specifier->tag_name;

                                }

                                if (tag && has_name(tag, &l))
                                {
                                    struct flow_object* _Opt member_obj = arena_new_object(ctx);
                                    if (member_obj == NULL)
                                    {
                                        throw;
                                    }

                                    member_obj->parent = p_object;

                                    member_obj->p_expression_origin = p_expression_origin;
                                    member_obj->p_declarator_origin = p_declarator_opt;
                                    member_obj->current.state = FLOW_OBJECT_STATE_NOT_APPLICABLE;
                                    objects_view_push_back(&p_object->members, member_obj);
                                }
                                else
                                {
                                    struct flow_object* _Opt p_member_obj =
                                        make_object_core(ctx,
                                            &p_member_declarator->declarator->type,
                                            &l,
                                            p_declarator_opt,
                                            p_expression_origin);

                                    if (p_member_obj == NULL)
                                    {
                                        throw;
                                    }
                                    p_member_obj->parent = p_object;
                                    objects_view_push_back(&p_object->members, p_member_obj);
                                }
                            }
                            p_member_declarator = p_member_declarator->next;
                        }
                    }
                    else if (p_member_declaration->specifier_qualifier_list != NULL)
                    {
                        if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                        {
                            struct type t = { 0 };
                            t.category = TYPE_CATEGORY_ITSELF;
                            t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                            t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                            struct flow_object* _Opt member_obj = make_object_core(ctx, &t, &l, p_declarator_opt, p_expression_origin);
                            if (member_obj == NULL)
                            {
                                type_destroy(&t);
                                throw;
                            }

                            for (int k = 0; k < member_obj->members.size; k++)
                            {
                                objects_view_push_back(&p_object->members, member_obj->members.data[k]);
                                member_obj->members.data[k] = NULL;
                            }

                            type_destroy(&t);
                        }
                    }
                    p_member_declaration = p_member_declaration->next;
                }
                return p_object;
            }
            return p_object;
        }


        else if (type_is_array(p_type))
        {
            //p_object->state = flags;
            //if (p_object->members_size > 0)
            //{
            //    //not sure if we instanticate all items of array
            //    p_object->members[0].state = flags;
            //}
            //TODO create object for fixed len arrays!
            return p_object;
        }


        p_object->current.state = FLOW_OBJECT_STATE_UNINITIALIZED;
    }
    catch
    {
        p_object = NULL;
    }
    return p_object;
}

struct flow_object* _Opt make_flow_object(struct flow_visit_ctx* ctx,
    struct type* p_type,
                           const struct declarator* _Opt p_declarator_opt,
                           const struct expression* _Opt p_expression_origin)
{

    struct object_name_list list = { .name = "" };
    struct flow_object* _Opt p_object = make_object_core(ctx, p_type, &list, p_declarator_opt, p_expression_origin);

    return p_object;
}

struct token* _Opt flow_object_get_token(const struct flow_object* object)
{
    if (object->p_declarator_origin)
    {
        return object->p_declarator_origin->name_opt;
    }
    if (object->p_expression_origin)
    {
        return object->p_expression_origin->first_token;
    }
    return NULL;
}

void flow_object_add_new_state_as_a_copy_of_current_state(struct flow_object* object, const char* name, int state_number)
{
    _Opt struct flow_object_state* _Owner _Opt pnew = calloc(1, sizeof * pnew);
    if (pnew == NULL) return;//ENOMEM;

    pnew->dbg_name = name;
    pnew->state_number = state_number;


    pnew->next = object->current.next;
    object->current.next = pnew;

    flow_object_state_copy(pnew, &object->current);
    //TODO fix pnew is changed..
}

void flow_object_remove_state(struct flow_object* object, int state_number)
{
    struct flow_object_state* previous = &object->current;
    struct flow_object_state* _Opt it = object->current.next;
    while (it)
    {
        if (it->state_number == state_number)
        {
            struct flow_object_state* _Owner _Opt p_it_next = it->next;
            it->next = NULL;
            flow_object_state_delete(previous->next);
            previous->next = p_it_next;
            break;
        }
        previous = it;
        it = it->next;
    }

}

void print_object_core(int ident,
    struct object_visitor* p_visitor,
    const char* previous_names,
    bool is_pointer,
    bool short_version,
    unsigned int visit_number)
{
    if (p_visitor->p_object->visit_number == visit_number) return;
    p_visitor->p_object->visit_number = visit_number;

    if (p_visitor->p_type->struct_or_union_specifier)
    {
        assert(p_visitor->p_object->current.state == FLOW_OBJECT_STATE_NOT_APPLICABLE);
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            printf("%*c", ident + 1, ' ');
            printf("#%02d {\n", p_visitor->p_object->id);

            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;


            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            const char* name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "";

                            char buffer[200] = { 0 };
                            if (is_pointer)
                                snprintf(buffer, sizeof buffer, "%s->%s", previous_names, name);
                            else
                                snprintf(buffer, sizeof buffer, "%s.%s", previous_names, name);

                            _Opt struct object_visitor visitor = { 0 };
                            visitor.p_type = &p_member_declarator->declarator->type;
                            visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];

                            print_object_core(ident + 2, &visitor, buffer,
                                type_is_pointer(&p_member_declarator->declarator->type), short_version,
                                visit_number);

                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else if (p_member_declaration->specifier_qualifier_list != NULL)
                {
                    struct type t = { 0 };
                    t.category = TYPE_CATEGORY_ITSELF;
                    t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                    t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;


                    struct type* temp = p_visitor->p_type;
                    p_visitor->p_type = &t;

                    int visit_number0 = p_visitor->p_object->visit_number;
                    p_visitor->p_object->visit_number = 0;
                    print_object_core(ident + 1,
                        p_visitor,
                        previous_names,
                        false,
                        short_version,
                        visit_number);

                    p_visitor->p_type = temp; //restore
                    p_visitor->p_object->visit_number = visit_number0;
                    type_destroy(&t);
                }
                p_member_declaration = p_member_declaration->next;
            }

            printf("%*c", ident + 1, ' ');
            printf("}\n");
        }
    }
    else if (type_is_pointer(p_visitor->p_type))
    {
        struct type t2 = type_remove_pointer(p_visitor->p_type);
        printf("%*c", ident, ' ');

        if (short_version)
        {
            printf("#%02d %s == ", p_visitor->p_object->id, previous_names);
            flow_object_print_state(p_visitor->p_object);
            if (flow_object_is_null(p_visitor->p_object))
            {
            }
            else if (flow_object_can_be_uninitialized(p_visitor->p_object))
            {
            }
            else
            {
                printf(" -> ");

                if (p_visitor->p_object->current.pointed != NULL)
                {
                    printf(" #%02d", p_visitor->p_object->current.pointed->id);
                }
                else
                {
                    printf("{...}");
                }
            }
        }
        else
        {
            printf("%p:%s == ", p_visitor->p_object, previous_names);
            printf("{");

            struct flow_object_state* _Opt it = p_visitor->p_object->current.next;
            while (it)
            {
                printf(LIGHTCYAN);
                printf("(#%02d %s)", it->state_number, it->dbg_name);
                object_state_set_item_print(it);
                printf(RESET);
                printf(",");
                it = it->next;
            }
            //printf("*");
            printf(LIGHTMAGENTA);
            printf("(current)");
            flow_object_print_state(p_visitor->p_object);
            printf(RESET);
            printf("}");
        }
        printf("\n");

#if 0
        if (p_visitor->p_object->current.ref.size > 0)
        {
            char buffer[200] = { 0 };
            if (type_is_struct_or_union(&t2))
            {
                snprintf(buffer, sizeof buffer, "%s", previous_names);
            }
            else
            {
                snprintf(buffer, sizeof buffer, "*%s", previous_names);
            }

            for (int i = 0; i < p_visitor->p_object->current.ref.size; i++)
            {
                struct object_visitor visitor = { 0 };
                visitor.p_type = &t2;
                visitor.p_object = p_visitor->p_object->current.ref.data[i];
                print_object_core(ident + 1, &visitor, buffer, is_pointer, short_version, visit_number);
            }
        }
#endif
        type_destroy(&t2);
    }
    else
    {
        printf("%*c", ident, ' ');

        if (short_version)
        {
            printf("#%02d %s == ", p_visitor->p_object->id, previous_names);
            flow_object_print_state(p_visitor->p_object);
        }
        else
        {
            printf("%p:%s == ", p_visitor->p_object, previous_names);
            printf("{");

            struct flow_object_state* _Opt it = p_visitor->p_object->current.next;
            while (it)
            {
                printf("(#%02d %s)", it->state_number, it->dbg_name);
                object_state_set_item_print(it);
                printf(",");
                it = it->next;
            }


            flow_object_print_state(p_visitor->p_object);
            printf("}");
        }

        printf("\n");
    }


}


void flow_object_merge_state(struct flow_object* pdest, struct flow_object* object1, struct flow_object* object2)
{
    pdest->current.state = object1->current.state | object2->current.state;

    if (pdest->members.size == object1->members.size &&
        object1->members.size == object2->members.size)
    {
        for (int i = 0; i < object1->members.size; i++)
        {
            struct flow_object* m1 = object1->members.data[i];
            struct flow_object* m2 = object2->members.data[i];
            flow_object_merge_state(pdest->members.data[i], m1, m2);
        }
    }

#if 0
    for (int i = 0; i < object1->current.ref.size; i++)
    {
        struct flow_object* pointed = object1->current.ref.data[i];
        if (pointed)
        {
            objects_view_push_back(&pdest->current.ref, pointed);
        }
    }

    for (int i = 0; i < object2->current.ref.size; i++)
    {
        struct flow_object* pointed = object2->current.ref.data[i];
        if (pointed)
        {
            objects_view_push_back(&pdest->current.ref, pointed);
        }
    }

#endif


}


int object_restore_current_state_from_core(struct flow_object* object, int state_number, unsigned int visit_number)
{
    if (object->visit_number == visit_number) return 1;//already visited    
    object->visit_number = visit_number;


    struct flow_object_state* _Opt it = object->current.next;
    while (it)
    {
        if (it->state_number == state_number)
        {
            object->current.state = it->state;
#if 0
            objects_view_copy(&object->current.ref, &it->ref);
#endif
            break;
        }
        it = it->next;
    }

    for (int i = 0; i < object->members.size; i++)
    {
        object_restore_current_state_from_core(object->members.data[i], state_number, visit_number);
    }
#if 0
    for (int i = 0; i < object->current.ref.size; i++)
    {
        struct flow_object* pointed = object->current.ref.data[i];

        if (pointed)
        {
            object_restore_current_state_from_core(pointed, state_number, visit_number);
        }
    }
#endif
    return 1;
}

int flow_object_restore_current_state_from(struct flow_object* object, int state_number)
{
    return object_restore_current_state_from_core(object, state_number, s_visit_number++);
}

int object_merge_current_state_with_state_number_core(struct flow_object* object, int state_number, unsigned int visit_number)
{
    if (object->visit_number == visit_number)
    {
        return 1;//already visited
    }
    object->visit_number = visit_number;

    struct flow_object_state* _Opt it = object->current.next;
    while (it)
    {
        if (it->state_number == state_number)
        {
            it->state |= object->current.state;
#if 0
            objects_view_merge(&it->ref, &object->current.ref);
#endif
            break;
        }
        it = it->next;
    }

    for (int i = 0; i < object->members.size; i++)
    {
        object_merge_current_state_with_state_number_core(object->members.data[i], state_number, visit_number);
    }
    if (object->current.state == FLOW_OBJECT_STATE_NULL ||
        object->current.state == FLOW_OBJECT_STATE_UNINITIALIZED) //moved
    {
        /*
        struct Y { int i; };
        struct X { struct Y y;  };

        struct X* _Opt _Owner create(struct Y* pY)
        {
            struct X* _Opt _Owner p  = malloc(sizeof * p);
            if (p)  {
                p->y = *pY;
            }
            else
            {
               //p is null, so the pointed object does not need to merge
            }
            return p;
        */
    }
    else
    {
#if 0
        for (int i = 0; i < object->current.ref.size; i++)
        {

            struct flow_object* pointed = object->current.ref.data[i];
            if (pointed)
            {
                object_merge_current_state_with_state_number_core(pointed, state_number, visit_number);
            }

        }
#endif
    }
    return 1;
}


void object_get_name(const struct type* p_type,
    const struct flow_object* p_object,
    char* outname,
    int out_size);


void print_flow_object(struct type* p_type, struct flow_object* p_object, bool short_version)
{
    char name[100] = { 0 };
    object_get_name(p_type, p_object, name, sizeof name);

    _Opt struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    print_object_core(0, &visitor, name, type_is_pointer(p_type), short_version, s_visit_number++);
}


void object_set_uninitialized_core(struct object_visitor* p_visitor)
{
    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;


            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                _Opt struct object_visitor visitor = { 0 };
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_uninitialized_core(&visitor);
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else if (p_member_declaration->specifier_qualifier_list != NULL)
                {
                    if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                        struct type* type_temp = p_visitor->p_type;
                        p_visitor->p_type = &t; //new type, same object

                        object_set_uninitialized_core(p_visitor);

                        p_visitor->p_type = type_temp; //restore                         

                        type_destroy(&t);
                    }

                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
    }

    if (type_is_pointer(p_visitor->p_type))
    {
        p_visitor->p_object->current.state = FLOW_OBJECT_STATE_UNINITIALIZED;

#if 0
        if (p_visitor->p_object->current.ref.size)
        {
            struct type t2 = type_remove_pointer(p_visitor->p_type);
            for (int i = 0; i < p_visitor->p_object->current.ref.size; i++)
            {
                struct flow_object* pointed = p_visitor->p_object->current.ref.data[i];
                object_set_nothing(&t2, pointed);
            }
            type_destroy(&t2);
        }
#endif
    }
    else
    {
        p_visitor->p_object->current.state = FLOW_OBJECT_STATE_UNINITIALIZED;
    }
}

void flow_object_set_uninitialized(struct type* p_type, struct flow_object* p_object)
{
    _Opt struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_uninitialized_core(&visitor);
}

static void checked_empty_core(struct flow_visit_ctx* ctx,
    struct type* p_type,
    struct flow_object* p_object,
    const char* previous_names,
    const struct marker* p_marker)
{
    if (p_type->struct_or_union_specifier && p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        struct member_declaration* _Opt p_member_declaration =
            p_struct_or_union_specifier ?
            p_struct_or_union_specifier->member_declaration_list.head :
            NULL;

        /*
        *  Some parts of the object needs to be moved..
        *  we need to print error one by one
        */
        int member_index = 0;
        while (p_member_declaration)
        {
            if (p_member_declaration->member_declarator_list_opt)
            {
                struct member_declarator* _Opt p_member_declarator =
                    p_member_declaration->member_declarator_list_opt->head;
                while (p_member_declarator)
                {

                    if (p_member_declarator->declarator)
                    {
                        const char* name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "";
                        char buffer[200] = { 0 };
                        if (type_is_pointer(p_type))
                            snprintf(buffer, sizeof buffer, "%s->%s", previous_names, name);
                        else
                            snprintf(buffer, sizeof buffer, "%s.%s", previous_names, name);


                        checked_empty_core(ctx, &p_member_declarator->declarator->type,
                            p_object->members.data[member_index],
                            name,
                            p_marker);

                        member_index++;
                    }
                    p_member_declarator = p_member_declarator->next;
                }
            }
            else if (p_member_declaration->specifier_qualifier_list != NULL)
            {
                //TODO!!!
            }
            p_member_declaration = p_member_declaration->next;
        }
        return;
    }

    if (type_is_owner_or_pointer_to_dtor(p_type))
    {
        if (p_object->current.state == (FLOW_OBJECT_STATE_UNINITIALIZED | FLOW_OBJECT_STATE_NULL | FLOW_OBJECT_STATE_MOVED) ||
            p_object->current.state == (FLOW_OBJECT_STATE_NULL | FLOW_OBJECT_STATE_MOVED) ||
            p_object->current.state == FLOW_OBJECT_STATE_NULL ||
            p_object->current.state == FLOW_OBJECT_STATE_MOVED ||
            p_object->current.state == FLOW_OBJECT_STATE_UNINITIALIZED ||
            p_object->current.state == (FLOW_OBJECT_STATE_UNINITIALIZED | FLOW_OBJECT_STATE_NULL) ||
            p_object->current.state == (FLOW_OBJECT_STATE_UNINITIALIZED | FLOW_OBJECT_STATE_MOVED)
            )
        {
        }
        else
        {

            compiler_diagnostic(W_FLOW_MISSING_DTOR,
                ctx->ctx,
                NULL,
                p_marker,
                "object '%s' may not be empty",
                previous_names);
        }
    }
}

void checked_empty(struct flow_visit_ctx* ctx,
    struct type* p_type,
    struct flow_object* p_object,
    const struct marker* p_marker)
{
    char name[100] = { 0 };
    object_get_name(p_type, p_object, name, sizeof name);

    checked_empty_core(ctx,
    p_type,
    p_object,
    name,
    p_marker);
}

static void object_set_moved_core(struct object_visitor* p_visitor)
{

    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;


            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                _Opt struct object_visitor visitor = { 0 };
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_moved_core(&visitor);
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else if (p_member_declaration->specifier_qualifier_list != NULL)
                {
                    if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                        struct type* type_temp = p_visitor->p_type;
                        p_visitor->p_type = &t; //new type, same object

                        object_set_moved_core(p_visitor);

                        p_visitor->p_type = type_temp; //restore                         

                        type_destroy(&t);
                    }

                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
    }

    if (type_is_pointer(p_visitor->p_type))
    {
        p_visitor->p_object->current.state = FLOW_OBJECT_STATE_MOVED;
    }
    else
    {
        p_visitor->p_object->current.state = FLOW_OBJECT_STATE_MOVED;
    }
}

void flow_object_set_moved(struct type* p_type, struct flow_object* p_object)
{
    _Opt struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_moved_core(&visitor);
}

static void object_set_unknown_core(struct object_visitor* p_visitor, bool t_is_nullable, unsigned int visit_number, bool nullable_enabled)
{
    if (p_visitor->p_object->visit_number == visit_number) return; //already visited
    p_visitor->p_object->visit_number = visit_number;


    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;


            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                _Opt struct object_visitor visitor = { 0 };
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];

                                object_set_unknown_core(&visitor,
                                    t_is_nullable,
                                    visit_number,
                                    nullable_enabled);
                            }
                            else
                            {
                                //TODO BUG union?                                
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else if (p_member_declaration->specifier_qualifier_list != NULL)
                {
                    if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                        struct type* temp = p_visitor->p_type;
                        p_visitor->p_type = &t;

                        int vn = p_visitor->p_object->visit_number;
                        p_visitor->p_object->visit_number = 0;
                        object_set_unknown_core(p_visitor, t_is_nullable, visit_number, nullable_enabled);



                        //restore
                        p_visitor->p_object->visit_number = vn;
                        p_visitor->p_type = temp;

                        type_destroy(&t);
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
        return;
    }

    if (type_is_pointer(p_visitor->p_type))
    {
        if (t_is_nullable || type_is_opt(p_visitor->p_type, nullable_enabled))
            p_visitor->p_object->current.state = FLOW_OBJECT_STATE_NULL | FLOW_OBJECT_STATE_NOT_NULL;
        else
            p_visitor->p_object->current.state = FLOW_OBJECT_STATE_NOT_NULL;


        struct flow_object* _Opt pointed = p_visitor->p_object->current.pointed;
        if (pointed)
        {
            struct type t2 = type_remove_pointer(p_visitor->p_type);
            bool t2_is_nullable = type_is_opt(&t2, nullable_enabled);
            _Opt struct object_visitor visitor = { 0 };
            visitor.p_type = &t2;
            visitor.p_object = pointed;

            object_set_unknown_core(&visitor, t2_is_nullable, visit_number, nullable_enabled);
            type_destroy(&t2);
        }

    }
    else
    {
        if (!type_is_struct_or_union(p_visitor->p_type))
            p_visitor->p_object->current.state = FLOW_OBJECT_STATE_ZERO | FLOW_OBJECT_STATE_NOT_ZERO;
    }
}

void flow_object_set_unknown(struct type* p_type, bool t_is_nullable, struct flow_object* p_object, bool nullable_enabled)
{
    _Opt struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_unknown_core(&visitor, t_is_nullable, s_visit_number++, nullable_enabled);
}


static void object_set_deleted_core(struct type* p_type, struct flow_object* p_object, unsigned int visit_number)
{
    if (p_object->visit_number == visit_number) return; //already visited
    p_object->visit_number = visit_number;


    if (p_type->struct_or_union_specifier && p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;

            int member_index = 0;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (member_index < p_object->members.size)
                            {
                                object_set_deleted_core(&p_member_declarator->declarator->type, p_object->members.data[member_index], visit_number);
                            }
                            else
                            {
                                //TODO BUG union?                                
                            }
                            member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else if (p_member_declaration->specifier_qualifier_list != NULL)
                {
                    //TODO!!!
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
        return;
    }

    if (type_is_pointer(p_type))
    {
        p_object->current.state = FLOW_OBJECT_STATE_LIFE_TIME_ENDED;
#if 0
        for (int i = 0; i < p_object->current.ref.size; i++)
        {
            struct flow_object* pointed = p_object->current.ref.data[i];
            if (pointed)
            {
                struct type t2 = type_remove_pointer(p_type);
                object_set_deleted_core(&t2, pointed, visit_number);
                type_destroy(&t2);
            }
        }
#endif
    }
    else
    {
        if (!type_is_struct_or_union(p_type))
            p_object->current.state = FLOW_OBJECT_STATE_LIFE_TIME_ENDED;
    }
}

void flow_object_set_can_be_uninitialized(struct flow_object* p_object)
{
    p_object->current.state |= FLOW_OBJECT_STATE_UNINITIALIZED;
}
void flow_object_set_is_unitialized(struct flow_object* p_object)
{
    p_object->current.state = FLOW_OBJECT_STATE_UNINITIALIZED;
    if (p_object->current.alternatives.size > 0)
    {
        for (int i = 0; i < p_object->current.alternatives.size; i++)
        {
            flow_object_set_can_be_uninitialized(p_object->current.alternatives.data[i]);
        }
    }
}

void flow_object_set_can_be_moved(struct flow_object* p_object)
{
    if (p_object->current.state & FLOW_OBJECT_STATE_NOT_NULL)
    {
        p_object->current.state &= ~FLOW_OBJECT_STATE_NOT_NULL;
        p_object->current.state |= FLOW_OBJECT_STATE_MOVED;
        p_object->current.state |= FLOW_OBJECT_STATE_MOVED;
    }
}
void flow_object_set_is_moved(struct flow_object* p_object)
{
    p_object->current.state = FLOW_OBJECT_STATE_MOVED;

    if (p_object->current.alternatives.size > 0)
    {
        for (int i = 0; i < p_object->current.alternatives.size; i++)
        {
            flow_object_set_can_be_moved(p_object->current.alternatives.data[i]);
        }
    }
}


void object_set_deleted(struct type* p_type, struct flow_object* p_object)
{
    object_set_deleted_core(p_type, p_object, s_visit_number++);
}

void object_set_zero_core(struct object_visitor* p_visitor)
{
    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;

            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                _Opt struct object_visitor visitor = { 0 };
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_zero_core(&visitor);
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else if (p_member_declaration->specifier_qualifier_list != NULL)
                {
                    if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                        struct type* temp = p_visitor->p_type;
                        p_visitor->p_type = &t;
                        object_set_zero_core(p_visitor);
                        p_visitor->p_type = temp; //restore
                        type_destroy(&t);
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
        return;
    }

    if (type_is_pointer(p_visitor->p_type))
    {
        p_visitor->p_object->current.state = FLOW_OBJECT_STATE_NULL;
    }
    else
    {
        p_visitor->p_object->current.state = FLOW_OBJECT_STATE_ZERO;
    }
}

void flow_object_set_zero(struct type* p_type, struct flow_object* p_object)
{
    _Opt struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_zero_core(&visitor);
}

void object_set_end_of_lifetime_core(struct object_visitor* p_visitor)
{
    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;

            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                _Opt struct object_visitor visitor = { 0 };
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_end_of_lifetime_core(&visitor);
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else if (p_member_declaration->specifier_qualifier_list != NULL)
                {
                    if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                        struct type* temp = p_visitor->p_type;
                        p_visitor->p_type = &t;
                        object_set_end_of_lifetime_core(p_visitor);
                        p_visitor->p_type = temp; //restore
                        type_destroy(&t);
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
        return;
    }

    p_visitor->p_object->current.state = FLOW_OBJECT_STATE_LIFE_TIME_ENDED;
}

void flow_object_set_end_of_lifetime(struct type* p_type, struct flow_object* p_object)
{
    _Opt struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_end_of_lifetime_core(&visitor);
}

//returns true if all parts that need to be moved weren't moved.
bool object_check(struct type* p_type, struct flow_object* p_object)
{
    try
    {
        if (p_type->type_qualifier_flags & TYPE_QUALIFIER_VIEW)
        {
            return false;
        }

        if (!type_is_owner_or_pointer_to_dtor(p_type))
        {
            return false;
        }

        if (p_type->struct_or_union_specifier && p_object->members.size > 0)
        {
            struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
                get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

            if (p_struct_or_union_specifier == NULL)
            {
                throw;
            }

            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;
            int possible_need_destroy_count = 0;
            int need_destroy_count = 0;
            int member_index = 0;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {

                        if (p_member_declarator->declarator)
                        {
                            if (type_is_owner(&p_member_declarator->declarator->type))
                            {
                                possible_need_destroy_count++;
                            }

                            if (object_check(&p_member_declarator->declarator->type,
                                p_object->members.data[member_index]))
                            {
                                need_destroy_count++;
                            }
                            member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else if (p_member_declaration->specifier_qualifier_list != NULL)
                {
                    //TODO struct object_visitor* p_visitor                
                }
                p_member_declaration = p_member_declaration->next;
            }

            return need_destroy_count > 1 && (need_destroy_count == possible_need_destroy_count);
        }
        else
        {
            bool should_had_been_moved = false;
            if (type_is_pointer(p_type))
            {
                should_had_been_moved = (p_object->current.state & FLOW_OBJECT_STATE_NOT_NULL);
            }
            else
            {
                if (p_object->current.state == FLOW_OBJECT_STATE_UNINITIALIZED ||
                    (p_object->current.state & FLOW_OBJECT_STATE_MOVED) ||
                    p_object->current.state == FLOW_OBJECT_STATE_NOT_NULL ||
                    p_object->current.state == (FLOW_OBJECT_STATE_UNINITIALIZED))
                {
                }
                else
                {
                    should_had_been_moved = true;
                }
            }

            return should_had_been_moved;
        }
    }
    catch
    {
    }
    return false;
}

void object_get_name_core(
    const struct type* p_type,
    const struct flow_object* p_object,
    const struct flow_object* p_object_target,
    const char* previous_names,
    char* outname,
    int out_size,
    unsigned int visit_number)
{
    try
    {
        if (p_object->visit_number == visit_number) return;
        ((struct flow_object*)p_object)->visit_number = visit_number;

        if (p_object == p_object_target)
        {
            snprintf(outname, out_size, "%s", previous_names);
            return;
        }

        if (p_type->struct_or_union_specifier && p_object->members.size > 0)
        {
            struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
                get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

            if (p_struct_or_union_specifier == NULL)
                throw;

            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;

            int member_index = 0;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {

                        if (p_member_declarator->declarator)
                        {
                            const char* name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "";
                            char buffer[200] = { 0 };
                            if (type_is_pointer(p_type))
                                snprintf(buffer, sizeof buffer, "%s->%s", previous_names, name);
                            else
                                snprintf(buffer, sizeof buffer, "%s.%s", previous_names, name);

                            object_get_name_core(
                                &p_member_declarator->declarator->type,
                                p_object->members.data[member_index],
                                p_object_target,
                                buffer,
                                outname,
                                out_size, visit_number);

                            member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else if (p_member_declaration->specifier_qualifier_list != NULL)
                {
                    // assert(false); //TODO
                }
                p_member_declaration = p_member_declaration->next;
            }

        }
        else
        {
            snprintf(outname, out_size, "%s", previous_names);
        }
    }
    catch
    {
    }
}


void object_get_name(const struct type* p_type,
    const struct flow_object* p_object,
    char* outname,
    int out_size)
{
    outname[0] = '\0';

    if (p_object->p_declarator_origin)
    {
        const char* root_name = p_object->p_declarator_origin->name_opt ? p_object->p_declarator_origin->name_opt->lexeme : "?";
        const struct flow_object* _Opt root = p_object->p_declarator_origin->p_flow_object;
        object_get_name_core(&p_object->p_declarator_origin->type, root, p_object, root_name, outname, out_size, s_visit_number++);
    }
    else if (p_object->p_expression_origin)
    {
        int bytes_written = 0;
        struct token* _Opt p = p_object->p_expression_origin->first_token;
        for (int i = 0; i < 10; i++)
        {
            const char* ps = p->lexeme;
            while (*ps)
            {
                if (bytes_written < (out_size - 1))
                {
                    outname[bytes_written] = *ps;
                }
                bytes_written++;
                ps++;
            }

            if (p == p_object->p_expression_origin->last_token)
                break;

            p = p->next;
            assert(p != NULL);
        }

        if (bytes_written < (out_size - 1))
            outname[bytes_written] = '\0';
        else
            outname[out_size - 1] = '\0';
    }
    else
    {
        outname[0] = '?';
        outname[1] = '\0';
    }
}

static void checked_read_object_core(struct flow_visit_ctx* ctx,
    struct object_visitor* p_visitor,
    bool is_nullable,
    const struct token* _Opt position_token_opt,
    const struct marker* _Opt p_marker_opt,
    bool check_pointed_object,
    const char* previous_names,
    unsigned int visit_number)
{
    assert(previous_names != NULL);

    if (p_visitor->p_object->visit_number == visit_number) return;
    p_visitor->p_object->visit_number = visit_number;


    if (p_visitor->p_type->struct_or_union_specifier && p_visitor->p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        struct member_declaration* _Opt p_member_declaration =
            p_struct_or_union_specifier ?
            p_struct_or_union_specifier->member_declaration_list.head :
            NULL;

        /*
        *  Some parts of the object needs to be moved..
        *  we need to print error one by one
        */
        while (p_member_declaration)
        {
            if (p_member_declaration->member_declarator_list_opt)
            {
                struct member_declarator* _Opt p_member_declarator =
                    p_member_declaration->member_declarator_list_opt->head;
                while (p_member_declarator)
                {

                    if (p_member_declarator->declarator)
                    {
                        const char* name =
                            p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "?";

                        char buffer[200] = { 0 };
                        if (type_is_pointer(p_visitor->p_type))
                            snprintf(buffer, sizeof buffer, "%s->%s", previous_names, name);
                        else
                            snprintf(buffer, sizeof buffer, "%s.%s", previous_names, name);

                        _Opt struct object_visitor  visitor = { 0 };
                        visitor.p_type = &p_member_declarator->declarator->type;
                        visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];


                        checked_read_object_core(ctx,
                            &visitor,
                            is_nullable,
                            position_token_opt,
                            p_marker_opt,
                            check_pointed_object,
                            buffer,
                            visit_number);

                        p_visitor->member_index++;
                    }
                    p_member_declarator = p_member_declarator->next;
                }
            }
            else if (p_member_declaration->specifier_qualifier_list)
            {
                struct type t = { 0 };
                t.category = TYPE_CATEGORY_ITSELF;
                t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                char buffer[200] = { 0 };
                if (type_is_pointer(p_visitor->p_type))
                    snprintf(buffer, sizeof buffer, "%s->", previous_names);
                else
                    snprintf(buffer, sizeof buffer, "%s.", previous_names);

                struct type* temp = p_visitor->p_type;
                p_visitor->p_type = &t;

                int visit_number0 = p_visitor->p_object->visit_number;
                p_visitor->p_object->visit_number = 0;

                checked_read_object_core(ctx,
                        p_visitor,
                        is_nullable,
                        position_token_opt,
                        p_marker_opt,
                        check_pointed_object,
                        buffer,
                        visit_number);

                p_visitor->p_type = temp; //restore
                p_visitor->p_object->visit_number = visit_number0;
                type_destroy(&t);

            }
            p_member_declaration = p_member_declaration->next;
        }
        return;
    }
    else
    {

        if (type_is_pointer(p_visitor->p_type) &&
            !is_nullable &&
            !type_is_opt(p_visitor->p_type, ctx->ctx->options.null_checks_enabled) &&
            flow_object_can_be_null(p_visitor->p_object))
        {
            compiler_diagnostic(W_FLOW_NULL_DEREFERENCE,
                ctx->ctx,
                NULL,
                p_marker_opt,
                "non-nullable pointer '%s' may be null",
                previous_names);
        }

        if (type_is_pointer(p_visitor->p_type) &&
            check_pointed_object &&
            flow_object_can_be_not_null_or_moved(p_visitor->p_object))
        {
            struct type t2 = type_remove_pointer(p_visitor->p_type);

            if (p_visitor->p_object->current.pointed)
            {
                _Opt struct object_visitor  visitor = { 0 };
                visitor.p_type = &t2;
                visitor.p_object = p_visitor->p_object->current.pointed;

                checked_read_object_core(ctx,
                    &visitor,
                    is_nullable,
                    position_token_opt,
                    p_marker_opt,
                    true,
                    previous_names,
                    visit_number);
            }

            type_destroy(&t2);
        }


        if (p_visitor->p_object->current.state & FLOW_OBJECT_STATE_UNINITIALIZED)
        {
            if (type_is_array(p_visitor->p_type))
            {
                //unitialized arrays are used as initialized pointers to uninitialized flow_objects.
            }
            else
            {
                compiler_diagnostic(W_FLOW_UNINITIALIZED,
                    ctx->ctx,
                    position_token_opt,
                    p_marker_opt,
                    "uninitialized object '%s'",
                    previous_names);
            }
        }


        //TODO there is some problem with  FLOW_OBJECT_STATE_LIFE_TIME_ENDED
        //state somewhere!
        if (p_visitor->p_object->current.state & FLOW_OBJECT_STATE_LIFE_TIME_ENDED)
        {
            /*
               current implementation does not handle
               "dependent states". Many times the pointer is null
               and the pointed object does not exist anymore.
               But these two states are not related and it is causing
               too many false positives
            */

            //compiler_diagnostic(W_FLOW_LIFETIME_ENDED,
            //    ctx->ctx,
            //     position_token_opt,
            //    p_marker_opt,
            //    "lifetime ended '%s'",
            //    previous_names);
        }


    }
}

/*
  Check if all flow_objects connect to this one
   - are initialized
*/
void checked_read_object(struct flow_visit_ctx* ctx,
    struct type* p_type,
    bool is_nullable,
    struct flow_object* p_object,
    const struct token* _Opt position_token,
    const struct marker* _Opt p_marker_opt,
    bool check_pointed_object)
{
    const char* _Owner _Opt s = NULL;
    char name[200] = { 0 };

    object_get_name(p_type, p_object, name, sizeof name);

    _Opt struct object_visitor visitor = { 0 };
    visitor.p_object = p_object;
    visitor.p_type = p_type;

    checked_read_object_core(ctx,
    &visitor,
    is_nullable,
    position_token,
    p_marker_opt,
    check_pointed_object,
    name,
    s_visit_number++);
    free((void* _Owner)s);
}

static void flow_end_of_block_visit_core(struct flow_visit_ctx* ctx,
    struct object_visitor* p_visitor,
    bool b_type_is_view,
    const struct token* position_token,
    const char* previous_names,
    unsigned int visit_number)
{

    if (p_visitor->p_object->visit_number == visit_number) return;
    p_visitor->p_object->visit_number = visit_number;


    if (p_visitor->p_type->struct_or_union_specifier && p_visitor->p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier == NULL)
            return;

        struct member_declaration* _Opt p_member_declaration =
            p_struct_or_union_specifier->member_declaration_list.head;

        if (object_check(p_visitor->p_type, p_visitor->p_object))
        {
            /*
            *  All parts of the object needs to be moved, so instead of
            *  describing each part we will just say that the object should
            *  have been moved.
            */
            const struct token* _Opt name = flow_object_get_token(p_visitor->p_object);
            if (compiler_diagnostic(W_FLOW_MISSING_DTOR,
                ctx->ctx,
                name, NULL,
                "members of '%s' were not released.",
                previous_names))
            {

                if (p_visitor->p_object->p_declarator_origin)
                    compiler_diagnostic(W_LOCATION, ctx->ctx, position_token, NULL, "end of '%s' scope", previous_names);
            }
        }
        else
        {
            /*
            *  Some parts of the object needs to be moved..
            *  we need to print error one by one
            */


            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {

                        if (p_member_declarator->declarator)
                        {
                            const char* name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "?";

                            char buffer[200] = { 0 };
                            if (type_is_pointer(p_visitor->p_type))
                                snprintf(buffer, sizeof buffer, "%s->%s", previous_names, name);
                            else
                                snprintf(buffer, sizeof buffer, "%s.%s", previous_names, name);

                            const bool member_is_view = type_is_view(&p_member_declarator->declarator->type);

                            _Opt struct object_visitor visitor = { 0 };
                            visitor.p_type = &p_member_declarator->declarator->type;
                            visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];

                            flow_end_of_block_visit_core(ctx,
                                &visitor,
                                b_type_is_view || member_is_view,
                                position_token,
                                buffer,
                                visit_number);
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else if (p_member_declaration->specifier_qualifier_list != NULL)
                {
                    struct type t = { 0 };
                    t.category = TYPE_CATEGORY_ITSELF;
                    t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                    t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                    struct type* temp = p_visitor->p_type;
                    p_visitor->p_type = &t;

                    const bool member_is_view = type_is_view(&t);

                    int visit_number0 = p_visitor->p_object->visit_number;
                    p_visitor->p_object->visit_number = 0;
                    flow_end_of_block_visit_core(ctx,
                        p_visitor,
                        member_is_view,
                        position_token,
                        previous_names,
                        visit_number);

                    p_visitor->p_type = temp; //restore
                    p_visitor->p_object->visit_number = visit_number0;
                    type_destroy(&t);

                }
                p_member_declaration = p_member_declaration->next;
            }
        }


    }
    else
    {
        const char* name = previous_names;
        const struct token* _Opt position = NULL;
        if (p_visitor->p_object->p_declarator_origin)
            position = p_visitor->p_object->p_declarator_origin->name_opt ? p_visitor->p_object->p_declarator_origin->name_opt : p_visitor->p_object->p_declarator_origin->first_token_opt;
        else if (p_visitor->p_object->p_expression_origin)
            position = p_visitor->p_object->p_expression_origin->first_token;
        else
        {
            assert(false);
        }

        if (name[0] == '\0')
        {
            /*function arguments without name*/
            name = "?";
        }
        //bool should_had_been_moved = false;


        /*
           Despite the name FLOW_OBJECT_STATE_NOT_NULL does not means null, it means
           the reference is not referring an object, the value could be -1 for instance.
        */
        if (type_is_pointer(p_visitor->p_type) &&
            !b_type_is_view &&
            type_is_owner(p_visitor->p_type) &&
            p_visitor->p_object->current.state & FLOW_OBJECT_STATE_NOT_NULL)
        {
            if (compiler_diagnostic(W_FLOW_MISSING_DTOR,
                ctx->ctx,
                position, NULL,
                "object pointed by '%s' was not released.", previous_names))
            {
                compiler_diagnostic(W_LOCATION,
                ctx->ctx,
                position_token, NULL,
                "end of '%s' lifetime", previous_names);
            }
        }
        else if (!b_type_is_view && type_is_pointed_dtor(p_visitor->p_type) && type_is_pointer(p_visitor->p_type))
        {
            char buffer[100] = { 0 };
            snprintf(buffer, sizeof buffer, "%s", previous_names);
            struct type t2 = type_remove_pointer(p_visitor->p_type);

            if (p_visitor->p_object->current.pointed)
            {
                _Opt struct object_visitor visitor = { 0 };
                visitor.p_type = &t2;
                visitor.p_object = p_visitor->p_object->current.pointed;
                flow_end_of_block_visit_core(ctx, &visitor, b_type_is_view, position, buffer, visit_number);
            }


            type_destroy(&t2);
        }
        else if (type_is_owner(p_visitor->p_type) && !type_is_pointer(p_visitor->p_type))
        {
            //non-pointer _Owner
            if (p_visitor->p_object->current.state == FLOW_OBJECT_STATE_UNINITIALIZED ||
                p_visitor->p_object->current.state == FLOW_OBJECT_STATE_NULL ||
                p_visitor->p_object->current.state == FLOW_OBJECT_STATE_MOVED)
            {
            }
            else
            {
                if (compiler_diagnostic(W_FLOW_MISSING_DTOR,
                    ctx->ctx,
                    position, NULL,
                    "object pointed by '%s' was not released.", previous_names))
                {
                    compiler_diagnostic(W_LOCATION,
                    ctx->ctx,
                    position_token, NULL,
                    "end of '%s' lifetime", previous_names);
                }
            }
        }
        else if (type_is_pointer(p_visitor->p_type))
        {
            if (p_visitor->p_type->storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
            {
                if (type_is_owner_or_pointer_to_dtor(p_visitor->p_type))
                {
                    //owner pointer parameters can point to deleted objects, so 
                    //we cannot check this state inside checked_read_object
                }
                else
                {
                    //Visiting a pointer parameter. We check if we didn't mess a external object
                //TODO static flow_objects
                    struct type t2 = type_remove_pointer(p_visitor->p_type);

                    if (p_visitor->p_object->current.pointed &&
                        p_visitor->p_object->p_declarator_origin)
                    {
                        struct token* _Opt name_token = p_visitor->p_object->p_declarator_origin->name_opt ?
                            p_visitor->p_object->p_declarator_origin->name_opt :
                            p_visitor->p_object->p_declarator_origin->first_token_opt;

                        checked_read_object(ctx,
                         &t2,
                         false,
                         p_visitor->p_object->current.pointed,
                         name_token,
                         NULL,
                         true);
                    }
                    type_destroy(&t2);
                }
            }
        }
        else
        {
        }

    }
}

void flow_end_of_block_visit(struct flow_visit_ctx* ctx,
    struct type* p_type,
    bool type_is_view,
    struct flow_object* p_object,
    const struct token* position_token,
    const char* previous_names)
{
    _Opt struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    flow_end_of_block_visit_core(ctx,
    &visitor,
    type_is_view,
    position_token,
    previous_names,
    s_visit_number++);
}

bool flow_object_is_zero_or_null(const struct flow_object* p_object)
{
    return (p_object->current.state == FLOW_OBJECT_STATE_NULL) ||
        (p_object->current.state == FLOW_OBJECT_STATE_ZERO);
}

/*
   This function must check and do the flow assignment of
   a = b
*/
static void flow_assignment_core(
    struct flow_visit_ctx* ctx,
    const struct token* error_position,
    const struct marker* p_a_marker,
    const struct marker* p_b_marker,
    enum assigment_type assigment_type,
    bool check_uninitialized_b,
    bool a_type_is_view,
    bool a_type_is_nullable,
    struct object_visitor* p_visitor_a,
    struct object_visitor* p_visitor_b,
    bool* _Opt  set_argument_to_unkown)
{
    //const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

#ifdef _DEBUG
    while (error_position->line == 25)
    {
        break;
    }
#endif
    // printf("line  %d\n", error_position->line);
     //type_print(p_a_type);
     //printf(" = ");
     //type_print(p_b_type);
     //printf("\n");

     /*general check for copying uninitialized object*/


    if (check_uninitialized_b &&
        flow_object_can_be_uninitialized(p_visitor_b->p_object))
    {
        //a = b where b can be uninitialized

        if (type_is_array(p_visitor_b->p_type))
        {
            if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                struct type item_type = { 0 };

                if (type_is_array(p_visitor_a->p_type))
                    item_type = get_array_item_type(p_visitor_a->p_type);
                else
                    item_type = type_remove_pointer(p_visitor_a->p_type);

                const bool cannot_be_uninitialized =
                    (ctx->ctx->options.ownership_enabled && !type_is_ctor(&item_type)) ||
                    type_is_const(&item_type);

                if (cannot_be_uninitialized)
                {
                    char b_object_name[100] = { 0 };
                    object_get_name(p_visitor_b->p_type, p_visitor_b->p_object, b_object_name, sizeof b_object_name);
                    compiler_diagnostic(W_FLOW_UNINITIALIZED,
                                ctx->ctx,
                                NULL,
                                p_b_marker,
                        "uninitialized object '%s' passed to non-optional parameter", b_object_name);
                }

                type_destroy(&item_type);
            }
        }
        else
        {
            char b_object_name[100] = { 0 };
            object_get_name(p_visitor_b->p_type, p_visitor_b->p_object, b_object_name, sizeof b_object_name);

            if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                compiler_diagnostic(W_FLOW_UNINITIALIZED,
                            ctx->ctx,
                            NULL,
                            p_b_marker,
                    "passing an uninitialized argument '%s' object", b_object_name);
            }
            else if (assigment_type == ASSIGMENT_TYPE_RETURN)
            {
                compiler_diagnostic(W_FLOW_UNINITIALIZED,
                            ctx->ctx,
                            NULL,
                            p_b_marker,
                            "returning an uninitialized '%s' object", b_object_name);
            }
            else
            {
                compiler_diagnostic(W_FLOW_UNINITIALIZED,
                            ctx->ctx,
                            NULL,
                            p_b_marker,
                            "reading an uninitialized '%s' object", b_object_name);
            }
        }

        return;
    }

    if (check_uninitialized_b && flow_object_can_have_its_lifetime_ended(p_visitor_a->p_object))
    {
        //a = b where a was deleted
        char buffer[100] = { 0 };
        object_get_name(p_visitor_a->p_type, p_visitor_a->p_object, buffer, sizeof buffer);

        compiler_diagnostic(W_FLOW_LIFETIME_ENDED,
                    ctx->ctx,
                    NULL,
                    p_a_marker,
                    "The object '%s' may have been deleted or its lifetime have ended.", buffer);


        return;
    }

    /*general check passing possible null to non _Opt*/
    if (type_is_pointer(p_visitor_a->p_type) &&
        (!type_is_opt(p_visitor_a->p_type, ctx->ctx->options.null_checks_enabled)) &&
        flow_object_can_be_null(p_visitor_b->p_object))
    {
        if (!a_type_is_nullable)
        {
            char buffer[100] = { 0 };
            object_get_name(p_visitor_b->p_type, p_visitor_b->p_object, buffer, sizeof buffer);

            if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                compiler_diagnostic(W_FLOW_NULLABLE_TO_NON_NULLABLE,
                       ctx->ctx,
                       NULL,
                       p_b_marker,
                       "passing a possible null pointer '%s' to non-nullable pointer parameter", buffer);
            }
            else if (assigment_type == ASSIGMENT_TYPE_RETURN)
            {
                compiler_diagnostic(W_FLOW_NULLABLE_TO_NON_NULLABLE,
                       ctx->ctx,
                       NULL,
                       p_b_marker,
                       "returning a possible null pointer '%s' to non-nullable pointer", buffer);
            }
            else
            {
                compiler_diagnostic(W_FLOW_NULLABLE_TO_NON_NULLABLE,
                       ctx->ctx,
                       NULL,
                       p_b_marker,
                       "assignment of possible null pointer '%s' to non-nullable pointer", buffer);
            }
        }
    }

    if (type_is_pointer(p_visitor_a->p_type))
    {
        if (!a_type_is_view && type_is_owner(p_visitor_a->p_type))
        {
            checked_empty(ctx, p_visitor_a->p_type, p_visitor_a->p_object, p_a_marker);
        }

        if (flow_object_is_zero_or_null(p_visitor_b->p_object))
        {
            if (type_is_array(p_visitor_b->p_type))
            {
                p_visitor_a->p_object->current.state = FLOW_OBJECT_STATE_NOT_NULL;
                return;
            }
            else if (type_is_nullptr_t(p_visitor_b->p_type) || type_is_integer(p_visitor_b->p_type))
            {
                flow_object_set_current_state_to_is_null(p_visitor_a->p_object);

                return;
            }
        }
    }

    if (!a_type_is_view && type_is_pointed_dtor(p_visitor_a->p_type) && type_is_pointer(p_visitor_a->p_type))
    {
        checked_empty(ctx, p_visitor_a->p_type, p_visitor_a->p_object, p_a_marker);

        if (flow_object_is_zero_or_null(p_visitor_b->p_object))
        {
            //0 to objec_owner??
            //a = nullpr
            //flow_object_set_zero(p_a_type, p_a_object);
            return;
        }
    }

    /*copying to void * _Owner*/
    if (type_is_void_ptr(p_visitor_a->p_type) && type_is_pointer(p_visitor_b->p_type))
    {
        p_visitor_a->p_object->current.state = p_visitor_b->p_object->current.state;

        if (!a_type_is_view && type_is_owner(p_visitor_a->p_type))
        {
            /*
            *  Moving an already moved object
            */
            if (flow_object_can_be_moved(p_visitor_b->p_object))
            {
                compiler_diagnostic(W_FLOW_MOVED,
                                            ctx->ctx,
                                            NULL,
                                            p_b_marker,
                                            "object may be already moved");
            }

            //*b must be empty before copying to void* _Owner
            struct type t = type_remove_pointer(p_visitor_b->p_type);


            if (p_visitor_b->p_object->current.pointed == NULL)
            {
                // The question is..if we had this object expanded
                // could it possible have resources?
                //-> {...}
                if (flow_object_is_expansible(p_visitor_b->p_object) &&
                    type_is_owner(&t))
                {
                    //if the anwser is yes then we need a warning
                    compiler_diagnostic(W_FLOW_MISSING_DTOR,
                                                ctx->ctx,
                                                NULL,
                                                p_a_marker,
                                                "pointed object may be not empty");
                }
            }
            else
            {
                checked_empty(ctx, &t, p_visitor_b->p_object->current.pointed, p_b_marker);
                object_set_deleted(&t, p_visitor_b->p_object->current.pointed);
            }

            type_destroy(&t);

            if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                flow_object_set_is_unitialized(p_visitor_b->p_object);
                p_visitor_b->p_object->current.state = FLOW_OBJECT_STATE_UNINITIALIZED;
            }
            else
            {
                flow_object_set_is_moved(p_visitor_b->p_object);
            }
        }
        return;
    }


    if (type_is_pointer(p_visitor_a->p_type) && type_is_pointer(p_visitor_b->p_type))
    {
        p_visitor_a->p_object->current.state = p_visitor_b->p_object->current.state;
        p_visitor_a->p_object->current.pointed = p_visitor_b->p_object->current.pointed;

        struct type t = type_remove_pointer(p_visitor_a->p_type);

        /*if the parameter points to _Ctor object, then we don´t need to check
          argument pointed object.
        */
        const bool checked_pointed_object_read =
            ctx->ctx->options.ownership_enabled && !type_is_ctor(&t);

        bool is_nullable = a_type_is_nullable || type_is_opt(&t, ctx->ctx->options.null_checks_enabled);

        checked_read_object(ctx,
            p_visitor_b->p_type,
            is_nullable,
            p_visitor_b->p_object,
            error_position,
            p_b_marker,
            checked_pointed_object_read);


        //object_copy_state(p_a_type, p_a_object, p_b_type, p_b_object);
        type_destroy(&t);

        if (!a_type_is_view && type_is_owner(p_visitor_a->p_type))
        {
            /*
               T * _Owner pA = pB;
            */

            if (flow_object_can_be_moved(p_visitor_b->p_object))
            {
                //TODO we need 2 positions, source, dest
                compiler_diagnostic(W_FLOW_MOVED,
                   ctx->ctx,
                   error_position, NULL,
                   "source object has already been moved");
            }


            if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                p_visitor_b->p_object->current.state = FLOW_OBJECT_STATE_UNINITIALIZED;
                if (p_visitor_b->p_object->current.pointed)
                {
                    struct flow_object* pointed = p_visitor_b->p_object->current.pointed;

                    struct type t2 = type_remove_pointer(p_visitor_b->p_type);
                    object_set_deleted(&t2, pointed);
                    type_destroy(&t2);
                }
            }
            else
            {

                //TODO
                p_visitor_a->p_object->current.state = p_visitor_a->p_object->current.state & ~FLOW_OBJECT_STATE_MOVED;
                if (p_visitor_b->p_object->current.state & FLOW_OBJECT_STATE_NOT_NULL)
                {
                    //null not-null -> null moved
                    p_visitor_b->p_object->current.state &= ~FLOW_OBJECT_STATE_NOT_NULL;
                    p_visitor_b->p_object->current.state |= FLOW_OBJECT_STATE_MOVED;
                }
            }
        }
        else if (!a_type_is_view && type_is_pointed_dtor(p_visitor_a->p_type))
        {
            if (type_is_owner_or_pointer_to_dtor(p_visitor_b->p_type))
            {
                if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
                {
                    if (p_visitor_b->p_object->current.pointed)
                    {
                        struct flow_object* pointed = p_visitor_b->p_object->current.pointed;

                        struct type t2 = type_remove_pointer(p_visitor_b->p_type);
                        flow_object_set_uninitialized(&t2, pointed);
                        type_destroy(&t2);
                    }

                }
                else
                    flow_object_set_moved(p_visitor_b->p_type, p_visitor_b->p_object);
            }
            else
            {
                if (p_visitor_b->p_type->address_of)
                {
                    //must be address of.
                    if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
                    {
                        p_visitor_b->p_object->current.state = FLOW_OBJECT_STATE_UNINITIALIZED;

                        if (p_visitor_b->p_object->current.pointed)
                        {
                            struct flow_object* pointed = p_visitor_b->p_object->current.pointed;

                            struct type t2 = type_remove_pointer(p_visitor_b->p_type);
                            flow_object_set_uninitialized(&t2, pointed);
                            type_destroy(&t2);
                        }
                    }
                    else
                        flow_object_set_moved(p_visitor_b->p_type, p_visitor_b->p_object);
                }
                else
                {
                    //avoid error on top of error
                    //address error already emitted
                    //at this point
                }
            }

        }
        else
        {
            if (a_type_is_view || !type_is_owner(p_visitor_a->p_type))
            {
                p_visitor_a->p_object->current.state = p_visitor_b->p_object->current.state;
            }


            if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                struct type t3 = type_remove_pointer(p_visitor_a->p_type);
                if (!type_is_const(&t3))
                {
                    if (p_visitor_b->p_object->current.pointed)
                    {
                        if (set_argument_to_unkown)
                        {
                            //Tells the caller it must make argument unknown
                            *set_argument_to_unkown = true;
                        }
                        //   flow_object_set_unknown(&t3, t3_is_nullable, pointed, nullable_enabled);
                    }
                }
                type_destroy(&t3);
            }
        }

        return;
    }

    if (p_visitor_a->p_type->struct_or_union_specifier && p_visitor_a->p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_a_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor_a->p_type->struct_or_union_specifier);

        if (p_visitor_b->p_type->struct_or_union_specifier == NULL)
            return;

        struct struct_or_union_specifier* _Opt p_b_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor_b->p_type->struct_or_union_specifier);

        if (p_a_struct_or_union_specifier && p_b_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_a_member_declaration =
                p_a_struct_or_union_specifier->member_declaration_list.head;

            struct member_declaration* _Opt p_b_member_declaration =
                p_b_struct_or_union_specifier->member_declaration_list.head;


            while (p_a_member_declaration && p_b_member_declaration)
            {
                if (p_a_member_declaration->member_declarator_list_opt &&
                    p_b_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_a_member_declarator =
                        p_a_member_declaration->member_declarator_list_opt->head;

                    struct member_declarator* _Opt p_b_member_declarator =
                        p_b_member_declaration->member_declarator_list_opt->head;

                    while (p_a_member_declarator && p_b_member_declarator)
                    {
                        if (p_a_member_declarator->declarator &&
                            p_b_member_declarator->declarator)
                        {
                            if (p_visitor_a->member_index < p_visitor_a->p_object->members.size &&
                                p_visitor_b->member_index < p_visitor_b->p_object->members.size)
                            {
                                _Opt struct object_visitor visitor_a = { 0 };
                                visitor_a.p_type = &p_a_member_declarator->declarator->type;
                                visitor_a.p_object = p_visitor_a->p_object->members.data[p_visitor_a->member_index];


                                _Opt struct object_visitor visitor_b = { 0 };
                                visitor_b.p_type = &p_b_member_declarator->declarator->type;
                                visitor_b.p_object = p_visitor_b->p_object->members.data[p_visitor_b->member_index];


                                flow_assignment_core(ctx,
                                    error_position,
                                    p_a_marker,
                                    p_b_marker,
                                    assigment_type,
                                    check_uninitialized_b,
                                    a_type_is_view,
                                    a_type_is_nullable,
                                    &visitor_a,
                                    &visitor_b,
                                    set_argument_to_unkown);
                            }
                            else
                            {
                                //TODO BUG union?                                
                            }
                            p_visitor_a->member_index++;
                            p_visitor_b->member_index++;

                        }
                        p_a_member_declarator = p_a_member_declarator->next;
                        p_b_member_declarator = p_b_member_declarator->next;
                    }
                }
                else
                {
                    if (p_a_member_declaration->specifier_qualifier_list &&
                       p_a_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_a_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                        struct type* temp1 = p_visitor_a->p_type;
                        struct type* temp2 = p_visitor_b->p_type;
                        p_visitor_a->p_type = &t;
                        p_visitor_b->p_type = &t;

                        flow_assignment_core(
                                            ctx,
                                            error_position,
                                            p_a_marker,
                                            p_b_marker,
                                            assigment_type,
                                            check_uninitialized_b,
                                            a_type_is_view,
                                            a_type_is_nullable,
                                            p_visitor_a,
                                            p_visitor_b,
                                            set_argument_to_unkown);

                        //restore
                        p_visitor_a->p_type = temp1;
                        p_visitor_b->p_type = temp2;

                        type_destroy(&t);
                    }
                }
                p_a_member_declaration = p_a_member_declaration->next;
                p_b_member_declaration = p_b_member_declaration->next;
            }
            return;
        }
    }

    p_visitor_a->p_object->current.state = p_visitor_b->p_object->current.state;
    if (!a_type_is_view && type_is_owner(p_visitor_a->p_type))
    {
        if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            flow_object_set_uninitialized(p_visitor_b->p_type, p_visitor_b->p_object);
        else
            flow_object_set_moved(p_visitor_b->p_type, p_visitor_b->p_object);
    }
}


struct flow_object* _Opt  expression_get_flow_object(struct flow_visit_ctx* ctx, struct expression* p_expression, bool nullable_enabled)
{
    try
    {
        if (p_expression->expression_type == PRIMARY_EXPRESSION_DECLARATOR)
        {
            assert(p_expression->declarator);
            if (p_expression->declarator->p_alias_of_expression)
            {
                /*We need to original object*/
                return expression_get_flow_object(ctx, p_expression->declarator->p_alias_of_expression, nullable_enabled);
            }
            else
            {
                assert(p_expression->declarator != NULL);

                if (p_expression->declarator->declaration_specifiers &&
                    !is_automatic_variable(p_expression->declarator->declaration_specifiers->storage_class_specifier_flags))
                {
                    assert(p_expression->declarator->p_flow_object != NULL);

                    //External flow_objects are added to the arena on-demand
                    if (flow_objects_find(&ctx->arena, p_expression->declarator->p_flow_object) == NULL)
                    {
                        p_expression->declarator->p_flow_object = make_flow_object(ctx, &p_expression->declarator->type, p_expression->declarator, NULL);
                        if (p_expression->declarator->p_flow_object == NULL)
                            throw;

                        flow_object_set_unknown(&p_expression->declarator->type,
                                                type_is_opt(&p_expression->declarator->type, ctx->ctx->options.null_checks_enabled),
                                                p_expression->declarator->p_flow_object,
                                                ctx->ctx->options.null_checks_enabled);
                    }
                }
                return p_expression->declarator->p_flow_object;
            }
        }

        else if (p_expression->expression_type == UNARY_EXPRESSION_ADDRESSOF)
        {
            assert(p_expression->right != NULL);

            struct flow_object* _Opt p_object = make_flow_object(ctx, &p_expression->type, NULL, p_expression);
            if (p_object == NULL) throw;

            struct flow_object* _Opt p_object_pointed =
                expression_get_flow_object(ctx, p_expression->right, nullable_enabled);

            if (p_object_pointed)
                object_set_pointer(p_object, p_object_pointed);

            p_object->current.state = FLOW_OBJECT_STATE_NOT_NULL;
            p_object->is_temporary = true;
            return p_object;
        }
        else if (p_expression->expression_type == PRIMARY_EXPRESSION_PARENTESIS)
        {
            assert(p_expression->right != NULL);
            return expression_get_flow_object(ctx, p_expression->right, nullable_enabled);
        }
        else if (p_expression->expression_type == CAST_EXPRESSION)
        {
            assert(p_expression->left != NULL);
            struct flow_object* _Opt p = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
            if (p)
            {
                if (type_is_pointer(&p_expression->type_name->type))
                {
                    //casting from 0 to pointer we need to change the zero to null
                    //#define NULL ((void*)0)
                    if (p->current.state & FLOW_OBJECT_STATE_ZERO)
                    {
                        p->current.state &= ~FLOW_OBJECT_STATE_ZERO;
                        p->current.state |= FLOW_OBJECT_STATE_NULL;
                    }
                    if (p->current.state & FLOW_OBJECT_STATE_NOT_ZERO)
                    {
                        p->current.state &= ~FLOW_OBJECT_STATE_NOT_ZERO;
                        p->current.state |= FLOW_OBJECT_STATE_NOT_NULL;
                    }
                }
            }
            return p;
        }
        else if (p_expression->expression_type == POSTFIX_DOT)
        {
            assert(p_expression->left != NULL);

            struct flow_object* _Opt p_obj = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
            if (p_obj)
            {
                if (p_expression->member_index < p_obj->members.size)
                    return p_obj->members.data[p_expression->member_index];
                else
                {
                    // assert(false);
                    return NULL;
                }
            }
        }
        else if (p_expression->expression_type == POSTFIX_ARRAY)
        {
            assert(p_expression->left != NULL);

            //All arrays items point to the same object.
            struct flow_object* _Opt p_obj = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
            if (p_obj)
            {

                if (p_obj->current.pointed == NULL)
                {
                    flow_object_expand_pointer(ctx, &p_expression->left->type, p_obj);
                }

                if (p_obj->current.pointed)
                {
                    struct flow_object* pointed = p_obj->current.pointed;
                    return pointed;
                }
#if 0
                if (p_obj->current.ref.size == 1)
                {
                    struct flow_object* pointed = p_obj->current.ref.data[0];
                    return pointed;
                }
                else
                {
                    struct flow_object* p_object = make_flow_object(ctx, &p_expression->type, NULL, p_expression);
                    object_set_nothing(&p_expression->type, p_object);
                    for (int i = 0; i < p_obj->current.ref.size; i++)
                    {
                        struct flow_object* pointed = p_obj->current.ref.data[i];
                        if (pointed != NULL)
                        {
                            if (p_expression->member_index < pointed->members.size)
                            {
                                p_object->current.state |=
                                    pointed->members.data[p_expression->member_index]->current.state;
                                objects_view_merge(&p_object->current.ref, &pointed->members.data[p_expression->member_index]->current.ref);
                                //return pointed->members.data[p_expression->member_index];
                            }
                            else
                            {
                                //return NULL;
                            }
                        }
                    }
                    return p_object;
                }
#endif
            }
            return NULL;
        }
        else if (p_expression->expression_type == POSTFIX_ARROW)
        {
            assert(p_expression->left != NULL);

            struct flow_object* _Opt p_obj = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
            if (p_obj)
            {
                if (p_obj->current.pointed == 0)
                {
                    flow_object_expand_pointer(ctx, &p_expression->left->type, p_obj);
                }

                struct flow_object* _Opt pointed = p_obj->current.pointed;

                if (pointed == NULL ||
                    p_expression->member_index >= pointed->members.size)
                {
                    //ops!
                    return NULL;
                }

                struct flow_object* _Opt p_obj2 = pointed->members.data[p_expression->member_index];

                p_obj2->p_declarator_origin = NULL;
                p_obj2->p_expression_origin = p_expression;
                return p_obj2;
            }
            return NULL;
        }
        else if (p_expression->expression_type == UNARY_EXPRESSION_CONTENT)
        {
            assert(p_expression->right != NULL);

            struct flow_object* _Opt p_obj = expression_get_flow_object(ctx, p_expression->right, nullable_enabled);
            if (p_obj)
            {
                if (p_obj->current.pointed == NULL)
                {
                    flow_object_expand_pointer(ctx, &p_expression->right->type, p_obj);
                }

                if (p_obj->current.pointed != NULL)
                {
                    return p_obj->current.pointed;
                }
            }
            return p_obj;
        }
        else if (p_expression->expression_type == POSTFIX_FUNCTION_CALL)
        {
            struct flow_object* _Opt p_object = make_flow_object(ctx, &p_expression->type, NULL, p_expression);
            if (p_object == NULL) throw;

            const bool is_nullable = type_is_opt(&p_expression->type, nullable_enabled);
            flow_object_set_unknown(&p_expression->type, is_nullable, p_object, nullable_enabled);
            p_object->is_temporary = true;

            if (type_is_pointer(&p_expression->type) && flow_object_is_expansible(p_object))
            {
                flow_object_expand_pointer(ctx, &p_expression->type, p_object);
            }


            return p_object;
        }
        else if (p_expression->expression_type == POSTFIX_EXPRESSION_COMPOUND_LITERAL)
        {
            assert(p_expression->type_name != NULL);
            return p_expression->type_name->abstract_declarator->p_flow_object;
        }
        else if (p_expression->expression_type == PRIMARY_EXPRESSION_STRING_LITERAL)
        {
            struct flow_object* _Opt p_object = make_flow_object(ctx, &p_expression->type, NULL, p_expression);
            if (p_object == NULL) throw;

            p_object->current.state = FLOW_OBJECT_STATE_NOT_NULL;
            return p_object;
        }
        else if (p_expression->expression_type == PRIMARY_EXPRESSION_PREDEFINED_CONSTANT)
        {
            struct flow_object* _Opt p_object = make_flow_object(ctx, &p_expression->type, NULL, p_expression);
            if (p_object == NULL) throw;

            if (p_expression->type.type_specifier_flags == TYPE_SPECIFIER_NULLPTR_T)
            {
                p_object->current.state = FLOW_OBJECT_STATE_NULL;
            }
            else
            {
                if (object_has_constant_value(&p_expression->object))
                {
                    bool not_zero = object_to_bool(&p_expression->object);
                    p_object->current.state = not_zero ? FLOW_OBJECT_STATE_NOT_ZERO : FLOW_OBJECT_STATE_ZERO;
                }
            }

            return p_object;
        }
        else if (p_expression->expression_type == ASSIGNMENT_EXPRESSION_ASSIGN)
        {
            assert(p_expression->left != NULL);

            struct flow_object* _Opt p_obj = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);

            //
            //
            return p_obj;
        }
        else if (p_expression->expression_type == CONDITIONAL_EXPRESSION)
        {
            assert(p_expression->left != NULL);
            assert(p_expression->right != NULL);

            struct flow_object* _Opt p_object = make_flow_object(ctx, &p_expression->type, NULL, p_expression);
            if (p_object == NULL) throw;

            struct flow_object* _Opt p_obj1 = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);

            struct flow_object* _Opt p_obj2 = expression_get_flow_object(ctx, p_expression->right, nullable_enabled);

            if (p_obj1 && p_obj2)
            {
                flow_object_merge_state(p_object, p_obj1, p_obj2);
            }

            return p_object;
        }
        else if (p_expression->expression_type == EQUALITY_EXPRESSION_EQUAL ||
                 p_expression->expression_type == EQUALITY_EXPRESSION_NOT_EQUAL)
        {

            struct flow_object* _Opt p_object = make_flow_object(ctx, &p_expression->type, NULL, p_expression);
            if (p_object == NULL) throw;

            if (object_has_constant_value(&p_expression->object))
            {
                bool not_zero = object_to_bool(&p_expression->object);
                p_object->current.state = not_zero ? FLOW_OBJECT_STATE_NOT_ZERO : FLOW_OBJECT_STATE_ZERO;
            }
            else
            {
                p_object->current.state = FLOW_OBJECT_STATE_NOT_ZERO | FLOW_OBJECT_STATE_ZERO;
            }
            return p_object;
        }
        else if (p_expression->expression_type == ADDITIVE_EXPRESSION_PLUS)
        {
            struct flow_object* _Opt p_object = make_flow_object(ctx, &p_expression->type, NULL, p_expression);
            if (p_object == NULL) throw;

            if (type_is_pointer(&p_expression->type))
            {
                //p + 1
                //never null
                p_object->current.state = FLOW_OBJECT_STATE_NOT_NULL;
            }
            else
            {
                if (object_has_constant_value(&p_expression->object))
                {
                    bool not_zero = object_to_bool(&p_expression->object);
                    p_object->current.state = not_zero ? FLOW_OBJECT_STATE_NOT_NULL : FLOW_OBJECT_STATE_NULL;
                }
                else
                {
                    p_object->current.state = FLOW_OBJECT_STATE_NOT_NULL | FLOW_OBJECT_STATE_NULL;
                }
            }
            return p_object;
        }
        else if (p_expression->expression_type == UNARY_EXPRESSION_NEG ||
                 p_expression->expression_type == UNARY_EXPRESSION_PLUS)
        {
            assert(p_expression->right != NULL);

            struct flow_object* _Opt p_obj_right = expression_get_flow_object(ctx, p_expression->right, nullable_enabled);
            struct flow_object* _Opt p_object = make_flow_object(ctx, &p_expression->type, NULL, p_expression);
            if (p_object == NULL) throw;

            if (p_obj_right)
            {
                p_object->current.state = p_obj_right->current.state;
            }

            return p_object;
        }
        //
        else
        {
            struct flow_object* _Opt p_object = make_flow_object(ctx, &p_expression->type, NULL, p_expression);
            if (p_object == NULL) throw;

            if (type_is_pointer(&p_expression->type))
            {
                if (object_has_constant_value(&p_expression->object))
                {
                    bool not_zero = object_to_bool(&p_expression->object);
                    p_object->current.state = not_zero ? FLOW_OBJECT_STATE_NOT_NULL : FLOW_OBJECT_STATE_NULL;
                }
                else
                {
                    p_object->current.state = FLOW_OBJECT_STATE_NOT_NULL | FLOW_OBJECT_STATE_NULL;
                }
            }
            else
            {
                if (object_has_constant_value(&p_expression->object))
                {
                    bool not_zero = object_to_bool(&p_expression->object);
                    p_object->current.state = not_zero ? FLOW_OBJECT_STATE_NOT_ZERO : FLOW_OBJECT_STATE_ZERO;
                }
                else
                {
                    p_object->current.state = FLOW_OBJECT_STATE_NOT_ZERO | FLOW_OBJECT_STATE_ZERO;
                }
            }


            return p_object;
        }

    }
    catch
    {

    }
    //printf("null object");
    //assert(false);
    return NULL;
}

void flow_check_assignment(
    struct flow_visit_ctx* ctx,
    const struct token* error_position,
    const struct marker* p_a_marker,
    const struct marker* p_b_marker,
    enum assigment_type assigment_type,
    bool check_uninitialized_b,
    bool a_type_is_view,
    bool a_type_is_nullable,
    struct type* p_a_type, struct flow_object* p_a_object,
    struct type* p_b_type, struct flow_object* p_b_object,
    bool* _Opt set_argument_to_unkown)
{
    if (type_is_pointer(p_b_type) && flow_object_is_expansible(p_b_object))
    {
        //number of warning goes up!
        //flow_object_expand_pointer(ctx, p_b_type, p_b_object);
    }

    struct object_visitor visitor_a = {
    .p_object = p_a_object,
    .p_type = p_a_type
    };

    struct object_visitor visitor_b = {
     .p_object = p_b_object,
     .p_type = p_b_type
    };


    flow_assignment_core(
     ctx,
    error_position,
    p_a_marker,
    p_b_marker,
    assigment_type,
    check_uninitialized_b,
    a_type_is_view,
    a_type_is_nullable,
    &visitor_a,
    &visitor_b,
    set_argument_to_unkown);
}


void print_object_state_to_str(enum flow_state e, char str[], int sz)
{
    bool first = true;
    struct osstream ss = { 0 };

    if (e == FLOW_OBJECT_STATE_NOT_APPLICABLE)
        ss_fprintf(&ss, "--");

    if (e & FLOW_OBJECT_STATE_UNINITIALIZED)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "unset");
    }

    if (e & FLOW_OBJECT_STATE_NOT_NULL)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "not-null");
    }

    if (e & FLOW_OBJECT_STATE_NULL)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "null");
    }

    if (e & FLOW_OBJECT_STATE_ZERO)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "zero");
    }

    if (e & FLOW_OBJECT_STATE_NOT_ZERO)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "not-zero");
    }


    if (e & FLOW_OBJECT_STATE_LIFE_TIME_ENDED)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "lifetime-ended");
    }

    if (e & FLOW_OBJECT_STATE_MOVED)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "moved");
    }
    snprintf(str, sz, "%s", ss.c_str);
    ss_close(&ss);
}

void flow_object_state_print(struct flow_object_state* p_state)
{
    struct osstream ss = { 0 };

    char temp[200] = { 0 };
    print_object_state_to_str(p_state->state, temp, sizeof temp);
    ss_fprintf(&ss, "%d %s", p_state->state_number, temp);


    if (p_state->pointed)
    {
        ss_fprintf(&ss, " ->%d", p_state->pointed->id);
    }

    if (p_state->alternatives.size > 0)
        ss_fprintf(&ss, " ");
    for (int i = 0; i < p_state->alternatives.size; i++)
    {
        if (i != 0)
            ss_fprintf(&ss, ",");

        ss_fprintf(&ss, "%d", p_state->alternatives.data[i]->id);
    }
    printf("%-25s│", ss.c_str);
    ss_close(&ss);
}

void print_object_line(struct flow_object* p_object, int extra_cols)
{
    struct osstream ss = { 0 };

    if (p_object->parent)
    {
        ss_fprintf(&ss, "↑%d", p_object->parent->id);

        //if (p_object->current.alternatives.size > 0)
         //ss_fprintf(&ss, " &");

        printf("│%-2d│", p_object->id);
        printf("%-20s│", ss.c_str); //here we need compesate the unicode byte len of ↑
    }
    else
    {
        int line = 0, col = 0;
        if (p_object->p_declarator_origin)
        {
            if (p_object->p_declarator_origin->name_opt)
            {
                line = p_object->p_declarator_origin->name_opt->line;
                col = p_object->p_declarator_origin->name_opt->col;
                ss_fprintf(&ss, "%2d:%2d ", line, col);
                ss_fprintf(&ss, "%s", p_object->p_declarator_origin->name_opt->lexeme);
            }
            else
            {
                ss_fprintf(&ss, "%2d:%2d ", line, col);
                ss_fprintf(&ss, "%s", "?");
            }
        }
        else if (p_object->p_expression_origin)
        {
            line = p_object->p_expression_origin->first_token->line;
            col = p_object->p_expression_origin->first_token->col;
            ss_fprintf(&ss, "%2d:%2d ", line, col);

            ss_fprintf(&ss, "%s", p_object->p_expression_origin->first_token->lexeme);
        }
        else
        {
            ss_fprintf(&ss, "&");
        }
        printf("│%-2d│", p_object->id);
        printf("%-18s│", ss.c_str);
    }

    ss_close(&ss);


    int cols = 0;
    struct flow_object_state* _Opt p_state = &p_object->current;
    while (p_state)
    {
        cols++;
        flow_object_state_print(p_state);
        p_state = p_state->next;
    }

    for (int i = 0; i <= extra_cols - cols; i++)
    {
        printf("%-25s│", " ");
    }
    printf("\n");

}

void flow_visit_declaration(struct flow_visit_ctx* ctx, struct declaration* p_declaration);


static void flow_visit_secondary_block(struct flow_visit_ctx* ctx, struct secondary_block* p_secondary_block);
static void flow_visit_struct_or_union_specifier(struct flow_visit_ctx* ctx, struct struct_or_union_specifier* p_struct_or_union_specifier);
struct true_false_set;
static void flow_visit_expression(struct flow_visit_ctx* ctx, struct expression* p_expression, struct true_false_set* a);
static void flow_visit_statement(struct flow_visit_ctx* ctx, struct statement* p_statement);
static void flow_visit_enum_specifier(struct flow_visit_ctx* ctx, struct enum_specifier* p_enum_specifier);
static void flow_visit_type_specifier(struct flow_visit_ctx* ctx, struct type_specifier* p_type_specifier);
static void flow_visit_bracket_initializer_list(struct flow_visit_ctx* ctx, struct braced_initializer* p_bracket_initializer_list);
static void flow_visit_expression_statement(struct flow_visit_ctx* ctx, struct expression_statement* p_expression_statement);

enum boolean_flag
{
    BOOLEAN_FLAG_NONE = 0,
    BOOLEAN_FLAG_TRUE = 1 << 0,
    BOOLEAN_FLAG_FALSE = 1 << 1,
};

struct true_false_set_item
{
    struct expression* p_expression;
    enum boolean_flag true_branch_state;
    enum boolean_flag false_branch_state;
};

struct true_false_set
{
    struct true_false_set_item* _Owner _Opt data;
    int size;
    int capacity;
};

static void true_false_set_clear(struct true_false_set* p)
{
    free(p->data);
    p->data = NULL;
    p->size = 0;
    p->capacity = 0;
}

enum merge_options
{
    MERGE_OPTIONS_A_TRUE = 1 << 0,
    MERGE_OPTIONS_A_FALSE = 1 << 1,
    MERGE_OPTIONS_B_TRUE = 1 << 2,
    MERGE_OPTIONS_B_FALSE = 1 << 3
};

void true_false_set_destroy(_Dtor struct true_false_set* p)
{
    free(p->data);
}

static int true_false_set_reserve(struct true_false_set* p, int n)
{
    if (n > p->capacity)
    {
        if ((size_t)n > (SIZE_MAX / (sizeof(p->data[0]))))
        {
            return EOVERFLOW;
        }

        void* _Owner _Opt pnew = realloc(p->data, n * sizeof(p->data[0]));
        if (pnew == NULL)
            return ENOMEM;
        static_set(p->data, "moved");
        p->data = pnew;
        p->capacity = n;
    }
    return 0;
}

static int true_false_set_push_back(struct true_false_set* p, const struct true_false_set_item* book)
{
    if (p->size == INT_MAX)
    {
        return EOVERFLOW;
    }

    if (p->size + 1 > p->capacity)
    {
        int new_capacity = 0;
        if (p->capacity > (INT_MAX - p->capacity / 2))
        {
            /*overflow*/
            new_capacity = INT_MAX;
        }
        else
        {
            new_capacity = p->capacity + p->capacity / 2;
            if (new_capacity < p->size + 1)
            {
                new_capacity = p->size + 1;
            }
        }

        int error = true_false_set_reserve(p, new_capacity);
        if (error != 0)
        {
            return error;
        }
    }

    p->data[p->size] = *book; /*COPIED*/


    p->size++;

    return 0;
}

static void true_false_set_invert(struct true_false_set* true_false_set)
{
    for (int i = 0; i < true_false_set->size; i++)
    {
        enum boolean_flag temp = true_false_set->data[i].true_branch_state;
        true_false_set->data[i].true_branch_state = true_false_set->data[i].false_branch_state;
        true_false_set->data[i].false_branch_state = temp;
    }
}

static void true_false_set_swap(struct true_false_set* a, struct true_false_set* b)
{
    struct true_false_set temp = *a;
    *a = *b;
    *b = temp;
}

static int find_item_index_by_expression(const struct true_false_set* a, const struct expression* p_expression)
{
    for (int i = 0; i < a->size; i++)
    {
        if (a->data[i].p_expression == p_expression)
            return i;
    }
    return -1;
}

static void true_false_set_merge(struct true_false_set* result,
    struct true_false_set* a,
    struct true_false_set* b,
    enum merge_options options_true,
    enum merge_options options_false)
{

    for (int i = 0; i < a->size; i++)
    {
        const struct true_false_set_item* p_item_a = &a->data[i];

        _Opt struct true_false_set_item new_item = { 0 };
        new_item.p_expression = p_item_a->p_expression;

        if (options_true & MERGE_OPTIONS_A_TRUE)
            new_item.true_branch_state |= p_item_a->true_branch_state;

        if (options_true & MERGE_OPTIONS_A_FALSE)
            new_item.true_branch_state |= p_item_a->false_branch_state;

        if (options_false & MERGE_OPTIONS_A_TRUE)
            new_item.false_branch_state |= p_item_a->true_branch_state;

        if (options_false & MERGE_OPTIONS_A_FALSE)
            new_item.true_branch_state |= p_item_a->false_branch_state;


        true_false_set_push_back(result, &new_item);
    }

    for (int k = 0; k < b->size; k++)
    {
        const struct true_false_set_item* p_item_b = &b->data[k];

        int index = find_item_index_by_expression(result, p_item_b->p_expression);
        if (index == -1)
        {
            index = result->size;
            _Opt struct true_false_set_item item2 = { 0 };
            item2.p_expression = p_item_b->p_expression;
            true_false_set_push_back(result, &item2);
        }

        struct true_false_set_item* p_item_result = &result->data[index];

        if (options_true & MERGE_OPTIONS_B_TRUE)
            p_item_result->true_branch_state |= p_item_b->true_branch_state;

        if (options_true & MERGE_OPTIONS_B_FALSE)
            p_item_result->true_branch_state |= p_item_b->false_branch_state;

        if (options_false & MERGE_OPTIONS_B_TRUE)
            p_item_result->false_branch_state |= p_item_b->true_branch_state;

        if (options_false & MERGE_OPTIONS_B_FALSE)
            p_item_result->true_branch_state |= p_item_b->false_branch_state;
    }
}

static void true_false_set_set_objects_to_core_branch(struct flow_visit_ctx* ctx,
    struct true_false_set* a,
    bool nullable_enabled,
    bool true_branch)
{
    for (int i = 0; i < a->size; i++)
    {
        assert(a->data[i].p_expression != NULL);

        struct flow_object* _Opt p_object =
            expression_get_flow_object(ctx, a->data[i].p_expression, nullable_enabled);

        if (p_object)
        {
            if (p_object->current.state == FLOW_OBJECT_STATE_NOT_NULL ||
                p_object->current.state == FLOW_OBJECT_STATE_NULL ||
                p_object->current.state == FLOW_OBJECT_STATE_MOVED ||
                p_object->current.state == FLOW_OBJECT_STATE_ZERO ||
                p_object->current.state == FLOW_OBJECT_STATE_NOT_ZERO ||
                p_object->current.state == FLOW_OBJECT_STATE_LIFE_TIME_ENDED)
            {
                continue;
            }

            const enum boolean_flag flag =
                true_branch ?
                a->data[i].true_branch_state :
                a->data[i].false_branch_state;

            if ((flag & BOOLEAN_FLAG_TRUE) && (flag & BOOLEAN_FLAG_FALSE))
            {
            }
            else if (flag & BOOLEAN_FLAG_FALSE)
            {
                p_object->current.state &= ~FLOW_OBJECT_STATE_NOT_NULL;
                p_object->current.state &= ~FLOW_OBJECT_STATE_MOVED;
            }
            else if (flag & BOOLEAN_FLAG_TRUE)
            {
                p_object->current.state &= ~FLOW_OBJECT_STATE_NULL;
                p_object->current.state &= ~FLOW_OBJECT_STATE_ZERO;

            }
        }
    }
}

static void true_false_set_set_objects_to_true_branch(struct flow_visit_ctx* ctx, struct true_false_set* a, bool nullable_enabled)
{
    true_false_set_set_objects_to_core_branch(ctx, a, nullable_enabled, true);
}

static void true_false_set_set_objects_to_false_branch(struct flow_visit_ctx* ctx, struct true_false_set* a, bool nullable_enabled)
{
    true_false_set_set_objects_to_core_branch(ctx, a, nullable_enabled, false);
}

static int arena_add_copy_of_current_state(struct flow_visit_ctx* ctx, const char* name);


static void arena_remove_state(struct flow_visit_ctx* ctx, int state_number);

struct visit_objects {
    struct flow_defer_scope* current_block;
    struct flow_defer_scope* next_child;
};


static void flow_exit_block_visit_defer_item(struct flow_visit_ctx* ctx,
    struct defer_list_item* p_item,
    struct token* position_token)
{
    if (p_item->defer_statement)
    {
        const int error_count = ctx->ctx->p_report->error_count;
        const int warnings_count = ctx->ctx->p_report->warnings_count;
        const int info_count = ctx->ctx->p_report->info_count;

        flow_visit_secondary_block(ctx, p_item->defer_statement->secondary_block);

        if (error_count != ctx->ctx->p_report->error_count ||
            warnings_count != ctx->ctx->p_report->warnings_count ||
            info_count != ctx->ctx->p_report->info_count)
        {
            compiler_diagnostic(W_LOCATION, ctx->ctx, position_token, NULL, "defer end of scope");
        }
    }
    else if (p_item->declarator)
    {
        struct declarator* p_declarator = p_item->declarator;
        const char* name = p_declarator->name_opt ? p_declarator->name_opt->lexeme : "?";

        if (p_declarator->p_flow_object)
        {
            flow_end_of_block_visit(ctx,
                &p_declarator->type,
                type_is_view(&p_declarator->type),
                p_declarator->p_flow_object,
                position_token,
                name);
        }
        else
        {
            assert(0);
        }
    }
}

static void flow_exit_block_visit_defer_list(struct flow_visit_ctx* ctx,
    struct defer_list* p_defer_list,
    struct token* position_token)
{
    struct defer_list_item* _Opt p_item = p_defer_list->head;
    while (p_item)
    {
        flow_exit_block_visit_defer_item(ctx, p_item, position_token);
        p_item = p_item->next;
    }
}

static void flow_defer_item_set_end_of_lifetime(struct flow_visit_ctx* ctx,
    struct defer_list_item* p_item,
    struct token* position_token)
{
    if (p_item->defer_statement)
    {
        //?
    }
    else if (p_item->declarator)
    {
        struct declarator* p_declarator = p_item->declarator;
        //const char* name = p_declarator->name_opt ? p_declarator->name_opt->lexeme : "?";

        if (p_declarator->p_flow_object)
        {
            flow_object_set_end_of_lifetime(&p_declarator->type, p_declarator->p_flow_object);
        }
        else
        {
            assert(0);
        }
    }
}

static void flow_defer_list_set_end_of_lifetime(struct flow_visit_ctx* ctx,
    struct defer_list* p_defer_list,
    struct token* position_token)
{
    struct defer_list_item* _Opt p_item = p_defer_list->head;
    while (p_item)
    {
        flow_defer_item_set_end_of_lifetime(ctx, p_item, position_token);
        p_item = p_item->next;
    }
}

static void flow_visit_secondary_block(struct flow_visit_ctx* ctx, struct secondary_block* p_secondary_block)
{
    flow_visit_statement(ctx, p_secondary_block->statement);
}

static void flow_visit_defer_statement(struct flow_visit_ctx* ctx, struct defer_statement* p_defer_statement)
{
    /*
      We are not going to visit the secondary block here because
      this is not the place were defer is executed.
    */
}

NODISCARD
static int arena_add_copy_of_current_state(struct flow_visit_ctx* ctx, const char* name)
{
    int state_number = ctx->state_number_generator;
    ctx->state_number_generator++;
    for (int i = 0; i < ctx->arena.size; i++)
    {
        flow_object_add_new_state_as_a_copy_of_current_state(ctx->arena.data[i], name, state_number);
    }
    return state_number;
}

static int arena_add_empty_state(struct flow_visit_ctx* ctx, const char* name)
{
    int state_number = ctx->state_number_generator;
    ctx->state_number_generator++;

    for (int i = 0; i < ctx->arena.size; i++)
    {
        struct flow_object* p_object = ctx->arena.data[i];
        _Opt struct flow_object_state* _Owner _Opt p_flow_object_state = calloc(1, sizeof * p_flow_object_state);
        if (p_flow_object_state)
        {
            p_flow_object_state->dbg_name = name;
            p_flow_object_state->state_number = state_number;
            flow_object_add_state(p_object, p_flow_object_state);
        }

    }
    return state_number;
}

static void flow_object_set_state_from_current(struct flow_object* object, int state_number)
{
    struct flow_object_state* _Opt p_flow_object_state = object->current.next;
    while (p_flow_object_state)
    {
        if (p_flow_object_state->state_number == state_number)
        {
            flow_object_state_copy(p_flow_object_state, &object->current);
            break;
        }
        p_flow_object_state = p_flow_object_state->next;
    }
}

static void arena_set_state_from_current(struct flow_visit_ctx* ctx, int number_state)
{
    for (int i = 0; i < ctx->arena.size; i++)
    {
        struct flow_object* p_object = ctx->arena.data[i];
        flow_object_set_state_from_current(p_object, number_state);
    }
}

static int flow_object_merge_current_with_state(struct flow_visit_ctx* ctx, struct flow_object* object, int state_number)
{
    try
    {
        struct flow_object_state* _Opt it = object->current.next;
        while (it)
        {
            if (it->state_number == state_number)
            {
                it->state |= object->current.state;
                if (object->current.pointed == NULL && it->pointed == NULL)
                {
                    //nothing
                }
                else if (object->current.pointed == NULL && it->pointed != NULL)
                {
                    //mesmo
                }
                else if (object->current.pointed != NULL && it->pointed == NULL)
                {
                    it->pointed = object->current.pointed;
                }
                else if (object->current.pointed != it->pointed)
                {
                    assert(object->current.pointed != NULL);
                    assert(it->pointed != NULL);

                    struct flow_object* _Opt p_new_object = arena_new_object(ctx);
                    if (p_new_object == NULL) throw;

                    _Opt struct flow_object_state* _Owner _Opt p_new_state = calloc(1, sizeof * p_new_state);
                    if (p_new_state == NULL) throw;

                    p_new_state->dbg_name = "merged";
                    p_new_state->state_number = state_number;
                    objects_view_push_back(&p_new_state->alternatives, object->current.pointed);
                    objects_view_push_back(&p_new_state->alternatives, it->pointed);
                    flow_object_add_state(p_new_object, p_new_state);

                    int n_childs_1 = object->current.pointed->members.size;
                    int n_childs_2 = it->pointed->members.size;
                    if (n_childs_1 == n_childs_2)
                    {

                        for (int j = 0; j < n_childs_1; j++)
                        {
                            struct flow_object* _Opt p_new_child = arena_new_object(ctx);
                            if (p_new_child == NULL) throw;

                            p_new_child->parent = p_new_object;

                            struct flow_object* child1 = object->current.pointed->members.data[j];
                            struct flow_object* child2 = it->pointed->members.data[j];

                            _Opt struct flow_object_state* _Owner _Opt p_child_new_state = calloc(1, sizeof * p_child_new_state);
                            if (p_child_new_state == NULL) throw;

                            p_child_new_state->dbg_name = "merged";
                            p_child_new_state->state_number = state_number;
                            p_child_new_state->state = child1->current.state | it->state;
                            objects_view_push_back(&p_child_new_state->alternatives, child1);
                            objects_view_push_back(&p_child_new_state->alternatives, child2);
                            flow_object_add_state(p_new_child, p_child_new_state);
                            objects_view_push_back(&p_new_object->members, p_new_child);
                        }
                    }
                    else
                    {
                        //ops
                        //dbg_break();
                    }

                    it->pointed = p_new_object;
                }
                break;
            }
            it = it->next;
        }
    }
    catch
    {
    }
    return 0;
}

static void arena_merge_current_state_with_state_number(struct flow_visit_ctx* ctx, int number_state)
{
    for (int i = 0; i < ctx->arena.size; i++)
    {
        flow_object_merge_current_with_state(ctx, ctx->arena.data[i], number_state);
    }
}

static void object_restore_current_state_from(struct flow_visit_ctx* ctx, struct flow_object* object, int state_number)
{
    struct flow_object_state* _Opt it = object->current.next;
    while (it)
    {
        if (it->state_number == state_number)
        {
            flow_object_state_copy(&object->current, it);
            break;
        }
        it = it->next;
    }
}

static void arena_restore_current_state_from(struct flow_visit_ctx* ctx, int number_state)
{
    for (int i = 0; i < ctx->arena.size; i++)
    {
        object_restore_current_state_from(ctx, ctx->arena.data[i], number_state);
    }
}

static void arena_remove_state(struct flow_visit_ctx* ctx, int state_number)
{
    for (int i = 0; i < ctx->arena.size; i++)
    {
        flow_object_remove_state(ctx->arena.data[i], state_number);
    }
}

static void flow_visit_initializer(struct flow_visit_ctx* ctx, struct initializer* p_initializer);
static void flow_visit_declarator(struct flow_visit_ctx* ctx, struct declarator* p_declarator);


static void braced_initializer_flow_core(struct flow_visit_ctx* ctx, struct object* obj, struct flow_object* flow_obj)
{
    /*
       We use the obj to get the expression that initializes it.
    */

    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    if (obj->p_init_expression)
    {
        struct flow_object* _Opt p_right_object =
            expression_get_flow_object(ctx, obj->p_init_expression, nullable_enabled);

        if (p_right_object)
        {
            struct marker a_marker = {
                .p_token_begin = NULL,
                .p_token_end = NULL,
            };

            struct marker b_marker = {
                .p_token_begin = obj->p_init_expression->first_token,
                .p_token_end = obj->p_init_expression->last_token,
            };

            flow_check_assignment(ctx,
                                obj->p_init_expression->first_token,
                                &a_marker,
                                &b_marker,
                                ASSIGMENT_TYPE_OBJECTS,
                                false,
                                type_is_view(&obj->type),
                                type_is_opt(&obj->type, ctx->ctx->options.null_checks_enabled),
                                &obj->type,
                                flow_obj,
                                &obj->p_init_expression->type,
                                p_right_object,
                                NULL);
        }
    }
    else
    {
        /*default initialization*/
        flow_object_set_zero(&obj->type, flow_obj);
    }

    if (flow_obj->members.size > 0)
    {
        /*flow_object and object have the same number of members*/
        int i = 0;

        struct object* _Opt m = obj->members;
        while (m)
        {
            braced_initializer_flow_core(ctx, m, flow_obj->members.data[i]);
            m = m->next;
            i++;
        }
    }
}

static void braced_initializer_flow(struct flow_visit_ctx* ctx, struct object* obj, struct flow_object* flow_obj)
{
    try
    {
        braced_initializer_flow_core(ctx, obj, flow_obj);

        if (flow_obj->p_declarator_origin == NULL)
        {
            throw;
        }

        /*
           Let´s check if the object has been initialized correctly
        */

        bool is_nullable = type_is_opt(&obj->type, ctx->ctx->options.null_checks_enabled);

        struct marker a_marker = {
                          .p_token_begin = flow_obj->p_declarator_origin->first_token_opt,
                          .p_token_end = flow_obj->p_declarator_origin->last_token_opt,
        };
        checked_read_object(ctx,
        &obj->type,
        is_nullable,
        flow_obj,
        flow_obj->p_declarator_origin->first_token_opt,
        &a_marker,
        false);
    }
    catch
    {
    }
}


static void flow_visit_init_declarator(struct flow_visit_ctx* ctx, struct init_declarator* p_init_declarator)
{
    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    try
    {
        flow_visit_declarator(ctx, p_init_declarator->p_declarator);

        if (p_init_declarator->initializer)
        {
            if (p_init_declarator->initializer->assignment_expression)
            {
                struct true_false_set a = { 0 };
                flow_visit_expression(ctx, p_init_declarator->initializer->assignment_expression, &a);
                true_false_set_destroy(&a);
            }
            else
            {
                if (p_init_declarator->initializer->braced_initializer)
                {
                    flow_visit_bracket_initializer_list(ctx,
                        p_init_declarator->initializer->braced_initializer);
                }
                else
                {
                    assert(false);
                }
            }
        }

        if (p_init_declarator->p_declarator->type.category != TYPE_CATEGORY_FUNCTION)
        {
            if (p_init_declarator->initializer &&
                p_init_declarator->initializer->assignment_expression)
            {
                struct flow_object* _Opt p_right_object =
                    expression_get_flow_object(ctx, p_init_declarator->initializer->assignment_expression, nullable_enabled);

                if (p_right_object)
                {
                    struct marker a_marker = {
                        .p_token_begin = p_init_declarator->p_declarator->first_token_opt,
                        .p_token_end = p_init_declarator->p_declarator->last_token_opt,
                    };

                    struct marker b_marker = {
                        .p_token_begin = p_init_declarator->initializer->assignment_expression->first_token,
                        .p_token_end = p_init_declarator->initializer->assignment_expression->last_token,
                    };

                    assert(p_init_declarator->p_declarator->p_flow_object != NULL);

                    flow_check_assignment(ctx,
                                        p_init_declarator->initializer->assignment_expression->first_token,
                                        &a_marker,
                                        &b_marker,
                                        ASSIGMENT_TYPE_OBJECTS,
                                        false,
                                        type_is_view(&p_init_declarator->p_declarator->type),
                                        type_is_opt(&p_init_declarator->p_declarator->type, ctx->ctx->options.null_checks_enabled),
                                        &p_init_declarator->p_declarator->type,
                                        p_init_declarator->p_declarator->p_flow_object,
                                        &p_init_declarator->initializer->assignment_expression->type,
                                        p_right_object,
                                        NULL);
                }
                //cast?
                if (expression_is_malloc(p_init_declarator->initializer->assignment_expression))
                {
                    assert(p_init_declarator->p_declarator->p_flow_object != NULL);

                    struct type t = type_remove_pointer(&p_init_declarator->p_declarator->type);
                    struct flow_object* _Opt po = make_flow_object(ctx, &t, p_init_declarator->p_declarator, NULL);
                    if (po == NULL)
                    {
                        type_destroy(&t);
                        throw;
                    }

                    object_set_pointer(p_init_declarator->p_declarator->p_flow_object, po);
                    type_destroy(&t);
                    p_init_declarator->p_declarator->p_flow_object->current.state = FLOW_OBJECT_STATE_NOT_NULL | FLOW_OBJECT_STATE_NULL;
                }
                else if (expression_is_calloc(p_init_declarator->initializer->assignment_expression))
                {
                    assert(p_init_declarator->p_declarator->p_flow_object != NULL);

                    struct type t = type_remove_pointer(&p_init_declarator->p_declarator->type);
                    struct flow_object* _Opt pointed_calloc_object = make_flow_object(ctx, &t, p_init_declarator->p_declarator, NULL);
                    if (pointed_calloc_object == NULL)
                    {
                        type_destroy(&t);
                        throw;
                    }

                    flow_object_set_zero(&t, pointed_calloc_object);
                    object_set_pointer(p_init_declarator->p_declarator->p_flow_object, pointed_calloc_object);

                    struct marker a_marker = {
                      .p_token_begin = p_init_declarator->p_declarator->first_token_opt,
                      .p_token_end = p_init_declarator->p_declarator->last_token_opt,
                    };

                    checked_read_object(ctx,
                        &t,
                        type_is_opt(&t, ctx->ctx->options.null_checks_enabled),
                        pointed_calloc_object,
                        p_init_declarator->p_declarator->first_token_opt,
                        &a_marker,
                        false);

                    type_destroy(&t);
                    p_init_declarator->p_declarator->p_flow_object->current.state = FLOW_OBJECT_STATE_NOT_NULL | FLOW_OBJECT_STATE_NULL;
                }
            }
            else  if (p_init_declarator->initializer &&
                p_init_declarator->initializer->braced_initializer)
            {
                assert(p_init_declarator->p_declarator->p_flow_object != NULL);
                braced_initializer_flow(ctx,
                    &p_init_declarator->p_declarator->object,
                    p_init_declarator->p_declarator->p_flow_object);
            }
            else
            {
                if (p_init_declarator->p_declarator->declaration_specifiers &&
                    (
                        (!(p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_BLOCK_SCOPE)) ||
                        (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_STATIC)
                        )
                    )
                {
                    assert(p_init_declarator->p_declarator->p_flow_object != NULL);
                    flow_object_set_zero(&p_init_declarator->p_declarator->type, p_init_declarator->p_declarator->p_flow_object);
                }
                else
                {
                    assert(p_init_declarator->p_declarator->p_flow_object != NULL);
                    flow_object_set_uninitialized(&p_init_declarator->p_declarator->type, p_init_declarator->p_declarator->p_flow_object);
                }
            }
        }
    }
    catch
    {
        //some unexpected error
    }
}


static void flow_visit_init_declarator_list(struct flow_visit_ctx* ctx, struct init_declarator_list* p_init_declarator_list);

static void flow_visit_declaration_specifiers(struct flow_visit_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers,
    struct type* _Opt p_type);


static void flow_visit_simple_declaration(struct flow_visit_ctx* ctx, struct simple_declaration* p_simple_declaration)
{
    flow_visit_declaration_specifiers(ctx, p_simple_declaration->p_declaration_specifiers, NULL);
    flow_visit_init_declarator_list(ctx, &p_simple_declaration->init_declarator_list);
}

static void flow_check_pointer_used_as_bool(struct flow_visit_ctx* ctx, struct expression* p_expression);

void print_arena(struct flow_visit_ctx* ctx)
{
    int extra_cols = 0;
    for (int i = 0; i < ctx->arena.size; i++)
    {
        struct flow_object* p_object = ctx->arena.data[i];
        struct flow_object_state* _Opt p_state = p_object->current.next;
        int count = 0;
        while (p_state)
        {
            count++;
            p_state = p_state->next;
        }
        if (count > extra_cols)
            extra_cols = count;
    }


    //┐
    printf("\n");
    printf("┌──┬──────────────────┬─────────────────────────");
    if (extra_cols > 0)
    {
        for (int i = 0; i < extra_cols; i++)
        {
            if (i < extra_cols - 1)
                printf("┬─────────────────────────");
            else
                printf("┬─────────────────────────");
        }
    }

    printf("┐");

    printf("\n");

    for (int i = 0; i < ctx->arena.size; i++)
    {
        struct flow_object* p = ctx->arena.data[i];
        print_object_line(p, extra_cols);
    }
    printf("└──┴──────────────────┴─────────────────────────");
    if (extra_cols > 0)
    {
        for (int i = 0; i < extra_cols; i++)
        {
            if (i < extra_cols - 1)
                printf("┴─────────────────────────");
            else
                printf("┴─────────────────────────");
        }
    }

    printf("┘");

    printf("\n");
    printf("\n");
}

static void flow_visit_if_statement(struct flow_visit_ctx* ctx, struct selection_statement* p_selection_statement)
{
    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    if (p_selection_statement->p_init_statement &&
        p_selection_statement->p_init_statement->p_expression_statement)
        flow_visit_expression_statement(ctx, p_selection_statement->p_init_statement->p_expression_statement);

    if (p_selection_statement->p_init_statement &&
        p_selection_statement->p_init_statement->p_simple_declaration)
        flow_visit_simple_declaration(ctx, p_selection_statement->p_init_statement->p_simple_declaration);


    /*
      if(int *p = f());
      The hidden expression is p
    */
    _Opt _View struct expression hidden_expression = { 0 };

    struct true_false_set true_false_set = { 0 };

    if (p_selection_statement->condition &&
        p_selection_statement->condition->expression)
    {
        flow_check_pointer_used_as_bool(ctx, p_selection_statement->condition->expression);
        flow_visit_expression(ctx, p_selection_statement->condition->expression, &true_false_set);
    }

    if (p_selection_statement->condition &&
        p_selection_statement->condition->p_init_declarator)
    {
        flow_visit_init_declarator(ctx, p_selection_statement->condition->p_init_declarator);
    }

    if (p_selection_statement->condition &&
        p_selection_statement->condition->expression == NULL &&
        p_selection_statement->condition->p_init_declarator != NULL)
    {
        hidden_expression.expression_type = PRIMARY_EXPRESSION_DECLARATOR;
        hidden_expression.declarator = p_selection_statement->condition->p_init_declarator->p_declarator;
        assert(p_selection_statement->condition->p_init_declarator->p_declarator->first_token_opt != NULL);
        hidden_expression.first_token = p_selection_statement->condition->p_init_declarator->p_declarator->first_token_opt;
        hidden_expression.last_token = hidden_expression.first_token;
        flow_visit_expression(ctx, &hidden_expression, &true_false_set);
    }

    assert(p_selection_statement->first_token->type == TK_KEYWORD_IF);

    /*
       This index is from the end of top of stack going to base of statck
    */
    const int before_if_state_number = arena_add_copy_of_current_state(ctx, "before-if");

    true_false_set_set_objects_to_true_branch(ctx, &true_false_set, nullable_enabled);
    flow_visit_secondary_block(ctx, p_selection_statement->secondary_block);

    const bool true_branch_ends_with_jump =
        secondary_block_ends_with_jump(p_selection_statement->secondary_block);


    /*let's make a copy of the state we left true branch*/
    //const int true_branch = 1;
    const int left_true_branch_state_number = arena_add_copy_of_current_state(ctx, "left-true-branch");

    arena_restore_current_state_from(ctx, before_if_state_number);


    if (p_selection_statement->else_secondary_block_opt)
    {
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
        flow_visit_secondary_block(ctx, p_selection_statement->else_secondary_block_opt);
    }
    else
    {
        //we emulate a empty else {}
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
    }

    bool else_ends_with_jump =
        p_selection_statement->else_secondary_block_opt ?
        secondary_block_ends_with_jump(p_selection_statement->else_secondary_block_opt) :
        false;


    if (true_branch_ends_with_jump)
    {
        if (else_ends_with_jump)
        {
            /*
               if (){
                 return
               }
               else
               {
                 return;
               }
            */
            /*no merge*/
        }
        else
        {
            /*
               if (){
                 return
               }
               else
               {

               }
            */

        }
    }
    else
    {
        if (else_ends_with_jump)
        {
            /*
               if (){

               }
               else
               {
                 return;
               }
            */

            arena_restore_current_state_from(ctx, left_true_branch_state_number);
        }
        else
        {
            /*
               if (){
               }
               else {

               }
            */

            arena_merge_current_state_with_state_number(ctx, left_true_branch_state_number);

            arena_restore_current_state_from(ctx, left_true_branch_state_number);
        }
    }

    flow_exit_block_visit_defer_list(ctx, &p_selection_statement->defer_list, p_selection_statement->last_token);
    flow_defer_list_set_end_of_lifetime(ctx, &p_selection_statement->defer_list, p_selection_statement->last_token);

    arena_remove_state(ctx, before_if_state_number);
    arena_remove_state(ctx, left_true_branch_state_number);
    true_false_set_destroy(&true_false_set);

}

static void flow_visit_block_item(struct flow_visit_ctx* ctx, struct block_item* p_block_item);


static void flow_visit_try_statement(struct flow_visit_ctx* ctx, struct try_statement* p_try_statement)
{
    try
    {
        const int throw_join_state_old = ctx->throw_join_state;
        struct secondary_block* _Opt catch_secondary_block_old = ctx->catch_secondary_block_opt;

        ctx->catch_secondary_block_opt = p_try_statement->catch_secondary_block_opt;

        ctx->throw_join_state = arena_add_empty_state(ctx, "try");

        const int original_state_number = arena_add_copy_of_current_state(ctx, "original");


        flow_visit_secondary_block(ctx, p_try_statement->secondary_block);
        arena_set_state_from_current(ctx, original_state_number); //state of end of secondary block

        if (p_try_statement->catch_secondary_block_opt)
        {
            //current all possible states of throw
            arena_restore_current_state_from(ctx, ctx->throw_join_state);
            flow_visit_secondary_block(ctx, p_try_statement->catch_secondary_block_opt);
            //current has the state at the end of catch block
        }

        bool try_reached_the_end = !secondary_block_ends_with_jump(p_try_statement->secondary_block);
        bool catch_reached_the_end = !secondary_block_ends_with_jump(p_try_statement->catch_secondary_block_opt);

        if (try_reached_the_end && catch_reached_the_end)
        {
            //we could merge directly at current
            arena_merge_current_state_with_state_number(ctx, original_state_number);
            arena_restore_current_state_from(ctx, original_state_number);
        }
        else if (try_reached_the_end)
        {
            arena_restore_current_state_from(ctx, original_state_number);
        }
        else if (catch_reached_the_end)
        {
            //ctx_object_restore_current_state_from(ctx, orignial);       
        }


        arena_remove_state(ctx, original_state_number);
        arena_remove_state(ctx, ctx->throw_join_state);

        ctx->throw_join_state = throw_join_state_old; //restore
        ctx->catch_secondary_block_opt = catch_secondary_block_old; //restore
    }
    catch
    {
    }
}

static void flow_visit_switch_statement(struct flow_visit_ctx* ctx, struct selection_statement* p_selection_statement)
{
    const int old_initial_state = ctx->initial_state;
    const int old_break_join_state = ctx->break_join_state;

    ctx->initial_state = arena_add_copy_of_current_state(ctx, "original");
    ctx->break_join_state = arena_add_empty_state(ctx, "break join");

    flow_visit_secondary_block(ctx, p_selection_statement->secondary_block);

    bool reached_the_end = !secondary_block_ends_with_jump(p_selection_statement->secondary_block);

    if (!reached_the_end)
    {
        arena_restore_current_state_from(ctx, ctx->break_join_state);
    }

    flow_exit_block_visit_defer_list(ctx, &p_selection_statement->defer_list, p_selection_statement->secondary_block->last_token);
    flow_defer_list_set_end_of_lifetime(ctx, &p_selection_statement->defer_list, p_selection_statement->secondary_block->last_token);

    arena_remove_state(ctx, ctx->initial_state);
    arena_remove_state(ctx, ctx->break_join_state);

    //restore
    ctx->initial_state = old_initial_state;
    ctx->break_join_state = old_break_join_state;
}

static void flow_visit_selection_statement(struct flow_visit_ctx* ctx, struct selection_statement* p_selection_statement)
{
    if (p_selection_statement->first_token->type == TK_KEYWORD_IF)
    {
        flow_visit_if_statement(ctx, p_selection_statement);
    }
    else if (p_selection_statement->first_token->type == TK_KEYWORD_SWITCH)
    {
        flow_visit_switch_statement(ctx, p_selection_statement);
    }
    else
        assert(false);
}

static void flow_visit_compound_statement(struct flow_visit_ctx* ctx, struct compound_statement* p_compound_statement);

static void flow_visit_initializer_list(struct flow_visit_ctx* ctx, struct initializer_list* p_initializer_list);

static void flow_visit_bracket_initializer_list(struct flow_visit_ctx* ctx, struct braced_initializer* p_bracket_initializer_list)
{
    if (p_bracket_initializer_list->initializer_list == NULL)
    {

    }
    else
    {
        flow_visit_initializer_list(ctx, p_bracket_initializer_list->initializer_list);
    }
}

static void flow_visit_bracket_initializer_list(struct flow_visit_ctx* ctx, struct braced_initializer* p_bracket_initializer_list);

static void flow_visit_initializer_list_item(struct flow_visit_ctx* ctx, struct initializer_list_item* p_initializer)
{
    assert(p_initializer->initializer != NULL);
    flow_visit_initializer(ctx, p_initializer->initializer);
}

static void flow_visit_initializer(struct flow_visit_ctx* ctx, struct initializer* p_initializer)
{
    if (p_initializer->assignment_expression)
    {
        struct true_false_set a = { 0 };
        flow_visit_expression(ctx, p_initializer->assignment_expression, &a);
        true_false_set_destroy(&a);
    }
    else if (p_initializer->braced_initializer)
    {
        flow_visit_bracket_initializer_list(ctx, p_initializer->braced_initializer);
    }
}

static void flow_visit_initializer_list(struct flow_visit_ctx* ctx, struct initializer_list* p_initializer_list)
{
    struct initializer_list_item* _Opt p_initializer = p_initializer_list->head;
    while (p_initializer)
    {
        flow_visit_initializer_list_item(ctx, p_initializer);
        p_initializer = p_initializer->next;
    }
}

static void flow_visit_generic_selection(struct flow_visit_ctx* ctx, struct generic_selection* p_generic_selection)
{
    if (p_generic_selection->expression)
    {
        struct true_false_set a = { 0 };
        flow_visit_expression(ctx, p_generic_selection->expression, &a);
        true_false_set_destroy(&a);
    }
}


static void flow_compare_function_arguments(struct flow_visit_ctx* ctx,
    struct type* p_type,
    struct argument_expression_list* p_argument_expression_list)
{
    try
    {
        const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

        const struct param_list* _Opt p_param_list = type_get_func_or_func_ptr_params(p_type);
        if (p_param_list == NULL) throw;

        struct param* _Opt p_current_parameter_type = p_param_list->head;
        struct argument_expression* _Opt p_current_argument = p_argument_expression_list->head;

        while (p_current_argument && p_current_parameter_type)
        {

            struct true_false_set a = { 0 };

            struct diagnostic temp =
                ctx->ctx->options.diagnostic_stack.stack[ctx->ctx->options.diagnostic_stack.top_index];

            //we don´t report W_FLOW_UNINITIALIZED here because it is checked next.. (TODO parts of expression)
            diagnostic_remove(&ctx->ctx->options.diagnostic_stack.stack[ctx->ctx->options.diagnostic_stack.top_index], W_FLOW_UNINITIALIZED);

            flow_visit_expression(ctx, p_current_argument->expression, &a);

            ctx->ctx->options.diagnostic_stack.stack[ctx->ctx->options.diagnostic_stack.top_index] = temp;

            true_false_set_destroy(&a);

            struct flow_object* _Opt p_argument_object =
                expression_get_flow_object(ctx, p_current_argument->expression, nullable_enabled);

            if (p_argument_object)
            {
                struct flow_object* _Opt parameter_object = make_flow_object(ctx, &p_current_parameter_type->type, NULL, p_current_argument->expression);
                if (parameter_object == NULL) throw;

                flow_object_set_uninitialized(&p_current_parameter_type->type, parameter_object);

                struct marker a_marker = {
                    .p_token_begin = p_current_argument->expression->first_token,
                    .p_token_end = p_current_argument->expression->last_token
                };

                //TODO pass real function to get location
                struct marker b_marker = {
                    .p_token_begin = p_current_argument->expression->first_token,
                    .p_token_end = p_current_argument->expression->last_token
                };

                flow_check_assignment(ctx,
                  p_current_argument->expression->first_token,
                  &a_marker,
                  &b_marker,
                  ASSIGMENT_TYPE_PARAMETER,
                  true,
                  type_is_view(&p_current_parameter_type->type),
                  type_is_opt(&p_current_parameter_type->type, ctx->ctx->options.null_checks_enabled),
                  &p_current_parameter_type->type,
                  parameter_object, /*dest object*/

                  &p_current_argument->expression->type,
                  p_argument_object,
                  &p_current_argument->set_unkown
                );
            }
            p_current_argument = p_current_argument->next;
            p_current_parameter_type = p_current_parameter_type->next;
        }

        while (p_current_argument)
        {
            /*
               We have more argument than parameters, this happens with variadic functions
            */

            struct flow_object* _Opt p_argument_object =
                expression_get_flow_object(ctx, p_current_argument->expression, nullable_enabled);

            if (p_argument_object)
            {
                struct marker marker = {
                    .p_token_begin = p_current_argument->expression->first_token,
                    .p_token_end = p_current_argument->expression->last_token
                };
                checked_read_object(ctx,
                    &p_current_argument->expression->type,
                    type_is_opt(&p_current_argument->expression->type, ctx->ctx->options.null_checks_enabled),
                    p_argument_object,
                    p_current_argument->expression->first_token,
                    &marker,
                    false);
            }
            else
            {
                //
            }
            p_current_argument = p_current_argument->next;
        }

        //////////////////////////// SECOND PASS ////////////////////////////
        /*
            //consider this sample...
            void f(struct X *p,  int * p);

            int main()
            {
                struct X *  pX = make();
                if (pX->p)
                {
                   //cake is making pX->p  unknown before function call..it must be after
                   f(pX, pX->p);
                }
            }
        */

        /*struct param* */ p_current_parameter_type = p_param_list->head;
        /*struct argument_expression* */ p_current_argument = p_argument_expression_list->head;


        while (p_current_argument && p_current_parameter_type)
        {
            if (p_current_argument->set_unkown &&
                type_is_pointer(&p_current_argument->expression->type))
            {
                struct type pointed_type = type_remove_pointer(&p_current_argument->expression->type);

                struct flow_object* _Opt p_argument_object =
                    expression_get_flow_object(ctx, p_current_argument->expression, nullable_enabled);


                if (p_argument_object)
                {
                    const bool argument_type_is_nullable =
                        type_is_opt(&pointed_type, ctx->ctx->options.null_checks_enabled);

                    if (p_argument_object->current.pointed)
                    {
                        flow_object_set_unknown(&pointed_type,
                                           argument_type_is_nullable,
                                           p_argument_object->current.pointed,
                                           ctx->ctx->options.null_checks_enabled);
                    }
                    else
                    {
                        //assert(false);
                    }
                }

                type_destroy(&pointed_type);
            }
            p_current_argument = p_current_argument->next;
            p_current_parameter_type = p_current_parameter_type->next;
        }

        while (p_current_argument)
        {
            /*
               We have more argument than parameters, this happens with variadic functions
            */

            struct flow_object* _Opt p_argument_object =
                expression_get_flow_object(ctx, p_current_argument->expression, nullable_enabled);

            if (p_argument_object)
            {
                //??
            }
            else
            {
                //??
            }
            p_current_argument = p_current_argument->next;
        }
    }
    catch
    {
    }
}

static void check_uninitialized(struct flow_visit_ctx* ctx, struct expression* p_expression)
{
    if (p_expression->is_assignment_expression)
        return;

    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    if (type_is_function(&p_expression->type) ||
        type_is_void(&p_expression->type) ||
        type_is_nullptr_t(&p_expression->type))
    {
        return;
    }

    struct flow_object* _Opt p_object = expression_get_flow_object(ctx, p_expression, nullable_enabled);

    if (!ctx->expression_is_not_evaluated)
    {
        if (p_object && p_object->current.state == FLOW_OBJECT_STATE_UNINITIALIZED)
        {
            if (p_expression->expression_type == PRIMARY_EXPRESSION_DECLARATOR &&
                p_expression->declarator &&
                p_expression->declarator->name_opt)
            {
                compiler_diagnostic(W_FLOW_UNINITIALIZED,
                    ctx->ctx,
                    p_expression->first_token, NULL, "using a uninitialized object '%s'", p_expression->declarator->name_opt->lexeme);
            }
            else
            {
                compiler_diagnostic(W_FLOW_UNINITIALIZED,
                    ctx->ctx,
                    p_expression->first_token, NULL, "using a uninitialized object");
            }
        }
        else if (p_object && p_object->current.state & FLOW_OBJECT_STATE_UNINITIALIZED)
        {
            if (ctx->ctx->options.ownership_enabled)
            {
                if (p_expression->declarator && p_expression->declarator->name_opt)
                {
                    compiler_diagnostic(W_FLOW_UNINITIALIZED,
                        ctx->ctx,
                        p_expression->first_token,
                        NULL,
                        "object '%s' can be uninitialized ",
                        p_expression->declarator->name_opt->lexeme);
                }
                else
                {
                    compiler_diagnostic(W_FLOW_UNINITIALIZED,
                        ctx->ctx,
                        p_expression->first_token, NULL, "maybe using a uninitialized object");
                }
            }
        }
    }
}

void flow_object_push_states_from(const struct flow_object* p_object_from, struct flow_object* p_object_to)
{
    struct flow_object_state* _Opt it_from = p_object_from->current.next;
    while (it_from)
    {
#if 0
        flow_object_add_state(
        p_object_to,
        p_object_to->current.state,
        &p_object_to->current.ref,
        it_from->dbg_name,
        it_from->state_number);
#endif

        it_from = it_from->next;
    }

    for (int i = 0; i < p_object_to->members.size; i++)
    {
        flow_object_push_states_from(p_object_from, p_object_to->members.data[i]);
    }
}


static void flow_check_pointer_used_as_bool(struct flow_visit_ctx* ctx, struct expression* p_expression)
{
    //when pointer as used as bool, like if (p) or p && p->i we check
    //if the pointer has a flow condition always true or false.

    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    if (type_is_pointer(&p_expression->type))
    {

        struct flow_object* _Opt p_object = expression_get_flow_object(ctx, p_expression, nullable_enabled);
        if (p_object)
        {
            struct marker marker = {
                 .p_token_begin = p_expression->first_token,
                 .p_token_end = p_expression->last_token
            };

            if (!ctx->inside_loop && flow_object_is_null(p_object))
            {
                compiler_diagnostic(W_FLOW_NON_NULL,
                        ctx->ctx,
                        NULL,
                        &marker,
                        "pointer is always null");

            }
            else if (!ctx->inside_loop && flow_object_is_not_null(p_object))
            {
                compiler_diagnostic(W_FLOW_NON_NULL,
                        ctx->ctx,
                        NULL,
                        &marker,
                        "pointer is always not-null");
            }
        }
    }
}

static void arena_broadcast_change(struct flow_visit_ctx* ctx, struct flow_object* p)
{
    for (int i = 0; i < ctx->arena.size; i++)
    {
        struct flow_object* p_obj = ctx->arena.data[i];

        for (int j = 0; j < p_obj->current.alternatives.size; j++)
        {
            if (p_obj->current.alternatives.data[j] == p)
            {
                flow_object_update_current(p_obj);
                break;
            }
        }
    }
}

static struct argument_expression* _Opt param_list_find_argument_by_name(struct param_list* p_param_list,
    struct argument_expression_list* list,
    const char* name)
{
    struct param* _Opt p_param = p_param_list->head;
    struct argument_expression* _Opt p_argument_expression = list->head;
    while (p_param && p_argument_expression)
    {
        if (p_param->type.name_opt &&
            strcmp(p_param->type.name_opt, name) == 0)
        {
            return p_argument_expression;
        }
        p_argument_expression = p_argument_expression->next;
        p_param = p_param->next;
    }
    return NULL;
}

/*
   Makes all alias to null
*/
static void flow_clear_alias(struct expression* p_expression)
{
    if (p_expression->declarator)
        p_expression->declarator->p_alias_of_expression = NULL;

    struct argument_expression* _Opt p = p_expression->argument_expression_list.head;
    while (p)
    {
        flow_clear_alias(p->expression);
        p = p->next;
    }


    if (p_expression->left)
        flow_clear_alias(p_expression->left);
    if (p_expression->right)
        flow_clear_alias(p_expression->right);
}

static void flow_expression_bind(struct flow_visit_ctx* ctx,
                                 struct expression* p_expression,
                                 struct param_list* p_param_list,
                                 struct argument_expression_list* p_argument_expression_list)
{

    if (p_expression->expression_type == PRIMARY_EXPRESSION_DECLARATOR)
    {
        assert(p_expression->declarator != NULL);
        assert(p_expression->declarator->name_opt != NULL);

        struct argument_expression* _Opt p_argument_expression =
            param_list_find_argument_by_name(p_param_list,
                                             p_argument_expression_list,
                                             p_expression->declarator->name_opt->lexeme);
        if (p_argument_expression)
        {
            if (p_argument_expression->expression->declarator &&
                p_argument_expression->expression->declarator->p_alias_of_expression)
            {
                p_expression->declarator->p_alias_of_expression = p_argument_expression->expression->declarator->p_alias_of_expression;
            }
            else
            {
                p_expression->declarator->p_alias_of_expression = p_argument_expression->expression;
            }
            return;
        }
    }

    struct argument_expression* _Opt p = p_expression->argument_expression_list.head;
    while (p)
    {
        flow_expression_bind(ctx, p->expression, p_param_list, p_argument_expression_list);
        p = p->next;
    }


    if (p_expression->left)
        flow_expression_bind(ctx, p_expression->left, p_param_list, p_argument_expression_list);
    if (p_expression->right)
        flow_expression_bind(ctx, p_expression->right, p_param_list, p_argument_expression_list);
}


static void flow_visit_expression(struct flow_visit_ctx* ctx, struct expression* p_expression, struct true_false_set* expr_true_false_set)
{
    true_false_set_clear(expr_true_false_set); //out

    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    switch (p_expression->expression_type)
    {
    case EXPRESSION_TYPE_INVALID:
        assert(false);
        break;

    case PRIMARY_EXPRESSION__FUNC__:
        break;

    case PRIMARY_EXPRESSION_ENUMERATOR:

        break;
    case PRIMARY_EXPRESSION_DECLARATOR:
    {
        assert(p_expression->declarator != NULL);

        if (p_expression->declarator->p_alias_of_expression)
        {
            /*
               Contracts:
               in this case we visit the expression that this declaration
               is representing
            */
            flow_visit_expression(ctx, p_expression->declarator->p_alias_of_expression, expr_true_false_set);
        }
        else
        {
            _Opt struct true_false_set_item item = { 0 };
            item.p_expression = p_expression;
            item.true_branch_state = BOOLEAN_FLAG_TRUE;
            item.false_branch_state = BOOLEAN_FLAG_FALSE;
            true_false_set_push_back(expr_true_false_set, &item);
            check_uninitialized(ctx, p_expression);
        }
    }
    break;

    case PRIMARY_EXPRESSION_PARENTESIS:
        assert(p_expression->right != NULL);
        flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
        break;

    case PRIMARY_EXPRESSION_STRING_LITERAL:
    case PRIMARY_EXPRESSION_CHAR_LITERAL:
    case PRIMARY_EXPRESSION_NUMBER:
    case PRIMARY_EXPRESSION_PREDEFINED_CONSTANT:
        break;

    case PRIMARY_EXPRESSION_GENERIC:
        assert(p_expression->generic_selection != NULL);
        flow_visit_generic_selection(ctx, p_expression->generic_selection);
        break;

    case POSTFIX_DOT:
    {
        assert(p_expression->left != NULL);

        struct true_false_set left_set = { 0 };
        flow_visit_expression(ctx, p_expression->left, &left_set);

        true_false_set_destroy(&left_set);

        struct true_false_set_item item;
        item.p_expression = p_expression;
        item.true_branch_state = BOOLEAN_FLAG_TRUE;
        item.false_branch_state = BOOLEAN_FLAG_FALSE;
        true_false_set_push_back(expr_true_false_set, &item);
    }
    break;

    case POSTFIX_ARROW:
    {
        assert(p_expression->left != NULL);

        struct true_false_set left_set = { 0 };
        flow_visit_expression(ctx, p_expression->left, &left_set);
        true_false_set_destroy(&left_set);

        struct flow_object* _Opt p_object = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);

        if (p_object != NULL)
        {
            if (flow_object_can_be_null(p_object))
            {
                if (ctx->expression_is_not_evaluated)
                {
                }
                else
                {
                    struct marker marker = { 0 };
                    marker.p_token_begin = p_expression->left->first_token;
                    marker.p_token_end = p_expression->left->last_token;
                    compiler_diagnostic(W_FLOW_NULL_DEREFERENCE,
                            ctx->ctx,
                            NULL,
                            &marker,
                           "pointer may be null");
                }
            }
            else if (flow_object_can_be_uninitialized(p_object))
            {
                if (ctx->expression_is_not_evaluated)
                {
                }
                else
                {
                    compiler_diagnostic(W_FLOW_NULL_DEREFERENCE,
                            ctx->ctx,
                            p_expression->left->first_token, NULL, "object is possibly uninitialized");
                }
            }
            else if (flow_object_can_have_its_lifetime_ended(p_object))
            {
                if (ctx->expression_is_not_evaluated)
                {
                }
                else
                {
                    compiler_diagnostic(W_FLOW_LIFETIME_ENDED,
                            ctx->ctx,
                            p_expression->left->first_token, NULL, "object lifetime ended");
                }
            }
        }

        if (!ctx->expression_is_not_evaluated)
        {
            struct flow_object* _Opt p_object2 = expression_get_flow_object(ctx, p_expression, nullable_enabled);
            if (p_object2 && flow_object_can_have_its_lifetime_ended(p_object2))
            {
                struct marker marker = {
                    .p_token_begin = p_expression->first_token,
                    .p_token_end = p_expression->last_token
                };
                compiler_diagnostic(W_FLOW_LIFETIME_ENDED,
                        ctx->ctx,
                        NULL,
                        &marker,
                        "object lifetime ended");
            }
        }

        struct true_false_set_item item;
        item.p_expression = p_expression;
        item.true_branch_state = BOOLEAN_FLAG_TRUE;
        item.false_branch_state = BOOLEAN_FLAG_FALSE;
        true_false_set_push_back(expr_true_false_set, &item);
    }
    break;

    case POSTFIX_INCREMENT:
    case POSTFIX_DECREMENT:
    {
        assert(p_expression->left != NULL);

        struct flow_object* const _Opt p_object = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
        if (p_object)
        {
            if (flow_object_is_null(p_object))
            {
                //p_object->current.state &= ~FLOW_OBJECT_STATE_NULL;
                p_object->current.state = FLOW_OBJECT_STATE_NOT_NULL;
            }
            else if (flow_object_is_zero(p_object))
            {
                //p_object->current.state &= ~FLOW_OBJECT_STATE_ZERO;
                p_object->current.state = FLOW_OBJECT_STATE_NOT_ZERO;
            }
        }
        flow_visit_expression(ctx, p_expression->left, expr_true_false_set);
    }
    break;

    case POSTFIX_ARRAY:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        flow_visit_expression(ctx, p_expression->left, expr_true_false_set);
        flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
        true_false_set_clear(expr_true_false_set);

        struct true_false_set_item item;
        item.p_expression = p_expression;
        item.true_branch_state = BOOLEAN_FLAG_TRUE;
        item.false_branch_state = BOOLEAN_FLAG_FALSE;
        true_false_set_push_back(expr_true_false_set, &item);

    }
    break;

    case POSTFIX_FUNCTION_CALL:
    {
        if (!ctx->inside_contract)
        {
            assert(p_expression->left != NULL);

            struct true_false_set left_local = { 0 };
            flow_visit_expression(ctx, p_expression->left, &left_local);

            flow_compare_function_arguments(ctx, &p_expression->left->type, &p_expression->argument_expression_list);
            true_false_set_destroy(&left_local);
        }
        //////////////////////////////////////////////////////////////////////////////////////////////////////
#if EXPERIMENTAL_CONTRACTS
        if (p_expression->left->declarator &&
            type_is_function(&p_expression->left->declarator->type))
        {
            struct type return_type = get_function_return_type(&p_expression->left->declarator->type);
            if (p_expression->left->declarator->p_expression_true)
            {
                struct expression* p_expression_true = p_expression->left->declarator->p_expression_true;

                /*given you expression we clear all previous alias*/
                flow_clear_alias(p_expression_true);

                /*then we bind new alias*/
                flow_expression_bind(ctx,
                                     p_expression_true,
                                     &p_expression->left->declarator->type.params,
                                     &p_expression->argument_expression_list);


                if (type_is_scalar(&return_type))
                {
                    struct true_false_set local = { 0 };

                    bool inside_contract = ctx->inside_contract;

                    ctx->inside_contract = true;
                    flow_visit_expression(ctx, p_expression_true, &local);
                    ctx->inside_contract = inside_contract; //restore

                    for (int i = 0; i < local.size; i++)
                    {
                        struct true_false_set_item item5 = {
                          .p_expression = local.data[i].p_expression,
                          .true_branch_state = local.data[i].true_branch_state
                        };

                        true_false_set_push_back(expr_true_false_set, &item5);
                    }
                    true_false_set_destroy(&local);
                }
                else
                {
                    struct true_false_set true_false_set4 = { 0 };
                    bool old = ctx->inside_assert;
                    ctx->inside_assert = true;

                    bool inside_contract = ctx->inside_contract;
                    ctx->inside_contract = true;
                    flow_visit_expression(ctx, p_expression->left->declarator->p_expression_true, &true_false_set4); //assert(p == 0);            
                    ctx->inside_contract = inside_contract; //restore

                    ctx->inside_assert = old;
                    true_false_set_set_objects_to_true_branch(ctx, &true_false_set4, nullable_enabled);
                    true_false_set_destroy(&true_false_set4);
                }
            }

            if (p_expression->left->declarator->p_expression_false)
            {
                struct expression* p_expression_false = p_expression->left->declarator->p_expression_false;

                /*given you expression we clear all previous alias*/
                flow_clear_alias(p_expression_false);

                /*then we bind new alias*/
                flow_expression_bind(ctx,
                                     p_expression_false,
                                     &p_expression->left->declarator->type.params,
                                     &p_expression->argument_expression_list);


                struct true_false_set local = { 0 };



                bool inside_contract = ctx->inside_contract;

                ctx->inside_contract = true;
                flow_visit_expression(ctx, p_expression_false, &local);
                ctx->inside_contract = inside_contract; //restore

                for (int i = 0; i < local.size; i++)
                {
                    int index =
                        find_item_index_by_expression(expr_true_false_set, local.data[i].p_expression);
                    if (index == -1)
                    {
                        struct true_false_set_item item5 = {
                          .p_expression = local.data[i].p_expression,
                          .false_branch_state = local.data[i].true_branch_state
                        };

                        true_false_set_push_back(expr_true_false_set, &item5);
                    }
                    else
                    {
                        expr_true_false_set->data[index].false_branch_state |= local.data[i].false_branch_state;
                    }

                }
                true_false_set_destroy(&local);

            }
            type_destroy(&return_type);

        }
#endif
    }
    break;

    case POSTFIX_EXPRESSION_FUNCTION_LITERAL:
        assert(p_expression->compound_statement != NULL);
        flow_visit_compound_statement(ctx, p_expression->compound_statement);

        break;

    case POSTFIX_EXPRESSION_COMPOUND_LITERAL:

        assert(p_expression->left == NULL);
        assert(p_expression->right == NULL);
        assert(p_expression->type_name != NULL);
        assert(p_expression->braced_initializer != NULL);


        flow_visit_bracket_initializer_list(ctx, p_expression->braced_initializer);

        struct flow_object* _Opt temp2 = make_flow_object(ctx, &p_expression->type, NULL, p_expression);
        if (temp2 == NULL)
        {
            return;
        }

        if (p_expression->type_name->abstract_declarator->p_flow_object)
        {
            flow_object_swap(temp2, p_expression->type_name->abstract_declarator->p_flow_object);

            //TODO the state of object depends of the initializer        
            flow_object_set_zero(&p_expression->type, p_expression->type_name->abstract_declarator->p_flow_object);
        }

        break;

    case UNARY_EXPRESSION_ALIGNOF_EXPRESSION:

        if (p_expression->right)
        {
            flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
        }

        break;

    case UNARY_EXPRESSION_ALIGNOF_TYPE:
        break;

    case UNARY_EXPRESSION_ASSERT:

        if (p_expression->right)
        {
            struct true_false_set true_false_set4 = { 0 };
            bool old = ctx->inside_assert;
            ctx->inside_assert = true;
            flow_visit_expression(ctx, p_expression->right, &true_false_set4); //assert(p == 0);            
            ctx->inside_assert = old;
            true_false_set_set_objects_to_true_branch(ctx, &true_false_set4, nullable_enabled);
            true_false_set_destroy(&true_false_set4);
        }

        break;

    case UNARY_EXPRESSION_SIZEOF_EXPRESSION:

        if (p_expression->right)
        {
            const bool t2 = ctx->expression_is_not_evaluated;
            ctx->expression_is_not_evaluated = true;
            flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
            ctx->expression_is_not_evaluated = t2;
        }


        break;

    case UNARY_EXPRESSION_NEG:
    case UNARY_EXPRESSION_PLUS:
        assert(p_expression->right != NULL);
        flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
        break;

    case UNARY_EXPRESSION_NOT:
        assert(p_expression->right != NULL);
        flow_check_pointer_used_as_bool(ctx, p_expression->right);
        flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
        true_false_set_invert(expr_true_false_set);
        break;

    case UNARY_EXPRESSION_SIZEOF_TYPE:
    case UNARY_EXPRESSION_COUNTOF:
    case UNARY_EXPRESSION_INCREMENT:
    case UNARY_EXPRESSION_DECREMENT:
    case UNARY_EXPRESSION_BITNOT:
    case UNARY_EXPRESSION_ADDRESSOF:
        break;

    case UNARY_EXPRESSION_CONTENT:
    {
        assert(p_expression->right != NULL);

        struct flow_object* _Opt p_object0 = expression_get_flow_object(ctx, p_expression->right, nullable_enabled);

        if (p_object0 && p_object0->current.state == FLOW_OBJECT_STATE_UNINITIALIZED)
        {
            if (!ctx->expression_is_not_evaluated)
            {
                struct marker marker = { 0 };
                marker.p_token_begin = p_expression->right->first_token;
                marker.p_token_end = p_expression->right->last_token;
                compiler_diagnostic(W_FLOW_UNINITIALIZED,
                    ctx->ctx,
                    NULL, &marker, "using a uninitialized object");
            }
        }
        else if (p_object0 && flow_object_can_be_null(p_object0))
        {
            /*
              *p = 1*
            */
            if (!ctx->expression_is_not_evaluated)
            {
                compiler_diagnostic(W_FLOW_NULL_DEREFERENCE,
                    ctx->ctx,
                    p_expression->right->first_token, NULL, "dereference a NULL object");
            }
        }

        struct true_false_set local_true_false = { 0 };
        flow_visit_expression(ctx, p_expression->right, &local_true_false);
        /*empty set*/
        true_false_set_destroy(&local_true_false);
    }
    break;

    case ASSIGNMENT_EXPRESSION_ASSIGN:
    case ASSIGNMENT_EXPRESSION_PLUS_ASSIGN:
    case ASSIGNMENT_EXPRESSION_MINUS_ASSIGN:
    case ASSIGNMENT_EXPRESSION_MULTI_ASSIGN:
    case ASSIGNMENT_EXPRESSION_DIV_ASSIGN:
    case ASSIGNMENT_EXPRESSION_MOD_ASSIGN:
    case ASSIGNMENT_EXPRESSION_SHIFT_LEFT_ASSIGN:
    case ASSIGNMENT_EXPRESSION_SHIFT_RIGHT_ASSIGN:
    case ASSIGNMENT_EXPRESSION_AND_ASSIGN:
    case ASSIGNMENT_EXPRESSION_OR_ASSIGN:
    case ASSIGNMENT_EXPRESSION_NOT_ASSIGN:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        struct true_false_set left_set = { 0 };
        flow_visit_expression(ctx, p_expression->left, &left_set);
        true_false_set_swap(expr_true_false_set, &left_set);
        true_false_set_destroy(&left_set);

        struct true_false_set right_set = { 0 };
        flow_visit_expression(ctx, p_expression->right, &right_set);
        true_false_set_destroy(&right_set);

        //struct object temp_obj1 = { 0 };
        struct flow_object* const _Opt p_right_object = expression_get_flow_object(ctx, p_expression->right, nullable_enabled);

        //struct object temp_obj2 = { 0 };
        struct flow_object* const _Opt p_dest_object = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);

        if (p_dest_object == NULL || p_right_object == NULL)
        {
            return;
        }
        //TODO

        struct marker a_marker = {
          .p_token_begin = p_expression->left->first_token,
          .p_token_end = p_expression->left->last_token
        };

        struct marker b_marker = {
          .p_token_begin = p_expression->right->first_token,
          .p_token_end = p_expression->right->last_token
        };

        flow_check_assignment(ctx,
            p_expression->left->first_token,
            &a_marker,
            &b_marker,
            ASSIGMENT_TYPE_OBJECTS,
            true,
            type_is_view(&p_expression->left->type), /*dest type*/
            type_is_opt(&p_expression->left->type, ctx->ctx->options.null_checks_enabled), /*dest type*/
            &p_expression->left->type, /*dest type*/
            p_dest_object, /*dest object*/
            &p_expression->right->type, /*source type*/
            p_right_object /*source*/,
            NULL);


        /*
          built-in malloc, calloc assignment
        */
        arena_broadcast_change(ctx, p_dest_object);

        if (expression_is_malloc(p_expression->right))
        {
            struct type t = type_remove_pointer(&p_expression->left->type);
            struct flow_object* _Opt po = make_flow_object(ctx, &t, NULL, p_expression->left);
            if (po == NULL)
            {
                type_destroy(&t);
                return;
            }
            object_set_pointer(p_dest_object, po);
            type_destroy(&t);
            p_dest_object->current.state = FLOW_OBJECT_STATE_NOT_NULL | FLOW_OBJECT_STATE_NULL;
        }
        else if (expression_is_calloc(p_expression->right))
        {
            struct type t = type_remove_pointer(&p_expression->left->type);
            struct flow_object* _Opt po = make_flow_object(ctx, &t, NULL, p_expression->left);
            if (po == NULL)
            {
                type_destroy(&t);
                return;
            }
            flow_object_set_zero(&t, po);
            object_set_pointer(p_dest_object, po);
            type_destroy(&t);
            p_dest_object->current.state = FLOW_OBJECT_STATE_NOT_NULL | FLOW_OBJECT_STATE_NULL;
        }
    }
    break;
    case MULTIPLICATIVE_EXPRESSION_DIV:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        struct true_false_set left_set = { 0 };
        struct true_false_set right_set = { 0 };

        flow_visit_expression(ctx, p_expression->left, &left_set);

        struct flow_object* _Opt p_object = expression_get_flow_object(ctx, p_expression->right, ctx->ctx->options.null_checks_enabled);
        if (p_object)
        {
            if (flow_object_can_be_zero(p_object))
            {
                compiler_diagnostic(W_FLOW_DIVIZION_BY_ZERO, ctx->ctx, p_expression->right->first_token, NULL, "possible division by zero");
            }
        }

        /*
                               true_set               false_set
             b / a             b_true_set a_true_set  a_true_set
             0 / a             -                      a_true_set a_true_set
        */

        flow_visit_expression(ctx, p_expression->right, &right_set);
        true_false_set_merge(expr_true_false_set, &left_set, &right_set,
            MERGE_OPTIONS_A_TRUE | MERGE_OPTIONS_B_TRUE,
            MERGE_OPTIONS_A_TRUE | MERGE_OPTIONS_B_TRUE);

        true_false_set_destroy(&left_set);
        true_false_set_destroy(&right_set);
    }
    break;
    case CAST_EXPRESSION:
    case MULTIPLICATIVE_EXPRESSION_MULT:
    case MULTIPLICATIVE_EXPRESSION_MOD:
    case ADDITIVE_EXPRESSION_PLUS:
    case ADDITIVE_EXPRESSION_MINUS:
    case SHIFT_EXPRESSION_RIGHT:
    case SHIFT_EXPRESSION_LEFT:
    {
        if (p_expression->left)
        {
            struct true_false_set left_set = { 0 };
            flow_visit_expression(ctx, p_expression->left, &left_set);
            true_false_set_destroy(&left_set);
        }

        if (p_expression->right)
        {
            struct true_false_set right_set = { 0 };
            flow_visit_expression(ctx, p_expression->right, &right_set);
            true_false_set_destroy(&right_set);
        }
    }
    break;

    case RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN:
    case RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN:
    case RELATIONAL_EXPRESSION_BIGGER_THAN:
    case RELATIONAL_EXPRESSION_LESS_THAN:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        const bool left_is_constant = object_has_constant_value(&p_expression->left->object);
        const bool right_is_constant = object_has_constant_value(&p_expression->right->object);

        if (left_is_constant)
        {
            const long long left_value = object_to_signed_long_long(&p_expression->left->object);

            struct true_false_set true_false_set_right = { 0 };
            flow_visit_expression(ctx, p_expression->right, &true_false_set_right);
            if (left_value == 0)
            {
                true_false_set_swap(expr_true_false_set, &true_false_set_right);
                for (int i = 0; i < expr_true_false_set->size; i++)
                {
                    struct true_false_set_item* item = &expr_true_false_set->data[i];
                    item->false_branch_state |= item->true_branch_state;
                }

                if (p_expression->expression_type == RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN ||
                    p_expression->expression_type == RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN)
                {
                    true_false_set_invert(expr_true_false_set);
                }
            }
            true_false_set_destroy(&true_false_set_right);
        }

        else if (right_is_constant)
        {
            const long long right_value = object_to_signed_long_long(&p_expression->right->object);
            struct true_false_set true_false_set_left3 = { 0 };
            flow_visit_expression(ctx, p_expression->left, &true_false_set_left3);
            if (right_value == 0)
            {
                true_false_set_swap(expr_true_false_set, &true_false_set_left3);
                for (int i = 0; i < expr_true_false_set->size; i++)
                {
                    struct true_false_set_item* item = &expr_true_false_set->data[i];
                    item->false_branch_state |= item->true_branch_state;
                }
                if (p_expression->expression_type == RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN ||
                    p_expression->expression_type == RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN)
                {
                    true_false_set_invert(expr_true_false_set);
                }
            }
            true_false_set_destroy(&true_false_set_left3);
        }
        else
        {
            struct true_false_set true_false_set = { 0 };
            flow_visit_expression(ctx, p_expression->left, &true_false_set);
            flow_visit_expression(ctx, p_expression->right, &true_false_set);
            true_false_set_destroy(&true_false_set);
        }
    }
    break;

    case EQUALITY_EXPRESSION_NOT_EQUAL:
    case EQUALITY_EXPRESSION_EQUAL:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        long long value = 0;
        struct expression* _Opt p_comp_expression = NULL;
        if (object_has_constant_value(&p_expression->left->object) &&
            !object_has_constant_value(&p_expression->right->object))
        {
            value = object_to_signed_long_long(&p_expression->left->object);
            p_comp_expression = p_expression->right;
        }
        else if (object_has_constant_value(&p_expression->right->object) &&
                !object_has_constant_value(&p_expression->left->object))
        {
            value = object_to_signed_long_long(&p_expression->right->object);
            p_comp_expression = p_expression->left;
        }


        if (p_comp_expression)
        {
            struct true_false_set true_false_set = { 0 };
            flow_visit_expression(ctx, p_comp_expression, &true_false_set);

            //constant == p_comp_expression  |  p_comp_expression == constant
            //constant != p_comp_expression  |  p_comp_expression != constant

            struct flow_object* _Opt p_object = expression_get_flow_object(ctx, p_comp_expression, nullable_enabled);
            if (p_object)
            {
                struct marker marker = {
                     .p_token_begin = p_comp_expression->first_token,
                     .p_token_end = p_comp_expression->last_token
                };


                if ((flow_object_is_null(p_object) || flow_object_is_zero(p_object)) && value == 0)
                {
                    if (p_expression->expression_type == EQUALITY_EXPRESSION_EQUAL)
                    {
                        if (ctx->inside_assert)
                        {
                            /*
                             assert checks in runtime the same state we have at compile time
                             assert(p == NULL);
                            */
                        }
                        else
                        {
                            //if (p == NULL) { } //warning  p is always null
                            if (type_is_pointer(&p_comp_expression->type))
                            {
                                if (!ctx->inside_loop)
                                    compiler_diagnostic(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "pointer is always null");
                            }
                            else
                            {
                                if (!ctx->inside_loop)
                                    compiler_diagnostic(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "value is always zero");
                            }
                        }
                    }
                    else if (p_expression->expression_type == EQUALITY_EXPRESSION_NOT_EQUAL)
                    {
                        /*
                           runtime check is diferent from static state
                           assert(p != NULL);
                        */
                        if (type_is_pointer(&p_comp_expression->type))
                            compiler_diagnostic(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "pointer is always null");
                        else
                            compiler_diagnostic(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "value is always zero");
                    }
                }
                else if ((flow_object_is_not_null(p_object) || flow_object_is_not_zero(p_object)) && value == 0)
                {
                    if (p_expression->expression_type == EQUALITY_EXPRESSION_EQUAL)
                    {
                        /*
                           runtime check is diferent from static state
                           assert(p == NULL);
                        */
                        if (type_is_pointer(&p_comp_expression->type))
                        {
                            if (!ctx->inside_loop)
                                compiler_diagnostic(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "pointer is always non-null");
                        }
                        else
                        {
                            if (!ctx->inside_loop)
                                compiler_diagnostic(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "value is always non-zero");
                        }
                    }
                    else if (p_expression->expression_type == EQUALITY_EXPRESSION_NOT_EQUAL)
                    {
                        /*
                           assert checks in runtime the same state we have at compile time
                           assert(p != NULL);
                        */
                        if (ctx->inside_assert)
                        {
                            /*
                             assert checks in runtime the same state we have at compile time
                             assert(p == NULL);
                            */
                        }
                        else
                        {
                            if (type_is_pointer(&p_comp_expression->type))
                            {
                                if (!ctx->inside_loop)
                                    compiler_diagnostic(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "pointer is always non-null");
                            }
                            else
                            {
                                if (!ctx->inside_loop)
                                    compiler_diagnostic(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "value is always non-zero");
                            }
                        }
                    }
                }
            }

            true_false_set_swap(expr_true_false_set, &true_false_set);
            if (p_expression->expression_type == EQUALITY_EXPRESSION_EQUAL && value == 0)
            {
                true_false_set_invert(expr_true_false_set);
            }
            else if (p_expression->expression_type == EQUALITY_EXPRESSION_NOT_EQUAL && value != 0)
            {
                true_false_set_invert(expr_true_false_set);
            }
            true_false_set_destroy(&true_false_set);
        }
        else
        {
            struct true_false_set true_false_set = { 0 };
            flow_visit_expression(ctx, p_expression->left, &true_false_set);
            flow_visit_expression(ctx, p_expression->right, &true_false_set);
            true_false_set_destroy(&true_false_set);
        }
    }
    break;

    case LOGICAL_OR_EXPRESSION:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        flow_check_pointer_used_as_bool(ctx, p_expression->left);
        flow_check_pointer_used_as_bool(ctx, p_expression->right);


        struct true_false_set left_set = { 0 };
        flow_visit_expression(ctx, p_expression->left, &left_set);

        if (object_has_constant_value(&p_expression->left->object) &&
            object_to_bool(&p_expression->left->object) == true)
        {
            // left || right
            //left is true, so the right side will not run
        }
        else
        {
            const int original_state_number = arena_add_copy_of_current_state(ctx, "original");

            //Set all variables to false state, because otherwise, the right branch
            // would not be evaluated
            true_false_set_set_objects_to_false_branch(ctx, &left_set, nullable_enabled);

            struct true_false_set right_set = { 0 };
            flow_visit_expression(ctx, p_expression->right, &right_set);

            //Tudo que faz left ser true ou right ser true

            for (int i = 0; i < left_set.size; i++)
            {
                struct true_false_set_item item5;

                item5.p_expression = left_set.data[i].p_expression;
                item5.true_branch_state |= (left_set.data[i].true_branch_state | left_set.data[i].false_branch_state);
                item5.false_branch_state |= left_set.data[i].false_branch_state;
                true_false_set_push_back(expr_true_false_set, &item5);
            }

            for (int k = 0; k < right_set.size; k++)
            {
                int index =
                    find_item_index_by_expression(expr_true_false_set, right_set.data[k].p_expression);
                if (index == -1)
                {
                    index = expr_true_false_set->size;

                    struct true_false_set_item item4 = {
                      .p_expression = right_set.data[k].p_expression
                    };

                    true_false_set_push_back(expr_true_false_set, &item4);
                }

                //Tudo que faz left true e right true faz expressao se true
                expr_true_false_set->data[index].p_expression = right_set.data[k].p_expression;
                //d->data[index].true_branch_state |= right_set.data[k].true_branch_state;
                //Tudo que faz left true ou left false, e right false faz ser false
                expr_true_false_set->data[index].false_branch_state |= right_set.data[k].false_branch_state;

                //No path true seria possivel nao ser feito o right
                expr_true_false_set->data[index].true_branch_state |= (BOOLEAN_FLAG_TRUE | BOOLEAN_FLAG_FALSE);

            }

            //TODO we whould not restore the previous states for states that 
            //are not true/false
            // if (false || init(a)) ... we cannot undo the out a
            arena_restore_current_state_from(ctx, original_state_number);
            arena_remove_state(ctx, original_state_number);
            true_false_set_destroy(&right_set);
        }
        true_false_set_destroy(&left_set);
    }
    break;

    case LOGICAL_AND_EXPRESSION:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        flow_check_pointer_used_as_bool(ctx, p_expression->left);
        flow_check_pointer_used_as_bool(ctx, p_expression->right);


        struct true_false_set left_set = { 0 };
        flow_visit_expression(ctx, p_expression->left, &left_set);

        const int original_state_number = arena_add_copy_of_current_state(ctx, "original");

        //Set all variables to true state, because otherwise, the right branch
        // would not be evaluated
        true_false_set_set_objects_to_true_branch(ctx, &left_set, nullable_enabled);

        struct true_false_set right_set = { 0 };
        flow_visit_expression(ctx, p_expression->right, &right_set);
        //arena_restore_current_state_from(ctx, original_state_number);

       //Anything that makes left and right true also makes left && right true. 
       //Anything that makes left false or right false also makes left && right false.

        for (int i = 0; i < left_set.size; i++)
        {
            const struct true_false_set_item* p_item_left = &left_set.data[i];

            _Opt struct true_false_set_item left_and_right = { 0 };
            left_and_right.p_expression = p_item_left->p_expression;

            left_and_right.true_branch_state |= p_item_left->true_branch_state;
            left_and_right.false_branch_state |= p_item_left->true_branch_state | p_item_left->false_branch_state;

            true_false_set_push_back(expr_true_false_set, &left_and_right);
        }

        for (int k = 0; k < right_set.size; k++)
        {
            const struct true_false_set_item* p_item_right = &right_set.data[k];

            int index = find_item_index_by_expression(expr_true_false_set, p_item_right->p_expression);
            if (index == -1)
            {
                index = expr_true_false_set->size;
                struct true_false_set_item item2 = {
                  .p_expression = p_item_right->p_expression
                };
                true_false_set_push_back(expr_true_false_set, &item2);
            }

            //Tudo que faz left true e right true faz expressao se true
            expr_true_false_set->data[index].p_expression = p_item_right->p_expression;
            expr_true_false_set->data[index].true_branch_state |= p_item_right->true_branch_state;
            //Tudo que faz left true ou left false, e right false faz ser false
            expr_true_false_set->data[index].false_branch_state |= p_item_right->false_branch_state;

            //right expression may not be evaluated, in this case all previous states are also valid
            //so if the variable could be true and false then we need to add            
            expr_true_false_set->data[index].false_branch_state |= (BOOLEAN_FLAG_TRUE | BOOLEAN_FLAG_FALSE);

        }

        arena_restore_current_state_from(ctx, original_state_number);
        arena_remove_state(ctx, original_state_number);
        true_false_set_destroy(&left_set);
        true_false_set_destroy(&right_set);
    }
    break;

    case INCLUSIVE_OR_EXPRESSION:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        // A | B
        struct true_false_set true_false_set = { 0 };

        flow_visit_expression(ctx, p_expression->left, &true_false_set);
        flow_visit_expression(ctx, p_expression->right, &true_false_set);

        true_false_set_destroy(&true_false_set);
    }
    break;

    case AND_EXPRESSION:
    case EXCLUSIVE_OR_EXPRESSION:

        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        flow_visit_expression(ctx, p_expression->left, expr_true_false_set);
        flow_visit_expression(ctx, p_expression->right, expr_true_false_set);


        break;

    case UNARY_EXPRESSION_TRAITS:
        break;

    case UNARY_EXPRESSION_IS_SAME:
        break;

    case UNARY_DECLARATOR_ATTRIBUTE_EXPR:
        break;

    case EXPRESSION_EXPRESSION:
        break;

    case CONDITIONAL_EXPRESSION:
    {
        assert(p_expression->condition_expr != NULL);
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);


        struct true_false_set true_false_set = { 0 };

        flow_check_pointer_used_as_bool(ctx, p_expression->condition_expr);
        flow_visit_expression(ctx, p_expression->condition_expr, &true_false_set);

        const int before_if_state_number = arena_add_copy_of_current_state(ctx, "before-if");

        true_false_set_set_objects_to_true_branch(ctx, &true_false_set, nullable_enabled);

        struct true_false_set set = { 0 };
        flow_visit_expression(ctx, p_expression->left, &set);
        true_false_set_destroy(&set);


        const int left_true_branch_state_number = arena_add_copy_of_current_state(ctx, "left-true-branch");

        arena_restore_current_state_from(ctx, before_if_state_number);

        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);

        struct true_false_set set2 = { 0 };
        flow_visit_expression(ctx, p_expression->right, &set2);
        true_false_set_destroy(&set2);

        arena_merge_current_state_with_state_number(ctx, left_true_branch_state_number);

        arena_restore_current_state_from(ctx, left_true_branch_state_number);
        arena_remove_state(ctx, before_if_state_number);
        arena_remove_state(ctx, left_true_branch_state_number);
        true_false_set_destroy(&true_false_set);
    }
    break;

    }
}

static void flow_visit_expression_statement(struct flow_visit_ctx* ctx, struct expression_statement* p_expression_statement)
{
    struct true_false_set d = { 0 };
    if (p_expression_statement->expression_opt)
        flow_visit_expression(ctx, p_expression_statement->expression_opt, &d);
    true_false_set_destroy(&d);
}

static void flow_visit_block_item_list(struct flow_visit_ctx* ctx, struct block_item_list* p_block_item_list);

static void flow_visit_compound_statement(struct flow_visit_ctx* ctx, struct compound_statement* p_compound_statement)
{
    flow_visit_block_item_list(ctx, &p_compound_statement->block_item_list);
    flow_exit_block_visit_defer_list(ctx, &p_compound_statement->defer_list, p_compound_statement->last_token);
    flow_defer_list_set_end_of_lifetime(ctx, &p_compound_statement->defer_list, p_compound_statement->last_token);
}

static void flow_visit_do_while_statement(struct flow_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    assert(p_iteration_statement->first_token->type == TK_KEYWORD_DO);
    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    struct true_false_set true_false_set = { 0 };

    try
    {
        if (p_iteration_statement->expression1)
        {
            flow_visit_expression(ctx, p_iteration_statement->expression1, &true_false_set);
        }

        flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);

        flow_exit_block_visit_defer_list(ctx, &p_iteration_statement->defer_list, p_iteration_statement->secondary_block->last_token);
        flow_defer_list_set_end_of_lifetime(ctx, &p_iteration_statement->defer_list, p_iteration_statement->secondary_block->last_token);

        bool was_last_statement_inside_true_branch_return =
            secondary_block_ends_with_jump(p_iteration_statement->secondary_block);


        if (was_last_statement_inside_true_branch_return)
        {
            //restore_state(ctx, 0);
            //if (p_object_compared_with_not_null)
            //{
                //do {}  while (p);
              //  p_object_compared_with_not_null->state = FLOW_OBJECT_STATE_NULL;
            //}
        }
        else
        {
            //do { } while (p);
            true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
        }
    }
    catch
    {
    }

    true_false_set_destroy(&true_false_set);
}

static void flow_visit_while_statement(struct flow_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    assert(p_iteration_statement->first_token->type == TK_KEYWORD_WHILE);

    if (p_iteration_statement->expression1 == NULL)
        return;

    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    const int old_initial_state = ctx->initial_state;
    const int old_break_join_state = ctx->break_join_state;

    ctx->initial_state = arena_add_copy_of_current_state(ctx, "original");
    ctx->break_join_state = arena_add_empty_state(ctx, "break join");

    struct true_false_set true_false_set = { 0 };

    /*
        we do like this to acumulate states.

        if (expression)
        {
           statements...
           if (expression)
           {
             statements...
           }
        }
        break_exit:
    */

    //We do a visit but this is not conclusive..so we ignore warnings
    diagnostic_stack_push_empty(&ctx->ctx->options.diagnostic_stack);
    flow_visit_expression(ctx, p_iteration_statement->expression1, &true_false_set);


    true_false_set_set_objects_to_true_branch(ctx, &true_false_set, nullable_enabled);

    flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);

    //Second pass warning is ON
    diagnostic_stack_pop(&ctx->ctx->options.diagnostic_stack);

    struct true_false_set true_false_set2 = { 0 };
    flow_visit_expression(ctx, p_iteration_statement->expression1, &true_false_set2);
    true_false_set_destroy(&true_false_set2);

    //visit secondary_block again
    true_false_set_set_objects_to_true_branch(ctx, &true_false_set, nullable_enabled);
    flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);

    flow_exit_block_visit_defer_list(ctx, &p_iteration_statement->defer_list, p_iteration_statement->secondary_block->last_token);

    const bool was_last_statement_inside_true_branch_return =
        secondary_block_ends_with_jump(p_iteration_statement->secondary_block);

    if (was_last_statement_inside_true_branch_return)
    {
        /*
           while (p) { return; }
        */
        arena_restore_current_state_from(ctx, ctx->initial_state);
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
    }
    else
    {
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
        arena_merge_current_state_with_state_number(ctx, ctx->break_join_state);
        arena_restore_current_state_from(ctx, ctx->break_join_state);
    }

    flow_defer_list_set_end_of_lifetime(ctx, &p_iteration_statement->defer_list, p_iteration_statement->secondary_block->last_token);

    arena_remove_state(ctx, ctx->initial_state);
    arena_remove_state(ctx, ctx->break_join_state);


    //restore
    ctx->initial_state = old_initial_state;
    ctx->break_join_state = old_break_join_state;
    true_false_set_destroy(&true_false_set);
}

static void flow_visit_for_statement(struct flow_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    /*
      TODO
       {
        int i = 0;
        if (condition)
        {
            //second-block
            i++;
            if (condition)
            {
                //second-block
                i++;
                //recursive
            }
        }
    }
    */

    assert(p_iteration_statement->first_token->type == TK_KEYWORD_FOR);

    struct true_false_set d = { 0 };

    try
    {
        if (p_iteration_statement->declaration &&
            p_iteration_statement->declaration->init_declarator_list.head)
        {
            flow_visit_init_declarator_list(ctx, &p_iteration_statement->declaration->init_declarator_list);
        }

        if (p_iteration_statement->expression0)
        {
            flow_visit_expression(ctx, p_iteration_statement->expression0, &d);
        }

        if (p_iteration_statement->expression1)
        {
            flow_check_pointer_used_as_bool(ctx, p_iteration_statement->expression1);
            flow_visit_expression(ctx, p_iteration_statement->expression1, &d);
        }

        //TODO we need to merge states inside loops

        //Disable warning because the state is temporary..missing a visit
        diagnostic_stack_push_empty(&ctx->ctx->options.diagnostic_stack);

        flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);

        diagnostic_stack_pop(&ctx->ctx->options.diagnostic_stack);


        if (p_iteration_statement->expression2)
        {
            flow_visit_expression(ctx, p_iteration_statement->expression2, &d);
        }
        const bool b_secondary_block_ends_with_jump =
            secondary_block_ends_with_jump(p_iteration_statement->secondary_block);

        /*we visit again*/
        if (!b_secondary_block_ends_with_jump)
        {
            flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
            flow_exit_block_visit_defer_list(ctx, &p_iteration_statement->defer_list, p_iteration_statement->secondary_block->last_token);
            flow_defer_list_set_end_of_lifetime(ctx, &p_iteration_statement->defer_list, p_iteration_statement->secondary_block->last_token);
        }

    }
    catch
    {
    }
    true_false_set_destroy(&d);
}


static void flow_visit_iteration_statement(struct flow_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    bool inside_loop = ctx->inside_loop;
    ctx->inside_loop = true;

    switch (p_iteration_statement->first_token->type)
    {
    case  TK_KEYWORD_WHILE:
        flow_visit_while_statement(ctx, p_iteration_statement);
        break;
    case TK_KEYWORD_DO:
        flow_visit_do_while_statement(ctx, p_iteration_statement);
        break;
    case TK_KEYWORD_FOR:
        flow_visit_for_statement(ctx, p_iteration_statement);
        break;
    default:
        assert(false);
        break;
    }
    ctx->inside_loop = inside_loop; //restore
}

static void flow_visit_jump_statement(struct flow_visit_ctx* ctx, struct jump_statement* p_jump_statement)
{
    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;
    try
    {
        if (p_jump_statement->first_token->type == TK_KEYWORD_CAKE_THROW)
        {
            arena_merge_current_state_with_state_number(ctx, ctx->throw_join_state);

            //check_all_defer_until_try(ctx, ctx->tail_block, p_jump_statement->first_token);
            flow_exit_block_visit_defer_list(ctx, &p_jump_statement->defer_list, p_jump_statement->first_token);
        }
        else if (p_jump_statement->first_token->type == TK_KEYWORD_RETURN)
        {
            if (ctx->p_return_type == NULL)
            {
                //we must be inside a function and we need this return set.
                throw;
            }

            if (p_jump_statement->expression_opt)
            {
                struct true_false_set d = { 0 };
                flow_visit_expression(ctx, p_jump_statement->expression_opt, &d);
                true_false_set_destroy(&d);
            }

            /*
              returning a declarator will move the ownership
            */
            if (p_jump_statement->expression_opt)
            {
                struct flow_object* _Opt p_object =
                    expression_get_flow_object(ctx, p_jump_statement->expression_opt, nullable_enabled);

                if (p_object)
                {
                    assert(ctx->p_return_type != NULL);
                    struct flow_object* _Opt p_dest_object =
                        make_flow_object(ctx, ctx->p_return_type, NULL, p_jump_statement->expression_opt);

                    if (p_dest_object == NULL)
                    {
                        throw;
                    }

                    assert(ctx->p_return_type != NULL);
                    flow_object_set_zero(ctx->p_return_type, p_dest_object);

                    struct marker a_marker = {
                       .p_token_begin = p_jump_statement->expression_opt->first_token,
                       .p_token_end = p_jump_statement->expression_opt->last_token,
                    };
                    struct marker b_marker = {
                       .p_token_begin = p_jump_statement->expression_opt->first_token,
                       .p_token_end = p_jump_statement->expression_opt->last_token,
                    };

                    assert(ctx->p_return_type != NULL);

                    flow_check_assignment(ctx,
                     p_jump_statement->expression_opt->first_token,
                     &a_marker,
                     &b_marker,
                     ASSIGMENT_TYPE_RETURN,
                     true,
                        type_is_view(ctx->p_return_type), /*dest type*/
                        type_is_opt(ctx->p_return_type, ctx->ctx->options.null_checks_enabled), /*dest type*/
                        ctx->p_return_type, /*dest type*/
                        p_dest_object, /*dest object*/
                        &p_jump_statement->expression_opt->type, /*source type*/
                        p_object, /*source*/
                        NULL
                    );

                    const int state_before_return = arena_add_copy_of_current_state(ctx, "before-return");

                    // Simulate the function's state as if it had already returned. 
                    // This allows us to verify whether the returned object points to any 
                    // local variables.

                    flow_defer_list_set_end_of_lifetime(ctx, &p_jump_statement->defer_list, p_jump_statement->first_token);

                    if (ctx->p_return_type == NULL)
                        throw;

                    checked_read_object(ctx,
                                        ctx->p_return_type,
                                        type_is_opt(ctx->p_return_type, ctx->ctx->options.null_checks_enabled),
                                        p_dest_object,
                                        NULL,
                                        &a_marker,
                                        true);

                    //then we restore the state
                    arena_restore_current_state_from(ctx, state_before_return);
                }

                if (p_object && p_object->is_temporary)
                {
                    //a + b
                    p_object->current.state = FLOW_OBJECT_STATE_LIFE_TIME_ENDED;
                }

            }

            flow_exit_block_visit_defer_list(ctx, &p_jump_statement->defer_list, p_jump_statement->first_token);
        }
        else if (p_jump_statement->first_token->type == TK_KEYWORD_CONTINUE)
        {
            flow_exit_block_visit_defer_list(ctx, &p_jump_statement->defer_list, p_jump_statement->first_token);
        }
        else if (p_jump_statement->first_token->type == TK_KEYWORD_BREAK)
        {
            arena_merge_current_state_with_state_number(ctx, ctx->break_join_state);
            flow_exit_block_visit_defer_list(ctx, &p_jump_statement->defer_list, p_jump_statement->first_token);
        }
        else if (p_jump_statement->first_token->type == TK_KEYWORD_GOTO)
        {
            //goto needs a label
            assert(p_jump_statement->label != NULL);

            int label_state_number = -1;
            for (int i = 0; i < ctx->labels_size; i++)
            {
                if (ctx->labels[i].state_number == label_state_number)
                {
                    break; //already exist
                }
            }
            if (label_state_number == -1)
            {
                label_state_number = arena_add_empty_state(ctx, p_jump_statement->label->lexeme);
                ctx->labels[ctx->labels_size].state_number = label_state_number;
                ctx->labels[ctx->labels_size].label_name = p_jump_statement->label->lexeme;
                ctx->labels_size++;
            }

            arena_merge_current_state_with_state_number(ctx, label_state_number);
            flow_exit_block_visit_defer_list(ctx, &p_jump_statement->defer_list, p_jump_statement->first_token);
        }
        else
        {
            assert(false);
        }
    }
    catch
    {
    }
}

static void flow_visit_label(struct flow_visit_ctx* ctx, struct label* p_label);

static void flow_visit_labeled_statement(struct flow_visit_ctx* ctx, struct labeled_statement* p_labeled_statement)
{
    flow_visit_label(ctx, p_labeled_statement->label);
    flow_visit_statement(ctx, p_labeled_statement->statement);
}

static void flow_visit_primary_block(struct flow_visit_ctx* ctx, struct primary_block* p_primary_block)
{

    if (p_primary_block->defer_statement)
    {
        flow_visit_defer_statement(ctx, p_primary_block->defer_statement);
    }
    else
    {
        if (p_primary_block->compound_statement)
        {
            flow_visit_compound_statement(ctx, p_primary_block->compound_statement);
        }
        else if (p_primary_block->iteration_statement)
        {
            flow_visit_iteration_statement(ctx, p_primary_block->iteration_statement);
        }
        else if (p_primary_block->selection_statement)
        {
            flow_visit_selection_statement(ctx, p_primary_block->selection_statement);
        }
        else if (p_primary_block->try_statement)
        {
            flow_visit_try_statement(ctx, p_primary_block->try_statement);
        }
    }
}

static void flow_visit_unlabeled_statement(struct flow_visit_ctx* ctx, struct unlabeled_statement* p_unlabeled_statement)
{
    if (p_unlabeled_statement->primary_block)
    {
        flow_visit_primary_block(ctx, p_unlabeled_statement->primary_block);
    }
    else if (p_unlabeled_statement->expression_statement)
    {
        flow_visit_expression_statement(ctx, p_unlabeled_statement->expression_statement);
    }
    else if (p_unlabeled_statement->jump_statement)
    {
        flow_visit_jump_statement(ctx, p_unlabeled_statement->jump_statement);
    }
    else
    {
        assert(false);
    }
}

static void flow_visit_statement(struct flow_visit_ctx* ctx, struct statement* p_statement)
{
    if (p_statement->labeled_statement)
    {
        flow_visit_labeled_statement(ctx, p_statement->labeled_statement);
    }
    else if (p_statement->unlabeled_statement)
    {
        flow_visit_unlabeled_statement(ctx, p_statement->unlabeled_statement);
    }
}

static void flow_visit_label(struct flow_visit_ctx* ctx, struct label* p_label)
{
    if (p_label->p_identifier_opt)
    {
        for (int i = 0; i < ctx->labels_size; i++)
        {
            if (strcmp(ctx->labels[i].label_name, p_label->p_identifier_opt->lexeme) == 0)
            {

                arena_restore_current_state_from(ctx, ctx->labels[i].state_number);

                break; //already exist
            }
        }
    }
    else
    {
        //case, default
        arena_restore_current_state_from(ctx, ctx->initial_state);
    }
}

static void flow_visit_block_item(struct flow_visit_ctx* ctx, struct block_item* p_block_item)
{
    if (p_block_item->declaration)
    {
        flow_visit_declaration(ctx, p_block_item->declaration);
    }
    else if (p_block_item->unlabeled_statement)
    {
        flow_visit_unlabeled_statement(ctx, p_block_item->unlabeled_statement);
    }
    else if (p_block_item->label)
    {
        flow_visit_label(ctx, p_block_item->label);
    }
}

static void flow_visit_block_item_list(struct flow_visit_ctx* ctx, struct block_item_list* p_block_item_list)
{
    struct block_item* _Opt p_block_item = p_block_item_list->head;
    while (p_block_item)
    {
        flow_visit_block_item(ctx, p_block_item);
        p_block_item = p_block_item->next;
    }
}

static enum flow_state parse_string_state(const char* s, bool* invalid)
{
    //TODO faling with _
    *invalid = false;

    enum flow_state e = 0;
    const char* p = s;

    while (*p)
    {
        if (isalpha(*p))
        {
            int sz = 0;
            const char* start = p;
            while (isalpha(*p) || *p == '-')
            {
                sz++;
                p++;
            }

            if (strncmp(start, "moved", sz) == 0)
                e |= FLOW_OBJECT_STATE_MOVED;

            else if (strncmp(start, "null", sz) == 0)
                e |= FLOW_OBJECT_STATE_NULL;
            else if (strncmp(start, "not-null", sz) == 0)
                e |= FLOW_OBJECT_STATE_NOT_NULL;
            else if (strncmp(start, "maybe-null", sz) == 0)
                e |= (FLOW_OBJECT_STATE_NOT_NULL | FLOW_OBJECT_STATE_NULL);
            else if (strncmp(start, "uninitialized", sz) == 0)
                e |= FLOW_OBJECT_STATE_UNINITIALIZED;
            else if (strncmp(start, "zero", sz) == 0)
                e |= FLOW_OBJECT_STATE_ZERO;
            else if (strncmp(start, "not-zero", sz) == 0)
                e |= FLOW_OBJECT_STATE_NOT_ZERO;
            else if (strncmp(start, "any", sz) == 0)
                e |= (FLOW_OBJECT_STATE_NOT_ZERO | FLOW_OBJECT_STATE_ZERO);
            else
            {
                *invalid = true;
                return 0; //error invalid name
            }
        }
        else
        {
            p++;
        }
    }

    return e;
}

static void flow_visit_pragma_declaration(struct flow_visit_ctx* ctx, struct pragma_declaration* p_pragma_declaration)
{
    execute_pragma(ctx->ctx, p_pragma_declaration, true);
}

static void flow_visit_static_assert_declaration(struct flow_visit_ctx* ctx, struct static_assert_declaration* p_static_assert_declaration)
{
    const bool t2 = ctx->expression_is_not_evaluated;
    ctx->expression_is_not_evaluated = true;
    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    struct true_false_set a = { 0 };
    flow_visit_expression(ctx, p_static_assert_declaration->constant_expression, &a);

    ctx->expression_is_not_evaluated = t2; //restore


    if (p_static_assert_declaration->first_token->type == TK_KEYWORD_CAKE_STATIC_DEBUG ||
        p_static_assert_declaration->first_token->type == TK_KEYWORD_CAKE_STATIC_DEBUG_EX)
    {
        bool ex = p_static_assert_declaration->first_token->type == TK_KEYWORD_CAKE_STATIC_DEBUG_EX;

        compiler_diagnostic(W_LOCATION, ctx->ctx, p_static_assert_declaration->first_token, NULL, "static_debug");

        struct flow_object* _Opt p_obj =
            expression_get_flow_object(ctx, p_static_assert_declaration->constant_expression, nullable_enabled);

        if (p_obj)
        {
            print_flow_object(&p_static_assert_declaration->constant_expression->type, p_obj, !ex);
            if (p_obj->is_temporary)
            {
                p_obj->current.state = FLOW_OBJECT_STATE_LIFE_TIME_ENDED;
            }
        }

        if (ex)
        {
            print_arena(ctx);
        }
    }
    else if (p_static_assert_declaration->first_token->type == TK_KEYWORD_STATIC_STATE)
    {
        /*TODO
           check state

        */

        bool is_invalid = false;
        enum flow_state e = 0;
        if (p_static_assert_declaration->string_literal_opt)
            e = parse_string_state(p_static_assert_declaration->string_literal_opt->lexeme, &is_invalid);
        if (is_invalid)
        {
            compiler_diagnostic(C_ANALIZER_ERROR_STATIC_STATE_FAILED, ctx->ctx, p_static_assert_declaration->first_token, NULL, "invalid parameter %s", p_static_assert_declaration->string_literal_opt->lexeme);
        }
        else
        {

            struct flow_object* _Opt p_obj =
                expression_get_flow_object(ctx, p_static_assert_declaration->constant_expression, nullable_enabled);
            if (p_obj)
            {


                if (e != p_obj->current.state)
                {
                    compiler_diagnostic(C_ANALIZER_ERROR_STATIC_STATE_FAILED, ctx->ctx, p_static_assert_declaration->first_token, NULL, "static_state failed");
                    if (p_static_assert_declaration->string_literal_opt)
                        printf("expected :%s\n", p_static_assert_declaration->string_literal_opt->lexeme);
                    printf("current  :");
                    flow_object_print_state(p_obj);
                    printf("\n");
                }
            }
            else
            {
                if (e != FLOW_OBJECT_STATE_NOT_APPLICABLE)
                {
                    compiler_diagnostic(C_ANALIZER_ERROR_STATIC_STATE_FAILED, ctx->ctx, p_static_assert_declaration->first_token, NULL, "static_state failed");
                }
            }

            if (p_obj && p_obj->is_temporary)
            {
                p_obj->current.state = FLOW_OBJECT_STATE_LIFE_TIME_ENDED;
            }

        }
    }
    else if (p_static_assert_declaration->first_token->type == TK_KEYWORD_STATIC_SET)
    {
        struct flow_object* _Opt p_obj =
            expression_get_flow_object(ctx, p_static_assert_declaration->constant_expression, nullable_enabled);

        if (p_obj)
        {
            if (p_static_assert_declaration->string_literal_opt)
            {
                const char* lexeme =
                    p_static_assert_declaration->string_literal_opt->lexeme;

                if (strcmp(lexeme, "\"zero\"") == 0)
                {
                    //gives the semantics of {0} or calloc
                    flow_object_set_zero(&p_static_assert_declaration->constant_expression->type, p_obj);
                }
                else
                {
                    bool is_invalid = false;
                    enum flow_state e =
                        parse_string_state(p_static_assert_declaration->string_literal_opt->lexeme, &is_invalid);

                    if (!is_invalid)
                    {
                        if (p_obj->members.size > 0)
                        {
                            compiler_diagnostic(C_ERROR_STATIC_SET, ctx->ctx, p_static_assert_declaration->first_token, NULL, "use only for non agregates");
                        }
                        p_obj->current.state = e;
                    }
                    else
                    {
                        compiler_diagnostic(C_ERROR_STATIC_SET, ctx->ctx, p_static_assert_declaration->first_token, NULL, "invalid parameter %s", p_static_assert_declaration->string_literal_opt->lexeme);
                    }
                }
            }

        }
        if (p_obj && p_obj->is_temporary)
        {
            p_obj->current.state = FLOW_OBJECT_STATE_LIFE_TIME_ENDED;
        }

    }

    true_false_set_destroy(&a);
}

static void flow_visit_direct_declarator(struct flow_visit_ctx* ctx, struct direct_declarator* p_direct_declarator)
{
    if (p_direct_declarator->function_declarator)
    {
        struct parameter_declaration* _Opt parameter = NULL;

        if (p_direct_declarator->function_declarator->parameter_type_list_opt &&
            p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list)
        {
            parameter = p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head;
        }

        ctx->parameter_list++;

        while (parameter)
        {
            flow_visit_declaration_specifiers(ctx, parameter->declaration_specifiers, &parameter->declarator->type);

            if (parameter->declarator)
            {
                flow_visit_declarator(ctx, parameter->declarator);
            }

            parameter = parameter->next;
        }

        ctx->parameter_list--;

    }
    else if (p_direct_declarator->array_declarator)
    {
        if (p_direct_declarator->array_declarator->assignment_expression)
        {
            struct true_false_set a = { 0 };
            flow_visit_expression(ctx, p_direct_declarator->array_declarator->assignment_expression, &a);
            true_false_set_destroy(&a);
        }

    }
}

static void flow_visit_declarator(struct flow_visit_ctx* ctx, struct declarator* p_declarator)
{
    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;
    try
    {
        if (
            p_declarator->type.category != TYPE_CATEGORY_FUNCTION)
        {

            if (ctx->parameter_list > 1)
            {
                /*
                 The objective here is to avoid including the arguments
                 of function pointers inside the scope.
                 Sample
                 void x_destroy(void (*f)(void * _Owner p))
                 We add f but not p.
                */
                return;
            }


            p_declarator->p_flow_object = make_flow_object(ctx, &p_declarator->type, p_declarator, NULL);
            if (p_declarator->p_flow_object == NULL)
            {
                throw;
            }

            flow_object_set_uninitialized(&p_declarator->type, p_declarator->p_flow_object);


            if (p_declarator->declaration_specifiers &&
                p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
            {
                if (type_is_pointer(&p_declarator->type))
                {
                    if (type_is_opt(&p_declarator->type, ctx->ctx->options.null_checks_enabled))
                    {
                        p_declarator->p_flow_object->current.state = FLOW_OBJECT_STATE_NOT_NULL | FLOW_OBJECT_STATE_NULL;
                    }
                    else
                    {
                        p_declarator->p_flow_object->current.state = FLOW_OBJECT_STATE_NOT_NULL;
                    }

                    if (type_is_pointer_to_out(&p_declarator->type))
                    {
                        struct type t = type_remove_pointer(&p_declarator->type);
                        struct flow_object* _Opt po = make_flow_object(ctx, &t, p_declarator, NULL);
                        if (po == NULL)
                        {
                            type_destroy(&t);
                            throw;
                        }
                        flow_object_set_uninitialized(&t, po);
                        object_set_pointer(p_declarator->p_flow_object, po); //MOVED                    
                        type_destroy(&t);
                    }
                    else if (type_is_owner_or_pointer_to_dtor(&p_declarator->type))
                    {
                        struct type t = type_remove_pointer(&p_declarator->type);
                        struct flow_object* _Opt po = make_flow_object(ctx, &t, p_declarator, NULL);
                        if (po == NULL)
                        {
                            type_destroy(&t);
                            throw;
                        }
                        const bool t_is_nullable = type_is_opt(&t, ctx->ctx->options.null_checks_enabled);
                        flow_object_set_unknown(&t, t_is_nullable, po, nullable_enabled);
                        object_set_pointer(p_declarator->p_flow_object, po); //MOVED                    
                        type_destroy(&t);
                    }
                }
                else if (type_is_struct_or_union(&p_declarator->type))
                {
                    const bool is_nullable = type_is_opt(&p_declarator->type, nullable_enabled);
                    flow_object_set_unknown(&p_declarator->type, is_nullable, p_declarator->p_flow_object, nullable_enabled);
                }
                else if (type_is_array(&p_declarator->type))
                {
                    // assert(false);//TODO
                     //flow_object_set_unknown(&p_declarator->type, &p_declarator->object);
                    p_declarator->p_flow_object->current.state = FLOW_OBJECT_STATE_NOT_ZERO;
                }
                else
                {
                    p_declarator->p_flow_object->current.state = FLOW_OBJECT_STATE_ZERO | FLOW_OBJECT_STATE_NOT_ZERO;
                }


#if 0
                if (type_is_pointer(&p_declarator->type))
                {
                    //TODO necessary?
                    struct type t2 = type_remove_pointer(&p_declarator->type);
                    if (p_declarator->p_object->pointed)
                    {
                        set_object(&t2, p_declarator->p_object->pointed, (FLOW_OBJECT_STATE_NOT_NULL | FLOW_OBJECT_STATE_NULL));
                    }
                    type_destroy(&t2);
                }
#endif
            }
        }

        /*if (p_declarator->pointer)
        {
            struct pointer* p = p_declarator->pointer;
            while (p)
            {
                p = p->pointer;
            }
        }*/


        if (p_declarator->direct_declarator)
        {
            flow_visit_direct_declarator(ctx, p_declarator->direct_declarator);
        }
    }
    catch
    {
    }
}

static void flow_visit_init_declarator_list(struct flow_visit_ctx* ctx, struct init_declarator_list* p_init_declarator_list)
{
    struct init_declarator* _Opt p_init_declarator = p_init_declarator_list->head;
    while (p_init_declarator)
    {
        flow_visit_init_declarator(ctx, p_init_declarator);
        p_init_declarator = p_init_declarator->next;
    }
}

static void flow_visit_member_declarator(struct flow_visit_ctx* ctx, struct member_declarator* p_member_declarator)
{
    if (p_member_declarator->declarator)
    {
        flow_visit_declarator(ctx, p_member_declarator->declarator);
    }
}

static void flow_visit_member_declarator_list(struct flow_visit_ctx* ctx, struct member_declarator_list* p_member_declarator_list)
{
    struct member_declarator* _Opt p_member_declarator = p_member_declarator_list->head;
    while (p_member_declarator)
    {
        flow_visit_member_declarator(ctx, p_member_declarator);
        p_member_declarator = p_member_declarator->next;
    }
}

static void flow_visit_member_declaration(struct flow_visit_ctx* ctx, struct member_declaration* p_member_declaration)
{
    if (p_member_declaration->member_declarator_list_opt)
    {
        flow_visit_member_declarator_list(ctx, p_member_declaration->member_declarator_list_opt);
    }
}

static void flow_visit_member_declaration_list(struct flow_visit_ctx* ctx, struct member_declaration_list* p_member_declaration_list)
{
    struct member_declaration* _Opt p_member_declaration = p_member_declaration_list->head;
    while (p_member_declaration)
    {
        flow_visit_member_declaration(ctx, p_member_declaration);
        p_member_declaration = p_member_declaration->next;
    }
}

static void flow_visit_struct_or_union_specifier(struct flow_visit_ctx* ctx, struct struct_or_union_specifier* p_struct_or_union_specifier)
{
    flow_visit_member_declaration_list(ctx, &p_struct_or_union_specifier->member_declaration_list);
}

static void flow_visit_enumerator(struct flow_visit_ctx* ctx, struct enumerator* p_enumerator)
{
    struct true_false_set a = { 0 };
    if (p_enumerator->constant_expression_opt)
        flow_visit_expression(ctx, p_enumerator->constant_expression_opt, &a);
    true_false_set_destroy(&a);
}

static void flow_visit_enumerator_list(struct flow_visit_ctx* ctx, struct enumerator_list* p_enumerator_list)
{
    struct enumerator* _Opt current = p_enumerator_list->head;
    while (current)
    {
        flow_visit_enumerator(ctx, current);
        current = current->next;
    }
}

static void flow_visit_enum_specifier(struct flow_visit_ctx* ctx, struct enum_specifier* p_enum_specifier)
{
    flow_visit_enumerator_list(ctx, &p_enum_specifier->enumerator_list);
}

static void flow_visit_type_specifier(struct flow_visit_ctx* ctx, struct type_specifier* p_type_specifier)
{
    if (p_type_specifier->struct_or_union_specifier)
    {
        flow_visit_struct_or_union_specifier(ctx, p_type_specifier->struct_or_union_specifier);
    }

    if (p_type_specifier->enum_specifier)
    {
        flow_visit_enum_specifier(ctx, p_type_specifier->enum_specifier);
    }
}

static void flow_visit_type_specifier_qualifier(struct flow_visit_ctx* ctx, struct type_specifier_qualifier* p_type_specifier_qualifier)
{
    if (p_type_specifier_qualifier->type_specifier)
    {
        flow_visit_type_specifier(ctx, p_type_specifier_qualifier->type_specifier);
    }
}

static void flow_visit_declaration_specifier(struct flow_visit_ctx* ctx, struct declaration_specifier* p_declaration_specifier)
{
    if (p_declaration_specifier->type_specifier_qualifier)
    {
        flow_visit_type_specifier_qualifier(ctx, p_declaration_specifier->type_specifier_qualifier);
    }
}

static void flow_visit_declaration_specifiers(struct flow_visit_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers,
    struct type* _Opt p_type_opt)
{
    /*
        * Se tiver typeof ou auto vamos apagar todos type specifiers.
        * e trocar por um novo
        * const typeof(int (*)()) a;
           //a = 1;
          auto p = (const typeof(int (*)())) 0;

          TODO esconder os type spefiver e qualifider , esconder auto.
          o resto tipo static deixar.

        */
        //

    struct declaration_specifier* _Opt p_declaration_specifier = p_declaration_specifiers->head;


    while (p_declaration_specifier)
    {
        flow_visit_declaration_specifier(ctx, p_declaration_specifier);
        p_declaration_specifier = p_declaration_specifier->next;
    }
}

/*
* retorna true se o ultimo item for um return
*/
static bool flow_is_last_item_return(struct compound_statement* p_compound_statement)
{
#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wflow-not-null"

    if (p_compound_statement &&
        p_compound_statement->block_item_list.tail &&
        p_compound_statement->block_item_list.tail->unlabeled_statement &&
        p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement &&
        p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement->first_token &&
        p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement->first_token->type == TK_KEYWORD_RETURN)
    {
        return true;
    }
    return false;

#pragma CAKE diagnostic pop
}

void flow_visit_declaration(struct flow_visit_ctx* ctx, struct declaration* p_declaration)
{
    if (p_declaration->static_assert_declaration)
    {
        flow_visit_static_assert_declaration(ctx, p_declaration->static_assert_declaration);
    }

    if (p_declaration->pragma_declaration)
    {
        flow_visit_pragma_declaration(ctx, p_declaration->pragma_declaration);
    }


    if (p_declaration->declaration_specifiers)
    {
        if (p_declaration->init_declarator_list.head)
        {
            flow_visit_declaration_specifiers(ctx, p_declaration->declaration_specifiers,
                &p_declaration->init_declarator_list.head->p_declarator->type);
        }
        else
        {
            flow_visit_declaration_specifiers(ctx, p_declaration->declaration_specifiers, NULL);

        }
    }

    if (p_declaration->init_declarator_list.head)
    {
        flow_visit_init_declarator_list(ctx, &p_declaration->init_declarator_list);
    }

    if (p_declaration->function_body)
    {
        assert(ctx->p_return_type == NULL);

        struct type type = get_function_return_type(&p_declaration->init_declarator_list.head->p_declarator->type);
        ctx->p_return_type = &type;

        flow_visit_compound_statement(ctx, p_declaration->function_body);
        type_destroy(&type);
        ctx->p_return_type = NULL;
    }
}

void flow_start_visit_declaration(struct flow_visit_ctx* ctx, struct declaration* p_declaration)
{
    ctx->labels_size = 0;
    flow_objects_clear(&ctx->arena);

    ctx->state_number_generator = 1; //reserva 0 p current

    if (p_declaration->function_body)
    {
        flow_visit_declaration(ctx, p_declaration);
        assert(p_declaration->function_body != NULL); //flow_visit_declaration does not change this

        if (!flow_is_last_item_return(p_declaration->function_body))
        {
            flow_exit_block_visit_defer_list(ctx, &p_declaration->defer_list, p_declaration->function_body->last_token);
        }
    }
    else
    {
        flow_visit_declaration(ctx, p_declaration);
    }

    flow_objects_clear(&ctx->arena);
}

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wanalyzer-maybe-uninitialized" 

_Opt struct flow_object* _Opt arena_new_object(struct flow_visit_ctx* ctx)
{
    _Opt struct flow_object* _Owner _Opt p = calloc(1, sizeof * p);
    if (p != NULL)
    {
        p->current.dbg_name = "current";
        p->id = ctx->arena.size + 1;
        if (flow_objects_push_back(&ctx->arena, p) != 0)
        {
            p = NULL;
        }
    }
    return (struct flow_object* _Opt)p; //warning removed
}

#pragma CAKE diagnostic pop


void flow_visit_ctx_destroy(_Dtor struct flow_visit_ctx* p)
{
    flow_objects_destroy(&p->arena);
}




/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable


#ifdef _WIN32


#include <winerror.h>
//#include <winsock2.h>
#endif

void throw_break_point()
{
    /*
      put a break point here to stop when throw is called
    */
}

const char* get_posix_error_message(int error)
{
    switch (error)
    {
    case EPERM:
        return "Operation not permitted";
    case  ENOENT:
        return "No such file or directory";
    case  ESRCH:
        return "No such process";
    case  EINTR:
        return "Interrupted system call";
    case  EIO:
        return "I/O error";
    case  ENXIO:
        return "No such device or address";
    case  E2BIG:
        return "Arg list too long";
    case  ENOEXEC:
        return "Exec string_format error";
    case  EBADF:
        return "Bad file number";
    case  ECHILD:
        return "No child processes";
    case  EAGAIN:
        return "Try again";
    case  ENOMEM:
        return "Out of memory";
    case  EACCES:
        return "Permission denied";
    case  EFAULT:
        return "Bad address";
    case  EBUSY:
        return "Device or resource busy";
    case  EEXIST:
        return "File exists";
    case  EXDEV:
        return "Cross-device link";
    case  ENODEV:
        return "No such device";
    case  ENOTDIR:
        return "Not a directory";
    case  EISDIR:
        return "Is a directory";
    case  EINVAL:
        return "Invalid argument";
    case  ENFILE:
        return "File table overflow";
    case  EMFILE:
        return "Too many open files";
    case  ENOTTY:
        return "Not a typewriter";
    case  ETXTBSY:
        return "Text file busy";
    case  EFBIG:
        return "File too large";
    case  ENOSPC:
        return "No space left on device";
    case  ESPIPE:
        return "Illegal seek";
    case  EROFS:
        return "Read-only file system";
    case  EMLINK:
        return "Too many links";
    case  EPIPE:
        return "Broken pipe";
    case  EDOM:
        return "Math argument out of domain of func";
    case  ERANGE:
        return "Math result not representable";
    case  EDEADLK:
        return "Resource deadlock would occur";
    case  ENAMETOOLONG:
        return "File name too long";
    case  ENOLCK:
        return "No record locks available";
    case  ENOSYS:
        return "Function not implemented";
    case  ENOTEMPTY:
        return "Directory not empty";
    case  ELOOP:
        return "Too many symbolic links encountered";
        //case  EWOULDBLOCK:
        //case EAGAIN:  return "Operation would block";
    case  ENOMSG:
        return "No message of desired type";
    case  EIDRM:
        return "Identifier removed";
    case  ENOSTR:
        return "Device not a stream";
    case  ENODATA:
        return "No data available";
    case  ETIME:
        return "Timer expired";
    case  ENOSR:
        return "Out of streams resources";

    case  ENOLINK:
        return "Link has been severed";
    case  EPROTO:
        return "Protocol error";
    case  EBADMSG:
        return "Not a data message";
    case  EOVERFLOW:
        return "Value too large for defined data type";
    case  EILSEQ:
        return "Illegal byte sequence";
    case  ENOTSOCK:
        return "Socket operation on non-socket";
    case  EDESTADDRREQ:
        return "Destination address required";
    case  EMSGSIZE:
        return "Message too long";
    case  EPROTOTYPE:
        return "Protocol wrong type for socket";
    case  ENOPROTOOPT:
        return "Protocol not available";
    case  EPROTONOSUPPORT:
        return "Protocol not supported";

    case  EOPNOTSUPP:
        return "Operation not supported on transport endpoint";

    case  EAFNOSUPPORT:
        return "Address family not supported by protocol";
    case  EADDRINUSE:
        return "Address already in use";
    case  EADDRNOTAVAIL:
        return "Cannot assign requested address";
    case  ENETDOWN:
        return "Network is down";
    case  ENETUNREACH:
        return "Network is unreachable";
    case  ENETRESET:
        return "Network dropped connection because of reset";
    case  ECONNABORTED:
        return "Software caused connection abort";
    case  ECONNRESET:
        return "Connection reset by peer";
    case  ENOBUFS:
        return "No buffer space available";
    case  EISCONN:
        return "Transport endpoint is already connected";
    case  ENOTCONN:
        return "Transport endpoint is not connected";

    case  ETIMEDOUT:
        return "Connection timed out";
    case  ECONNREFUSED:
        return "Connection refused";

    case  EHOSTUNREACH:
        return "No route to host";
    case  EALREADY:
        return "Operation already in progress";
    case  EINPROGRESS:
        return "Operation now in progress";
#ifndef _WIN32
    case  ENOTBLK:
        return "Block device required";
#ifndef __APPLE__
    case  ECHRNG:
        return "Channel number out of range";
    case  EL2NSYNC:
        return "Level 2 not synchronized";
    case  EL3HLT:
        return "Level 3 halted";
    case  EL3RST:
        return "Level 3 reset";
    case  ELNRNG:
        return "Link number out of range";
    case  EUNATCH:
        return "Protocol driver not attached";
    case  ENOCSI:
        return "No CSI structure available";
    case  EL2HLT:
        return "Level 2 halted";
    case  EBADE:
        return "Invalid ex   ";
    case  EBADR:
        return "Invalid request descriptor";
    case  EXFULL:
        return "Exchange full";
    case  ENOANO:
        return "No anode";
    case  EBADRQC:
        return "Invalid request code";
    case  EBADSLT:
        return "Invalid slot";

        //case  EDEADLOCK:
        //case EDEADLK:

    case  EBFONT:
        return "Bad font file string_format";
    case  ENONET:
        return "Machine is not on the network";
    case  ENOPKG:
        return "Package not installed";
    case  EREMOTE:
        return "Object is remote";

    case  EMULTIHOP:
        return "Multihop attempted";
    case  EDOTDOT:
        return "RFS specific error";
    case  EADV:
        return "Advertise error";
    case  ESRMNT:
        return "Srmount error";
    case  ECOMM:
        return "Communication error on send";
    case  ERESTART:
        return "Interrupted system call should be restarted";
    case  ESTRPIPE:
        return "Streams pipe error";
    case  EUSERS:
        return "Too many users";
    case  ENOTUNIQ:
        return "Email not unique on network";
    case  EBADFD:
        return "File descriptor in bad state";
    case  EREMCHG:
        return "Remote address changed";
    case  ELIBACC:
        return "Can not access a needed shared library";
    case  ELIBBAD:
        return "Accessing a corrupted shared library";
    case  ELIBSCN:
        return ".lib section in a.out corrupted";
    case  ELIBMAX:
        return "Attempting to link in too many shared libraries";
    case  ELIBEXEC:
        return "Cannot exec a shared library directly";
    case  EUCLEAN:
        return "Structure needs cleaning";
    case  ENOTNAM:
        return "Not a XENIX named type file";
    case  ENAVAIL:
        return "No XENIX semaphores available";
    case  EISNAM:
        return "Is a named type file";
    case  EREMOTEIO:
        return "Remote I/O error";
    case  EDQUOT:
        return "Quota exceeded";
    case  ENOMEDIUM:
        return "No medium found";
    case  EMEDIUMTYPE:
        return "Wrong medium type";
#endif

    case  ESOCKTNOSUPPORT:
        return "Socket type not supported";
    case  EPFNOSUPPORT:
        return "Protocol family not supported";
    case  EHOSTDOWN:
        return "Host is down";
    case  ESHUTDOWN:
        return "Cannot send after transport endpoint shutdown";
    case  ETOOMANYREFS:
        return "Too many references: cannot splice";
    case  ESTALE:
        return "Stale NFS file handle";

#endif
    default:
        break;

    }

    return "Unknown";
}
#ifdef _WIN32


int windows_error_to_posix(int i)
{
    switch (i)
    {
    case ERROR_ACCESS_DENIED:
        return EACCES;
    case ERROR_ALREADY_EXISTS:
        return EEXIST;
    case ERROR_BAD_UNIT:
        return ENODEV;
    case ERROR_BUFFER_OVERFLOW:
        return ENAMETOOLONG;
    case ERROR_BUSY:
        return EBUSY;
    case ERROR_BUSY_DRIVE:
        return EBUSY;
    case ERROR_CANNOT_MAKE:
        return EACCES;
    case ERROR_CANTOPEN:
        return EIO;
    case ERROR_CANTREAD:
        return EIO;
    case ERROR_CANTWRITE:
        return EIO;
    case ERROR_CURRENT_DIRECTORY:
        return EACCES;
    case ERROR_DEV_NOT_EXIST:
        return ENODEV;
    case ERROR_DEVICE_IN_USE:
        return EBUSY;
    case ERROR_DIR_NOT_EMPTY:
        return ENOTEMPTY;
    case ERROR_DIRECTORY:
        return EINVAL;
    case ERROR_DISK_FULL:
        return ENOSPC;
    case ERROR_FILE_EXISTS:
        return EEXIST;
    case ERROR_FILE_NOT_FOUND:
        return ENOENT;
    case ERROR_HANDLE_DISK_FULL:
        return ENOSPC;
    case ERROR_INVALID_ACCESS:
        return EACCES;
    case ERROR_INVALID_DRIVE:
        return ENODEV;
    case ERROR_INVALID_FUNCTION:
        return ENOSYS;
    case ERROR_INVALID_HANDLE:
        return EINVAL;
    case ERROR_INVALID_NAME:
        return EINVAL;
    case ERROR_LOCK_VIOLATION:
        return ENOLCK;
    case ERROR_LOCKED:
        return ENOLCK;
    case ERROR_NEGATIVE_SEEK:
        return EINVAL;
    case ERROR_NOACCESS:
        return EACCES;
    case ERROR_NOT_ENOUGH_MEMORY:
        return ENOMEM;
    case ERROR_NOT_READY:
        return EAGAIN;
    case ERROR_NOT_SAME_DEVICE:
        return EXDEV;
    case ERROR_OPEN_FAILED:
        return EIO;
    case ERROR_OPEN_FILES:
        return EBUSY;
    case ERROR_OPERATION_ABORTED:
        return ECANCELED;
    case ERROR_OUTOFMEMORY:
        return ENOMEM;
    case ERROR_PATH_NOT_FOUND:
        return ENOENT;
    case ERROR_READ_FAULT:
        return EIO;
    case ERROR_RETRY:
        return EAGAIN;
    case ERROR_SEEK:
        return EIO;
    case ERROR_SHARING_VIOLATION:
        return EACCES;
    case ERROR_TOO_MANY_OPEN_FILES:
        return EMFILE;
    case ERROR_WRITE_FAULT:
        return EIO;
    case ERROR_WRITE_PROTECT:
        return EACCES;
    case WSAEACCES:
        return EACCES;
    case WSAEADDRINUSE:
        return EADDRINUSE;
    case WSAEADDRNOTAVAIL:
        return EADDRNOTAVAIL;
    case WSAEAFNOSUPPORT:
        return EAFNOSUPPORT;
    case WSAEALREADY:
        return EALREADY;
    case WSAEBADF:
        return EBADF;
    case WSAECONNABORTED:
        return ECONNABORTED;
    case WSAECONNREFUSED:
        return ECONNREFUSED;
    case WSAECONNRESET:
        return ECONNRESET;
    case WSAEDESTADDRREQ:
        return EDESTADDRREQ;
    case WSAEFAULT:
        return EFAULT;
    case WSAEHOSTUNREACH:
        return EHOSTUNREACH;
    case WSAEINPROGRESS:
        return EINPROGRESS;
    case WSAEINTR:
        return EINTR;
    case WSAEINVAL:
        return EINVAL;
    case WSAEISCONN:
        return EISCONN;
    case WSAEMFILE:
        return EMFILE;
    case WSAEMSGSIZE:
        return EMSGSIZE;
    case WSAENETDOWN:
        return ENETDOWN;
    case WSAENETRESET:
        return ENETRESET;
    case WSAENETUNREACH:
        return ENETUNREACH;
    case WSAENOBUFS:
        return ENOBUFS;
    case WSAENOPROTOOPT:
        return ENOPROTOOPT;
    case WSAENOTCONN:
        return ENOTCONN;
    case WSAENOTSOCK:
        return ENOTSOCK;
    case WSAEOPNOTSUPP:
        return EOPNOTSUPP;
    case WSAEPROTONOSUPPORT:
        return EPROTONOSUPPORT;
    case WSAEPROTOTYPE:
        return EPROTOTYPE;
    case WSAETIMEDOUT:
        return ETIMEDOUT;
    case WSAEWOULDBLOCK:
        return EWOULDBLOCK;
    default:
        break;
    }
    return EPERM;
}
#endif
/*
int GetWindowsOrLinuxSocketLastErrorAsPosix(void)
{
#ifdef _WIN32
    return windows_error_to_posix(WSAGetLastError());
#else
    return errno;
#endif
}
*/



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/


#pragma safety enable



size_t get_align_void_ptr(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return _Alignof(void*);
    case TARGET_X86_X64_GCC:  return 8;
    case TARGET_X86_MSVC:     return 4;
    case TARGET_X64_MSVC:     return 8;
    }
    assert(false);
    return 0;
}

size_t get_size_void_ptr(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return sizeof(void*);
    case TARGET_X86_X64_GCC:  return 8;
    case TARGET_X86_MSVC:     return 4;
    case TARGET_X64_MSVC:     return 8;
    }
    assert(false);
    return 0;

}

size_t get_align_char(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return _Alignof(char);
    case TARGET_X86_X64_GCC:  return 1;
    case TARGET_X86_MSVC:     return 1;
    case TARGET_X64_MSVC:     return 1;
    }
    assert(false);
    return 0;
}

size_t get_size_char(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return sizeof(char);
    case TARGET_X86_X64_GCC:  return 1;
    case TARGET_X86_MSVC:     return 1;
    case TARGET_X64_MSVC:     return 1;
    }
    assert(false);
    return 0;

}

size_t get_align_bool(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return _Alignof(_Bool);
    case TARGET_X86_X64_GCC:  return 1;
    case TARGET_X86_MSVC:     return 1;
    case TARGET_X64_MSVC:     return 1;
    }
    assert(false);
    return 0;
}

size_t get_size_bool(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return sizeof(_Bool);
    case TARGET_X86_X64_GCC:  return 1;
    case TARGET_X86_MSVC:     return 1;
    case TARGET_X64_MSVC:     return 1;
    }
    assert(false);
    return 0;
}

size_t get_align_short(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return _Alignof(short);
    case TARGET_X86_X64_GCC:  return 2;
    case TARGET_X86_MSVC:     return 2;
    case TARGET_X64_MSVC:     return 2;
    }
    assert(false);
    return 0;
}

size_t get_size_short(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return sizeof(short);
    case TARGET_X86_X64_GCC:  return 2;
    case TARGET_X86_MSVC:     return 2;
    case TARGET_X64_MSVC:     return 2;
    }
    assert(false);
    return 0;
}

size_t get_align_int(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return _Alignof(int);
    case TARGET_X86_X64_GCC:  return 4;
    case TARGET_X86_MSVC:     return 4;
    case TARGET_X64_MSVC:     return 4;
    }
    assert(false);
    return 0;
}

size_t get_size_int(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return sizeof(int);
    case TARGET_X86_X64_GCC:  return 4;
    case TARGET_X86_MSVC:     return 5;
    case TARGET_X64_MSVC:     return 6;
    }    
    assert(false);
    return 0;
}

size_t get_align_long(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return _Alignof(long);
    case TARGET_X86_X64_GCC:  return 8;
    case TARGET_X86_MSVC:     return 4;
    case TARGET_X64_MSVC:     return 4;
    }
    assert(false);
    return 0;
}

size_t get_size_long(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return sizeof(long);
    case TARGET_X86_X64_GCC:  return 8;
    case TARGET_X86_MSVC:     return 4;
    case TARGET_X64_MSVC:     return 4;
    }
    assert(false);
    return 0;
}

size_t get_align_long_long(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return _Alignof(long long);
    case TARGET_X86_X64_GCC:  return 8;
    case TARGET_X86_MSVC:     return 8;
    case TARGET_X64_MSVC:     return 8;
    }
    assert(false);
    return 0;
}

size_t get_size_long_long(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return sizeof(long long);
    case TARGET_X86_X64_GCC:  return 8;
    case TARGET_X86_MSVC:     return 8;
    case TARGET_X64_MSVC:     return 8;
    }
    
    assert(false);
    return 0;
}


size_t get_align_float(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return _Alignof(float);
    case TARGET_X86_X64_GCC:  return 4;
    case TARGET_X86_MSVC:     return 4;
    case TARGET_X64_MSVC:     return 4;
    }
    assert(false);
    return 0;
}

size_t get_size_float(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return sizeof(float);
    case TARGET_X86_X64_GCC:  return 4;
    case TARGET_X86_MSVC:     return 4;
    case TARGET_X64_MSVC:     return 4;
    }    
    assert(false);
    return 0;
}

size_t get_align_double(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return _Alignof(double);
    case TARGET_X86_X64_GCC:  return 8;
    case TARGET_X86_MSVC:     return 8;
    case TARGET_X64_MSVC:     return 8;
    }
    assert(false);
    return 0;
}

size_t get_size_double(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return sizeof(double);
    case TARGET_X86_X64_GCC:  return 8;
    case TARGET_X86_MSVC:     return 8;
    case TARGET_X64_MSVC:     return 8;
    }    
    assert(false);
    return 0;
}

size_t get_align_long_double(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return _Alignof(long double);
    case TARGET_X86_X64_GCC:  return 16;
    case TARGET_X86_MSVC:     return 8;
    case TARGET_X64_MSVC:     return 8;
    }
    assert(false);
    return 0;
}

size_t get_size_long_double(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:      return sizeof(long double);
    case TARGET_X86_X64_GCC:  return 16;
    case TARGET_X86_MSVC:     return 8;
    case TARGET_X64_MSVC:     return 8;
    }    
    assert(false);
    return 0;
}


enum type_specifier_flags get_wchar_type_specifier(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:
#ifdef _WIN32
        return (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_SHORT);
#else
        return (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT);
#endif
        break;

    case TARGET_X86_X64_GCC:
        return (TYPE_SPECIFIER_INT);
        break;

    case TARGET_X86_MSVC:
    case TARGET_X64_MSVC:
        return (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_SHORT);
        break;
    }
    assert(false);
    return 0;
}

enum type_specifier_flags get_size_t_specifier(enum target target)
{
    switch (target)
    {
    case TARGET_DEFAULT:

#ifdef _WIN32
#ifdef _WIN64
        return (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT64);
#else
        return (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT);
#endif
#else 
#ifdef __x86_64__
        /* 64-bit */
        return (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_LONG);
#else
        return (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT);
#endif
#endif

        break;
    case TARGET_X86_X64_GCC:
        return (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT64);
        break;
    case TARGET_X86_MSVC:
        return (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT);
        break;
    case TARGET_X64_MSVC:
        return (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT64);
        break;
    }
    assert(false);
    return 0;
}


bool is_automatic_variable(enum storage_class_specifier_flags f)
{
    if (f & STORAGE_SPECIFIER_EXTERN)
        return false;

    if (f & STORAGE_SPECIFIER_STATIC)
        return false;

    if (f & STORAGE_SPECIFIER_PARAMETER)
        return true;

    if (f & STORAGE_SPECIFIER_BLOCK_SCOPE)
        return true;

    return false;
}

void print_item(struct osstream* ss, bool* first, const char* item)
{
    if (!(*first))
        ss_fprintf(ss, " ");
    ss_fprintf(ss, "%s", item);
    *first = false;

}

bool print_type_alignment_flags(struct osstream* ss, bool* first, enum alignment_specifier_flags flags, enum target target)
{
    if (target == TARGET_X86_MSVC ||
             target == TARGET_X86_MSVC)
    {
        if (flags & ALIGNMENT_SPECIFIER_8_FLAGS)
            print_item(ss, first, "__declspec(align(80))");
        if (flags & ALIGNMENT_SPECIFIER_16_FLAGS)
            print_item(ss, first, "__declspec(align(16))");
        if (flags & ALIGNMENT_SPECIFIER_32_FLAGS)
            print_item(ss, first, "__declspec(align(32))");
        if (flags & ALIGNMENT_SPECIFIER_64_FLAGS)
            print_item(ss, first, "__declspec(align(64))");
        if (flags & ALIGNMENT_SPECIFIER_128_FLAGS)
            print_item(ss, first, "__declspec(align(128))");
    }
    else if (target == TARGET_X86_X64_GCC)
    {
        if (flags & ALIGNMENT_SPECIFIER_8_FLAGS)
            print_item(ss, first, "__attribute__((aligned(8)))");
        if (flags & ALIGNMENT_SPECIFIER_16_FLAGS)
            print_item(ss, first, "__attribute__((aligned(16)))");
        if (flags & ALIGNMENT_SPECIFIER_32_FLAGS)
            print_item(ss, first, "__attribute__((aligned(32)))");
        if (flags & ALIGNMENT_SPECIFIER_64_FLAGS)
            print_item(ss, first, "__attribute__((aligned(64)))");
        if (flags & ALIGNMENT_SPECIFIER_128_FLAGS)
            print_item(ss, first, "__attribute__((aligned(128)))");
    }
    return *first;
}

bool print_type_specifier_flags(struct osstream* ss, bool* first, enum type_specifier_flags e_type_specifier_flags)
{
    if (e_type_specifier_flags & TYPE_SPECIFIER_VOID)
        print_item(ss, first, "void");

    if (e_type_specifier_flags & TYPE_SPECIFIER_SIGNED)
        print_item(ss, first, "signed");

    if (e_type_specifier_flags & TYPE_SPECIFIER_UNSIGNED)
        print_item(ss, first, "unsigned");

    if (e_type_specifier_flags & TYPE_SPECIFIER_INT)
        print_item(ss, first, "int");

    if (e_type_specifier_flags & TYPE_SPECIFIER_SHORT)
        print_item(ss, first, "short");

    if (e_type_specifier_flags & TYPE_SPECIFIER_LONG)
        print_item(ss, first, "long");

    if (e_type_specifier_flags & TYPE_SPECIFIER_LONG_LONG)
        print_item(ss, first, "long long");

    if (e_type_specifier_flags & TYPE_SPECIFIER_INT8)
        print_item(ss, first, "__int8");

    if (e_type_specifier_flags & TYPE_SPECIFIER_INT16)
        print_item(ss, first, "__int16");

    if (e_type_specifier_flags & TYPE_SPECIFIER_INT32)
        print_item(ss, first, "__int32");

    if (e_type_specifier_flags & TYPE_SPECIFIER_INT64)
        print_item(ss, first, "__int64");


    if (e_type_specifier_flags & TYPE_SPECIFIER_CHAR)
        print_item(ss, first, "char");

    if (e_type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
        print_item(ss, first, "double");

    if (e_type_specifier_flags & TYPE_SPECIFIER_FLOAT)
        print_item(ss, first, "float");

    if (e_type_specifier_flags & TYPE_SPECIFIER_BOOL)
        print_item(ss, first, "_Bool");

    if (e_type_specifier_flags & TYPE_SPECIFIER_COMPLEX)
        print_item(ss, first, "_Complex");

    if (e_type_specifier_flags & TYPE_SPECIFIER_DECIMAL32)
        print_item(ss, first, "_Decimal32");

    if (e_type_specifier_flags & TYPE_SPECIFIER_DECIMAL64)
        print_item(ss, first, "_Decimal64");

    if (e_type_specifier_flags & TYPE_SPECIFIER_DECIMAL128)
        print_item(ss, first, "_Decimal128");

    if (e_type_specifier_flags & TYPE_SPECIFIER_NULLPTR_T)
        print_item(ss, first, "nullptr_t");

    if (e_type_specifier_flags & TYPE_SPECIFIER_GCC__BUILTIN_VA_LIST)
        print_item(ss, first, "__builtin_va_list");



    return *first;
}

void print_type_qualifier_flags(struct osstream* ss, bool* first, enum type_qualifier_flags e_type_qualifier_flags)
{

    if (e_type_qualifier_flags & TYPE_QUALIFIER_CONST)
        print_item(ss, first, "const");

    if (e_type_qualifier_flags & TYPE_QUALIFIER_RESTRICT)
        print_item(ss, first, "restrict");

    if (e_type_qualifier_flags & TYPE_QUALIFIER_VOLATILE)
        print_item(ss, first, "volatile");

    if (e_type_qualifier_flags & TYPE_QUALIFIER_OWNER)
        print_item(ss, first, "_Owner");

    if (e_type_qualifier_flags & TYPE_QUALIFIER_DTOR)
        print_item(ss, first, "_Dtor");

    if (e_type_qualifier_flags & TYPE_QUALIFIER_VIEW)
        print_item(ss, first, "_View");

    if (e_type_qualifier_flags & TYPE_QUALIFIER_OPT)
        print_item(ss, first, "_Opt");

}

void print_msvc_declspec(struct osstream* ss, bool* first, enum msvc_declspec_flags  msvc_declspec_flags)
{
    /*
       The objective is to print only what changes code generation / link
    */
    if (msvc_declspec_flags & MSVC_DECLSPEC_ALIGN_8_FLAG)
    {
        print_item(ss, first, "__declspec(align(8))");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_ALIGN_16_FLAG)
    {
        print_item(ss, first, "__declspec(align(16))");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_ALIGN_32_FLAG)
    {
        print_item(ss, first, "__declspec(align(32))");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_ALIGN_64_FLAG)
    {
        print_item(ss, first, "__declspec(align(64))");
    }

    if (msvc_declspec_flags & MSVC_DECLSPEC_ALLOCATE_FLAG)
    {
        print_item(ss, first, "__declspec(allocate)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_ALLOCATOR_FLAG)
    {
        print_item(ss, first, "__declspec(allocator)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_APPDOMAIN_FLAG)
    {

    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_CODE_SEG_FLAG)
    {

    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_DEPRECATED_FLAG)
    {

    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_DLLIMPORT_FLAG)
    {
        print_item(ss, first, "__declspec(dllimport)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_DLLEXPORT_FLAG)
    {
        print_item(ss, first, "__declspec(dllexport)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_EMPTY_BASES_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_HYBRID_PATCHABLE_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_JITINTRINSIC_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_NAKED_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_NOALIAS_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_NOINLINE_FLAG)
    {
        print_item(ss, first, "__declspec(noinline)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_NORETURN_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_NOTHROW_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_NOVTABLE_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_NO_SANITIZE_ADDRESS_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_PROCESS_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_PROPERTY_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_RESTRICT_FLAG)
    {
        print_item(ss, first, "__declspec(restrict)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_SAFEBUFFERS_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_SELECTANY_FLAG)
    {
        print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_SPECTRE_FLAG)
    {
        print_item(ss, first, "__declspec(spectre(nomitigation))");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_THREAD_FLAG)
    {
        print_item(ss, first, "__declspec(thread)");
    }
    if (msvc_declspec_flags & MSVC_DECLSPEC_UUID_FLAG)
    {
        //print_item(ss, first, "__declspec(selectany)");
    }
}

void print_type_qualifier_specifiers(struct osstream* ss, const struct type* type, enum target target)
{
    bool first = true;
    print_type_qualifier_flags(ss, &first, type->type_qualifier_flags);

    if (type->type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION)
    {
        assert(type->struct_or_union_specifier != NULL);
        print_item(ss, &first, "struct ");
        ss_fprintf(ss, "%s", type->struct_or_union_specifier->tag_name);
    }
    else if (type->type_specifier_flags & TYPE_SPECIFIER_ENUM)
    {
        assert(type->enum_specifier != NULL);
        print_item(ss, &first, "enum ");
        if (type->enum_specifier->tag_token)
            ss_fprintf(ss, "%s", type->enum_specifier->tag_token->lexeme);

    }
    else if (type->type_specifier_flags & TYPE_SPECIFIER_TYPEDEF)
    {
        assert(false);
    }
    else
    {
        print_type_alignment_flags(ss, &first, type->alignment_specifier_flags, target);
        print_msvc_declspec(ss, &first, type->msvc_declspec_flags);
        print_type_specifier_flags(ss, &first, type->type_specifier_flags);
    }
}

void type_integer_promotion(struct type* a)
{
    //assert(type_is_integer(a));

    if ((a->type_specifier_flags & TYPE_SPECIFIER_BOOL) ||
        (a->type_specifier_flags & TYPE_SPECIFIER_CHAR) ||
        (a->type_specifier_flags & TYPE_SPECIFIER_SHORT) ||
        (a->type_specifier_flags & TYPE_SPECIFIER_INT8) ||
        (a->type_specifier_flags & TYPE_SPECIFIER_INT16))
    {
        a->type_specifier_flags = (TYPE_SPECIFIER_INT);
    }
}

void type_add_const(struct type* p_type)
{
    p_type->type_qualifier_flags |= TYPE_QUALIFIER_CONST;
}

void type_remove_qualifiers(struct type* p_type)
{
    p_type->type_qualifier_flags = 0;
}

struct type type_lvalue_conversion(const struct type* p_type, bool nullchecks_enabled)
{

    enum type_category category = type_get_category(p_type);
    switch (category)
    {
    case TYPE_CATEGORY_FUNCTION:
    {
        /*
           "function returning type" is converted to an expression that has type
           "pointer to function returning type".
        */
        struct type t = type_add_pointer(p_type, nullchecks_enabled);
        t.type_qualifier_flags &= ~TYPE_QUALIFIER_OPT;
        t.storage_class_specifier_flags &= ~STORAGE_SPECIFIER_PARAMETER;
        t.category = t.category;
        return t;
    }
    break;
    case TYPE_CATEGORY_ARRAY:
    {
        /*
          An expression that has type "array of type" is converted
          to an expression with type "pointer to type" that points to the initial element
          of the array object and s not an lvalue.
          If the array object has register storage class, the behavior is undefined.
        */
        struct type t = get_array_item_type(p_type);
        struct type t2 = type_add_pointer(&t, nullchecks_enabled);


        type_remove_qualifiers(&t2);
        /*
        int g(const int a[const 20]) {
            // in this function, a has type const int* const (const pointer to const int)
            }
        */
        type_destroy(&t);
        t2.storage_class_specifier_flags &= ~STORAGE_SPECIFIER_PARAMETER;
        return t2;
    }
    break;
    case TYPE_CATEGORY_POINTER:
        break;
    case TYPE_CATEGORY_ITSELF:
    default:
        break;
    }

    struct type t = type_dup(p_type);
    type_remove_qualifiers(&t);
    t.storage_class_specifier_flags &= ~STORAGE_SPECIFIER_PARAMETER;

    t.category = type_get_category(&t);

    return t;
}

struct type type_convert_to(const struct type* p_type, enum language_version target)
{
    /*
    * Convert types to previous standard format
    */

    if (target < LANGUAGE_C23 && type_is_nullptr_t(p_type))
    {

        struct type t = make_void_ptr_type();
        assert(t.name_opt == NULL);
        if (p_type->name_opt)
        {
            t.name_opt = strdup(p_type->name_opt);
        }
        return t;
    }


    return type_dup(p_type);
}

void print_type_core(struct osstream* ss, const struct type* p_type, bool onlydeclarator, bool printname, enum target target)
{
    const struct type* _Opt p = p_type;

    while (p)
    {
        if (onlydeclarator && p->next == NULL)
            break;

        switch (p->category)
        {
        case TYPE_CATEGORY_ITSELF:
        {
            struct osstream local = { 0 };
            bool first = true;

            print_type_qualifier_flags(&local, &first, p->type_qualifier_flags);

            if (p->struct_or_union_specifier)
            {
                ss_fprintf(&local, "struct %s", p->struct_or_union_specifier->tag_name);
            }
            else if (p->enum_specifier)
            {
                if (p->enum_specifier->tag_token)
                {
                    ss_fprintf(&local, "enum %s", p->enum_specifier->tag_token->lexeme);
                }
                else
                {
                    ss_fprintf(&local, "enum ");
                }
            }
            else
            {
                print_type_alignment_flags(&local, &first, p->alignment_specifier_flags, target);
                print_msvc_declspec(&local, &first, p->msvc_declspec_flags);
                print_type_specifier_flags(&local, &first, p->type_specifier_flags);
            }



            if (printname && p->name_opt)
            {
                if (first)
                {
                    ss_fprintf(ss, " ");
                    first = false;
                }
                ss_fprintf(ss, "%s", p->name_opt);
            }

            struct osstream local2 = { 0 };
            if (ss->size > 0)
                ss_fprintf(&local2, "%s %s", local.c_str, ss->c_str);
            else
                ss_fprintf(&local2, "%s", local.c_str);

            ss_swap(ss, &local2);
            ss_close(&local);
            ss_close(&local2);
        }
        break;
        case TYPE_CATEGORY_ARRAY:


            if (printname && p->name_opt)
            {
                //if (first)
                //{
                  //  ss_fprintf(ss, " ");
                    //first = false;
                //}
                ss_fprintf(ss, "%s", p->name_opt);
            }

            ss_fprintf(ss, "[");

            bool b = true;
            if (p->has_static_array_size)
            {
                ss_fprintf(ss, "static");
                b = false;
            }

            print_type_qualifier_flags(ss, &b, p->type_qualifier_flags);

            if (p->num_of_elements > 0)
            {
                if (!b)
                    ss_fprintf(ss, " ");

                ss_fprintf(ss, "%d", p->num_of_elements);
            }
            ss_fprintf(ss, "]");

            break;
        case TYPE_CATEGORY_FUNCTION:

            if (printname && p->name_opt)
            {
                //if (first)
                //{
                  //  ss_fprintf(ss, " ");
                    //first = false;
                //}
                ss_fprintf(ss, "%s", p->name_opt);
            }
            ss_fprintf(ss, "(");

            struct param* _Opt pa = p->params.head;

            while (pa)
            {
                struct osstream sslocal = { 0 };
                print_type(&sslocal, &pa->type, target);
                ss_fprintf(ss, "%s", sslocal.c_str);
                if (pa->next)
                    ss_fprintf(ss, ",");
                ss_close(&sslocal);
                pa = pa->next;
            }
            ss_fprintf(ss, ")");
            break;

        case TYPE_CATEGORY_POINTER:
        {
            struct osstream local = { 0 };
            if (p->next && (
                (p->next->category == TYPE_CATEGORY_FUNCTION ||
                    p->next->category == TYPE_CATEGORY_ARRAY)))
            {
                ss_fprintf(&local, "(");
            }

            ss_fprintf(&local, "*");
            bool first = false;
            print_type_qualifier_flags(&local, &first, p->type_qualifier_flags);

            if (printname && p->name_opt)
            {
                if (!first)
                {
                    ss_fprintf(ss, " ");
                }
                ss_fprintf(ss, "%s", p->name_opt);
                first = false;
            }

            if (ss->c_str)
                ss_fprintf(&local, "%s", ss->c_str);

            if (p->next &&
                (p->next->category == TYPE_CATEGORY_FUNCTION ||
                    p->next->category == TYPE_CATEGORY_ARRAY))
            {
                ss_fprintf(&local, ")", ss->c_str);
            }

            ss_swap(ss, &local);
            ss_close(&local);
        }
        break;
        }

        p = p->next;

    }
}

void print_type(struct osstream* ss, const struct type* p_type, enum target target)
{
    print_type_core(ss, p_type, false, true, target);
}

void print_type_no_names(struct osstream* ss, const struct type* p_type, enum target target)
{
    print_type_core(ss, p_type, false, false, target);
}

void print_type_declarator(struct osstream* ss, const struct type* p_type, enum target target)
{
    print_type_core(ss, p_type, true, true, target);
}

void type_print(const struct type* a, enum target target)
{
    struct osstream ss = { 0 };
    print_type(&ss, a, target);
    printf("%s", ss.c_str);
    ss_close(&ss);
}

void type_println(const struct type* a, enum target target)
{
    type_print(a, target);
    puts("\n");
}

enum type_category type_get_category(const struct type* p_type)
{
    return p_type->category;
}

void param_list_add(struct param_list* list, struct param* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void param_list_destroy(_Dtor struct param_list* p)
{
    struct param* _Owner _Opt item = p->head;
    while (item)
    {
        struct param* _Owner _Opt next = item->next;
        type_destroy(&item->type);
        free(item);
        item = next;
    }
}

void type_destroy_one(_Opt _Dtor struct type* p_type)
{
    free((void* _Owner)p_type->name_opt);
    param_list_destroy(&p_type->params);
    assert(p_type->next == NULL);
}

void type_destroy(_Opt _Dtor struct type* p_type)
{
    free((void* _Owner)p_type->name_opt);
    param_list_destroy(&p_type->params);

    struct type* _Owner _Opt item = p_type->next;
    while (item)
    {
        struct type* _Owner _Opt next = item->next;
        item->next = NULL;
        type_destroy_one(item);
        free(item);
        item = next;
    }

}

void type_delete(struct type* _Owner _Opt p_type)
{
    if (p_type)
    {
        type_destroy(p_type);
        free(p_type);
    }
}

bool type_has_attribute(const struct type* p_type, enum attribute_flags attributes)
{
    if (p_type->attributes_flags & attributes)
    {
        /*like
          [[maybe_unused]] int i;
        */
        return true;
    }

    struct attribute_specifier_sequence* _Opt p_attribute_specifier_sequence_opt = NULL;

    if (p_type->struct_or_union_specifier)
    {
        /*like
          struct [[maybe_unused]] X { }
          struct X x;
        */
        p_attribute_specifier_sequence_opt = p_type->struct_or_union_specifier->attribute_specifier_sequence_opt;

        struct struct_or_union_specifier* _Opt p_complete =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        if (p_attribute_specifier_sequence_opt == NULL && p_complete)
        {
            p_attribute_specifier_sequence_opt = p_complete->attribute_specifier_sequence_opt;
        }
    }
    else if (p_type->enum_specifier)
    {
        const struct enum_specifier* _Opt p_complete_enum_specifier =
            get_complete_enum_specifier(p_type->enum_specifier);

        p_attribute_specifier_sequence_opt = p_type->enum_specifier->attribute_specifier_sequence_opt;

        if (p_attribute_specifier_sequence_opt == NULL && p_complete_enum_specifier)
        {
            p_attribute_specifier_sequence_opt = p_complete_enum_specifier->attribute_specifier_sequence_opt;
        }
    }

    if (p_attribute_specifier_sequence_opt &&
        p_attribute_specifier_sequence_opt->attributes_flags & attributes)
    {
        return true;
    }

    return false;
}

bool type_is_maybe_unused(const struct type* p_type)
{
    return type_has_attribute(p_type, STD_ATTRIBUTE_MAYBE_UNUSED);
}

bool type_is_deprecated(const struct type* p_type)
{
    return type_has_attribute(p_type, STD_ATTRIBUTE_DEPRECATED);
}

bool type_is_nodiscard(const struct type* p_type)
{
    return type_has_attribute(p_type, STD_ATTRIBUTE_NODISCARD);
}

bool type_is_array(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ARRAY;
}

bool type_is_owner_or_pointer_to_dtor(const struct type* p_type)
{
    if (type_is_pointed_dtor(p_type))
        return true;

    if (type_is_owner(p_type))
    {
        return true;
    }
    return p_type->type_qualifier_flags & TYPE_QUALIFIER_DTOR;
}

bool type_is_pointer_to_owner(const struct type* p_type)
{
    if (p_type->next == NULL)
        return false;

    return type_is_owner(p_type->next);
}

bool type_is_dtor(const struct type* p_type)
{
    return p_type->type_qualifier_flags & TYPE_QUALIFIER_DTOR;
}

bool type_is_pointed_dtor(const struct type* p_type)
{
    if (!type_is_pointer(p_type))
        return false;

    assert(p_type->next != NULL);

    return type_is_dtor(p_type->next);
}

bool type_is_owner(const struct type* p_type)
{
    if (p_type->struct_or_union_specifier)
    {
        if (p_type->type_qualifier_flags & TYPE_QUALIFIER_VIEW)
            return false;

        struct struct_or_union_specifier* _Opt p_complete =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        if (p_complete && p_complete->is_owner)
        {
            //The objective here is fix a type later.
            /*
             struct X;
             struct X f(); //X is _Owner?
             struct X { char * _Owner p; };
             int main()
             {
               struct X x = 1 ? f() : f();
             }
            */

            return true;
        }
    }

    return p_type->type_qualifier_flags & TYPE_QUALIFIER_OWNER;
}

bool type_is_opt(const struct type* p_type, bool nullable_enabled)
{
    if (nullable_enabled)
    {
        return p_type->type_qualifier_flags & TYPE_QUALIFIER_OPT;
    }

    //If  nullable_enabled is disabled then all pointers are nullable
    return true;
}

bool type_is_view(const struct type* p_type)
{
    return p_type->type_qualifier_flags & TYPE_QUALIFIER_VIEW;
}

bool type_is_ctor(const struct type* p_type)
{
    return p_type->type_qualifier_flags & TYPE_QUALIFIER_CTOR;
}

bool type_is_const(const struct type* p_type)
{
    return p_type->type_qualifier_flags & TYPE_QUALIFIER_CONST;
}

bool type_is_constexpr(const struct type* p_type)
{
    return (p_type->storage_class_specifier_flags & STORAGE_SPECIFIER_CONSTEXPR);
}

bool type_is_const_or_constexpr(const struct type* p_type)
{
    return (p_type->type_qualifier_flags & TYPE_QUALIFIER_CONST) ||
        (p_type->storage_class_specifier_flags & STORAGE_SPECIFIER_CONSTEXPR);
}

bool type_is_pointer_to_const(const struct type* p_type)
{
    if (p_type->category == TYPE_CATEGORY_POINTER)
    {
        if (p_type->next)
        {
            return p_type->next->type_qualifier_flags & TYPE_QUALIFIER_CONST;
        }
    }
    return false;
}

bool type_is_void_ptr(const struct type* p_type)
{
    if (p_type->category == TYPE_CATEGORY_POINTER)
    {
        if (p_type->next)
        {
            return p_type->next->type_specifier_flags & TYPE_SPECIFIER_VOID;
        }
    }
    return false;
}

bool type_is_void(const struct type* p_type)
{
    if (p_type->category == TYPE_CATEGORY_ITSELF)
    {
        return p_type->type_specifier_flags & TYPE_SPECIFIER_VOID;
    }

    return false;
}

bool type_is_nullptr_t(const struct type* p_type)
{
    if (p_type->category == TYPE_CATEGORY_ITSELF)
    {
        return p_type->type_specifier_flags & TYPE_SPECIFIER_NULLPTR_T;
    }

    return false;
}

bool type_is_pointer_to_out(const struct type* p_type)
{
    if (p_type->next == NULL)
        return false;

    if (p_type->category == TYPE_CATEGORY_POINTER)
    {
        return p_type->next->type_qualifier_flags & TYPE_QUALIFIER_CTOR;
    }
    return false;
}

bool type_is_pointer(const struct type* p_type)
{
    return p_type->category == TYPE_CATEGORY_POINTER;
}

bool type_is_essential_bool(const struct type* p_type)
{
    return p_type->attributes_flags & CAKE_HIDDEN_ATTRIBUTE_LIKE_BOOL;
}
bool type_is_essential_char(const struct type* p_type)
{
    return p_type->attributes_flags & CAKE_HIDDEN_ATTRIBUTE_INT_LIKE_CHAR;
}

bool type_is_enum(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_ENUM;
}

bool type_is_struct_or_union(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION;
}

bool type_is_union(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return false;

    if (p_type->struct_or_union_specifier == NULL)
        return false;

    return p_type->struct_or_union_specifier->first_token->type == TK_KEYWORD_UNION;
}

/*
  The three types
  char, signed char, and unsigned char
  are collectively called the character types.
*/
bool type_is_character(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_CHAR;
}

bool type_is_vla(const struct type* p_type)
{
    const struct type* _Opt it = p_type;

    while (it && type_is_array(it))
    {
        if (it->array_num_elements_expression)
        {
            if (!object_has_constant_value(&it->array_num_elements_expression->object))
            {
                // int a[7][n]
                //if any of the array is not constant then it is vla
                return true;
            }
        }
        it = it->next;
    }
    return false;
}

bool type_is_decimal128(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_DECIMAL128;
}
bool type_is_decimal64(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_DECIMAL64;
}
bool type_is_decimal32(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_DECIMAL32;
}
bool type_is_long_double(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return  false;

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
    {
        if (p_type->type_specifier_flags & TYPE_SPECIFIER_LONG)
        {
            return true;
        }

    }
    return false;
}

bool type_is_double(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return  false;

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
    {
        if (!(p_type->type_specifier_flags & TYPE_SPECIFIER_LONG))
        {
            return true;
        }

    }
    return false;
}

bool type_is_int(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return  false;

    if ((p_type->type_specifier_flags == (TYPE_SPECIFIER_INT | TYPE_SPECIFIER_SIGNED)) ||
        (p_type->type_specifier_flags == TYPE_SPECIFIER_INT))
    {
        return true;
    }
    return false;
}

bool type_is_unsigned_int(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return  false;

    if (p_type->type_specifier_flags == (TYPE_SPECIFIER_INT | TYPE_SPECIFIER_UNSIGNED))
    {
        return true;
    }
    return false;
}


bool type_is_float(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return  false;

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_FLOAT)
    {
        return true;
    }
    return false;
}


bool type_is_bool(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_BOOL;
}

/*
 There are three standard floating types, designated as
 float, double, and long double.

 There are three decimal floating types, designated as _Decimal32, _Decimal64, and _Decimal128.
*/
bool type_is_floating_point(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return false;

    return p_type->type_specifier_flags &
        (TYPE_SPECIFIER_DOUBLE |
            TYPE_SPECIFIER_FLOAT);
}

bool type_is_unsigned_integer(const struct type* p_type)
{
    if (type_is_integer(p_type) &&
        (p_type->type_specifier_flags & TYPE_SPECIFIER_UNSIGNED))
    {
        return true;
    }

    return false;
}

bool type_is_signed_integer(const struct type* p_type)
{
    if (type_is_integer(p_type) &&
        !(p_type->type_specifier_flags & TYPE_SPECIFIER_UNSIGNED))
    {
        return true;
    }

    return false;
}

bool type_is_array_of_char(const struct type* p_type)
{
    if (p_type->category != TYPE_CATEGORY_ARRAY)
        return false;

    assert(p_type->next != NULL);
    return p_type->next->type_specifier_flags & TYPE_SPECIFIER_CHAR;
}

bool type_is_char(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return false;

    return p_type->type_specifier_flags & TYPE_SPECIFIER_CHAR;
}

/*
  The type char, the signed and unsigned integer types,
  and the enumerated types
  are collectively  called integer types.
*/
bool type_is_integer(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return false;

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
    {
        /*we cannot check long without check double*/
        //long double
        return false;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_ENUM)
    {
        return true;
    }

    return p_type->type_specifier_flags &
        (TYPE_SPECIFIER_CHAR |
            TYPE_SPECIFIER_SHORT |
            TYPE_SPECIFIER_INT |

            TYPE_SPECIFIER_INT16 |
            TYPE_SPECIFIER_INT32 |
            TYPE_SPECIFIER_INT64 |

            TYPE_SPECIFIER_INT |
            TYPE_SPECIFIER_LONG |
            TYPE_SPECIFIER_SIGNED |
            TYPE_SPECIFIER_UNSIGNED |
            TYPE_SPECIFIER_INT8 |
            TYPE_SPECIFIER_INT16 |
            TYPE_SPECIFIER_INT64 |
            TYPE_SPECIFIER_LONG_LONG |
            TYPE_SPECIFIER_BOOL);
}

/*
* Integer and floating types are collectively called arithmetic types.
*/
bool type_is_arithmetic(const struct type* p_type)
{
    return type_is_integer(p_type) || type_is_floating_point(p_type);
}

/*
 Arithmetic types, pointer types, and the nullptr_t type are collectively
 called scalar types.
*/
bool type_is_scalar(const struct type* p_type)
{
    //TODO we need two concepts...is_scalar on real type or is_scalar after lvalue converison

    if (type_is_arithmetic(p_type))
        return true;

    if (type_is_pointer(p_type))
        return true;

    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return false;


    if (p_type->type_specifier_flags & TYPE_SPECIFIER_ENUM)
        return true;
    if (p_type->type_specifier_flags & TYPE_SPECIFIER_NULLPTR_T)
        return true;

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_BOOL)
        return true;

    return false;
}


const struct param_list* _Opt type_get_func_or_func_ptr_params(const struct type* p_type)
{
    if (p_type->category == TYPE_CATEGORY_FUNCTION)
    {
        return &p_type->params;
    }
    else if (p_type->category == TYPE_CATEGORY_POINTER)
    {
        if (p_type->next &&
            p_type->next->category == TYPE_CATEGORY_FUNCTION)
        {
            return &p_type->next->params;
        }
    }
    return NULL;
}

void check_ownership_qualifiers_of_argument_and_parameter(struct parser_ctx* ctx,
    struct argument_expression* current_argument,
    struct type* paramer_type,
    int param_num)
{
    //            _Owner     _Dtor  _View parameter
    // _Owner      OK                   OK
    // _Dtor  X         OK         OK
    // _View       X (NULL)  X          OK

    const bool paramer_is_obj_owner = type_is_pointed_dtor(paramer_type);
    const bool paramer_is_owner = type_is_owner(paramer_type);
    const bool paramer_is_view = !paramer_is_obj_owner && !paramer_is_owner;

    const struct type* const argument_type = &current_argument->expression->type;
    const bool argument_is_owner = type_is_owner(&current_argument->expression->type);
    const bool argument_is_obj_owner = type_is_pointed_dtor(&current_argument->expression->type);
    const bool argument_is_view = !argument_is_owner && !argument_is_obj_owner;

    if (argument_is_owner && paramer_is_owner)
    {
        //ok
    }
    else if (argument_is_owner && paramer_is_obj_owner)
    {
        //ok
    }
    else if (argument_is_owner && paramer_is_view)
    {
        //ok
        if (current_argument->expression->type.storage_class_specifier_flags & STORAGE_SPECIFIER_FUNCTION_RETURN)
        {
            compiler_diagnostic(W_OWNERSHIP_USING_TEMPORARY_OWNER,
                ctx,
                current_argument->expression->first_token, NULL,
                "passing a temporary owner to a view");
        }

    }////////////////////////////////////////////////////////////
    else if (argument_is_obj_owner && paramer_is_owner)
    {
        compiler_diagnostic(W_OWNERSHIP_MOVE_ASSIGNMENT_OF_NON_OWNER,
            ctx,
            current_argument->expression->first_token, NULL,
            "cannot move _Dtor to _Owner");
    }
    else if (argument_is_obj_owner && paramer_is_obj_owner)
    {
        //ok
    }
    else if (argument_is_obj_owner && paramer_is_view)
    {
        //ok
        //ok
        if (current_argument->expression->type.storage_class_specifier_flags & STORAGE_SPECIFIER_FUNCTION_RETURN)
        {
            compiler_diagnostic(W_OWNERSHIP_USING_TEMPORARY_OWNER,
                ctx,
                current_argument->expression->first_token, NULL,
                "passing a temporary owner to a view");
        }


    }///////////////////////////////////////////////////////////////
    else if (argument_is_view && paramer_is_owner)
    {
        if (!expression_is_null_pointer_constant(current_argument->expression))
        {
            compiler_diagnostic(W_OWNERSHIP_MOVE_ASSIGNMENT_OF_NON_OWNER,
                ctx,
                current_argument->expression->first_token, NULL,
                "passing a _View argument to a _Owner parameter");
        }
    }
    else if (argument_is_view && paramer_is_obj_owner)
    {
        //check if the contented of pointer is _Owner.
        if (type_is_pointer(argument_type))
        {
            struct type t2 = type_remove_pointer(argument_type);
            if (!type_is_owner(&t2))
            {

                compiler_diagnostic(W_OWNERSHIP_MOVE_ASSIGNMENT_OF_NON_OWNER,
                    ctx,
                    current_argument->expression->first_token, NULL,
                    "pointed object is not _Owner");

            }
            else
            {
                //pointer object is _Owner
                if (!argument_type->address_of)
                {
                    //we need something created with address of.
                    compiler_diagnostic(W_MUST_USE_ADDRESSOF,
                        ctx,
                        current_argument->expression->first_token, NULL,
                        "_Dtor pointer must be created using address of operator &");
                }
            }

            type_destroy(&t2);
        }
        else
        {
            if (!expression_is_null_pointer_constant(current_argument->expression))
            {
                compiler_diagnostic(W_OWNERSHIP_MOVE_ASSIGNMENT_OF_NON_OWNER,
                    ctx,
                    current_argument->expression->first_token, NULL,
                    "passing a _View argument to a _Dtor parameter");
            }
        }

    }
    else if (argument_is_view && paramer_is_view)
    {
        //ok
    }///////////////////////////////////////////////////////////////
}

void check_argument_and_parameter(struct parser_ctx* ctx,
    struct argument_expression* current_argument,
    struct type* paramer_type,
    int param_num)
{
    // TODO use assignment check for everthing..

    if (type_is_owner_or_pointer_to_dtor(paramer_type))
    {
        if (type_is_pointed_dtor(paramer_type))
        {
            if (current_argument->expression->type.category == TYPE_CATEGORY_POINTER)
            {
                if (type_is_pointer(&current_argument->expression->type) &&
                    !type_is_pointer_to_owner(&current_argument->expression->type))
                {
                    compiler_diagnostic(W_OWNERSHIP_NOT_OWNER, ctx,
                        current_argument->expression->first_token, NULL,
                        "parameter %d requires a pointer to _Owner object",
                        param_num);
                }
            }
            else
            {
                compiler_diagnostic(W_OWNERSHIP_NOT_OWNER, ctx,
                    current_argument->expression->first_token, NULL,
                    "parameter %d requires a pointer to _Owner type",
                    param_num);
            }
        }
    }

    struct type* argument_type = &current_argument->expression->type;
    const bool is_null_pointer_constant = expression_is_null_pointer_constant(current_argument->expression);

    struct type parameter_type_converted = (type_is_array(paramer_type)) ?
        type_lvalue_conversion(paramer_type, ctx->options.null_checks_enabled) :
        type_dup(paramer_type);


    struct type argument_type_converted =
        expression_is_subjected_to_lvalue_conversion(current_argument->expression) ?
        type_lvalue_conversion(argument_type, ctx->options.null_checks_enabled) :
        type_dup(argument_type);

    /*
       less generic tests are first
    */
    if (type_is_enum(argument_type) && type_is_enum(paramer_type))
    {
        if (!type_is_same(argument_type, paramer_type, false))
        {
            compiler_diagnostic(C_ERROR_INCOMPATIBLE_TYPES, ctx,
                current_argument->expression->first_token, NULL,
                " incompatible types at argument %d", param_num);
        }

        check_ownership_qualifiers_of_argument_and_parameter(ctx,
            current_argument,
            paramer_type,
            param_num);

        type_destroy(&parameter_type_converted);
        type_destroy(&argument_type_converted);

        return;
    }

    if (type_is_arithmetic(argument_type) && type_is_arithmetic(paramer_type))
    {
        check_ownership_qualifiers_of_argument_and_parameter(ctx,
            current_argument,
            paramer_type,
            param_num);

        type_destroy(&parameter_type_converted);
        type_destroy(&argument_type_converted);

        return;
    }

    if (is_null_pointer_constant && type_is_pointer(paramer_type))
    {
        //TODO void F(int * [[_Opt]] p)
        // F(0) when passing null we will check if the parameter
        //have the anotation [[_Opt]]

        /*can be converted to any type*/
        check_ownership_qualifiers_of_argument_and_parameter(ctx,
            current_argument,
            paramer_type,
            param_num);

        type_destroy(&parameter_type_converted);
        type_destroy(&argument_type_converted);

        return;
    }

    if (is_null_pointer_constant && type_is_array(paramer_type))
    {
        compiler_diagnostic(W_FLOW_NON_NULL,
            ctx,
            current_argument->expression->first_token, NULL,
            " passing null as array");

        check_ownership_qualifiers_of_argument_and_parameter(ctx,
            current_argument,
            paramer_type,
            param_num);

        type_destroy(&parameter_type_converted);
        type_destroy(&argument_type_converted);

        return;
    }

    /*
       We have two pointers or pointer/array combination
    */
    if (type_is_pointer_or_array(argument_type) && type_is_pointer_or_array(paramer_type))
    {
        if (type_is_void_ptr(argument_type))
        {
            /*void pointer can be converted to any type*/
            check_ownership_qualifiers_of_argument_and_parameter(ctx,
                current_argument,
                paramer_type,
                param_num);

            type_destroy(&parameter_type_converted);
            type_destroy(&argument_type_converted);

            return;
        }

        if (type_is_void_ptr(paramer_type))
        {
            /*any pointer can be converted to void* */
            check_ownership_qualifiers_of_argument_and_parameter(ctx,
                current_argument,
                paramer_type,
                param_num);

            type_destroy(&parameter_type_converted);
            type_destroy(&argument_type_converted);

            return;
        }


        //TODO  lvalue

        if (type_is_array(paramer_type))
        {
            unsigned long long parameter_array_size = paramer_type->num_of_elements;
            if (type_is_array(argument_type))
            {
                unsigned long long argument_array_size = argument_type->num_of_elements;
                if (parameter_array_size != 0 &&
                    argument_array_size < parameter_array_size)
                {
                    compiler_diagnostic(C_ERROR_ARGUMENT_SIZE_SMALLER_THAN_PARAMETER_SIZE,
                        ctx,
                        current_argument->expression->first_token, NULL,
                        " argument of size [%d] is smaller than parameter of size [%d]", argument_array_size, parameter_array_size);
                }
            }
            else if (is_null_pointer_constant || type_is_nullptr_t(argument_type))
            {
                compiler_diagnostic(W_PASSING_NULL_AS_ARRAY,
                    ctx,
                    current_argument->expression->first_token, NULL,
                    " passing null as array");
            }
        }



        if (!type_is_same(&argument_type_converted, &parameter_type_converted, false))
        {
            type_print(&argument_type_converted, ctx->options.target);
            type_print(&parameter_type_converted, ctx->options.target);

            compiler_diagnostic(C_ERROR_INCOMPATIBLE_TYPES, ctx,
                current_argument->expression->first_token, NULL,
                " incompatible types at argument %d", param_num);
            //disabled for now util it works correctly
            //return false;
        }

        if (type_is_pointer(&argument_type_converted) && type_is_pointer(&parameter_type_converted))
        {
            //parameter pointer do non const
            //argument const.
            struct type argument_pointer_to = type_remove_pointer(&argument_type_converted);
            struct type parameter_pointer_to = type_remove_pointer(&parameter_type_converted);
            if (type_is_const(&argument_pointer_to) &&
                !type_is_const(&parameter_pointer_to) &&
                !type_is_owner_or_pointer_to_dtor(&parameter_pointer_to))
            {
                compiler_diagnostic(W_DISCARDED_QUALIFIERS, ctx,
                    current_argument->expression->first_token, NULL,
                    " discarding const at argument %d", param_num);
            }
            type_destroy(&argument_pointer_to);
            type_destroy(&parameter_pointer_to);
        }
        //return true;
    }

    //TODO
    //if (!type_is_same(paramer_type, &current_argument->expression->type, false))
    //{
    //    compiler_diagnostic(C1, ctx,
    //        current_argument->expression->first_token,
    //        " incompatible types at argument %d ", param_num);
    //}



    check_ownership_qualifiers_of_argument_and_parameter(ctx,
        current_argument,
        paramer_type,
        param_num);



    type_destroy(&argument_type_converted);
    type_destroy(&parameter_type_converted);
}



bool type_is_function(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_FUNCTION;
}

bool type_is_function_or_function_pointer(const struct type* p_type)
{
    if (type_is_function(p_type))
        return true;

    if (type_is_pointer(p_type))
    {
        //TODO not optimized
        struct type t = type_remove_pointer(p_type);
        bool r = type_is_function(&t);
        type_destroy(&t);
        return r;
    }

    return false;
}

bool type_is_empty(const struct type* p_type)
{
    return p_type->category == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags == TYPE_SPECIFIER_NONE;
}

struct type type_add_pointer(const struct type* p_type, bool null_checks_enabled)
{
    struct type r = type_dup(p_type);
    try
    {
        //waiting test
        //if (type_is_empty(&r)) throw;

        struct type* _Owner _Opt p = calloc(1, sizeof(struct type));
        if (p == NULL) throw;

        *p = r;
        r = (struct type){ 0 };
        r.next = p;
        r.category = TYPE_CATEGORY_POINTER;


        r.storage_class_specifier_flags = p_type->storage_class_specifier_flags;
    }
    catch
    {
    }

    return r;
}

struct type type_remove_pointer(const struct type* p_type)
{
    struct type r = type_dup(p_type);
    if (!type_is_pointer(p_type))
    {
        return r;
    }

    if (r.next)
    {
        struct type next = *r.next;
        /*
          we have moved the contents of r.next, but we also need to delete it's memory
        */
        free(r.next);
        r.next = NULL;
        type_destroy_one(&r);
        r = next;
    }
    else
    {
        assert(false);
    }

    assert(p_type->next != NULL); //guaranteed by type_is_pointer

    r.storage_class_specifier_flags = p_type->next->storage_class_specifier_flags;
    r.type_qualifier_flags = p_type->next->type_qualifier_flags;

    return r;
}


struct type get_array_item_type(const struct type* p_type)
{
    struct type r = type_dup(p_type);

    if (r.next)
    {
        struct type r2 = *r.next;

        free(r.next);
        free((void* _Owner) r.name_opt);
        param_list_destroy(&r.params);
        return r2;
    }

    return r;
}

struct type type_param_array_to_pointer(const struct type* p_type, bool null_checks_enabled)
{
    assert(type_is_array(p_type));
    struct type t = get_array_item_type(p_type);
    struct type t2 = type_add_pointer(&t, null_checks_enabled);

    if (p_type->type_qualifier_flags & TYPE_QUALIFIER_CONST)
    {
        /*
         void F(int a[static const 5]) {
          static_assert((typeof(a)) == (int* const));
        }
        */
        t2.type_qualifier_flags |= TYPE_QUALIFIER_CONST;
    }

    type_destroy(&t);
    t2.storage_class_specifier_flags &= ~STORAGE_SPECIFIER_PARAMETER;

    return t2;
}

bool type_is_pointer_or_array(const struct type* p_type)
{
    const enum type_category category = type_get_category(p_type);

    if (category == TYPE_CATEGORY_POINTER ||
        category == TYPE_CATEGORY_ARRAY)
    {
        return true;
    }

    if (category == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags == TYPE_SPECIFIER_NULLPTR_T)
    {
        return true;
    }

    return false;
}


//See 6.3.1.1
int type_get_integer_rank(const struct type* p_type1)
{
    if (type_is_pointer_or_array(p_type1))
    {
        assert(false);
        return 40;
    }

    if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_LONG_LONG) ||
        (p_type1->type_specifier_flags & TYPE_SPECIFIER_INT64))
    {
        return 80;
    }
    else if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_NULLPTR_T))
    {
        return 50; //?
    }
    else if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_LONG) ||
        (p_type1->type_specifier_flags & TYPE_SPECIFIER_INT32))
    {
        return 50;
    }
    else if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_INT) ||
        (p_type1->type_specifier_flags & TYPE_SPECIFIER_ENUM))
    {
        return 40;
    }
    else if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_SHORT) ||
        (p_type1->type_specifier_flags & TYPE_SPECIFIER_INT16))
    {
        return 30;
    }
    else if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_CHAR) ||
        (p_type1->type_specifier_flags & TYPE_SPECIFIER_INT8))
    {
        return 20;
    }
    else if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_BOOL))
    {
        return 10;
    }

    return 0;
}

struct type type_get_enum_underlying_type(const struct type* p)
{
    struct type r = type_make_int();
    //TODO
    return r;
}

struct type type_common(const struct type* p_type1, const struct type* p_type2, enum target target)
{
    //See 6.3.1.8 Usual arithmetic conversions


    /*
       First, if the type of either operand is _Decimal128,
       the other operand is converted to _Decimal128.
    */
    if (type_is_decimal128(p_type1))
    {
        return type_dup(p_type1);
    }

    if (type_is_decimal128(p_type2))
    {
        return type_dup(p_type2);
    }

    /*
      Otherwise, if the type of either operand is _Decimal64,
      the other operand is converted to _Decimal64
    */

    if (type_is_decimal64(p_type1))
    {
        return type_dup(p_type1);
    }

    if (type_is_decimal64(p_type2))
    {
        return type_dup(p_type2);
    }

    /*
      Otherwise, if the type of either operand is _Decimal32,
      the other operand is converted to _Decimal32.
    */
    if (type_is_decimal32(p_type1))
    {
        return type_dup(p_type1);
    }

    if (type_is_decimal32(p_type2))
    {
        return type_dup(p_type2);
    }

    /*
      Otherwise, if the corresponding real type of either operand is long double,
      the other operand is converted, without change of type domain, to a type whose
      corresponding real type is long double
    */
    if (type_is_long_double(p_type1))
    {
        return type_dup(p_type1);
    }

    if (type_is_long_double(p_type2))
    {
        return type_dup(p_type2);
    }

    /*
      Otherwise, if the corresponding real type of either operand is double,
      the other operand is converted, without change of type domain, to a type
      whose corresponding real type is double.
    */

    if (type_is_double(p_type1))
    {
        return type_dup(p_type1);
    }

    if (type_is_double(p_type2))
    {
        return type_dup(p_type2);
    }


    /*
      Otherwise, if the corresponding real type of either operand is float,
      the other operand is converted, without change of type domain,
      to a type whose corresponding real type is float
    */
    if (type_is_float(p_type1))
    {
        return type_dup(p_type1);
    }

    if (type_is_float(p_type2))
    {
        return type_dup(p_type2);
    }

    /*
     Otherwise, if any of the two types is an enumeration, it is converted to its underlying type.
    */
    struct type promoted_a = { 0 };
    struct type promoted_b = { 0 };


    if (type_is_enum(p_type1))
    {
        promoted_a = type_get_enum_underlying_type(p_type1);

    }
    else
    {
        promoted_a = type_dup(p_type1);
    }

    if (type_is_enum(p_type2))
    {
        promoted_b = type_get_enum_underlying_type(p_type2);
    }
    else
    {
        promoted_b = type_dup(p_type2);
    }

    /*
      Then, the integer promotions are performed on both operands. Next, the following rules are
      applied to the promoted operands
    */
    type_integer_promotion(&promoted_a);
    type_integer_promotion(&promoted_b);



    /*
      if both operands have the same type, then no further conversion is needed
    */
    if (type_is_same(&promoted_a, &promoted_b, false))
    {
        type_destroy(&promoted_b);
        return promoted_a;
    }

    /*
     Otherwise, if both operands have signed integer types or both have unsigned integer
     types, the operand with the type of lesser integer conversion rank is converted to the type
     of the operand with greater rank.
    */

    if (type_is_signed_integer(&promoted_a) == type_is_signed_integer(&promoted_b))
    {
        if (type_get_integer_rank(&promoted_a) > type_get_integer_rank(&promoted_b))
        {
            type_destroy(&promoted_b);
            return promoted_a;
        }

        type_destroy(&promoted_a);
        return promoted_b;
    }


    /*
     Otherwise, if the operand that has unsigned integer type has rank greater or equal to
     the rank of the type of the other operand, then the operand with signed integer type is
     converted to the type of the operand with unsigned integer type.
    */

    struct type* p_signed_promoted = type_is_signed_integer(&promoted_a) ? &promoted_a : &promoted_b;
    struct type* p_unsigned_promoted = type_is_unsigned_integer(&promoted_a) ? &promoted_a : &promoted_b;

    assert(p_signed_promoted != p_unsigned_promoted);

    if (type_get_integer_rank(p_unsigned_promoted) >= type_get_integer_rank(p_signed_promoted))
    {
        struct type r = { 0 };
        type_swap(&r, p_unsigned_promoted);
        type_destroy(&promoted_a);
        type_destroy(&promoted_b);
        return r;
    }

    /*
      Otherwise, if the type of the operand with signed integer type can represent all the values
      of the type of the operand with unsigned integer type, then the operand with unsigned
      integer type is converted to the type of the operand with signed integer type
    */

    size_t signed_promoted_sizeof = 0;
    if (type_get_sizeof(p_signed_promoted, &signed_promoted_sizeof, target) != 0)
    {
        assert(false);
    }

    size_t unsigned_promoted_sizeof = 0;
    if (type_get_sizeof(p_unsigned_promoted, &unsigned_promoted_sizeof, target) != 0)
    {
        assert(false);
    }

    if (signed_promoted_sizeof > unsigned_promoted_sizeof)
    {
        struct type r = { 0 };
        type_swap(&r, p_signed_promoted);
        type_destroy(&promoted_a);
        type_destroy(&promoted_b);
        return r;
    }

    /*
      Otherwise, both operands are converted to the unsigned integer type corresponding to
      the type of the operand with signed integer type
    */

    struct type r = { 0 };
    type_swap(&r, p_signed_promoted);
    r.type_specifier_flags |= TYPE_SPECIFIER_UNSIGNED;
    type_destroy(&promoted_a);
    type_destroy(&promoted_b);
    return r;
}

void type_set(struct type* a, const struct type* b)
{
    struct type t = type_dup(b);
    type_swap(&t, a);
    type_destroy(&t);
}

struct type type_dup(const struct type* p_type)
{
    try
    {
        struct type_list l = { 0 };
        const struct type* _Opt p = p_type;
        while (p)
        {
            struct type* _Owner _Opt p_new = calloc(1, sizeof(struct type));
            if (p_new == NULL)
            {
                type_list_destroy(&l);
                throw;
            }

            *p_new = *p;

            //actually I was not the _Owner of p_new->next
            static_set(p_new->next, "uninitialized");
            p_new->next = NULL;

            if (p->name_opt)
            {
                //actually p_new->name_opt was not mine..
                static_set(p_new->name_opt, "uninitialized");
                p_new->name_opt = strdup(p->name_opt);
            }

            if (p->category == TYPE_CATEGORY_FUNCTION)
            {
                //actually p_new->params.head  p_new->params.tail and was not mine..
                static_set(p_new->params.head, "uninitialized");
                p_new->params.head = NULL;
                static_set(p_new->params.tail, "uninitialized");
                p_new->params.tail = NULL;

                struct param* _Opt p_param = p->params.head;
                while (p_param)
                {
                    struct param* _Owner _Opt p_new_param = calloc(1, sizeof * p_new_param);
                    if (p_new_param == NULL)
                    {
                        type_list_destroy(&l);
                        type_delete(p_new);
                        throw;
                    }

                    p_new_param->type = type_dup(&p_param->type);

                    param_list_add(&p_new->params, p_new_param);
                    p_param = p_param->next;
                }
            }

            type_list_push_back(&l, p_new);
            p = p->next;
        }

        if (l.head == NULL)
            throw;

        struct type r = *l.head;
        /*
           we have moved the content of l.head
           but we also need to delete the memory
        */
        free(l.head);

        return r;
    }
    catch
    {
    }

    struct type empty = { 0 };
    return empty;
}

static enum sizeof_error get_offsetof_struct(struct struct_or_union_specifier* complete_struct_or_union_specifier,
    const char* member, size_t* sz, enum target target)
{
    enum sizeof_error sizeof_error = ESIZEOF_NONE;

    const bool is_union =
        (complete_struct_or_union_specifier->first_token->type == TK_KEYWORD_UNION);

    size_t size = 0;
    try
    {
        size_t maxalign = 0;

        struct member_declaration* _Opt d = complete_struct_or_union_specifier->member_declaration_list.head;
        while (d)
        {
            if (d->member_declarator_list_opt)
            {
                struct member_declarator* _Opt md = d->member_declarator_list_opt->head;
                while (md)
                {
                    size_t align = 1;

                    if (md->declarator)
                    {
                        assert(md->declarator->name_opt != NULL);

                        align = type_get_alignof(&md->declarator->type, target);

                        if (align > maxalign)
                        {
                            maxalign = align;
                        }
                        if (size % align != 0)
                        {
                            size += align - (size % align);
                        }

                        if (strcmp(md->declarator->name_opt->lexeme, member) == 0)
                        {
                            *sz = size;
                            return ESIZEOF_NONE;
                        }

                        size_t item_size = 0;
                        sizeof_error = type_get_sizeof(&md->declarator->type, &item_size, target);
                        if (sizeof_error != 0)
                            throw;

                        if (is_union)
                        {
                            if (item_size > size)
                                size = item_size;
                        }
                        else
                        {
                            size += item_size;
                        }
                    }
                    else
                    {
                        sizeof_error = ESIZEOF_INCOMPLETE;
                        throw;
                    }

                    md = md->next;
                }
            }
            else if (d->specifier_qualifier_list)
            {
                if (d->specifier_qualifier_list->struct_or_union_specifier)
                {
                    struct type t = { 0 };
                    t.category = TYPE_CATEGORY_ITSELF;
                    t.struct_or_union_specifier = d->specifier_qualifier_list->struct_or_union_specifier;
                    t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                    size_t align = type_get_alignof(&t, target);

                    if (align > maxalign)
                    {
                        maxalign = align;
                    }
                    if (size % align != 0)
                    {
                        size += align - (size % align);
                    }
                    size_t item_size = 0;

                    sizeof_error = type_get_sizeof(&t, &item_size, target);
                    if (sizeof_error != 0)
                        throw;

                    if (is_union)
                    {
                        if (item_size > size)
                            size = item_size;
                    }
                    else
                    {
                        //TODO overflow
                        size += item_size;
                    }
                    type_destroy(&t);
                }
                else
                {
                    sizeof_error = ESIZEOF_INCOMPLETE;
                    throw;
                }
            }

            d = d->next;
        }
        if (maxalign != 0)
        {
            if (size % maxalign != 0)
            {
                size += maxalign - (size % maxalign);
            }
        }
        else
        {
            sizeof_error = ESIZEOF_INCOMPLETE;
            throw;
        }
    }
    catch
    {
        return sizeof_error;
    }

    *sz = size;
    return sizeof_error;
}

enum sizeof_error get_sizeof_struct(struct struct_or_union_specifier* complete_struct_or_union_specifier, size_t* sz, enum target target)
{
    enum sizeof_error sizeof_error = ESIZEOF_NONE;

    const bool is_union =
        (complete_struct_or_union_specifier->first_token->type == TK_KEYWORD_UNION);

    size_t size = 0;
    try
    {
        size_t maxalign = 0;

        struct member_declaration* _Opt d = complete_struct_or_union_specifier->member_declaration_list.head;
        while (d)
        {
            if (d->member_declarator_list_opt)
            {
                struct member_declarator* _Opt md = d->member_declarator_list_opt->head;
                while (md)
                {
                    size_t align = 1;

                    if (md->declarator)
                    {
                        align = type_get_alignof(&md->declarator->type, target);

                        if (align > maxalign)
                        {
                            maxalign = align;
                        }
                        if (size % align != 0)
                        {
                            size += align - (size % align);
                        }
                        size_t item_size = 0;
                        sizeof_error = type_get_sizeof(&md->declarator->type, &item_size, target);
                        if (sizeof_error != 0)
                            throw;

                        if (is_union)
                        {
                            if (item_size > size)
                                size = item_size;
                        }
                        else
                        {
                            size += item_size;
                        }
                    }
                    else
                    {
                        sizeof_error = ESIZEOF_INCOMPLETE;
                        throw;
                    }
                    md = md->next;
                }
            }
            else if (d->specifier_qualifier_list)
            {
                if (d->specifier_qualifier_list->struct_or_union_specifier)
                {
                    struct type t = { 0 };
                    t.category = TYPE_CATEGORY_ITSELF;
                    t.struct_or_union_specifier = d->specifier_qualifier_list->struct_or_union_specifier;
                    t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                    size_t align = type_get_alignof(&t, target);

                    if (align > maxalign)
                    {
                        maxalign = align;
                    }
                    if (size % align != 0)
                    {
                        size += align - (size % align);
                    }
                    size_t item_size = 0;

                    sizeof_error = type_get_sizeof(&t, &item_size, target);
                    if (sizeof_error != 0)
                        throw;

                    if (is_union)
                    {
                        if (item_size > size)
                            size = item_size;
                    }
                    else
                    {
                        //TODO overflow
                        size += item_size;
                    }
                    type_destroy(&t);
                }
                else
                {
                    sizeof_error = ESIZEOF_INCOMPLETE;
                    throw;
                }
            }
            d = d->next;
        }
        if (maxalign != 0)
        {
            if (size % maxalign != 0)
            {
                size += maxalign - (size % maxalign);
            }
        }
        else
        {
            sizeof_error = ESIZEOF_INCOMPLETE;
            throw;
        }
    }
    catch
    {
        return sizeof_error;
    }

    *sz = size;
    return sizeof_error;
}

size_t type_get_alignof(const struct type* p_type, enum target target);
size_t get_alignof_struct(struct struct_or_union_specifier* complete_struct_or_union_specifier, enum target target)
{
    size_t align = 0;
    struct member_declaration* _Opt d = complete_struct_or_union_specifier->member_declaration_list.head;
    while (d)
    {
        if (d->member_declarator_list_opt)
        {
            struct member_declarator* _Opt md = d->member_declarator_list_opt->head;
            while (md)
            {
                if (md->declarator)
                {
                    size_t temp_align = type_get_alignof(&md->declarator->type, target);
                    if (temp_align > align)
                    {
                        align = temp_align;
                    }
                }
                else
                {
                    assert(false);
                }
                md = md->next;
            }
        }
        else if (d->specifier_qualifier_list)
        {
            /*We don't have the declarator like in */
            /*
              struct X {
                union {
                    struct {
                        int Zone;
                    };
                    int Value;
                };
            };
            static_assert(alignof(struct X) == 1);
            */

            /*so we create a type using only specifiers*/

            struct type type = { 0 };

            type.type_specifier_flags = d->specifier_qualifier_list->type_specifier_flags;

            type.enum_specifier = d->specifier_qualifier_list->enum_specifier;
            type.struct_or_union_specifier = d->specifier_qualifier_list->struct_or_union_specifier;


            size_t temp_align = type_get_alignof(&type, target);
            if (temp_align > align)
            {
                align = temp_align;
            }

            type_destroy(&type);
        }
        else
        {
            /*static_assert*/
        }
        d = d->next;
    }
    assert(align != 0);
    return align;
}

size_t type_get_alignof(const struct type* p_type, enum target target)
{
    size_t align = 0;

    enum type_category category = type_get_category(p_type);

    if (category == TYPE_CATEGORY_POINTER)
    {
        align = get_align_void_ptr(target);
    }
    else if (category == TYPE_CATEGORY_FUNCTION)
    {
        align = -1;
        //seterror(error, "sizeof function");
    }
    else if (category == TYPE_CATEGORY_ITSELF)
    {
        if (p_type->alignment_specifier_flags & ALIGNMENT_SPECIFIER_8_FLAGS)
        {
            align = 8;
        }
        else if (p_type->alignment_specifier_flags & ALIGNMENT_SPECIFIER_16_FLAGS)
        {
            align = 16;
        }
        else if (p_type->alignment_specifier_flags & ALIGNMENT_SPECIFIER_32_FLAGS)
        {
            align = 32;
        }
        else if (p_type->alignment_specifier_flags & ALIGNMENT_SPECIFIER_64_FLAGS)
        {
            align = 64;
        }
        else if (p_type->alignment_specifier_flags & ALIGNMENT_SPECIFIER_128_FLAGS)
        {
            align = 128;
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_CHAR)
        {
            align = get_align_char(target);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_BOOL)
        {
            align = get_align_bool(target);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_SHORT)
        {
            align = get_align_short(target);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_ENUM)
        {
            if (p_type->enum_specifier)
            {
                enum type_specifier_flags enum_type_specifier_flags =
                    get_enum_type_specifier_flags(p_type->enum_specifier);

                struct type t = make_with_type_specifier_flags(enum_type_specifier_flags);
                align = type_get_alignof(&t, target);
                type_destroy(&t);
            }
            else
                align = get_align_int(target);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_LONG)
        {
            align = get_align_long(target);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_LONG_LONG)
        {
            align = get_align_long_long(target);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT) //must be after long
        {
            align = get_align_int(target);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT64)
        {
            align = 8;
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT32)
        {
            align = 4;
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT16)
        {
            align = 2;
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT8)
        {
            align = 1;
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_FLOAT)
        {
            align = get_align_float(target);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
        {
            align = get_align_double(target);
        }
        else if (p_type->type_specifier_flags & (TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_DOUBLE))
        {
            align = get_align_long_double(target);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_GCC__BUILTIN_VA_LIST)
        {
#if __GNUC__
            align = _Alignof(__builtin_va_list);
#else
            align = get_align_void_ptr(target); //?            
#endif
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION)
        {
            if (p_type->struct_or_union_specifier)
            {
                struct struct_or_union_specifier* _Opt p_complete =
                    get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

                align = 1;
                if (p_complete)
                {
                    align = get_alignof_struct(p_complete, target);
                }
                else
                {
                    align = -2;
                }
            }
            else
            {
                align = -2;
                assert(false);
            }
        }
        else if (p_type->type_specifier_flags == TYPE_SPECIFIER_NONE)
        {
            align = -3;
            //seterror(error, "type information is missing");
        }
        else if (p_type->type_specifier_flags == TYPE_SPECIFIER_VOID)
        {
            align = 1;
        }
        else
        {
            assert(false);
        }
    }
    else if (category == TYPE_CATEGORY_ARRAY)
    {

        struct type type = get_array_item_type(p_type);
        align = type_get_alignof(&type, target);
        type_destroy(&type);
    }
    assert(align > 0);
    return align;
}

enum sizeof_error type_get_offsetof(const struct type* p_type, const char* member, size_t* size, enum target target)
{
    *size = 0; //out

    const enum type_category category = type_get_category(p_type);

    if (category != TYPE_CATEGORY_ITSELF)
    {
        *size = sizeof(void*);
        return ESIZEOF_FUNCTION;
    }

    if (!(p_type->type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION))
    {
        return ESIZEOF_INCOMPLETE;
    }

    if (p_type->struct_or_union_specifier == NULL)
    {
        return ESIZEOF_INCOMPLETE;
    }

    struct struct_or_union_specifier* _Opt p_complete =
        get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

    if (p_complete == NULL)
        return ESIZEOF_INCOMPLETE;

    return get_offsetof_struct(p_complete, member, size, target);
}

enum sizeof_error type_get_sizeof(const struct type* p_type, size_t* size, enum target target)
{
    *size = 0; //out

    const enum type_category category = type_get_category(p_type);

    if (category == TYPE_CATEGORY_POINTER)
    {
        *size = get_size_void_ptr(target);
        return ESIZEOF_NONE;
    }

    if (category == TYPE_CATEGORY_FUNCTION)
    {
        return ESIZEOF_FUNCTION;
    }

    if (category == TYPE_CATEGORY_ARRAY)
    {
        if (p_type->storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
        {
            //void f(int a[2])
            *size = get_size_void_ptr(target);
            return ESIZEOF_NONE;
        }
        else
        {
            if (type_is_vla(p_type))
                return ESIZEOF_VLA;

            unsigned long long arraysize = p_type->num_of_elements;
            struct type type = get_array_item_type(p_type);


            size_t sz = 0;

            const enum sizeof_error er = type_get_sizeof(&type, &sz, target);
            if (er != ESIZEOF_NONE)
            {
                type_destroy(&type);
                return er;
            }
            type_destroy(&type);


            unsigned long long result = 0;
            if (unsigned_long_long_mul(&result, sz, arraysize))
            {
                //https://github.com/thradams/cake/issues/248
                unsigned long long SIZE_MAX_WORKAROUND = 0;

#ifdef __linux__
#if __x86_64__
                SIZE_MAX_WORKAROUND = 0xffffffffffffffffULL;
#else
                SIZE_MAX_WORKAROUND = 0xffffffffULL;
#endif                    
#else                
                SIZE_MAX_WORKAROUND = SIZE_MAX;
#endif

                if (result > SIZE_MAX_WORKAROUND)
                {
                    return ESIZEOF_OVERLOW;
                }

                //
                if (result > /*SIZEMAX*/ 4294967295)
                {
                    return ESIZEOF_OVERLOW;
                }
                *size = (size_t)result;
            }
            else
            {
                return ESIZEOF_OVERLOW;
            }
            return ESIZEOF_NONE;
        }
    }

    assert(category == TYPE_CATEGORY_ITSELF);


    if (p_type->type_specifier_flags & TYPE_SPECIFIER_CHAR)
    {
        *size = get_size_char(target);
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_BOOL)
    {
        *size = get_size_bool(target);
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_SHORT)
    {
        *size = get_size_short(target);
        return ESIZEOF_NONE;
    }

    else if (p_type->type_specifier_flags & TYPE_SPECIFIER_GCC__BUILTIN_VA_LIST)
    {
#if __GNUC__
        * size = sizeof(__builtin_va_list);
#else
        * size = get_size_void_ptr(target); //?            
#endif
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_LONG)
    {
        *size = get_size_long(target);
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_LONG_LONG)
    {
        *size = get_size_long_long(target);
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT) //must be after long
    {
        //typedef long unsigned int uint64_t;
        *size = get_size_int(target);
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT64)
    {
        *size = get_size_long_long(target);
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT32)
    {
        *size = 4;
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT16)
    {
        *size = 2;
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT8)
    {
        *size = 1;
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_FLOAT)
    {
        *size = get_size_float(target);
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
    {
        *size = get_size_double(target);
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & (TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_DOUBLE))
    {
        *size = get_size_long_double(target);
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION)
    {
        if (p_type->struct_or_union_specifier == NULL)
        {
            return ESIZEOF_INCOMPLETE;
        }

        struct struct_or_union_specifier* _Opt p_complete =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        if (p_complete == NULL)
            return ESIZEOF_INCOMPLETE;

        return get_sizeof_struct(p_complete, size, target);
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_ENUM)
    {
        if (p_type->enum_specifier)
        {
            enum type_specifier_flags enum_type_specifier_flags =
                get_enum_type_specifier_flags(p_type->enum_specifier);

            struct type t = make_with_type_specifier_flags(enum_type_specifier_flags);
            enum sizeof_error e = type_get_sizeof(&t, size, target);
            type_destroy(&t);
            return e;
        }
        else
        {
            *size = get_size_int(target);
        }
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags == TYPE_SPECIFIER_NONE)
    {
        *size = 0;
        return ESIZEOF_INCOMPLETE;
    }

    if (p_type->type_specifier_flags == TYPE_SPECIFIER_VOID)
    {
        *size = 1;
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags == TYPE_SPECIFIER_NULLPTR_T)
    {
        *size = get_size_void_ptr(target);
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags == TYPE_SPECIFIER_DECIMAL32)
    {
        *size = 4;
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags == TYPE_SPECIFIER_DECIMAL64)
    {
        *size = 8;
        return ESIZEOF_NONE;
    }

    if (p_type->type_specifier_flags == TYPE_SPECIFIER_DECIMAL128)
    {
        *size = 16;
        return ESIZEOF_NONE;
    }


    return ESIZEOF_INCOMPLETE;
}

void type_set_attributes(struct type* p_type, struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->attributes_flags =
            pdeclarator->declaration_specifiers->attributes_flags;
    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        //p_type->type_qualifier_flags =
          //  pdeclarator->specifier_qualifier_list->ATR;
    }
}

struct type make_type_using_declarator(struct parser_ctx* ctx, struct declarator* pdeclarator);

bool function_returns_void(const struct type* p_type)
{
    struct type t = get_function_return_type(p_type);
    bool r = type_is_void(&t);
    type_destroy(&t);
    return r;
}

struct type get_function_return_type(const struct type* p_type)
{
    try
    {
        if (p_type->next == NULL)
            throw;

        if (type_is_pointer(p_type))
        {
            if (p_type->next->next == NULL)
            {
                throw;
            }

            /*pointer to function returning ... */
            struct type r = type_dup(p_type->next->next);
            return r;
        }

        /*function returning ... */
        struct type r = type_dup(p_type->next);
        return r;
    }
    catch
    {
    }
    struct type empty = { 0 };
    return empty;
}


void type_set_int(struct type* p_type)
{
    p_type->type_specifier_flags = TYPE_SPECIFIER_INT;
    p_type->type_qualifier_flags = 0;
    p_type->category = TYPE_CATEGORY_ITSELF;
}

struct type type_make_enumerator(const struct enum_specifier* enum_specifier)
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_ENUM;
    t.enum_specifier = enum_specifier;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type type_get_enum_type(const struct type* p_type)
{
    try
    {
        if (p_type->enum_specifier == NULL)
            throw;

        const struct enum_specifier* _Opt p_complete_enum_specifier =
            get_complete_enum_specifier(p_type->enum_specifier);

        if (p_complete_enum_specifier &&
            p_complete_enum_specifier->specifier_qualifier_list)
        {
            struct type t = { 0 };
            t.type_qualifier_flags = p_complete_enum_specifier->specifier_qualifier_list->type_qualifier_flags;
            t.type_specifier_flags = p_complete_enum_specifier->specifier_qualifier_list->type_specifier_flags;
            return t;
        }

        struct type t = { 0 };
        t.type_specifier_flags = TYPE_SPECIFIER_INT;
        return t;
    }
    catch
    {
    }
    struct type empty = { 0 };
    return empty;
}

struct type type_make_long_double()
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_DOUBLE;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type type_make_double()
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_DOUBLE;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type type_make_float()
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_FLOAT;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}


struct type type_make_size_t(enum target target)
{
    struct type t = { 0 };

    switch (target)
    {
    case TARGET_DEFAULT:
#ifdef _WIN64
        t.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT64;
#else
        t.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT;
#endif
        break;
    case TARGET_X86_X64_GCC:
        t.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT64;
        break;
    case TARGET_X86_MSVC:
        t.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT;
        break;
    case TARGET_X64_MSVC:
        t.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT64;
        break;
    }

    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type make_void_ptr_type()
{
    struct type t = { 0 };
    try
    {
        struct type* _Owner _Opt p = calloc(1, sizeof * p);
        if (p == NULL) throw;

        t.category = TYPE_CATEGORY_POINTER;
        p->category = TYPE_CATEGORY_ITSELF;
        p->type_specifier_flags = TYPE_SPECIFIER_VOID;
        t.next = p;
    }
    catch
    {

    }
    return t;
}

struct type make_void_type()
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_VOID;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type type_make_int_bool_like()
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_INT;
    t.attributes_flags = CAKE_HIDDEN_ATTRIBUTE_LIKE_BOOL;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type make_with_type_specifier_flags(enum type_specifier_flags f)
{
    struct type t = { 0 };
    t.type_specifier_flags = f;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type make_size_t_type(enum target target)
{
    struct type t = { 0 };
    t.type_specifier_flags = get_size_t_specifier(target);

    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type type_make_int()
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_INT;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type type_make_literal_string(int size_in_bytes,
    enum type_specifier_flags chartype,
    enum type_qualifier_flags qualifiers,
    enum target target)
{
    struct type t = { 0 };

    try
    {
        struct type* _Owner _Opt p2 = calloc(1, sizeof(struct type));
        if (p2 == NULL) throw;

        struct type char_type = { 0 };
        char_type.category = TYPE_CATEGORY_ITSELF;
        char_type.type_specifier_flags = chartype;

        size_t char_size = 0;

        if (type_get_sizeof(&char_type, &char_size, target) != 0)
        {
            type_delete(p2);
            throw;
        }

        if (char_size == 0)
        {
            char_size = 1;
        }
        type_destroy(&char_type);


        t.category = TYPE_CATEGORY_ARRAY;
        t.num_of_elements = size_in_bytes / char_size;

        p2->category = TYPE_CATEGORY_ITSELF;
        p2->type_specifier_flags = chartype;
        p2->type_qualifier_flags = qualifiers;
        t.next = p2;
    }
    catch
    {
    }

    return t;
}

bool struct_or_union_specifier_is_same(struct struct_or_union_specifier* _Opt a, struct struct_or_union_specifier* _Opt b)
{
    if (a && b)
    {
        struct struct_or_union_specifier* _Opt p_complete_a = get_complete_struct_or_union_specifier(a);
        struct struct_or_union_specifier* _Opt p_complete_b = get_complete_struct_or_union_specifier(b);

        if (p_complete_a != NULL && p_complete_b != NULL)
        {
            if (p_complete_a != p_complete_b)
            {
                return false;
            }
            return true;
        }
        else
        {
            /*both incomplete then we compare tag names*/
            if (a->tagtoken != NULL && b->tagtoken != NULL)
            {
                if (strcmp(a->tagtoken->lexeme, b->tagtoken->lexeme) == 0)
                    return true;
            }
        }
        return p_complete_a == NULL && p_complete_b == NULL;
    }
    return a == NULL && b == NULL;
}

bool enum_specifier_is_same(struct enum_specifier* _Opt a, struct enum_specifier* _Opt b)
{
    if (a && b)
    {
        if (get_complete_enum_specifier(a) && get_complete_enum_specifier(b))
        {
            if (get_complete_enum_specifier(a) != get_complete_enum_specifier(b))
            {
                return false;
            }
            return true;
        }
        return get_complete_enum_specifier(a) == NULL &&
            get_complete_enum_specifier(b) == NULL;
    }
    return a == NULL && b == NULL;
}


static bool type_is_same_core(const struct type* a,
                              const struct type* b,
                              bool compare_qualifiers)
{
    const struct type* _Opt pa = a;
    const struct type* _Opt pb = b;

    while (pa && pb)
    {
        if (pa->num_of_elements != pb->num_of_elements)
            return false;

        if (pa->category != pb->category)
            return false;

        if (pa->enum_specifier &&
            pb->enum_specifier &&
            get_complete_enum_specifier(pa->enum_specifier) !=
            get_complete_enum_specifier(pb->enum_specifier))
        {
            return false;
        }


        if (pa->enum_specifier && !pb->enum_specifier)
        {
            //TODO enum with types
            //enum  x int
           //return false;
        }

        if (!pa->enum_specifier && pb->enum_specifier)
        {
            //TODO enum with types
            //int x enum
            //return false;
        }

        //if (pa->name_opt != pb->name_opt) return false;
        if (pa->has_static_array_size != pb->has_static_array_size)
            return false;

        if (pa->category == TYPE_CATEGORY_FUNCTION)
        {

            if (pa->params.is_var_args != pb->params.is_var_args)
            {
                return false;
            }

            if (pa->params.is_void != pb->params.is_void)
            {
                return false;
            }

            struct param* _Opt p_param_a = pa->params.head;
            struct param* _Opt p_param_b = pb->params.head;
            while (p_param_a && p_param_b)
            {
                if (!type_is_same(&p_param_a->type, &p_param_b->type, compare_qualifiers))
                {
                    return false;
                }
                p_param_a = p_param_a->next;
                p_param_b = p_param_b->next;
            }
            return p_param_a == NULL && p_param_b == NULL;
        }

        if (pa->struct_or_union_specifier &&
            pb->struct_or_union_specifier)
        {

            if (pa->struct_or_union_specifier->complete_struct_or_union_specifier_indirection !=
                pb->struct_or_union_specifier->complete_struct_or_union_specifier_indirection)
            {
                //this should work but it is not...
            }

            if (strcmp(pa->struct_or_union_specifier->tag_name, pb->struct_or_union_specifier->tag_name) != 0)
            {
                return false;
            }
        }

        if (compare_qualifiers)
        {
            enum type_qualifier_flags aq = pa->type_qualifier_flags;
            enum type_qualifier_flags bq = pb->type_qualifier_flags;

            unsigned int all = (TYPE_QUALIFIER_OWNER | TYPE_QUALIFIER_VIEW |
             TYPE_QUALIFIER_OPT | TYPE_QUALIFIER_DTOR | TYPE_QUALIFIER_CTOR);

            aq = aq & ~all;
            bq = bq & ~all;

            if (aq != bq)
                return false;
        }


        enum type_specifier_flags a_flags = pa->type_specifier_flags;
        enum type_specifier_flags b_flags = pb->type_specifier_flags;

        if ((a_flags & TYPE_SPECIFIER_CHAR) == 0)
        {
            a_flags &= ~TYPE_SPECIFIER_SIGNED;
        }

        if ((b_flags & TYPE_SPECIFIER_CHAR) == 0)
        {
            b_flags &= ~TYPE_SPECIFIER_SIGNED;
        }

        if (a_flags != b_flags)
        {
            return false;
        }


        pa = pa->next;
        pb = pb->next;
    }
    return pa == NULL && pb == NULL;
}

bool type_is_same(const struct type* a, const struct type* b, bool compare_qualifiers)
{
    return type_is_same_core(a, b, compare_qualifiers);
}

bool type_is_compatible(const struct type* a, const struct type* b)
{
    return type_is_same_core(a, b, false);
}

void type_clear(struct type* a)
{
    struct type tmp = { 0 };
    type_swap(&tmp, a);
    type_destroy(&tmp);
}

void type_swap(_View struct type* a, _View struct type* b)
{
    _View struct type temp = *a;
    *a = *b;
    *b = temp;
}


void type_visit_to_mark_anonymous(struct type* p_type)
{
    //TODO better visit?
    if (p_type->struct_or_union_specifier != NULL &&
        p_type->struct_or_union_specifier->has_anonymous_tag)
    {
        if (p_type->struct_or_union_specifier->complete_struct_or_union_specifier_indirection)
        {
            p_type->struct_or_union_specifier->complete_struct_or_union_specifier_indirection->show_anonymous_tag = true;
        }
        p_type->struct_or_union_specifier->show_anonymous_tag = true;
    }

}


void type_merge_qualifiers_using_declarator(struct type* p_type, struct declarator* pdeclarator)
{

    enum type_qualifier_flags type_qualifier_flags = 0;


    if (pdeclarator->declaration_specifiers)
    {
        type_qualifier_flags = pdeclarator->declaration_specifiers->type_qualifier_flags;


    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        type_qualifier_flags = pdeclarator->specifier_qualifier_list->type_qualifier_flags;


    }

    p_type->type_qualifier_flags |= type_qualifier_flags;





}


void type_set_qualifiers_using_declarator(struct type* p_type, struct declarator* pdeclarator)
{

    enum type_qualifier_flags type_qualifier_flags = 0;
    if (pdeclarator->declaration_specifiers)
    {
        type_qualifier_flags = pdeclarator->declaration_specifiers->type_qualifier_flags;

    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        type_qualifier_flags = pdeclarator->specifier_qualifier_list->type_qualifier_flags;

    }

    p_type->type_qualifier_flags = type_qualifier_flags;


}
void type_set_alignment_specifier_flags_using_declarator(struct type* p_type, struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->alignment_specifier_flags |=
            pdeclarator->declaration_specifiers->alignment_specifier_flags;
    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        p_type->alignment_specifier_flags =
            pdeclarator->specifier_qualifier_list->alignment_specifier_flags;
    }
}

void type_set_msvc_declspec_using_declarator(struct type* p_type, struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->msvc_declspec_flags |=
            pdeclarator->declaration_specifiers->msvc_declspec_flags;
    }
}

void type_set_storage_specifiers_using_declarator(struct type* p_type, struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->storage_class_specifier_flags |=
            pdeclarator->declaration_specifiers->storage_class_specifier_flags;
    }
    else
    {
        //struct member
        //assert(false);
        /*
           where we don't have specifiers?
        */
        //p_type->storage_class_specifier_flags |= STORAGE_SPECIFIER_AUTO;
    }
}


void type_set_specifiers_using_declarator(struct type* p_type, struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->type_specifier_flags =
            pdeclarator->declaration_specifiers->type_specifier_flags;

        p_type->enum_specifier = pdeclarator->declaration_specifiers->enum_specifier;
        p_type->struct_or_union_specifier = pdeclarator->declaration_specifiers->struct_or_union_specifier;

    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        p_type->type_specifier_flags =
            pdeclarator->specifier_qualifier_list->type_specifier_flags;
        p_type->enum_specifier = pdeclarator->specifier_qualifier_list->enum_specifier;
        p_type->struct_or_union_specifier = pdeclarator->specifier_qualifier_list->struct_or_union_specifier;

    }


}

void type_set_attributes_using_declarator(struct type* p_type, struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        if (pdeclarator->declaration_specifiers->attributes_flags & STD_ATTRIBUTE_NODISCARD)
        {
            p_type->storage_class_specifier_flags |= STORAGE_SPECIFIER_FUNCTION_RETURN_NODISCARD;
        }
        p_type->attributes_flags =
            pdeclarator->declaration_specifiers->attributes_flags;
    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        //p_type->attributes_flags =
          //  pdeclarator->specifier_qualifier_list->attributes_flags;
    }
}


void type_list_push_front(struct type_list* books, struct type* _Owner new_book)
{
    assert(new_book->next == NULL);

    if (books->head == NULL)
    {
        books->head = new_book;
        books->tail = new_book;
    }
    else
    {
        new_book->next = books->head;
        books->head = new_book;
    }
}

void type_list_destroy(_Dtor struct type_list* p_type_list)
{
    struct type* _Owner _Opt item = p_type_list->head;
    while (item)
    {
        struct type* _Owner _Opt next = item->next;
        item->next = NULL;
        type_destroy_one(item);
        free(item);
        item = next;
    }
}

void type_list_push_back(struct type_list* type_list, struct type* _Owner new_book)
{
    if (type_list->tail == NULL)
    {
        assert(type_list->head == NULL);
        type_list->head = new_book;
    }
    else
    {
        assert(type_list->tail->next == NULL);
        type_list->tail->next = new_book;
    }

    type_list->tail = new_book;
}

void make_type_using_declarator_core(struct parser_ctx* ctx, struct declarator* pdeclarator, char** ppname, struct type_list* list);

void  make_type_using_direct_declarator(struct parser_ctx* ctx,
    struct direct_declarator* pdirectdeclarator,
    char** ppname,
    struct type_list* list)
{
    try
    {
        if (pdirectdeclarator->declarator)
        {
            make_type_using_declarator_core(ctx, pdirectdeclarator->declarator, ppname, list);
        }

        else if (pdirectdeclarator->function_declarator)
        {
            if (pdirectdeclarator->function_declarator->direct_declarator)
            {
                make_type_using_direct_declarator(ctx,
                    pdirectdeclarator->function_declarator->direct_declarator,
                    ppname,
                    list);
            }

            struct type* _Owner _Opt p_func = calloc(1, sizeof(struct type));
            if (p_func == NULL) throw;

            p_func->category = TYPE_CATEGORY_FUNCTION;

            assert(pdirectdeclarator->function_declarator->direct_declarator != NULL);
            if (pdirectdeclarator->function_declarator->direct_declarator->p_calling_convention)
            {
                const char* calling_convention_lexeme =
                    pdirectdeclarator->function_declarator->direct_declarator->p_calling_convention->lexeme;

                if (strcmp(calling_convention_lexeme, "__fastcall") == 0)
                    p_func->attributes_flags |= CAKE_ATTRIBUTE_FASTCALL;
                else if (strcmp(calling_convention_lexeme, "__stdcall") == 0)
                    p_func->attributes_flags |= CAKE_ATTRIBUTE_STDCALL;
                else if (strcmp(calling_convention_lexeme, "__cdecl") == 0)
                    p_func->attributes_flags |= CAKE_ATTRIBUTE_CDECL;
                else
                {
                    type_delete(p_func);
                    throw;
                }
            }

            if (pdirectdeclarator->function_declarator->parameter_type_list_opt)
            {
                p_func->params.is_var_args = pdirectdeclarator->function_declarator->parameter_type_list_opt->is_var_args;
                p_func->params.is_void = pdirectdeclarator->function_declarator->parameter_type_list_opt->is_void;
            }

            if (pdirectdeclarator->function_declarator->parameter_type_list_opt &&
                pdirectdeclarator->function_declarator->parameter_type_list_opt->parameter_list)
            {

                struct parameter_declaration* _Opt p =
                    pdirectdeclarator->function_declarator->parameter_type_list_opt->parameter_list->head;

                while (p)
                {
                    if (p->declarator == NULL)
                    {
                        type_delete(p_func);
                        throw;
                    }

                    struct param* _Owner _Opt p_new_param = calloc(1, sizeof(struct param));
                    if (p_new_param == NULL)
                    {
                        type_delete(p_func);
                        throw;
                    }

                    p_new_param->type = type_dup(&p->declarator->type);
                    param_list_add(&p_func->params, p_new_param);
                    p = p->next;
                }
            }


            type_list_push_back(list, p_func);
        }
        else if (pdirectdeclarator->array_declarator)
        {

            if (pdirectdeclarator->array_declarator->direct_declarator)
            {
                make_type_using_direct_declarator(ctx,
                    pdirectdeclarator->array_declarator->direct_declarator,
                    ppname,
                    list);
            }

            struct type* _Owner _Opt  p = calloc(1, sizeof(struct type));
            if (p == NULL) throw;

            p->category = TYPE_CATEGORY_ARRAY;

            p->num_of_elements =
                array_declarator_get_size(pdirectdeclarator->array_declarator);

            p->array_num_elements_expression = pdirectdeclarator->array_declarator->assignment_expression;

            if (pdirectdeclarator->array_declarator->static_token_opt)
            {
                p->has_static_array_size = true;
            }

            if (pdirectdeclarator->array_declarator->type_qualifier_list_opt)
            {
                p->type_qualifier_flags = pdirectdeclarator->array_declarator->type_qualifier_list_opt->flags;
            }

            type_list_push_back(list, p);

            // if (pdirectdeclarator->name_opt)
             //{
               //  p->name_opt = strdup(pdirectdeclarator->name_opt->lexeme);
             //}
        }

        if (pdirectdeclarator->name_opt)
        {
            *ppname = pdirectdeclarator->name_opt->lexeme;
        }

    }
    catch
    {
        //tODO
    }
}

void make_type_using_declarator_core(struct parser_ctx* ctx, struct declarator* pdeclarator,
    char** ppname, struct type_list* list)
{
    try
    {
        struct type_list pointers = { 0 };
        struct pointer* _Opt pointer = pdeclarator->pointer;
        while (pointer)
        {
            struct type* _Owner _Opt p_flat = calloc(1, sizeof(struct type));
            if (p_flat == NULL)
            {
                type_list_destroy(&pointers);
                throw;
            }

            if (pointer->type_qualifier_list_opt)
            {
                p_flat->type_qualifier_flags = pointer->type_qualifier_list_opt->flags;
            }

            if (pointer->attribute_specifier_sequence_opt)
            {
                p_flat->attributes_flags |= pointer->attribute_specifier_sequence_opt->attributes_flags;
            }
            p_flat->category = TYPE_CATEGORY_POINTER;

            if (pointer->calling_convention)
            {
                const char* calling_convention_lexeme =
                    pointer->calling_convention->lexeme;
                if (strcmp(calling_convention_lexeme, "__fastcall") == 0)
                    p_flat->attributes_flags |= CAKE_ATTRIBUTE_FASTCALL;
                else if (strcmp(calling_convention_lexeme, "__stdcall") == 0)
                    p_flat->attributes_flags |= CAKE_ATTRIBUTE_STDCALL;
                else if (strcmp(calling_convention_lexeme, "__cdecl") == 0)
                    p_flat->attributes_flags |= CAKE_ATTRIBUTE_CDECL;
                else
                {
                    type_list_destroy(&pointers);
                    type_delete(p_flat);
                    throw;
                }
            }

            type_list_push_front(&pointers, p_flat); /*inverted*/
            pointer = pointer->pointer;
        }

        if (pdeclarator->direct_declarator)
        {
            make_type_using_direct_declarator(ctx, pdeclarator->direct_declarator, ppname, list);
            if (list->head &&
                list->head->category == TYPE_CATEGORY_FUNCTION)
            {
                if (pointers.head)
                {
                    pointers.head->storage_class_specifier_flags |= STORAGE_SPECIFIER_FUNCTION_RETURN;
                }
            }
        }

        while (pointers.head)
        {
            struct type* _Owner p = pointers.head;
            pointers.head = p->next;
            p->next = NULL;
            type_list_push_back(list, p);
        }
    }
    catch
    {
    }
}

struct enum_specifier* _Opt declarator_get_enum_specifier(struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers &&
        pdeclarator->declaration_specifiers->enum_specifier)
    {
        return pdeclarator->declaration_specifiers->enum_specifier;
    }
    if (pdeclarator->specifier_qualifier_list &&
        pdeclarator->specifier_qualifier_list->enum_specifier)
    {
        return pdeclarator->specifier_qualifier_list->enum_specifier;
    }
    return NULL;
}


struct struct_or_union_specifier* _Opt declarator_get_struct_or_union_specifier(struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers &&
        pdeclarator->declaration_specifiers->struct_or_union_specifier)
    {
        return pdeclarator->declaration_specifiers->struct_or_union_specifier;
    }
    if (pdeclarator->specifier_qualifier_list &&
        pdeclarator->specifier_qualifier_list->struct_or_union_specifier)
    {
        return pdeclarator->specifier_qualifier_list->struct_or_union_specifier;
    }
    return NULL;
}

struct typeof_specifier* _Opt declarator_get_typeof_specifier(struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        return pdeclarator->declaration_specifiers->typeof_specifier;
    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        return pdeclarator->specifier_qualifier_list->typeof_specifier;
    }
    return NULL;
}

struct declarator* _Opt declarator_get_typedef_declarator(struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        return pdeclarator->declaration_specifiers->typedef_declarator;
    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        return pdeclarator->specifier_qualifier_list->typedef_declarator;
    }

    return NULL;
}

static bool is_valid_type(struct parser_ctx* ctx, struct token* _Opt p_token, const struct type* p_type)
{
    if (p_token == NULL)
        p_token = ctx->current;

    const struct type* _Opt p = p_type;
    while (p)
    {
        if (p->category == TYPE_CATEGORY_FUNCTION)
        {
            if (p->next && p->next->category == TYPE_CATEGORY_FUNCTION)
            {
                compiler_diagnostic(C_ERROR_FUNCTION_RETURNS_FUNCTION,
                                            ctx,
                                            p_token,
                                            NULL,
                                            "function returning function");
                return false;
            }
            else if (p->next && p->next->category == TYPE_CATEGORY_ARRAY)
            {
                compiler_diagnostic(C_ERROR_FUNCTION_RETURNS_ARRAY,
                                            ctx,
                                            p_token,
                                            NULL,
                                            "function returning array");
                return false;
            }
        }
        else if (p->category == TYPE_CATEGORY_ITSELF &&
                 p->type_specifier_flags == TYPE_SPECIFIER_NONE)
        {
            compiler_diagnostic(C_ERROR_INVALID_TYPE,
                                        ctx,
                                        p_token,
                                        NULL,
                                        "invalid type");
            return false;
        }

        p = p->next;
    }

    return true;
}

struct type make_type_using_declarator(struct parser_ctx* ctx, struct declarator* pdeclarator)
{

    try
    {
        struct type_list list = { 0 };

        char* _Opt name = NULL;
        make_type_using_declarator_core(ctx, pdeclarator, &name, &list);


        if (declarator_get_typeof_specifier(pdeclarator))
        {
            struct type* _Owner _Opt p_nt = calloc(1, sizeof(struct type));
            if (p_nt == NULL)
            {
                type_list_destroy(&list);
                throw;
            }

            struct type nt =
                type_dup(&declarator_get_typeof_specifier(pdeclarator)->type);

            *p_nt = nt;


            if (list.head != NULL)
                type_set_qualifiers_using_declarator(list.head, pdeclarator);

            if (list.tail)
            {
                assert(list.tail->next == NULL);
                list.tail->next = p_nt;
            }
            else
            {
                type_list_push_back(&list, p_nt);
            }
        }
        else if (declarator_get_typedef_declarator(pdeclarator))
        {
            struct declarator* _Opt p_typedef_declarator =
                declarator_get_typedef_declarator(pdeclarator);

            if (p_typedef_declarator == NULL)
            {
                type_list_destroy(&list);
                throw;
            }

            struct type nt =
                type_dup(&p_typedef_declarator->type);

            struct type* _Owner _Opt p_nt = calloc(1, sizeof(struct type));
            if (p_nt == NULL)
            {
                type_list_destroy(&list);
                type_destroy(&nt);
                throw;
            }

            *p_nt = nt;


            /*
              maybe typedef already has const qualifier
              so we cannot override
            */
            type_merge_qualifiers_using_declarator(p_nt, pdeclarator);

            if (list.tail)
            {
                assert(list.tail->next == 0);
                list.tail->next = p_nt;
            }
            else
            {
                type_list_push_back(&list, p_nt);
            }
        }
        else
        {
            struct type* _Owner _Opt p = calloc(1, sizeof(struct type));
            if (p == NULL)
            {
                type_list_destroy(&list);
                throw;
            }

            p->category = TYPE_CATEGORY_ITSELF;


            type_set_specifiers_using_declarator(p, pdeclarator);
            type_set_attributes_using_declarator(p, pdeclarator);
            type_set_alignment_specifier_flags_using_declarator(p, pdeclarator);

            type_set_qualifiers_using_declarator(p, pdeclarator);

            if (list.tail &&
                list.tail->category == TYPE_CATEGORY_FUNCTION)
            {
                p->storage_class_specifier_flags |= STORAGE_SPECIFIER_FUNCTION_RETURN;
            }

            type_list_push_back(&list, p);

            if (list.head)
                type_set_storage_specifiers_using_declarator(list.head, pdeclarator);
        }


        if (list.head == NULL) throw;

        if (pdeclarator->name_opt)
        {
            char* _Owner _Opt temp = strdup(pdeclarator->name_opt->lexeme);
            if (temp == NULL)
            {
                type_list_destroy(&list);
                throw;
            }

            free((void* _Owner) list.head->name_opt);
            list.head->name_opt = temp;
        }

        struct type r = *list.head;
        /*
          we moved the contents of head
          but we also need to delete the memory
        */
        free(list.head);

        type_set_storage_specifiers_using_declarator(&r, pdeclarator);
        type_set_msvc_declspec_using_declarator(&r, pdeclarator);
        type_set_alignment_specifier_flags_using_declarator(&r, pdeclarator);
        if (!is_valid_type(ctx, pdeclarator->first_token_opt, &r))
        {
            type_destroy(&r);
            struct type empty = { 0 };
            return empty;
        }
        return r;
    }
    catch
    {

    }

    struct type empty = { 0 };
    return empty;
}

void type_remove_names(struct type* p_type)
{
    /*
      function parameters names are preserved
    */
    struct type* _Opt p = p_type;

    while (p)
    {
        if (p->name_opt)
        {
            free((void* _Owner _Opt)p->name_opt);
            p->name_opt = NULL;
        }
        p = p->next;
    }
}

const struct type* type_get_specifer_part(const struct type* p_type)
{
    /*
     last part is the specifier
    */
    const struct type* _Opt p = p_type;
    while (p->next) p = p->next;
    return p;
}



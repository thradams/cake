/* Cake x86_msvc */
struct token {
    int type;
    char * lexeme;
    char * original;
    int line;
    int col;
    int level;
    int flags;
    struct token * token_origin;
    struct token * next;
    struct token * prev;
};

struct token_list {
    struct token * head;
    struct token * tail;
};

struct macro_parameter;

struct macro_argument {
    struct macro_parameter * macro_parameter;
    struct token_list  tokens;
    struct macro_argument * next;
};

struct macro {
    struct token * p_name_token;
    char * name;
    struct token_list  replacement_list;
    struct macro_parameter * parameters;
    unsigned char  is_function;
    int usage;
    unsigned char  def_macro;
};

struct HINSTANCE__ {
    int unused;
};

struct macro_expanded {
    char * name;
    struct macro_expanded * p_previous;
};

struct osstream {
    char * c_str;
    int size;
    int capacity;
};

struct flow_object;

struct flow_objects {
    struct flow_object ** data;
    int size;
    int capacity;
};

struct attribute_specifier_sequence;
struct declaration_specifiers;
struct declarator;

struct parameter_declaration {
    struct attribute_specifier_sequence * attribute_specifier_sequence_opt;
    struct declaration_specifiers * declaration_specifiers;
    struct declarator * declarator;
    struct parameter_declaration * next;
};

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
};

struct selection_statement;
struct iteration_statement;

struct break_reference {
    struct selection_statement * p_selection_statement;
    struct iteration_statement * p_iteration_statement;
};

struct expression;

struct designator {
    struct expression * constant_expression_opt;
    struct token * token;
    struct designator * next;
};

struct param;

struct param_list {
    unsigned char  is_var_args;
    unsigned char  is_void;
    struct param * head;
    struct param * tail;
};

struct struct_or_union_specifier;
struct enum_specifier;

struct type {
    int category;
    int attributes_flags;
    int msvc_declspec_flags;
    int alignment_specifier_flags;
    int type_specifier_flags;
    int type_qualifier_flags;
    int storage_class_specifier_flags;
    char * name_opt;
    struct struct_or_union_specifier * struct_or_union_specifier;
    struct enum_specifier * enum_specifier;
    struct expression * array_num_elements_expression;
    unsigned int num_of_elements;
    unsigned char  has_static_array_size;
    unsigned char  address_of;
    struct param_list  params;
    struct type * next;
};

struct type_name;

struct generic_association {
    struct type  type;
    struct type_name * p_type_name;
    struct expression * expression;
    struct token * first_token;
    struct token * last_token;
    struct generic_association * next;
};

struct pre_expression_ctx {
    long long value;
};

struct pragma_declaration {
    struct token * first_token;
    struct token * last_token;
};

struct atomic_type_specifier {
    struct token * token;
    struct type_name * type_name;
};

struct expression_statement;
struct simple_declaration;

struct init_statement {
    struct expression_statement * p_expression_statement;
    struct simple_declaration * p_simple_declaration;
};

struct secondary_block;

struct defer_statement {
    struct token * first_token;
    struct token * last_token;
    struct secondary_block * secondary_block;
};

struct storage_class_specifier {
    int flags;
    struct token * token;
};

struct block_item;

struct block_item_list {
    struct block_item * head;
    struct block_item * tail;
};

struct bitset {
    unsigned long bits[4];
};

struct diagnostic {
    struct bitset  errors;
    struct bitset  warnings;
    struct bitset  notes;
};

struct defer_list_item;

struct defer_list {
    struct defer_list_item * head;
    struct defer_list_item * tail;
};

struct compound_statement {
    struct token * first_token;
    struct token * last_token;
    struct block_item_list  block_item_list;
    struct diagnostic  diagnostic_flags;
    struct defer_list  defer_list;
};

struct label_list_item;

struct label_list {
    struct label_list_item * head;
    struct label_list_item * tail;
};

struct enumerator;
struct init_declarator;
struct struct_entry;

union __tag5 {
    unsigned int number;
    struct enum_specifier * p_enum_specifier;
    struct enumerator * p_enumerator;
    struct struct_or_union_specifier * p_struct_or_union_specifier;
    struct declarator * p_declarator;
    struct init_declarator * p_init_declarator;
    struct macro * p_macro;
    struct struct_entry * p_struct_entry;
};

struct stream {
    char * source;
    char * current;
    int line;
    int col;
    int line_continuation_count;
    char * path;
};

struct type_qualifier;

struct type_qualifier_list {
    int flags;
    struct type_qualifier * head;
    struct type_qualifier * tail;
};

struct try_statement;
struct statement;
struct primary_block;

struct defer_defer_scope {
    struct declarator * declarator;
    struct defer_statement * defer_statement;
    struct try_statement * p_try_statement;
    struct selection_statement * p_selection_statement;
    struct iteration_statement * p_iteration_statement;
    struct statement * p_statement;
    struct compound_statement * p_compound_statement;
    struct compound_statement * p_function_body;
    struct secondary_block * p_secondary_block;
    struct primary_block * p_primary_block;
    struct defer_defer_scope * last_child;
    struct defer_defer_scope * previous;
};

struct designator_list;

struct designation {
    struct designator_list * designator_list;
    struct token * token;
};

struct platform {
    char * name;
    char * thread_local_attr;
    char * alignas_fmt_must_have_one_percent_d;
    int bool_n_bits;
    int bool_alignment;
    int bool_type;
    int char_n_bits;
    int char_t_type;
    int char_alignment;
    int short_n_bits;
    int short_alignment;
    int int_n_bits;
    int int_alignment;
    int long_n_bits;
    int long_alignment;
    int long_long_n_bits;
    int long_long_alignment;
    int float_n_bits;
    int float_alignment;
    int double_n_bits;
    int double_alignment;
    int long_double_n_bits;
    int long_double_alignment;
    int pointer_n_bits;
    int pointer_alignment;
    int wchar_t_type;
    int int8_type;
    int int16_type;
    int int32_type;
    int int64_type;
    int size_t_type;
    int ptrdiff_type;
};

struct map_entry;

struct hash_map {
    struct map_entry ** table;
    int capacity;
    int size;
};

struct generic_assoc_list {
    struct generic_association * head;
    struct generic_association * tail;
};

struct generic_selection {
    struct expression * expression;
    struct type_name * type_name;
    struct expression * p_view_selected_expression;
    struct generic_assoc_list  generic_assoc_list;
    struct token * first_token;
    struct token * last_token;
};

struct declaration;
struct unlabeled_statement;
struct label;

struct block_item {
    struct token * first_token;
    struct declaration * declaration;
    struct unlabeled_statement * unlabeled_statement;
    struct label * label;
    struct block_item * next;
};

struct _FILETIME {
    unsigned long dwLowDateTime;
    unsigned long dwHighDateTime;
};

struct asm_statement;

struct primary_block {
    struct compound_statement * compound_statement;
    struct selection_statement * selection_statement;
    struct iteration_statement * iteration_statement;
    struct defer_statement * defer_statement;
    struct try_statement * try_statement;
    struct asm_statement * asm_statement;
};

struct flow_objects_view {
    struct flow_object ** data;
    int size;
    int capacity;
};

struct flow_object_state {
    char * dbg_name;
    int state_number;
    struct flow_object * pointed;
    int state;
    struct flow_objects_view  alternatives;
    struct flow_object_state * next;
};

struct specifier_qualifier_list;

struct type_name {
    struct token * first_token;
    struct token * last_token;
    struct specifier_qualifier_list * specifier_qualifier_list;
    struct declarator * abstract_declarator;
    struct type  type;
};

struct declaration_list {
    struct declaration * head;
    struct declaration * tail;
};

struct ast {
    struct token_list  token_list;
    struct declaration_list  declaration_list;
};

struct attribute_list;

struct attribute_specifier {
    int ack;
    struct token * first_token;
    struct token * last_token;
    struct attribute_list * attribute_list;
    struct attribute_specifier * next;
};

struct type_qualifier {
    int flags;
    struct token * token;
    struct type_qualifier * next;
};

struct attribute_argument_clause;

struct attribute {
    int msvc_declspec_flags;
    int attributes_flags;
    struct attribute_argument_clause * attribute_argument_clause;
    struct token * attribute_token;
    struct attribute * next;
};

struct diagnostic_stack {
    int top_index;
    struct diagnostic stack[10];
};

struct options {
    int input;
    int target;
    struct diagnostic_stack  diagnostic_stack;
    int style;
    unsigned char  show_includes;
    unsigned char  disable_assert;
    unsigned char  flow_analysis;
    unsigned char  test_mode;
    unsigned char  test_mode_inout;
    unsigned char  null_checks_enabled;
    unsigned char  ownership_enabled;
    unsigned char  preprocess_only;
    unsigned char  preprocess_def_macro;
    unsigned char  clear_error_at_end;
    unsigned char  sarif_output;
    unsigned char  no_output;
    unsigned char  const_literal;
    unsigned char  visual_studio_ouput_format;
    unsigned char  color_disabled;
    unsigned char  dump_tokens;
    unsigned char  dump_pptokens;
    unsigned char  auto_config;
    unsigned char  comment_to_attribute;
    unsigned char  do_static_debug;
    int static_debug_lines;
    char output[200];
    char sarifpath[200];
};

struct scope;

struct scope_list {
    struct scope * head;
    struct scope * tail;
};

struct diagnostic_id_stack;
struct _iobuf;
struct report;

struct parser_ctx {
    struct options  options;
    struct diagnostic_id_stack * p_diagnostic_id_stack;
    struct scope_list  scopes;
    struct declarator * p_current_function_opt;
    struct scope * p_current_function_scope_opt;
    struct label_list  label_list;
    struct try_statement * p_current_try_statement_opt;
    struct defer_statement * p_current_defer_statement_opt;
    struct selection_statement * p_current_selection_statement;
    struct _iobuf * sarif_file;
    unsigned int sarif_entries;
    struct token_list  input_list;
    struct token * current;
    struct token * previous;
    unsigned char  inside_generic_association;
    int label_id;
    unsigned int unique_tag_id;
    int anonymous_struct_count;
    struct report * p_report;
};

union __tag603 {
    signed long long host_long_long;
    unsigned long long host_u_long_long;
    long double host_long_double;
};

struct object;

struct object_list {
    struct object * head;
    struct object * tail;
    unsigned int count;
};

struct object {
    int state;
    int value_type;
    struct type  type;
    char * member_designator;
    union __tag603  value;
    struct object * parent;
    struct object * p_ref;
    struct expression * p_init_expression;
    struct object_list  members;
    struct object * next;
};

struct pointer;
struct direct_declarator;

struct declarator {
    unsigned char  has_shared_ownership;
    struct token * first_token_opt;
    struct token * last_token_opt;
    struct pointer * pointer;
    struct direct_declarator * direct_declarator;
    struct declaration_specifiers * declaration_specifiers;
    struct specifier_qualifier_list * specifier_qualifier_list;
    struct token * name_opt;
    struct compound_statement * function_body;
    struct declarator * p_complete_declarator;
    int num_uses;
    struct object  object;
    struct flow_object * p_flow_object;
    struct expression * p_expression_true;
    struct expression * p_expression_false;
    struct expression * p_alias_of_expression;
    struct type  type;
    unsigned char  declarator_renamed;
};

struct attribute_list {
    int attributes_flags;
    struct attribute * head;
    struct attribute * tail;
};

struct _WIN32_FIND_DATAA {
    unsigned long dwFileAttributes;
    struct _FILETIME  ftCreationTime;
    struct _FILETIME  ftLastAccessTime;
    struct _FILETIME  ftLastWriteTime;
    unsigned long nFileSizeHigh;
    unsigned long nFileSizeLow;
    unsigned long dwReserved0;
    unsigned long dwReserved1;
    char cFileName[260];
    char cAlternateFileName[14];
};

struct macro_argument_list {
    struct token_list  tokens;
    struct macro_argument * head;
    struct macro_argument * tail;
};

struct asm_statement {
    struct token * p_first_token;
    struct token * p_last_token;
};

struct scope {
    int scope_level;
    struct hash_map  tags;
    struct hash_map  variables;
    struct scope * next;
    struct scope * previous;
};

struct struct_entry_list {
    struct struct_entry ** data;
    int size;
    int capacity;
};

struct struct_entry {
    unsigned char  definition_was_printed;
    unsigned char  declaration_was_printed;
    struct struct_or_union_specifier * p_struct_or_union_specifier;
    struct struct_entry_list  hard_dependencies;
    struct struct_entry_list  soft_dependencies;
    struct struct_entry * next;
};

struct param {
    struct type  type;
    struct param * next;
};

struct _iobuf {
    void * _Placeholder;
};

struct __crt_multibyte_data;

struct __crt_locale_data;

struct __crt_locale_pointers {
    struct __crt_locale_data * locinfo;
    struct __crt_multibyte_data * mbcinfo;
};

struct initializer_list_item;

struct initializer_list {
    struct token * first_token;
    struct initializer_list_item * head;
    struct initializer_list_item * tail;
    int size;
};

struct stat {
    unsigned int st_dev;
    unsigned short st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    unsigned int st_rdev;
    long st_size;
    long long st_atime;
    long long st_mtime;
    long long st_ctime;
};

struct initializer;

struct initializer_list_item {
    struct designation * designation;
    struct initializer * initializer;
    struct initializer_list_item * next;
};

struct _stat64i32 {
    unsigned int st_dev;
    unsigned short st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    unsigned int st_rdev;
    long st_size;
    long long st_atime;
    long long st_mtime;
    long long st_ctime;
};

struct parameter_list;

struct parameter_type_list {
    unsigned char  is_var_args;
    unsigned char  is_void;
    struct parameter_list * parameter_list;
};

struct typeof_specifier;

struct type_specifier {
    int flags;
    struct token * token;
    struct struct_or_union_specifier * struct_or_union_specifier;
    struct typeof_specifier * typeof_specifier;
    struct enum_specifier * enum_specifier;
    struct declarator * typedef_declarator;
    struct atomic_type_specifier * atomic_type_specifier;
};

struct pointer {
    struct attribute_specifier_sequence * attribute_specifier_sequence_opt;
    struct type_qualifier_list * type_qualifier_list_opt;
    struct token * calling_convention;
    struct pointer * pointer;
};

struct member_declaration;

struct member_declaration_list {
    struct token * first_token;
    struct token * last_token;
    struct member_declaration * head;
    struct member_declaration * tail;
};

struct type_specifier_qualifier;
struct function_specifier;
struct alignment_specifier;

struct declaration_specifier {
    struct storage_class_specifier * storage_class_specifier;
    struct type_specifier_qualifier * type_specifier_qualifier;
    struct function_specifier * function_specifier;
    struct alignment_specifier * alignment_specifier;
    struct declaration_specifier * next;
};

struct condition {
    struct expression * expression;
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;
    struct declaration_specifiers * p_declaration_specifiers;
    struct init_declarator * p_init_declarator;
    struct token * first_token;
    struct token * last_token;
};

struct defer_list_item {
    struct declarator * declarator;
    struct defer_statement * defer_statement;
    struct defer_list_item * next;
};

struct object_visitor {
    int member_index;
    struct type * p_type;
    struct flow_object * p_object;
};

struct try_statement {
    struct secondary_block * secondary_block;
    struct secondary_block * catch_secondary_block_opt;
    struct token * first_token;
    struct token * last_token;
    struct token * catch_token_opt;
    struct expression * msvc_except_expression;
    int catch_label_id;
};

struct defer_visit_ctx {
    struct secondary_block * catch_secondary_block_opt;
    struct parser_ctx * ctx;
    struct ast  ast;
    struct defer_defer_scope * tail_block;
    int parameter_list;
};

struct label_list_item {
    struct token * p_last_usage;
    struct token * p_defined;
    struct label_list_item * next;
};

struct report {
    int no_files;
    double cpu_time_used_sec;
    int error_count;
    int warnings_count;
    int info_count;
    unsigned char  test_mode;
    int test_failed;
    int test_succeeded;
    unsigned char  ignore_this_report;
};

struct enumerator_list {
    struct enumerator * head;
    struct enumerator * tail;
};

struct enum_specifier {
    unsigned char  has_shared_ownership;
    struct attribute_specifier_sequence * attribute_specifier_sequence_opt;
    struct specifier_qualifier_list * specifier_qualifier_list;
    char tag_name[200];
    struct enumerator_list  enumerator_list;
    struct token * tag_token;
    struct token * first_token;
    struct enum_specifier * p_complete_enum_specifier;
};

struct marker {
    char * file;
    int line;
    int start_col;
    int end_col;
    struct token * p_token_caret;
    struct token * p_token_begin;
    struct token * p_token_end;
};

struct objects {
    struct object ** items;
    int size;
    int capacity;
};

struct parameter_list {
    struct parameter_declaration * head;
    struct parameter_declaration * tail;
};

struct array_declarator {
    struct direct_declarator * direct_declarator;
    struct expression * assignment_expression;
    struct expression * expression;
    struct type_qualifier_list * type_qualifier_list_opt;
    struct token * token;
    struct token * static_token_opt;
};

struct d_visit_ctx {
    struct options  options;
    int indentation;
    unsigned char  print_qualifiers;
    unsigned int cake_file_scope_declarator_number;
    unsigned int cake_local_declarator_number;
    struct hash_map  tag_names;
    struct hash_map  structs_map;
    struct hash_map  file_scope_declarator_map;
    struct hash_map  instantiated_function_literals;
    struct osstream  block_scope_declarators;
    struct osstream  add_this_before;
    struct osstream  add_this_before_external_decl;
    struct osstream  add_this_after_external_decl;
    unsigned char  is_local;
    unsigned char  zero_mem_used;
    unsigned char  memcpy_used;
    unsigned char  define_nullptr;
    unsigned char  null_pointer_constant_used;
    unsigned char  address_of_argument;
    struct declarator * p_current_function_opt;
    struct break_reference  break_reference;
    unsigned char  is__func__predefined_identifier_added;
    struct ast  ast;
};

struct labeled_statement {
    struct label * label;
    struct statement * statement;
};

struct init_declarator {
    unsigned char  has_shared_ownership;
    struct declarator * p_declarator;
    struct initializer * initializer;
    struct init_declarator * next;
};

struct init_declarator_list {
    struct init_declarator * head;
    struct init_declarator * tail;
};

struct static_assert_declaration;

struct declaration {
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;
    struct static_assert_declaration * static_assert_declaration;
    struct pragma_declaration * pragma_declaration;
    struct declaration_specifiers * declaration_specifiers;
    struct init_declarator_list  init_declarator_list;
    struct compound_statement * function_body;
    struct defer_list  defer_list;
    struct declarator * contract_declarator;
    struct token * first_token;
    struct token * last_token;
    struct declaration * next;
};

struct specifier_qualifier_list {
    int type_specifier_flags;
    int type_qualifier_flags;
    int alignment_specifier_flags;
    struct struct_or_union_specifier * struct_or_union_specifier;
    struct enum_specifier * enum_specifier;
    struct typeof_specifier * typeof_specifier;
    struct declarator * typedef_declarator;
    struct type_specifier_qualifier * head;
    struct type_specifier_qualifier * tail;
    struct token * first_token;
    struct token * last_token;
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;
};

struct typeof_specifier_argument;

struct typeof_specifier {
    struct token * first_token;
    struct token * last_token;
    struct typeof_specifier_argument * typeof_specifier_argument;
    struct type  type;
};

struct function_specifier {
    int flags;
    struct token * token;
};

struct typeof_specifier_argument {
    struct expression * expression;
    struct type_name * type_name;
};

struct designator_list {
    struct designator * head;
    struct designator * tail;
};

struct member_declarator_list;

struct member_declaration {
    struct specifier_qualifier_list * specifier_qualifier_list;
    struct member_declarator_list * member_declarator_list_opt;
    struct static_assert_declaration * static_assert_declaration;
    struct pragma_declaration * pragma_declaration;
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;
    struct member_declaration * next;
};

struct hash_item_set {
    unsigned int number;
    struct enum_specifier * p_enum_specifier;
    struct enumerator * p_enumerator;
    struct struct_or_union_specifier * p_struct_or_union_specifier;
    struct declarator * p_declarator;
    struct init_declarator * p_init_declarator;
    struct macro * p_macro;
    struct struct_entry * p_struct_entry;
};

struct iteration_statement {
    struct token * first_token;
    struct token * second_token;
    struct secondary_block * secondary_block;
    struct expression * expression1;
    struct expression * expression2;
    struct expression * expression0;
    struct declaration * declaration;
    struct defer_list  defer_list;
};

struct true_false_set_item;

struct true_false_set {
    struct true_false_set_item * data;
    int size;
    int capacity;
};

struct true_false_set_item {
    struct expression * p_expression;
    int true_branch_state;
    int false_branch_state;
};

struct dirent {
    unsigned short d_ino;
    long d_off;
    unsigned short d_reclen;
    unsigned char d_type;
    char d_name[256];
};

struct macro_parameter {
    char * name;
    struct macro_parameter * next;
    struct token_list  expanded_list;
    unsigned char  already_expanded;
};

struct type_list {
    struct type * head;
    struct type * tail;
};

struct include_dir;

struct include_dir_list {
    struct include_dir * head;
    struct include_dir * tail;
};

struct preprocessor_ctx {
    struct options  options;
    int flags;
    struct hash_map  macros;
    struct include_dir_list  include_dir;
    struct hash_map  pragma_once_map;
    struct token * current;
    struct token_list  input_list;
    unsigned int count_macro_value;
    unsigned char  conditional_inclusion;
    int n_warnings;
    int n_errors;
};

struct secondary_block {
    struct token * first_token;
    struct token * last_token;
    struct statement * statement;
};

struct jump_statement;

struct unlabeled_statement {
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;
    struct expression_statement * expression_statement;
    struct primary_block * primary_block;
    struct jump_statement * jump_statement;
};

struct flow_object {
    unsigned int visit_number;
    struct flow_object * parent;
    struct declarator * p_declarator_origin;
    struct expression * p_expression_origin;
    struct flow_objects_view  members;
    struct flow_object_state  current;
    int id;
    unsigned char  is_temporary;
};

struct label {
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;
    struct expression * constant_expression;
    struct expression * constant_expression_end;
    struct token * p_identifier_opt;
    struct token * p_first_token;
    struct label * next;
    int label_id;
};

struct argument_expression;

struct argument_expression_list {
    struct argument_expression * head;
    struct argument_expression * tail;
};

struct balanced_token_sequence;

struct attribute_argument_clause {
    struct balanced_token_sequence * p_balanced_token_sequence;
    struct token * token;
};

struct static_assert_declaration {
    struct token * first_token;
    struct token * last_token;
    struct expression * constant_expression;
    struct token * string_literal_opt;
};

struct alignment_specifier {
    int flags;
    struct type_name * type_name;
    struct expression * constant_expression;
    struct token * token;
};

struct case_label_list {
    struct label * head;
    struct label * tail;
};

struct TAGDIR {
    void * handle;
    struct dirent  dirent;
};

struct tokenizer_ctx {
    struct options  options;
    int n_warnings;
    int n_errors;
};

struct braced_initializer;

struct expression {
    int expression_type;
    struct type  type;
    struct object  object;
    struct type_name * type_name;
    struct braced_initializer * braced_initializer;
    struct compound_statement * compound_statement;
    struct generic_selection * generic_selection;
    struct token * first_token;
    struct token * last_token;
    struct token * offsetof_member_designator;
    struct declarator * declarator;
    struct init_declarator * p_init_declarator;
    int member_index;
    struct argument_expression_list  argument_expression_list;
    struct expression * condition_expr;
    struct expression * left;
    struct expression * right;
    unsigned char  is_assignment_expression;
};

struct function_declarator {
    struct direct_declarator * direct_declarator;
    struct scope  parameters_scope;
    struct parameter_type_list * parameter_type_list_opt;
};

struct direct_declarator {
    struct token * name_opt;
    struct token * p_calling_convention;
    struct declarator * declarator;
    struct array_declarator * array_declarator;
    struct function_declarator * function_declarator;
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;
};

struct expression_statement {
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;
    struct expression * expression_opt;
};

struct declaration_specifiers {
    int attributes_flags;
    int msvc_declspec_flags;
    int type_specifier_flags;
    int type_qualifier_flags;
    int storage_class_specifier_flags;
    int function_specifier_flags;
    int alignment_specifier_flags;
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;
    struct struct_or_union_specifier * struct_or_union_specifier;
    struct enum_specifier * enum_specifier;
    struct declarator * typedef_declarator;
    struct typeof_specifier * typeof_specifier;
    struct token * first_token;
    struct token * last_token;
    struct declaration_specifier * head;
    struct declaration_specifier * tail;
};

struct braced_initializer {
    struct token * first_token;
    struct token * last_token;
    struct initializer_list * initializer_list;
};

struct argument_expression {
    struct expression * expression;
    struct argument_expression * next;
    unsigned char  set_unkown;
};

struct simple_declaration {
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;
    struct declaration_specifiers * p_declaration_specifiers;
    struct init_declarator_list  init_declarator_list;
    struct token * first_token;
    struct token * last_token;
};

struct struct_or_union_specifier {
    unsigned char  has_shared_ownership;
    struct attribute_specifier_sequence * attribute_specifier_sequence_opt;
    struct member_declaration_list  member_declaration_list;
    struct token * first_token;
    struct token * last_token;
    unsigned char  is_owner;
    struct token * tagtoken;
    unsigned int unique_id;
    char tag_name[200];
    unsigned char  has_anonymous_tag;
    unsigned char  show_anonymous_tag;
    int scope_level;
    int visit_moved;
    struct struct_or_union_specifier * complete_struct_or_union_specifier_indirection;
};

struct balanced_token {
    struct token * token;
    struct balanced_token * next;
};

struct balanced_token_sequence {
    struct balanced_token * head;
    struct balanced_token * tail;
};

struct label_state {
    char * label_name;
    int state_number;
};

struct flow_visit_ctx {
    struct secondary_block * catch_secondary_block_opt;
    struct parser_ctx * ctx;
    struct ast  ast;
    struct type * p_return_type;
    int parameter_list;
    int state_number_generator;
    unsigned char  expression_is_not_evaluated;
    unsigned char  inside_assert;
    unsigned char  inside_contract;
    unsigned char  inside_loop;
    int throw_join_state;
    int break_join_state;
    int initial_state;
    struct flow_objects  arena;
    struct label_state labels[100];
    int labels_size;
};

struct initializer {
    struct token * first_token;
    struct braced_initializer * braced_initializer;
    struct expression * assignment_expression;
};

struct member_declarator;

struct member_declarator_list {
    struct member_declarator * head;
    struct member_declarator * tail;
};

struct map_entry {
    struct map_entry * next;
    unsigned int hash;
    char * key;
    int type;
    union __tag5  data;
};

struct member_declarator {
    struct declarator * declarator;
    struct expression * constant_expression;
    struct member_declarator * next;
};

struct diagnostic_id_stack {
    int size;
    int stack[10];
};

struct selection_statement {
    struct init_statement * p_init_statement;
    struct condition * condition;
    struct secondary_block * secondary_block;
    struct secondary_block * else_secondary_block_opt;
    struct token * open_parentesis_token;
    struct token * close_parentesis_token;
    struct case_label_list  label_list;
    struct token * first_token;
    struct token * last_token;
    struct token * else_token_opt;
    struct defer_list  defer_list;
    int label_id;
};

struct jump_statement {
    struct token * label;
    struct token * first_token;
    struct token * last_token;
    struct expression * expression_opt;
    int label_id;
    struct defer_list  defer_list;
};

struct include_dir {
    char * path;
    struct include_dir * next;
};

struct statement {
    struct labeled_statement * labeled_statement;
    struct unlabeled_statement * unlabeled_statement;
};

struct object_name_list {
    char * name;
    struct object_name_list * previous;
};

struct type_specifier_qualifier {
    struct type_specifier * type_specifier;
    struct type_qualifier * type_qualifier;
    struct alignment_specifier * alignment_specifier;
    struct type_specifier_qualifier * next;
};

struct attribute_specifier_sequence {
    struct token * first_token;
    struct token * last_token;
    int msvc_declspec_flags;
    int attributes_flags;
    struct attribute_specifier * head;
    struct attribute_specifier * tail;
};

struct enumerator {
    unsigned char  has_shared_ownership;
    struct token * token;
    struct attribute_specifier_sequence * attribute_specifier_sequence_opt;
    struct expression * constant_expression_opt;
    struct enum_specifier * enum_specifier;
    struct enumerator * next;
    struct object  value;
};


static void _cake_zmem(void *dest, unsigned int len)
{
  unsigned char *ptr;

  ptr = (unsigned char*)dest;
  while (len-- > 0) *ptr++ = 0;
}

static void _cake_memcpy(void * dest, const void * src, unsigned int n)
{
  char *csrc;
  char *cdest;
  unsigned int i; 

  csrc = (char *)src;
  cdest = (char *)dest;
  for (i = 0; i < n; i++) cdest[i] = csrc[i]; 
}

unsigned char token_is_blank(struct token * p);

unsigned char style_has_space(struct token * token)
{
    return token_is_blank(token->prev);
}


unsigned char style_has_one_space(struct token * token)
{
    return token->prev && token->prev->type == 143;
}


void token_delete(struct token * p);

void token_list_clear(struct token_list * list)
{
    struct token * p;

    p = list->head;
    while (p)
    {
        struct token * next;

        next = p->next;
        p->next = 0;
        token_delete(p);
        p = next;
    }
    list->head = 0;
    list->tail = 0;
}


void token_range_add_show(struct token * first, struct token * last)
{
    {
        struct token * current;

        current = first;
        for (; current != last->next; current = current->next)
        {
            current->flags = current->flags & -65;
            if (current->next == 0)
            {
                break;
            }
        }
    }
}


void token_range_remove_flag(struct token * first, struct token * last, int flag)
{
    {
        struct token * current;

        current = first;
        for (; current && current != last->next; current = current->next)
        {
            current->flags = current->flags & ~flag;
        }
    }
}


void token_range_add_flag(struct token * first, struct token * last, int flag)
{
    {
        struct token * current;

        current = first;
        for (; current && current != last->next; current = current->next)
        {
            current->flags |= flag;
        }
    }
}


void token_list_pop_back(struct token_list * list)
{
    if (list->head == 0)
    {
        return;
    }
    if (list->head == list->tail)
    {
        token_delete(list->head);
        list->head = 0;
        list->tail = 0;
    }
    else
    {
        ;
        ;
        list->tail = list->tail->prev;
        token_delete(list->tail->next);
        list->tail->next = 0;
        if (list->tail == list->head)
        {
            list->tail->prev = 0;
        }
    }
    ;
}


void token_list_pop_front(struct token_list * list)
{
    struct token * p;

    if (list->head == 0)
    {
        return;
    }
    p = list->head;
    ;
    if (list->head == list->tail)
    {
        list->head = 0;
        list->tail = 0;
    }
    else
    {
        list->head = p->next;
        if (list->head)
        {
            list->head->prev = 0;
        }
    }
    p->next = 0;
    p->prev = 0;
    token_delete(p);
    ;
}


struct token *token_list_pop_front_get(struct token_list * list)
{
    struct token * old_head;

    if (list->head == 0)
    {
        return 0;
    }
    old_head = list->head;
    list->head = old_head->next;
    if (list->head != 0)
    {
        list->head->prev = 0;
    }
    else
    {
        list->tail = 0;
    }
    ;
    old_head->prev = 0;
    old_head->next = 0;
    return old_head;
}


void token_list_swap(struct token_list * a, struct token_list * b)
{
    struct token_list  temp;

    temp = *a;
    *a = *b;
    *b = temp;
}


void free(void * ptr);

void token_delete(struct token * p)
{
    if (p)
    {
        ;
        free(p->lexeme);
        free(p);
    }
}


void token_list_set_file(struct token_list * list, struct token * filetoken, int line, int col)
{
    struct token * p;

    p = list->head;
    while (p)
    {
        p->token_origin = filetoken;
        p->line = line;
        p->col = col;
        p = p->next;
    }
}


void token_list_destroy(struct token_list * list)
{
    struct token * p;

    p = list->head;
    while (p)
    {
        struct token * next;

        next = p->next;
        p->next = 0;
        token_delete(p);
        p = next;
    }
}


int ss_fprintf(struct osstream * stream, char * fmt, ...);
void ss_close(struct osstream * stream);

char *token_list_join_tokens(struct token_list * list, unsigned char  bliteral)
{
    struct osstream  ss;
    unsigned char  has_space;
    struct token * current;
    char * cstr;

    _cake_zmem(&ss, 12);
    if (bliteral)
    {
        ss_fprintf(&ss, "\"");
    }
    has_space = 0;
    current = list->head;
    while (current)
    {
        char * p;

        if (token_is_blank(current))
        {
            has_space = 1;
            current = current->next;
            continue;
        }
        if (has_space)
        {
            ss_fprintf(&ss, " ");
        }
        p = current->lexeme;
        while (*p)
        {
            if (*p == 34)
            {
                ss_fprintf(&ss, "\\\"");
            }
            else
            {
                if (*p == 92)
                {
                    ss_fprintf(&ss, "\\\\");
                }
                else
                {
                    ss_fprintf(&ss, "%c", *p);
                }
            }
            p++;
        }
        current = current->next;
        if (current)
        {
            has_space = ((current->flags & 4) != 0);
        }
    }
    if (bliteral)
    {
        ss_fprintf(&ss, "\"");
    }
    cstr = ss.c_str;
    ss.c_str = 0;
    ss_close(&ss);
    return cstr;
}


struct token_list tokenizer(struct tokenizer_ctx * ctx, char * text, char * filename_opt, int level, int addflags);
void token_list_insert_after(struct token_list * list, struct token * after, struct token_list * append);

void token_list_paste_string_after(struct token_list * list, struct token * after, char * s)
{
    struct tokenizer_ctx  tctx;
    struct token_list  l;

    _cake_zmem(&tctx, 928);
    l = tokenizer(&tctx, s, 0, 0, 1);
    token_list_insert_after(list, after, &l);
    token_list_destroy(&l);
}


void token_list_insert_before(struct token_list * token_list, struct token * after, struct token_list * append_list);

void token_list_paste_string_before(struct token_list * list, struct token * before, char * s)
{
    struct tokenizer_ctx  tctx;
    struct token_list  l;

    _cake_zmem(&tctx, 928);
    l = tokenizer(&tctx, s, 0, 0, 1);
    token_list_insert_before(list, before, &l);
    token_list_destroy(&l);
}


void token_list_insert_after(struct token_list * token_list, struct token * after, struct token_list * append_list)
{
    if (append_list->head == 0)
    {
        return;
    }
    if (token_list->head == 0)
    {
        ;
        token_list->head = append_list->head;
        token_list->tail = append_list->tail;
        append_list->head = 0;
        append_list->tail = 0;
        return;
    }
    if (after == 0)
    {
        ;
        ;
        append_list->tail->next = token_list->head;
        token_list->head->prev = append_list->tail;
        token_list->head = append_list->head;
        append_list->head->prev = 0;
    }
    else
    {
        struct token * follow;

        follow = after->next;
        if (token_list->tail == after)
        {
            token_list->tail = append_list->tail;
        }
        else
        {
            if (token_list->head == after)
            {
            }
        }
        ;
        ;
        append_list->tail->next = follow;
        follow->prev = append_list->tail;
        after->next = append_list->head;
        append_list->head->prev = after;
    }
    append_list->head = 0;
    append_list->tail = 0;
    ;
}


void token_list_insert_before(struct token_list * token_list, struct token * after, struct token_list * append_list)
{
    token_list_insert_after(token_list, after->prev, append_list);
}


int __cdecl strcmp(char * _Str1, char * _Str2);

unsigned char token_list_is_equal(struct token_list * list_a, struct token_list * list_b)
{
    struct token * p_tka;
    struct token * p_tkb;

    p_tka = list_a->head;
    p_tkb = list_b->head;
    while (p_tka && p_tkb)
    {
        if (p_tka->type != p_tkb->type)
        {
            return 0;
        }
        if (strcmp(p_tka->lexeme, p_tkb->lexeme) != 0)
        {
            return 0;
        }
        p_tka = p_tka->next;
        p_tkb = p_tkb->next;
    }
    return p_tka == 0 && p_tkb == 0;
}


struct token *token_list_add(struct token_list * list, struct token * pnew)
{
    ;
    ;
    if (list->head == 0)
    {
        pnew->prev = 0;
        pnew->next = 0;
        list->head = pnew;
        list->tail = pnew;
    }
    else
    {
        ;
        ;
        pnew->prev = list->tail;
        list->tail->next = pnew;
        list->tail = pnew;
    }
    ;
    ;
    ;
    return list->tail;
}


int is_digit(struct stream * p)
{
    return (p->current[0] >= 48 && p->current[0] <= 57);
}


unsigned char token_is_identifier_or_keyword(int t)
{
    /*switch*/
    {
        int __v0 = t;
        if (__v0 == 8996) goto __L1; /*case 8996*/
        if (__v0 == 8999) goto __L2; /*case 8999*/
        if (__v0 == 9000) goto __L3; /*case 9000*/
        if (__v0 == 9001) goto __L4; /*case 9001*/
        if (__v0 == 9002) goto __L5; /*case 9002*/
        if (__v0 == 9003) goto __L6; /*case 9003*/
        if (__v0 == 9004) goto __L7; /*case 9004*/
        if (__v0 == 9005) goto __L8; /*case 9005*/
        if (__v0 == 9006) goto __L9; /*case 9006*/
        if (__v0 == 9007) goto __L10; /*case 9007*/
        if (__v0 == 9008) goto __L11; /*case 9008*/
        if (__v0 == 9009) goto __L12; /*case 9009*/
        if (__v0 == 9010) goto __L13; /*case 9010*/
        if (__v0 == 9011) goto __L14; /*case 9011*/
        if (__v0 == 9012) goto __L15; /*case 9012*/
        if (__v0 == 9013) goto __L16; /*case 9013*/
        if (__v0 == 9014) goto __L17; /*case 9014*/
        if (__v0 == 9015) goto __L18; /*case 9015*/
        if (__v0 == 9016) goto __L19; /*case 9016*/
        if (__v0 == 9017) goto __L20; /*case 9017*/
        if (__v0 == 9018) goto __L21; /*case 9018*/
        if (__v0 == 9019) goto __L22; /*case 9019*/
        if (__v0 == 9020) goto __L23; /*case 9020*/
        if (__v0 == 9021) goto __L24; /*case 9021*/
        if (__v0 == 9022) goto __L25; /*case 9022*/
        if (__v0 == 9023) goto __L26; /*case 9023*/
        if (__v0 == 9024) goto __L27; /*case 9024*/
        if (__v0 == 9025) goto __L28; /*case 9025*/
        if (__v0 == 9026) goto __L29; /*case 9026*/
        if (__v0 == 9027) goto __L30; /*case 9027*/
        if (__v0 == 9028) goto __L31; /*case 9028*/
        if (__v0 == 9029) goto __L32; /*case 9029*/
        if (__v0 == 9030) goto __L33; /*case 9030*/
        if (__v0 == 9032) goto __L34; /*case 9032*/
        if (__v0 == 9033) goto __L35; /*case 9033*/
        if (__v0 == 9034) goto __L36; /*case 9034*/
        if (__v0 == 9035) goto __L37; /*case 9035*/
        if (__v0 == 9036) goto __L38; /*case 9036*/
        if (__v0 == 9037) goto __L39; /*case 9037*/
        if (__v0 == 9038) goto __L40; /*case 9038*/
        if (__v0 == 9039) goto __L41; /*case 9039*/
        if (__v0 == 9040) goto __L42; /*case 9040*/
        if (__v0 == 9041) goto __L43; /*case 9041*/
        if (__v0 == 9042) goto __L44; /*case 9042*/
        if (__v0 == 9043) goto __L45; /*case 9043*/
        if (__v0 == 9044) goto __L46; /*case 9044*/
        if (__v0 == 9045) goto __L47; /*case 9045*/
        if (__v0 == 9064) goto __L48; /*case 9064*/
        if (__v0 == 9065) goto __L49; /*case 9065*/
        if (__v0 == 9066) goto __L50; /*case 9066*/
        if (__v0 == 9067) goto __L51; /*case 9067*/
        if (__v0 == 9068) goto __L52; /*case 9068*/
        if (__v0 == 9069) goto __L53; /*case 9069*/
        if (__v0 == 9070) goto __L54; /*case 9070*/
        if (__v0 == 9071) goto __L55; /*case 9071*/
        if (__v0 == 9072) goto __L56; /*case 9072*/
        if (__v0 == 9073) goto __L57; /*case 9073*/
        if (__v0 == 9074) goto __L58; /*case 9074*/
        if (__v0 == 9075) goto __L59; /*case 9075*/
        if (__v0 == 9076) goto __L60; /*case 9076*/
        if (__v0 == 9077) goto __L61; /*case 9077*/
        if (__v0 == 9078) goto __L62; /*case 9078*/
        if (__v0 == 9079) goto __L63; /*case 9079*/
        if (__v0 == 9080) goto __L64; /*case 9080*/
        if (__v0 == 9081) goto __L65; /*case 9081*/
        if (__v0 == 9082) goto __L66; /*case 9082*/
        if (__v0 == 9083) goto __L67; /*case 9083*/
        if (__v0 == 9084) goto __L68; /*case 9084*/
        if (__v0 == 9085) goto __L69; /*case 9085*/
        if (__v0 == 9086) goto __L70; /*case 9086*/
        if (__v0 == 9087) goto __L71; /*case 9087*/
        if (__v0 == 9088) goto __L72; /*case 9088*/
        if (__v0 == 9089) goto __L73; /*case 9089*/
        if (__v0 == 9090) goto __L74; /*case 9090*/
        if (__v0 == 9091) goto __L75; /*case 9091*/
        if (__v0 == 9092) goto __L76; /*case 9092*/
        if (__v0 == 9093) goto __L77; /*case 9093*/
        if (__v0 == 9094) goto __L78; /*case 9094*/
        if (__v0 == 9095) goto __L79; /*case 9095*/
        if (__v0 == 9096) goto __L80; /*case 9096*/
        if (__v0 == 9097) goto __L81; /*case 9097*/
        if (__v0 == 9098) goto __L82; /*case 9098*/
        if (__v0 == 9099) goto __L83; /*case 9099*/
        if (__v0 == 9100) goto __L84; /*case 9100*/
        goto __L85; /* default */

        {
            __L1: /*case 8996*/ 
            return 1;
            __L2: /*case 8999*/ 
            __L3: /*case 9000*/ 
            __L4: /*case 9001*/ 
            __L5: /*case 9002*/ 
            __L6: /*case 9003*/ 
            __L7: /*case 9004*/ 
            __L8: /*case 9005*/ 
            __L9: /*case 9006*/ 
            __L10: /*case 9007*/ 
            __L11: /*case 9008*/ 
            __L12: /*case 9009*/ 
            __L13: /*case 9010*/ 
            __L14: /*case 9011*/ 
            __L15: /*case 9012*/ 
            __L16: /*case 9013*/ 
            __L17: /*case 9014*/ 
            __L18: /*case 9015*/ 
            __L19: /*case 9016*/ 
            __L20: /*case 9017*/ 
            __L21: /*case 9018*/ 
            __L22: /*case 9019*/ 
            __L23: /*case 9020*/ 
            __L24: /*case 9021*/ 
            __L25: /*case 9022*/ 
            __L26: /*case 9023*/ 
            __L27: /*case 9024*/ 
            __L28: /*case 9025*/ 
            __L29: /*case 9026*/ 
            __L30: /*case 9027*/ 
            __L31: /*case 9028*/ 
            __L32: /*case 9029*/ 
            __L33: /*case 9030*/ 
            __L34: /*case 9032*/ 
            __L35: /*case 9033*/ 
            __L36: /*case 9034*/ 
            __L37: /*case 9035*/ 
            __L38: /*case 9036*/ 
            __L39: /*case 9037*/ 
            __L40: /*case 9038*/ 
            __L41: /*case 9039*/ 
            __L42: /*case 9040*/ 
            __L43: /*case 9041*/ 
            __L44: /*case 9042*/ 
            __L45: /*case 9043*/ 
            __L46: /*case 9044*/ 
            __L47: /*case 9045*/ 
            __L48: /*case 9064*/ 
            __L49: /*case 9065*/ 
            __L50: /*case 9066*/ 
            __L51: /*case 9067*/ 
            __L52: /*case 9068*/ 
            __L53: /*case 9069*/ 
            __L54: /*case 9070*/ 
            __L55: /*case 9071*/ 
            __L56: /*case 9072*/ 
            __L57: /*case 9073*/ 
            __L58: /*case 9074*/ 
            __L59: /*case 9075*/ 
            __L60: /*case 9076*/ 
            __L61: /*case 9077*/ 
            __L62: /*case 9078*/ 
            __L63: /*case 9079*/ 
            __L64: /*case 9080*/ 
            __L65: /*case 9081*/ 
            __L66: /*case 9082*/ 
            __L67: /*case 9083*/ 
            __L68: /*case 9084*/ 
            __L69: /*case 9085*/ 
            __L70: /*case 9086*/ 
            __L71: /*case 9087*/ 
            __L72: /*case 9088*/ 
            __L73: /*case 9089*/ 
            __L74: /*case 9090*/ 
            __L75: /*case 9091*/ 
            __L76: /*case 9092*/ 
            __L77: /*case 9093*/ 
            __L78: /*case 9094*/ 
            __L79: /*case 9095*/ 
            __L80: /*case 9096*/ 
            __L81: /*case 9097*/ 
            __L82: /*case 9098*/ 
            __L83: /*case 9099*/ 
            __L84: /*case 9100*/ 
            return 1;
            __L85: /* default */ 
            goto __L0; /* break */

        }
        __L0:;
    }
    return 0;
}


unsigned char token_is_blank(struct token * p)
{
    return p->type == 8998 || p->type == 143 || p->type == 132 || p->type == 133;
}


struct token *clone_token(struct token * p);

struct token *token_list_clone_and_add(struct token_list * list, struct token * pnew)
{
    struct token * clone;

    clone = clone_token(pnew);
    if (clone == 0)
    {
        return 0;
    }
    return token_list_add(list, clone);
}


void token_list_append_list_at_beginning(struct token_list * dest, struct token_list * source)
{
    if (source->head == 0)
    {
        return;
    }
    if (dest->head == 0)
    {
        dest->head = source->head;
        dest->tail = source->tail;
    }
    else
    {
        ;
        ;
        source->tail->next = dest->head;
        dest->head = source->head;
    }
    source->head = 0;
    source->tail = 0;
    ;
}


void token_list_append_list(struct token_list * dest, struct token_list * source)
{
    if (source->head == 0)
    {
        return;
    }
    if (dest->head == 0)
    {
        dest->head = source->head;
        dest->tail = source->tail;
    }
    else
    {
        ;
        ;
        dest->tail->next = source->head;
        source->head->prev = dest->tail;
        dest->tail = source->tail;
    }
    source->head = 0;
    source->tail = 0;
    ;
}


void *calloc(unsigned int nmemb, unsigned int size);
char *strdup(char * src);

struct token *clone_token(struct token * p)
{
    struct token * token;
    char * lexeme;

    token = calloc(1, 40);
    if (token == 0)
    {
        return 0;
    }
    lexeme = strdup(p->lexeme);
    if (lexeme == 0)
    {
        free(token);
        return 0;
    }
    *token = *p;
    token->lexeme = lexeme;
    token->next = 0;
    token->prev = 0;
    return token;
}


struct token_list token_list_remove_get(struct token_list * list, struct token * first, struct token * last)
{
    struct token_list  r;
    struct token * before_first;
    struct token * after_last;

    _cake_zmem(&r, 8);
    before_first = first->prev;
    after_last = last->next;
    if (before_first)
    {
        before_first->next = after_last;
    }
    else
    {
        list->head = last->next;
    }
    if (after_last)
    {
        after_last->prev = before_first;
    }
    else
    {
        list->tail = 0;
    }
    last->next = 0;
    r.head = (struct token *)first;
    first->prev = 0;
    r.tail = last;
    return r;
}


void token_list_remove(struct token_list * list, struct token * first, struct token * last)
{
    struct token_list  r;

    r = token_list_remove_get(list, first, last);
    token_list_destroy(&r);
}


unsigned char token_list_is_empty(struct token_list * p)
{
    ;
    return p->head == 0;
}


static int __cdecl printf(char * _Format, ...);
static int __cdecl _vfprintf_l(struct _iobuf * _Stream, char * _Format, struct __crt_locale_pointers * _Locale, char * _ArgList);
int __cdecl __stdio_common_vfprintf(unsigned long long _Options, struct _iobuf * _Stream, char * _Format, struct __crt_locale_pointers * _Locale, char * _ArgList);
static unsigned long long *__cdecl __local_stdio_printf_options(void);
static unsigned long long __c0__OptionsStorage;
struct _iobuf *__cdecl __acrt_iob_func(unsigned int _Ix);
void print_literal2(char * s);

void print_list(unsigned char  color_enabled, struct token_list * list)
{
    struct token * current;

    current = list->head;
    while (current)
    {
        if (current != list->head)
        {
            printf("\xcb\xb0");
        }
        print_literal2(current->lexeme);
        if (color_enabled)
        {
            printf("\x1b[0m");
        }
        if (current == list->tail)
        {
        }
        current = current->next;
    }
    printf("\n");
}



static unsigned long long *__cdecl __local_stdio_printf_options(void)
{
    return &__c0__OptionsStorage;
}

static int __cdecl _vfprintf_l(struct _iobuf * _Stream, char * _Format, struct __crt_locale_pointers * _Locale, char * _ArgList)
{
    return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}

static int __cdecl printf(char * _Format, ...)
{
    int _Result;
    char * _ArgList;

    ((void)(_ArgList = (char *)(&(_Format)) + 4));
    _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (char *)0));
    return _Result;
}
void print_literal2(char * s)
{
    while (*s)
    {
        /*switch*/
        {
            char __v0 = *s;
            if (__v0 == 10) goto __L1; /*case 10*/
            goto __L2; /* default */

            {
                __L1: /*case 10*/ 
                printf("\\n");
                goto __L0; /* break */

                __L2: /* default */ 
                printf("%c", *s);
            }
            __L0:;
        }
        s++;
    }
}


static int __cdecl snprintf(char * _Buffer, unsigned int _BufferCount, char * _Format, ...);
static int __cdecl vsnprintf(char * _Buffer, unsigned int _BufferCount, char * _Format, char * _ArgList);
int __cdecl __stdio_common_vsprintf(unsigned long long _Options, char * _Buffer, unsigned int _BufferCount, char * _Format, struct __crt_locale_pointers * _Locale, char * _ArgList);
char *get_token_name(int tk);
char *__cdecl strcat(char * _Destination, char * _Source);

void print_token(unsigned char  color_enabled, struct token * p_token)
{
    char buffer0[50];
    char buffer[50];

    {
        int i;

        i = 0;
        for (; i < p_token->level; i++)
        {
            printf("  ");
        }
    }
    if (p_token->flags & 1)
    {
        if (color_enabled)
        {
            printf("\x1b[92m");
        }
    }
    else
    {
        if (color_enabled)
        {
            printf("\x1b[37m");
        }
    }
    _cake_zmem(&buffer0, 50);
    snprintf(buffer0, 50, "%d:%d", p_token->line, p_token->col);
    printf("%-6s ", buffer0);
    printf("%-20s ", get_token_name(p_token->type));
    if (p_token->flags & 2)
    {
        if (color_enabled)
        {
            printf("\x1b[36;1m");
        }
    }
    _cake_zmem(&buffer, 50);
    strcat(buffer, "[");
    if (p_token->flags & 1)
    {
        strcat(buffer, "final ");
    }
    if (p_token->flags & 64)
    {
        strcat(buffer, "hide ");
    }
    if (p_token->flags & 2)
    {
        strcat(buffer, "expanded ");
    }
    if (p_token->flags & 4)
    {
        strcat(buffer, "space ");
    }
    if (p_token->flags & 8)
    {
        strcat(buffer, "newline ");
    }
    strcat(buffer, "]");
    printf("%-20s ", buffer);
    print_literal2(p_token->lexeme);
    printf("\n");
    if (color_enabled)
    {
        printf("\x1b[0m");
    }
}



static int __cdecl vsnprintf(char * _Buffer, unsigned int _BufferCount, char * _Format, char * _ArgList)
{
    int _Result;

    _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | 2ULL, _Buffer, _BufferCount, _Format, 0, _ArgList);
    return _Result < 0 ? -1 : _Result;
}

static int __cdecl snprintf(char * _Buffer, unsigned int _BufferCount, char * _Format, ...)
{
    int _Result;
    char * _ArgList;

    ((void)(_ArgList = (char *)(&(_Format)) + 4));
    _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
    ((void)(_ArgList = (char *)0));
    return _Result;
}
void print_tokens(unsigned char  color_enabled, struct token * p_token)
{
    struct token * current;

    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    if (color_enabled)
    {
        printf("\x1b[0m");
    }
    current = p_token;
    while (current)
    {
        print_token(color_enabled, current);
        current = current->next;
    }
    printf("\n");
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    if (color_enabled)
    {
        printf("\x1b[0m");
    }
}


void print_token_html(struct token * p_token)
{
    printf("<span class=\"");
    if (!(p_token->flags & 1))
    {
        printf("notfinal ");
    }
    if (p_token->flags & 1)
    {
        printf("final ");
    }
    if (p_token->flags & 64)
    {
        printf("hide ");
    }
    if (p_token->flags & 2)
    {
        printf("expanded ");
    }
    if (p_token->flags & 4)
    {
        printf("space ");
    }
    if (p_token->flags & 8)
    {
        printf("newline ");
    }
    printf("\">");
    print_literal2(p_token->lexeme);
    printf("</span>");
    if (p_token->type == 10 || p_token->type == 8998)
    {
        printf("<br>\n");
    }
}


void print_tokens_html(struct token * p_token)
{
    struct token * current;

    printf("<pre>\n");
    current = p_token;
    while (current)
    {
        print_token_html(current);
        current = current->next;
    }
    printf("\n</pre>");
}


void print_path(char * path);

void print_position(char * path, int line, int col, unsigned char  visual_studio_ouput_format, unsigned char  color_enabled)
{
    if (path == 0)
    {
        path = "";
    }
    if (visual_studio_ouput_format)
    {
        print_path(path);
        printf("(%d,%d): ", line, col);
    }
    else
    {
        if (color_enabled)
        {
            printf("\x1b[97m");
        }
        print_path(path);
        if (color_enabled)
        {
            printf("\x1b[97m:%d:%d: ", line, col);
        }
        else
        {
            printf(":%d:%d: ", line, col);
        }
    }
}


int __cdecl putc(int _Character, struct _iobuf * _Stream);

void print_line_and_token(struct marker * p_marker, unsigned char  color_enabled)
{
    if (1) /*try*/
    {
        struct token * p_token;
        int line;
        char nbuffer[20];
        int n;
        struct token * p_line_begin;
        struct token * p_token_begin;
        struct token * p_token_end;
        unsigned char  expand_macro;
        struct token * p_item;
        unsigned char  complete;
        int start_col;
        int end_col;
        unsigned char  onoff;

        p_token = p_marker->p_token_caret ? p_marker->p_token_caret : p_marker->p_token_begin;
        if (p_token == 0)
        {
            goto __L0; /* throw */
        }
        line = p_marker->line;
        if (color_enabled)
        {
            printf("\x1b[0m");
        }
        _cake_zmem(&nbuffer, 20);
        n = snprintf(nbuffer, 20, "%d", line);
        printf(" %s |", nbuffer);
        p_line_begin = p_token;
        while (p_line_begin->prev && (p_line_begin->prev->type != 10 && p_line_begin->prev->type != 8998 && p_line_begin->prev->type != 129))
        {
            p_line_begin = p_line_begin->prev;
        }
        p_token_begin = p_marker->p_token_begin ? p_marker->p_token_begin : p_marker->p_token_caret;
        p_token_end = p_marker->p_token_end ? p_marker->p_token_end : p_marker->p_token_caret;
        if (p_token_begin == 0)
        {
            goto __L0; /* throw */
        }
        expand_macro = ((p_token_begin->flags & 2) != 0);
        if (color_enabled)
        {
            printf("\x1b[34;1m");
        }
        p_item = p_line_begin;
        while (p_item)
        {
            if (color_enabled)
            {
                if (p_item->flags & 2)
                {
                    printf("\x1b[90m");
                }
                else
                {
                    if (p_item->type >= 8999 && p_item->type <= 9100)
                    {
                        printf("\x1b[34m");
                    }
                    else
                    {
                        if (p_item->type == 133 || p_item->type == 132)
                        {
                            printf("\x1b[93m");
                        }
                    }
                }
            }
            if (!(p_item->flags & 2) || expand_macro)
            {
                char * p;

                p = p_item->lexeme;
                if (p_item->type == 132)
                {
                    while (*p && *p != 10 && *p != 13)
                    {
                        putc(*p, (__acrt_iob_func(1)));
                        p++;
                    }
                }
                else
                {
                    while (*p)
                    {
                        putc(*p, (__acrt_iob_func(1)));
                        p++;
                    }
                }
            }
            if (color_enabled)
            {
                printf("\x1b[0m");
            }
            if (p_item->type == 10)
            {
                break;
            }
            if (p_item->type == 129)
            {
                break;
            }
            p_item = p_item->next;
        }
        if (color_enabled)
        {
            printf("\x1b[0m");
        }
        if (p_item == 0)
        {
            printf("\n");
        }
        printf(" %*s |", n, " ");
        complete = 0;
        start_col = 1;
        end_col = 1;
        onoff = 0;
        p_item = p_line_begin;
        while (p_item)
        {
            if (p_item == p_token_begin)
            {
                if (color_enabled)
                {
                    printf("\x1b[92m");
                }
                onoff = 1;
                end_col = start_col;
            }
            if (!(p_item->flags & 2) || expand_macro)
            {
                char * p;

                p = p_item->lexeme;
                while (*p)
                {
                    if (onoff)
                    {
                        putc(126, (__acrt_iob_func(1)));
                        end_col++;
                    }
                    else
                    {
                        if (*p == 9)
                        {
                            putc(*p, (__acrt_iob_func(1)));
                        }
                        else
                        {
                            putc(32, (__acrt_iob_func(1)));
                        }
                        if (!complete)
                        {
                            start_col++;
                        }
                    }
                    p++;
                }
            }
            if (p_item->type == 10)
            {
                break;
            }
            if (p_item == p_token_end)
            {
                complete = 1;
                onoff = 0;
                if (color_enabled)
                {
                    printf("\x1b[0m");
                }
            }
            p_item = p_item->next;
        }
        if (color_enabled)
        {
            printf("\x1b[0m");
        }
        printf("\n");
        p_marker->start_col = start_col;
        p_marker->end_col = end_col;
    }
    else __L0: /*catch*/ 
    {
    }
}


void stream_match(struct stream * stream);
static void digit_sequence_opt(struct stream * stream);
static void exponent_part_opt(struct stream * stream);
static void floating_suffix_opt(struct stream * stream, char suffix[4]);
static unsigned char is_hexadecimal_digit(struct stream * stream);
static void integer_suffix_opt(struct stream * stream, char suffix[4]);
static void hexadecimal_digit_sequence(struct stream * stream);
static void binary_exponent_part(struct stream * stream);
static unsigned char is_binary_digit(struct stream * stream);
static unsigned char is_octal_digit(struct stream * stream);
static unsigned char is_nonzero_digit(struct stream * stream);

int parse_number_core(struct stream * stream, char suffix[4], char errmsg[100])
{
    int type;

    errmsg[0] = 0;
    type = 0;
    if (stream->current[0] == 46)
    {
        type = 140;
        stream_match(stream);
        if (stream->current[0] == 46)
        {
            snprintf(errmsg, 100, "too many decimal points in number");
            return 0;
        }
        digit_sequence_opt(stream);
        exponent_part_opt(stream);
        floating_suffix_opt(stream, suffix);
    }
    else
    {
        if (stream->current[0] == 48 && (stream->current[1] == 120 || stream->current[1] == 88))
        {
            type = 138;
            stream_match(stream);
            stream_match(stream);
            if (is_hexadecimal_digit(stream))
            {
                while (is_hexadecimal_digit(stream))
                {
                    stream_match(stream);
                }
            }
            else
            {
                snprintf(errmsg, 100, "expected hexadecimal digit");
                return 0;
            }
            integer_suffix_opt(stream, suffix);
            if (stream->current[0] == 46)
            {
                type = 141;
                hexadecimal_digit_sequence(stream);
            }
            if (stream->current[0] == 112 || stream->current[0] == 80)
            {
                type = 141;
                binary_exponent_part(stream);
            }
            if (type == 141)
            {
                floating_suffix_opt(stream, suffix);
            }
        }
        else
        {
            if (stream->current[0] == 48 && (stream->current[1] == 98 || stream->current[1] == 66))
            {
                type = 139;
                stream_match(stream);
                stream_match(stream);
                if (is_binary_digit(stream))
                {
                    while (is_binary_digit(stream))
                    {
                        stream_match(stream);
                    }
                }
                else
                {
                    snprintf(errmsg, 100, "expected binary digit");
                    return 0;
                }
                integer_suffix_opt(stream, suffix);
            }
            else
            {
                if (stream->current[0] == 48)
                {
                    type = 137;
                    stream_match(stream);
                    if (stream->current[0] == 79 || stream->current[0] == 111)
                    {
                        stream_match(stream);
                    }
                    while (is_octal_digit(stream))
                    {
                        stream_match(stream);
                    }
                    integer_suffix_opt(stream, suffix);
                    if (stream->current[0] == 46)
                    {
                        type = 140;
                        hexadecimal_digit_sequence(stream);
                        floating_suffix_opt(stream, suffix);
                    }
                }
                else
                {
                    if (is_nonzero_digit(stream))
                    {
                        type = 136;
                        stream_match(stream);
                        while (is_digit(stream))
                        {
                            stream_match(stream);
                        }
                        integer_suffix_opt(stream, suffix);
                        if (stream->current[0] == 101 || stream->current[0] == 69)
                        {
                            exponent_part_opt(stream);
                            floating_suffix_opt(stream, suffix);
                            type = 140;
                        }
                        else
                        {
                            if (stream->current[0] == 46)
                            {
                                stream_match(stream);
                                type = 140;
                                if (stream->current[0] == 46)
                                {
                                    snprintf(errmsg, 100, "too many decimal points in number");
                                    return 0;
                                }
                                digit_sequence_opt(stream);
                                exponent_part_opt(stream);
                                floating_suffix_opt(stream, suffix);
                            }
                        }
                    }
                }
            }
        }
    }
    return type;
}



static void digit_sequence_opt(struct stream * stream)
{
    while (is_digit(stream))
    {
        stream_match(stream);
    }
}

static void exponent_part_opt(struct stream * stream)
{
    if (stream->current[0] == 101 || stream->current[0] == 69)
    {
        stream_match(stream);
        if (stream->current[0] == 45 || stream->current[0] == 43)
        {
            stream_match(stream);
        }
        digit_sequence_opt(stream);
    }
}

static void floating_suffix_opt(struct stream * stream, char suffix[4])
{
    if (stream->current[0] == 108 || stream->current[0] == 76)
    {
        suffix[0] = 76;
        stream_match(stream);
    }
    else
    {
        if (stream->current[0] == 102 || stream->current[0] == 70)
        {
            suffix[0] = 70;
            stream_match(stream);
        }
    }
}

static unsigned char is_hexadecimal_digit(struct stream * stream)
{
    return (stream->current[0] >= 48 && stream->current[0] <= 57) || (stream->current[0] >= 97 && stream->current[0] <= 102) || (stream->current[0] >= 65 && stream->current[0] <= 70);
}

static void integer_suffix_opt(struct stream * stream, char suffix[4])
{
    if (stream->current[0] == 85 || stream->current[0] == 117)
    {
        suffix[0] = 85;
        stream_match(stream);
        if (stream->current[0] == 108 || stream->current[0] == 76)
        {
            suffix[1] = 76;
            stream_match(stream);
        }
        if (stream->current[0] == 108 || stream->current[0] == 76)
        {
            suffix[2] = 76;
            stream_match(stream);
        }
    }
    else
    {
        if ((stream->current[0] == 108 || stream->current[0] == 76))
        {
            suffix[0] = 76;
            stream_match(stream);
            if ((stream->current[0] == 108 || stream->current[0] == 76))
            {
                suffix[1] = 76;
                stream_match(stream);
            }
            if (stream->current[0] == 85 || stream->current[0] == 117)
            {
                suffix[3] = suffix[2];
                suffix[2] = suffix[1];
                suffix[1] = suffix[0];
                suffix[0] = 85;
                stream_match(stream);
            }
        }
        else
        {
            if (stream->current[0] == 105 && stream->current[1] == 56)
            {
                stream_match(stream);
                stream_match(stream);
                stream_match(stream);
                suffix[0] = 105;
                suffix[1] = 56;
            }
            else
            {
                if (stream->current[0] == 105 && stream->current[1] == 51 && stream->current[2] == 50)
                {
                    stream_match(stream);
                    stream_match(stream);
                    stream_match(stream);
                    suffix[0] = 105;
                    suffix[1] = 51;
                    suffix[2] = 50;
                }
                else
                {
                    if (stream->current[0] == 105 && stream->current[1] == 54 && stream->current[2] == 52)
                    {
                        stream_match(stream);
                        stream_match(stream);
                        stream_match(stream);
                        suffix[0] = 105;
                        suffix[1] = 54;
                        suffix[2] = 52;
                    }
                }
            }
        }
    }
}

static void hexadecimal_digit_sequence(struct stream * stream)
{
    stream_match(stream);
    while (stream->current[0] == 39 || is_hexadecimal_digit(stream))
    {
        if (stream->current[0] == 39)
        {
            stream_match(stream);
            if (!is_hexadecimal_digit(stream))
            {
            }
            stream_match(stream);
        }
        else
        {
            stream_match(stream);
        }
    }
}

static void binary_exponent_part(struct stream * stream)
{
    stream_match(stream);
    if (stream->current[0] == 43 || stream->current[0] == 45)
    {
        stream_match(stream);
    }
    digit_sequence_opt(stream);
}

static unsigned char is_binary_digit(struct stream * stream)
{
    return stream->current[0] >= 48 && stream->current[0] <= 49;
}

static unsigned char is_octal_digit(struct stream * stream)
{
    return stream->current[0] >= 48 && stream->current[0] <= 55;
}

static unsigned char is_nonzero_digit(struct stream * stream)
{
    return stream->current[0] >= 49 && stream->current[0] <= 57;
}
int parse_number(char * lexeme, char suffix[4], char errmsg[100])
{
    struct stream  stream;

    stream.source = lexeme;
    stream.current = lexeme;
    stream.line = 1;
    stream.col = 1;
    stream.line_continuation_count = 0;
    stream.path = "";
    return parse_number_core(&stream, suffix, errmsg);
}


unsigned char *utf8_decode(unsigned char * s, unsigned int * c)
{
    unsigned char * next;

    *c = 0;
    if (s[0] == 0)
    {
        *c = 0;
        return 0;
    }
    next = 0;
    if (s[0] < 128)
    {
        *c = s[0];
        ;
        next = s + 1;
    }
    else
    {
        if ((s[0] & 224) == 192)
        {
            *c = ((int)(s[0] & 31) << 6) | ((int)(s[1] & 63) << 0);
            ;
            next = s + 2;
        }
        else
        {
            if ((s[0] & 240) == 224)
            {
                *c = ((int)(s[0] & 15) << 12) | ((int)(s[1] & 63) << 6) | ((int)(s[2] & 63) << 0);
                ;
                next = s + 3;
            }
            else
            {
                if ((s[0] & 248) == 240 && (s[0] <= 244))
                {
                    *c = ((int)(s[0] & 7) << 18) | ((int)(s[1] & 63) << 12) | ((int)(s[2] & 63) << 6) | ((int)(s[3] & 63) << 0);
                    ;
                    next = s + 4;
                }
                else
                {
                    *c = 0;
                    next = s + 1;
                }
            }
        }
    }
    if (*c >= 55296 && *c <= 57343)
    {
        *c = 0;
    }
    return next;
}


static unsigned char is_hex_digit(unsigned char c);

unsigned char *escape_sequences_decode_opt(unsigned char * p, unsigned int * out_value)
{
    if (*p == 120)
    {
        int result;

        p++;
        result = 0;
        while (is_hex_digit(*p))
        {
            int byte;

            byte = 0;
            if (*p >= 48 && *p <= 57)
            {
                byte = (*p - 48);
            }
            else
            {
                if (*p >= 97 && *p <= 102)
                {
                    byte = (*p - 97) + 10;
                }
                else
                {
                    if (*p >= 65 && *p <= 70)
                    {
                        byte = (*p - 65) + 10;
                    }
                }
            }
            result = (result << 4) | (byte & 15);
            p++;
        }
        *out_value = result;
    }
    else
    {
        if (*p == 117 || *p == 85)
        {
            int num_of_hex_digits;
            unsigned long long result;

            num_of_hex_digits = *p == 85 ? 8 : 4;
            p++;
            result = 0;
            {
                int i;

                i = 0;
                for (; i < num_of_hex_digits; i++)
                {
                    int byte;

                    byte = 0;
                    if (*p >= 48 && *p <= 57)
                    {
                        byte = (*p - 48);
                    }
                    else
                    {
                        if (*p >= 97 && *p <= 102)
                        {
                            byte = (*p - 97) + 10;
                        }
                        else
                        {
                            if (*p >= 65 && *p <= 70)
                            {
                                byte = (*p - 65) + 10;
                            }
                        }
                    }
                    result = (result << 4) | (byte & 15);
                    p++;
                }
            }
            *out_value = (int)result;
        }
        else
        {
            if (*p >= 48 && *p <= 55)
            {
                int result;

                result = 0;
                while ((*p >= 48 && *p <= 55))
                {
                    result = (result << 3) | (*p - 48);
                    p++;
                }
                *out_value = result;
            }
            else
            {
                /*switch*/
                {
                    unsigned char __v0 = *p;
                    if (__v0 == 97) goto __L10; /*case 97*/
                    if (__v0 == 98) goto __L11; /*case 98*/
                    if (__v0 == 102) goto __L12; /*case 102*/
                    if (__v0 == 110) goto __L13; /*case 110*/
                    if (__v0 == 114) goto __L14; /*case 114*/
                    if (__v0 == 116) goto __L15; /*case 116*/
                    if (__v0 == 118) goto __L16; /*case 118*/
                    if (__v0 == 39) goto __L17; /*case 39*/
                    if (__v0 == 92) goto __L18; /*case 92*/
                    if (__v0 == 34) goto __L19; /*case 34*/
                    if (__v0 == 10) goto __L20; /*case 10*/
                    goto __L21; /* default */

                    {
                        __L10: /*case 97*/ 
                        *out_value = 7;
                        goto __L9; /* break */

                        __L11: /*case 98*/ 
                        *out_value = 8;
                        goto __L9; /* break */

                        __L12: /*case 102*/ 
                        *out_value = 12;
                        goto __L9; /* break */

                        __L13: /*case 110*/ 
                        *out_value = 10;
                        goto __L9; /* break */

                        __L14: /*case 114*/ 
                        *out_value = 13;
                        goto __L9; /* break */

                        ;
                        __L15: /*case 116*/ 
                        *out_value = 9;
                        goto __L9; /* break */

                        __L16: /*case 118*/ 
                        *out_value = 11;
                        goto __L9; /* break */

                        __L17: /*case 39*/ 
                        *out_value = 39;
                        goto __L9; /* break */

                        __L18: /*case 92*/ 
                        *out_value = 92;
                        goto __L9; /* break */

                        __L19: /*case 34*/ 
                        *out_value = 34;
                        goto __L9; /* break */

                        __L20: /*case 10*/ 
                        goto __L9; /* break */

                        __L21: /* default */ 
                        ;
                        return 0;
                    }
                    __L9:;
                }
                p++;
            }
        }
    }
    return p;
}



static unsigned char is_hex_digit(unsigned char c)
{
    if (c >= 48 && c <= 57)
    {
        return 1;
    }
    else
    {
        if (c >= 97 && c <= 102)
        {
            return 1;
        }
        else
        {
            if (c >= 65 && c <= 70)
            {
                return 1;
            }
        }
    }
    return 0;
}
void enum_specifier_delete(struct enum_specifier * p);
void struct_or_union_specifier_delete(struct struct_or_union_specifier * p);
void enumerator_delete(struct enumerator * p);
void declarator_delete(struct declarator * p);
void init_declarator_delete(struct init_declarator * p);
void macro_delete(struct macro * p);
void struct_entry_delete(struct struct_entry * p);

void map_entry_delete(struct map_entry * p)
{
    if (p == 0)
    {
        return;
    }
    /*switch*/
    {
        int __v0 = p->type;
        if (__v0 == 0) goto __L2; /*case 0*/
        if (__v0 == 1) goto __L3; /*case 1*/
        if (__v0 == 2) goto __L4; /*case 2*/
        if (__v0 == 3) goto __L5; /*case 3*/
        if (__v0 == 4) goto __L6; /*case 4*/
        if (__v0 == 5) goto __L7; /*case 5*/
        if (__v0 == 6) goto __L8; /*case 6*/
        if (__v0 == 7) goto __L9; /*case 7*/
        goto __L1;

        {
            __L2: /*case 0*/ 
            goto __L1; /* break */

            __L3: /*case 1*/ 
            enum_specifier_delete(p->data.p_enum_specifier);
            goto __L1; /* break */

            __L4: /*case 2*/ 
            struct_or_union_specifier_delete(p->data.p_struct_or_union_specifier);
            goto __L1; /* break */

            __L5: /*case 3*/ 
            enumerator_delete(p->data.p_enumerator);
            goto __L1; /* break */

            __L6: /*case 4*/ 
            declarator_delete(p->data.p_declarator);
            goto __L1; /* break */

            __L7: /*case 5*/ 
            init_declarator_delete(p->data.p_init_declarator);
            goto __L1; /* break */

            __L8: /*case 6*/ 
            macro_delete(p->data.p_macro);
            goto __L1; /* break */

            __L9: /*case 7*/ 
            struct_entry_delete(p->data.p_struct_entry);
            goto __L1; /* break */

        }
        __L1:;
    }
    free(p->key);
    free(p);
}


void hashmap_remove_all(struct hash_map * map)
{
    if (map->table != 0)
    {
        {
            int i;

            i = 0;
            for (; i < map->capacity; i++)
            {
                struct map_entry * pentry;

                pentry = map->table[i];
                while (pentry != 0)
                {
                    struct map_entry * next;

                    next = pentry->next;
                    map_entry_delete(pentry);
                    pentry = next;
                }
            }
        }
        free(map->table);
        map->table = 0;
        map->size = 0;
    }
}


void hashmap_destroy(struct hash_map * map)
{
    hashmap_remove_all(map);
    ;
}


static unsigned int string_hash(char * key);
unsigned int __cdecl strlen(char * _Str);

struct map_entry *hashmap_find(struct hash_map * map, char * key)
{
    unsigned int hash;
    int index;
    struct map_entry * pentry;

    if (map->table == 0)
    {
        return 0;
    }
    hash = string_hash(key);
    index = hash % map->capacity;
    pentry = map->table[index];
    for (; pentry != 0; pentry = pentry->next)
    {
        if (pentry->hash == hash && strcmp(pentry->key, key) == 0)
        {
            return pentry;
        }
    }
    return 0;
}



static unsigned int string_hash(char * key)
{
    unsigned int hash_val;
    unsigned int first;
    unsigned int last;
    unsigned int stride;

    hash_val = 2166136261;
    first = 0;
    last = (unsigned int)strlen(key);
    stride = 1 + last / 10;
    for (; first < last; first += stride)
    {
        hash_val = 16777619 * hash_val ^ (unsigned int)key[first];
    }
    return (hash_val);
}
void *hashmap_remove(struct hash_map * map, char * key, int * p_type_opt)
{
    if (map->table != 0)
    {
        unsigned int hash;
        struct map_entry ** pp_entry;
        struct map_entry * p_entry;

        hash = string_hash(key);
        pp_entry = &map->table[hash % map->capacity];
        p_entry = *pp_entry;
        for (; p_entry != 0; p_entry = p_entry->next)
        {
            if ((p_entry->hash == hash) && (strcmp(p_entry->key, key) == 0))
            {
                void * p;

                *pp_entry = p_entry->next;
                if (p_type_opt)
                {
                    *p_type_opt = p_entry->type;
                }
                p = p_entry->data.p_declarator;
                free((void *)p_entry->key);
                free((void *)p_entry);
                return p;
            }
            pp_entry = &p_entry->next;
        }
    }
    return 0;
}


void hash_item_set_destroy(struct hash_item_set * p)
{
    declarator_delete(p->p_declarator);
    enumerator_delete(p->p_enumerator);
    enum_specifier_delete(p->p_enum_specifier);
    init_declarator_delete(p->p_init_declarator);
    struct_or_union_specifier_delete(p->p_struct_or_union_specifier);
    macro_delete(p->p_macro);
}


int hashmap_set(struct hash_map * map, char * key, struct hash_item_set * item)
{
    int result;
    void * p;
    int type;

    result = 0;
    p = 0;
    type = 0;
    if (item->p_declarator)
    {
        type = 4;
        p = item->p_declarator;
        item->p_declarator = 0;
    }
    else
    {
        if (item->p_enumerator)
        {
            type = 3;
            p = item->p_enumerator;
            item->p_enumerator = 0;
        }
        else
        {
            if (item->p_enum_specifier)
            {
                type = 1;
                p = item->p_enum_specifier;
                item->p_enum_specifier = 0;
            }
            else
            {
                if (item->p_init_declarator)
                {
                    type = 5;
                    p = item->p_init_declarator;
                    item->p_init_declarator = 0;
                }
                else
                {
                    if (item->p_struct_or_union_specifier)
                    {
                        type = 2;
                        p = item->p_struct_or_union_specifier;
                        item->p_struct_or_union_specifier = 0;
                    }
                    else
                    {
                        if (item->p_macro)
                        {
                            type = 6;
                            p = item->p_macro;
                            item->p_macro = 0;
                        }
                        else
                        {
                            if (item->p_struct_entry)
                            {
                                type = 7;
                                p = item->p_struct_entry;
                                item->p_struct_entry = 0;
                            }
                            else
                            {
                                type = 0;
                                p = (void *)item->number;
                            }
                        }
                    }
                }
            }
        }
    }
    if (1) /*try*/
    {
        if (map->table == 0)
        {
            if (map->capacity < 1)
            {
                map->capacity = 1000;
            }
            map->table = calloc(map->capacity, 4);
            if (map->table == 0)
            {
                goto __L7; /* throw */
            }
        }
        if (map->table != 0)
        {
            unsigned int hash;
            int index;
            struct map_entry * pentry;

            hash = string_hash(key);
            index = hash % map->capacity;
            pentry = map->table[index];
            for (; pentry != 0; pentry = pentry->next)
            {
                if (pentry->hash == hash && strcmp(pentry->key, key) == 0)
                {
                    break;
                }
            }
            if (pentry == 0)
            {
                struct map_entry * p_new_entry;
                char * temp_key;

                p_new_entry = calloc(1, 20);
                if (p_new_entry == 0)
                {
                    goto __L7; /* throw */
                }
                p_new_entry->hash = hash;
                p_new_entry->data.p_declarator = (void *)p;
                p_new_entry->type = type;
                temp_key = strdup(key);
                if (temp_key == 0)
                {
                    map_entry_delete(p_new_entry);
                    goto __L7; /* throw */
                }
                p_new_entry->key = temp_key;
                p_new_entry->next = map->table[index];
                map->table[index] = p_new_entry;
                map->size++;
                result = 0;
            }
            else
            {
                /*switch*/
                {
                    int __v0 = pentry->type;
                    if (__v0 == 0) goto __L17; /*case 0*/
                    if (__v0 == 1) goto __L18; /*case 1*/
                    if (__v0 == 2) goto __L19; /*case 2*/
                    if (__v0 == 3) goto __L20; /*case 3*/
                    if (__v0 == 4) goto __L21; /*case 4*/
                    if (__v0 == 5) goto __L22; /*case 5*/
                    if (__v0 == 6) goto __L23; /*case 6*/
                    if (__v0 == 7) goto __L24; /*case 7*/
                    goto __L16;

                    {
                        __L17: /*case 0*/ 
                        goto __L16; /* break */

                        __L18: /*case 1*/ 
                        ;
                        item->p_enum_specifier = pentry->data.p_enum_specifier;
                        goto __L16; /* break */

                        __L19: /*case 2*/ 
                        ;
                        item->p_struct_or_union_specifier = pentry->data.p_struct_or_union_specifier;
                        goto __L16; /* break */

                        __L20: /*case 3*/ 
                        ;
                        item->p_enumerator = pentry->data.p_enumerator;
                        goto __L16; /* break */

                        __L21: /*case 4*/ 
                        ;
                        item->p_declarator = pentry->data.p_declarator;
                        goto __L16; /* break */

                        __L22: /*case 5*/ 
                        ;
                        item->p_init_declarator = pentry->data.p_init_declarator;
                        goto __L16; /* break */

                        __L23: /*case 6*/ 
                        ;
                        item->p_macro = pentry->data.p_macro;
                        goto __L16; /* break */

                        __L24: /*case 7*/ 
                        ;
                        item->p_struct_entry = pentry->data.p_struct_entry;
                        goto __L16; /* break */

                    }
                    __L16:;
                }
                result = 1;
                pentry->data.p_declarator = (void *)p;
                pentry->type = type;
            }
        }
    }
    else __L7: /*catch*/ 
    {
    }
    return result;
}


void *__stdcall GetStdHandle(unsigned long nStdHandle);
int __stdcall GetConsoleMode(void * hConsoleHandle, unsigned long * lpMode);
int __stdcall SetConsoleMode(void * hConsoleHandle, unsigned long dwMode);
int __stdcall SetConsoleOutputCP(unsigned int wCodePageID);

unsigned char enable_vt_mode(void)
{
    unsigned long mode;
    void * h_out;

    mode = 0;
    h_out = GetStdHandle(4294967285L);
    if (h_out != ((void *)-1L) && GetConsoleMode(h_out, &mode) != 0 && SetConsoleMode(h_out, mode |= 4) != 0 && SetConsoleOutputCP(65001) != 0)
    {
        return 1;
    }
    return 0;
}


int __cdecl _kbhit(void);

int c_kbhit(void)
{
    return _kbhit();
}


int __cdecl _getch(void);

int c_getch(void)
{
    return _getch();
}


int __cdecl puts(char * _Buffer);
int __cdecl fflush(struct _iobuf * _Stream);

void c_clrscr()
{
    puts("\x1b[2J\x1b[1;1H");
    puts("\x1b[3J");
    fflush((__acrt_iob_func(1)));
}


void c_gotoxy(int x, int y)
{
    printf("\x1b[%d;%dH", y, x);
    fflush((__acrt_iob_func(1)));
}


void include_dir_list_destroy(struct include_dir_list * list)
{
    struct include_dir * p;

    p = list->head;
    while (p)
    {
        struct include_dir * next;

        next = p->next;
        free((void *)p->path);
        free(p);
        p = next;
    }
}


void preprocessor_ctx_destroy(struct preprocessor_ctx * p)
{
    hashmap_destroy(&p->macros);
    include_dir_list_destroy(&p->include_dir);
    hashmap_destroy(&p->pragma_once_map);
    token_list_destroy(&p->input_list);
}


unsigned char preprocessor_diagnostic(int w, struct preprocessor_ctx * ctx, struct token * p_token, char * fmt, ...);

void pre_unexpected_end_of_file(struct token * p_token, struct preprocessor_ctx * ctx)
{
    preprocessor_diagnostic(970, ctx, p_token, "unexpected end of file");
}


unsigned char options_diagnostic_is_error(struct options * options, int w);
unsigned char options_diagnostic_is_warning(struct options * options, int w);
unsigned char options_diagnostic_is_note(struct options * options, int w);

unsigned char preprocessor_diagnostic(int w, struct preprocessor_ctx * ctx, struct token * p_token_opt, char * fmt, ...)
{
    struct marker  marker;
    unsigned char  included_file_location;
    unsigned char  is_error;
    unsigned char  is_warning;
    unsigned char  is_note;
    unsigned char  color_enabled;
    char buffer[200];
    char * args;

    _cake_zmem(&marker, 28);
    if (p_token_opt == 0)
    {
        return 0;
    }
    marker.file = p_token_opt->token_origin->lexeme;
    marker.line = p_token_opt->line;
    marker.start_col = p_token_opt->col;
    marker.end_col = p_token_opt->col;
    marker.p_token_caret = p_token_opt;
    included_file_location = p_token_opt->level > 0;
    is_error = options_diagnostic_is_error(&ctx->options, w);
    is_warning = options_diagnostic_is_warning(&ctx->options, w);
    is_note = options_diagnostic_is_note(&ctx->options, w);
    if (is_error)
    {
        ctx->n_errors++;
    }
    else
    {
        if (is_warning)
        {
            ctx->n_warnings++;
        }
        else
        {
            if (is_note)
            {
            }
            else
            {
                if (w == 0)
                {
                }
                else
                {
                    return 0;
                }
            }
        }
    }
    if (w != 0 && !is_error && included_file_location)
    {
        return 0;
    }
    color_enabled = !ctx->options.color_disabled;
    print_position(marker.file, marker.line, marker.start_col, ctx->options.visual_studio_ouput_format, color_enabled);
    _cake_zmem(&buffer, 200);
    _cake_zmem(&args, 4);
    ((void)(args = (char *)(&(fmt)) + 4));
    vsnprintf(buffer, 200, fmt, args);
    ((void)(args = (char *)0));
    if (ctx->options.visual_studio_ouput_format)
    {
        if (is_warning)
        {
            printf("warning: %s\n", buffer);
        }
        else
        {
            if (is_error)
            {
                printf("warning: %s\n", buffer);
            }
            else
            {
                if (is_note)
                {
                    printf("note: %s\n", buffer);
                }
            }
        }
        print_line_and_token(&marker, ctx->options.visual_studio_ouput_format);
    }
    else
    {
        if (is_error)
        {
            if (color_enabled)
            {
                printf("\x1b[91merror \x1b[97mC%04d: %s\n\x1b[0m", w, buffer);
            }
            else
            {
                printf("error C%04d: %s\n", w, buffer);
            }
        }
        else
        {
            if (is_warning)
            {
                if (color_enabled)
                {
                    printf("\x1b[95mwarning \x1b[97mC%04d: %s\n\x1b[0m", w, buffer);
                }
                else
                {
                    printf("warning C%04d: %s\n", w, buffer);
                }
            }
            else
            {
                if (is_note)
                {
                    if (color_enabled)
                    {
                        printf("\x1b[36;1mnote: \x1b[97m%s\n\x1b[0m", buffer);
                    }
                    else
                    {
                        printf("note: %s\n", buffer);
                    }
                }
            }
        }
        print_line_and_token(&marker, ctx->options.visual_studio_ouput_format);
    }
    return 1;
}


struct include_dir *include_dir_add(struct include_dir_list * list, char * path)
{
    if (1) /*try*/
    {
        struct include_dir * p_new_include_dir;
        unsigned int len;

        p_new_include_dir = calloc(1, 8);
        if (p_new_include_dir == 0)
        {
            goto __L0; /* throw */
        }
        len = strlen(path);
        if (path[len - 1] == 92)
        {
            char * temp;

            temp = strdup(path);
            if (temp == 0)
            {
                free(p_new_include_dir);
                goto __L0; /* throw */
            }
            p_new_include_dir->path = temp;
        }
        else
        {
            if (path[len - 1] != 47)
            {
                char * temp;

                temp = calloc(len + 2, 1);
                if (temp == 0)
                {
                    free(p_new_include_dir);
                    goto __L0; /* throw */
                }
                p_new_include_dir->path = temp;
                snprintf((char *)p_new_include_dir->path, len + 2, "%s/", path);
            }
            else
            {
                char * temp;

                temp = strdup(path);
                if (temp == 0)
                {
                    free(p_new_include_dir);
                    goto __L0; /* throw */
                }
                p_new_include_dir->path = temp;
            }
        }
        if (list->head == 0)
        {
            list->head = p_new_include_dir;
            list->tail = p_new_include_dir;
        }
        else
        {
            ;
            ;
            list->tail->next = p_new_include_dir;
            list->tail = p_new_include_dir;
        }
        return list->tail;
    }
    else __L0: /*catch*/ 
    {
    }
    return 0;
}


unsigned char path_is_absolute(char * path);
void path_normalize(char * path);
static unsigned char pragma_once_already_included(struct preprocessor_ctx * ctx, char * path);
char *read_file(char * path, unsigned char  append_newline);
char *realpath(char * path, char * resolved_path);

char *find_and_read_include_file(struct preprocessor_ctx * ctx, char * path, char * current_file_dir, unsigned char  is_angle_bracket_form, unsigned char * p_already_included, char full_path_out[], int full_path_out_size, unsigned char  include_next)
{
    char newpath[200];
    char * content;
    struct include_dir * current;

    _cake_zmem(&newpath, 200);
    full_path_out[0] = 0;
    if (path_is_absolute(path))
    {
        char * content;

        snprintf(newpath, 200, "%s", path);
        path_normalize(newpath);
        if (pragma_once_already_included(ctx, newpath))
        {
            *p_already_included = 1;
            return 0;
        }
        content = read_file(newpath, 1);
        if (content != 0)
        {
            snprintf(full_path_out, full_path_out_size, "%s", path);
            return content;
        }
        return 0;
    }
    content = 0;
    if (!is_angle_bracket_form)
    {
        snprintf(newpath, 200, "%s/%s", current_file_dir, path);
        if (!realpath(newpath, full_path_out))
        {
            full_path_out[0] = 0;
        }
        path_normalize(full_path_out);
        if (pragma_once_already_included(ctx, full_path_out))
        {
            *p_already_included = 1;
            return 0;
        }
        if (full_path_out[0] != 0)
        {
            content = read_file(full_path_out, 1);
        }
        if (content != 0)
        {
            return content;
        }
    }
    current = ctx->include_dir.head;
    while (current)
    {
        unsigned int len;

        len = strlen(current->path);
        if (current->path[len - 1] == 47)
        {
            snprintf(newpath, full_path_out_size, "%s%s", current->path, path);
        }
        else
        {
            snprintf(newpath, full_path_out_size, "%s/%s", current->path, path);
        }
        if (!realpath(newpath, full_path_out))
        {
            full_path_out[0] = 0;
        }
        path_normalize(full_path_out);
        if (pragma_once_already_included(ctx, full_path_out))
        {
            *p_already_included = 1;
            return 0;
        }
        content = read_file(full_path_out, 1);
        if (content != 0)
        {
            if (include_next)
            {
                free(content);
                content = 0;
                include_next = 0;
            }
            else
            {
                return content;
            }
        }
        current = current->next;
    }
    full_path_out[0] = 0;
    return 0;
}



static unsigned char pragma_once_already_included(struct preprocessor_ctx * ctx, char * path)
{
    return hashmap_find(&ctx->pragma_once_map, path) != 0;
}
void add_macro(struct preprocessor_ctx * ctx, char * name)
{
    if (1) /*try*/
    {
        char * name_local;
        struct macro * macro;
        struct hash_item_set  item;

        name_local = strdup(name);
        if (name_local == 0)
        {
            goto __L0; /* throw */
        }
        macro = calloc(1, 32);
        if (macro == 0)
        {
            free(name_local);
            goto __L0; /* throw */
        }
        macro->name = name_local;
        item.number = 0;
        item.p_enum_specifier = 0;
        item.p_enumerator = 0;
        item.p_struct_or_union_specifier = 0;
        item.p_declarator = 0;
        item.p_init_declarator = 0;
        item.p_macro = macro;
        item.p_struct_entry = 0;
        hashmap_set(&ctx->macros, name, &item);
        hash_item_set_destroy(&item);
    }
    else __L0: /*catch*/ 
    {
    }
}


void remove_line_continuation(char * s);

struct token_list copy_argument_list_tokens(struct token_list * list)
{
    struct token_list  r;
    struct token * current;
    unsigned char  is_first;

    _cake_zmem(&r, 8);
    current = list->head;
    while (current && (token_is_blank(current) || current->type == 10))
    {
        current = current->next;
    }
    is_first = 1;
    for (; current; )
    {
        struct token * token;

        if (current && (token_is_blank(current) || current->type == 10))
        {
            if (current == list->tail)
            {
                break;
            }
            current = current->next;
            continue;
        }
        token = token_list_clone_and_add(&r, current);
        if (token->flags & 8)
        {
            token->flags = token->flags & -9;
            token->flags |= 4;
        }
        if (is_first)
        {
            token->flags = token->flags & -5;
            token->flags = token->flags & -9;
            is_first = 0;
        }
        remove_line_continuation(token->lexeme);
        if (current == list->tail)
        {
            break;
        }
        current = current->next;
    }
    return r;
}


void macro_argument_delete(struct macro_argument * p)
{
    if (p)
    {
        ;
        token_list_destroy(&p->tokens);
        free(p);
    }
}


struct token_list copy_argument_list(struct macro_argument * p_macro_argument)
{
    struct token_list  empty;

    if (1) /*try*/
    {
        struct token_list  list;

        list = copy_argument_list_tokens(&p_macro_argument->tokens);
        if (list.head == 0)
        {
            struct token * p_new_token;
            char * temp;

            p_new_token = calloc(1, 40);
            if (p_new_token == 0)
            {
                goto __L0; /* throw */
            }
            temp = strdup("");
            if (temp == 0)
            {
                token_delete(p_new_token);
                goto __L0; /* throw */
            }
            p_new_token->lexeme = temp;
            p_new_token->type = 142;
            token_list_add(&list, p_new_token);
        }
        return list;
    }
    else __L0: /*catch*/ 
    {
    }
    _cake_zmem(&empty, 8);
    return empty;
}


void macro_argument_list_destroy(struct macro_argument_list * list)
{
    struct macro_argument * p;

    token_list_destroy(&list->tokens);
    p = list->head;
    while (p)
    {
        struct macro_argument * next;

        next = p->next;
        p->next = 0;
        macro_argument_delete(p);
        p = next;
    }
}


void print_macro_arguments(unsigned char  color_enabled, struct macro_argument_list * arguments)
{
    struct macro_argument * p_argument;

    p_argument = arguments->head;
    while (p_argument)
    {
        if (p_argument->macro_parameter)
        {
            printf("%s:", p_argument->macro_parameter->name);
        }
        print_list(color_enabled, &p_argument->tokens);
        p_argument = p_argument->next;
    }
}


struct macro_argument *find_macro_argument_by_name(struct macro_argument_list * parameters, char * name)
{
    struct macro_argument * p_macro_argument;

    p_macro_argument = parameters->head;
    while (p_macro_argument)
    {
        if (strcmp(p_macro_argument->macro_parameter->name, name) == 0)
        {
            return p_macro_argument;
        }
        p_macro_argument = p_macro_argument->next;
    }
    return 0;
}


void argument_list_add(struct macro_argument_list * list, struct macro_argument * pnew)
{
    ;
    if (list->head == 0)
    {
        list->head = pnew;
        ;
        list->tail = pnew;
    }
    else
    {
        ;
        ;
        list->tail->next = pnew;
        list->tail = pnew;
    }
}


void print_macro(unsigned char  color_enabled, struct macro * macro)
{
    struct macro_parameter * parameter;

    printf("%s", macro->name);
    if (macro->is_function)
    {
        printf("(");
    }
    parameter = macro->parameters;
    while (parameter)
    {
        if (macro->parameters != parameter)
        {
            printf(",");
        }
        printf("%s", parameter->name);
        parameter = parameter->next;
    }
    if (macro->is_function)
    {
        printf(") ");
    }
    print_list(color_enabled, &macro->replacement_list);
}


void macro_parameters_delete(struct macro_parameter * parameters)
{
    struct macro_parameter * p;

    p = parameters;
    while (p)
    {
        struct macro_parameter * p_next;

        p_next = p->next;
        free((void *)p->name);
        free(p);
        p = p_next;
    }
}


unsigned char macro_is_same(struct macro * macro_a, struct macro * macro_b)
{
    struct macro_parameter * p_a;
    struct macro_parameter * p_b;

    if (macro_a->is_function != macro_b->is_function)
    {
        return 0;
    }
    if (strcmp(macro_a->name, macro_b->name) != 0)
    {
        return 0;
    }
    if (!token_list_is_equal(&macro_a->replacement_list, &macro_b->replacement_list) != 0)
    {
        return 0;
    }
    p_a = macro_a->parameters;
    p_b = macro_b->parameters;
    while (p_a && p_b)
    {
        if (strcmp(p_a->name, p_b->name) != 0)
        {
            return 0;
        }
        p_a = p_a->next;
        p_b = p_b->next;
    }
    return p_a == 0 && p_b == 0;
}


void macro_delete(struct macro * macro)
{
    if (macro)
    {
        struct macro_parameter * p_macro_parameter;

        token_list_destroy(&macro->replacement_list);
        p_macro_parameter = macro->parameters;
        while (p_macro_parameter)
        {
            struct macro_parameter * p_next;

            p_next = p_macro_parameter->next;
            free((void *)p_macro_parameter->name);
            token_list_destroy(&p_macro_parameter->expanded_list);
            free(p_macro_parameter);
            p_macro_parameter = p_next;
        }
        free((void *)macro->name);
        free(macro);
    }
}


struct macro *find_macro(struct preprocessor_ctx * ctx, char * name)
{
    struct map_entry * p_entry;

    p_entry = hashmap_find(&ctx->macros, name);
    if (p_entry == 0)
    {
        return 0;
    }
    return p_entry->data.p_macro;
}


void stream_print_line(struct stream * stream)
{
    char * p;

    p = stream->current;
    while ((p - 1) >= stream->source && *(p - 1) != 10)
    {
        p--;
    }
    while (*p && *(p + 1) != 10)
    {
        printf("%c", *p);
        p++;
    }
    printf("\n");
    {
        int i;

        i = 0;
        for (; i < stream->col - 1; i++)
        printf(" ");
    }
    printf("^\n");
}


void stream_match(struct stream * stream)
{
    if (stream->current[0] == 10)
    {
        stream->line++;
        stream->col = 1;
    }
    else
    {
        stream->col++;
    }
    if (stream->current[0] == 0)
    {
        return;
    }
    stream->current++;
    while (stream->current[0] == 92 && (stream->current[1] == 10 || (stream->current[1] == 13 && stream->current[2] == 10)))
    {
        if (stream->current[1] == 13 && stream->current[2] == 10)
        {
            stream->current++;
            stream->current++;
            stream->current++;
        }
        else
        {
            stream->current++;
            stream->current++;
        }
        stream->line++;
        stream->col = 1;
        stream->line_continuation_count++;
    }
}


void print_line(struct token * p)
{
    struct token * prev;
    struct token * next;

    printf("%s\n", p->token_origin->lexeme);
    prev = p;
    while (prev->prev && prev->prev->type != 10)
    {
        prev = prev->prev;
    }
    next = prev;
    while (next && next->type != 10)
    {
        printf("%s", next->lexeme);
        next = next->next;
    }
    printf("\n");
}


int is_nondigit(struct stream * p)
{
    return (p->current[0] >= 97 && p->current[0] <= 122) || (p->current[0] >= 65 && p->current[0] <= 90) || (p->current[0] == 95) || (p->current[0] == 36);
}


int is_punctuator(struct stream * stream)
{
    int type;

    type = 0;
    /*switch*/
    {
        char __v0 = stream->current[0];
        if (__v0 == 91) goto __L1; /*case 91*/
        if (__v0 == 93) goto __L2; /*case 93*/
        if (__v0 == 40) goto __L3; /*case 40*/
        if (__v0 == 41) goto __L4; /*case 41*/
        if (__v0 == 123) goto __L5; /*case 123*/
        if (__v0 == 125) goto __L6; /*case 125*/
        if (__v0 == 59) goto __L7; /*case 59*/
        if (__v0 == 44) goto __L8; /*case 44*/
        if (__v0 == 33) goto __L9; /*case 33*/
        if (__v0 == 58) goto __L11; /*case 58*/
        if (__v0 == 126) goto __L13; /*case 126*/
        if (__v0 == 63) goto __L14; /*case 63*/
        if (__v0 == 47) goto __L15; /*case 47*/
        if (__v0 == 42) goto __L17; /*case 42*/
        if (__v0 == 37) goto __L19; /*case 37*/
        if (__v0 == 45) goto __L21; /*case 45*/
        if (__v0 == 124) goto __L25; /*case 124*/
        if (__v0 == 43) goto __L28; /*case 43*/
        if (__v0 == 61) goto __L31; /*case 61*/
        if (__v0 == 94) goto __L33; /*case 94*/
        if (__v0 == 38) goto __L35; /*case 38*/
        if (__v0 == 62) goto __L38; /*case 62*/
        if (__v0 == 60) goto __L42; /*case 60*/
        if (__v0 == 35) goto __L46; /*case 35*/
        if (__v0 == 46) goto __L48; /*case 46*/
        goto __L0;

        {
            __L1: /*case 91*/ 
            type = 91;
            stream_match(stream);
            goto __L0; /* break */

            __L2: /*case 93*/ 
            type = 93;
            stream_match(stream);
            goto __L0; /* break */

            __L3: /*case 40*/ 
            type = 40;
            stream_match(stream);
            goto __L0; /* break */

            __L4: /*case 41*/ 
            type = 41;
            stream_match(stream);
            goto __L0; /* break */

            __L5: /*case 123*/ 
            type = 123;
            stream_match(stream);
            goto __L0; /* break */

            __L6: /*case 125*/ 
            type = 125;
            stream_match(stream);
            goto __L0; /* break */

            __L7: /*case 59*/ 
            type = 59;
            stream_match(stream);
            goto __L0; /* break */

            __L8: /*case 44*/ 
            type = 44;
            stream_match(stream);
            goto __L0; /* break */

            __L9: /*case 33*/ 
            type = 33;
            stream_match(stream);
            if (stream->current[0] == 61)
            {
                type = 8509;
                stream_match(stream);
            }
            goto __L0; /* break */

            __L11: /*case 58*/ 
            type = 58;
            stream_match(stream);
            if (stream->current[0] == 58)
            {
                type = 14906;
                stream_match(stream);
            }
            goto __L0; /* break */

            __L13: /*case 126*/ 
            type = 126;
            stream_match(stream);
            goto __L0; /* break */

            __L14: /*case 63*/ 
            type = 63;
            stream_match(stream);
            goto __L0; /* break */

            __L15: /*case 47*/ 
            type = 47;
            stream_match(stream);
            if (stream->current[0] == 61)
            {
                type = 12093;
                stream_match(stream);
            }
            goto __L0; /* break */

            __L17: /*case 42*/ 
            type = 42;
            stream_match(stream);
            if (stream->current[0] == 61)
            {
                type = 10813;
                stream_match(stream);
            }
            goto __L0; /* break */

            __L19: /*case 37*/ 
            type = 37;
            stream_match(stream);
            if (stream->current[0] == 61)
            {
                type = 9533;
                stream_match(stream);
            }
            goto __L0; /* break */

            __L21: /*case 45*/ 
            type = 45;
            stream_match(stream);
            if (stream->current[0] == 62)
            {
                type = 11582;
                stream_match(stream);
            }
            else
            {
                if (stream->current[0] == 45)
                {
                    type = 11565;
                    stream_match(stream);
                }
                else
                {
                    if (stream->current[0] == 61)
                    {
                        type = 11581;
                        stream_match(stream);
                    }
                }
            }
            goto __L0; /* break */

            __L25: /*case 124*/ 
            type = 124;
            stream_match(stream);
            if (stream->current[0] == 124)
            {
                type = 31868;
                stream_match(stream);
            }
            else
            {
                if (stream->current[0] == 61)
                {
                    type = 31805;
                    stream_match(stream);
                }
            }
            goto __L0; /* break */

            __L28: /*case 43*/ 
            type = 43;
            stream_match(stream);
            if (stream->current[0] == 43)
            {
                type = 11051;
                stream_match(stream);
            }
            else
            {
                if (stream->current[0] == 61)
                {
                    type = 11069;
                    stream_match(stream);
                }
            }
            goto __L0; /* break */

            __L31: /*case 61*/ 
            type = 61;
            stream_match(stream);
            if (stream->current[0] == 61)
            {
                type = 15677;
                stream_match(stream);
            }
            goto __L0; /* break */

            __L33: /*case 94*/ 
            type = 94;
            stream_match(stream);
            if (stream->current[0] == 61)
            {
                type = 24125;
                stream_match(stream);
            }
            goto __L0; /* break */

            __L35: /*case 38*/ 
            type = 38;
            stream_match(stream);
            if (stream->current[0] == 38)
            {
                type = 9766;
                stream_match(stream);
            }
            else
            {
                if (stream->current[0] == 61)
                {
                    type = 9789;
                    stream_match(stream);
                }
            }
            goto __L0; /* break */

            __L38: /*case 62*/ 
            type = 62;
            stream_match(stream);
            if (stream->current[0] == 62)
            {
                type = 15934;
                stream_match(stream);
                if (stream->current[0] == 61)
                {
                    type = 4079165;
                    stream_match(stream);
                }
            }
            else
            {
                if (stream->current[0] == 61)
                {
                    type = 15933;
                    stream_match(stream);
                }
            }
            goto __L0; /* break */

            __L42: /*case 60*/ 
            type = 60;
            stream_match(stream);
            if (stream->current[0] == 60)
            {
                type = 15420;
                stream_match(stream);
                if (stream->current[0] == 61)
                {
                    type = 3947581;
                    stream_match(stream);
                }
            }
            else
            {
                if (stream->current[0] == 61)
                {
                    type = 15421;
                    stream_match(stream);
                }
            }
            goto __L0; /* break */

            __L46: /*case 35*/ 
            type = 35;
            stream_match(stream);
            if (stream->current[0] == 35)
            {
                type = 8995;
                stream_match(stream);
            }
            goto __L0; /* break */

            __L48: /*case 46*/ 
            type = 46;
            stream_match(stream);
            if (stream->current[0] == 46 && stream->current[1] == 46)
            {
                type = 3026478;
                stream_match(stream);
                stream_match(stream);
            }
            goto __L0; /* break */

        }
        __L0:;
    }
    return type;
}


char *__cdecl strncpy(char * _Destination, char * _Source, unsigned int _Count);

struct token *new_token(char * lexeme_head, char * lexeme_tail, int type)
{
    struct token * p_new_token;

    p_new_token = 0;
    if (1) /*try*/
    {
        unsigned int sz;
        char * temp;

        p_new_token = calloc(1, 40);
        if (p_new_token == 0)
        {
            goto __L0; /* throw */
        }
        sz = lexeme_tail - lexeme_head;
        temp = calloc(sz + 1, 1);
        if (temp == 0)
        {
            goto __L0; /* throw */
        }
        p_new_token->lexeme = temp;
        p_new_token->type = type;
        strncpy(p_new_token->lexeme, lexeme_head, sz);
    }
    else __L0: /*catch*/ 
    {
        token_delete(p_new_token);
        p_new_token = 0;
    }
    return p_new_token;
}


struct token *identifier(struct stream * stream)
{
    char * start;
    struct token * p_new_token;

    start = stream->current;
    stream_match(stream);
    while (is_nondigit(stream) || is_digit(stream))
    {
        stream_match(stream);
    }
    p_new_token = new_token(start, stream->current, 8996);
    return p_new_token;
}


static void tokenizer_set_warning(struct tokenizer_ctx * ctx, struct stream * stream, char * fmt, ...);

struct token *character_constant(struct tokenizer_ctx * ctx, struct stream * stream)
{
    char * start;
    struct token * p_new_token;

    start = stream->current;
    if (stream->current[0] == 117)
    {
        stream_match(stream);
        if (stream->current[0] == 56)
        {
            stream_match(stream);
        }
    }
    else
    {
        if (stream->current[0] == 85 || stream->current[0] == 76)
        {
            stream_match(stream);
        }
    }
    stream_match(stream);
    while (stream->current[0] != 39)
    {
        if (stream->current[0] == 92)
        {
            stream_match(stream);
            stream_match(stream);
        }
        else
        {
            stream_match(stream);
        }
        if (stream->current[0] == 0 || stream->current[0] == 10)
        {
            tokenizer_set_warning(ctx, stream, "missing terminating ' character");
            break;
        }
    }
    stream_match(stream);
    p_new_token = new_token(start, stream->current, 131);
    return p_new_token;
}



static void tokenizer_set_warning(struct tokenizer_ctx * ctx, struct stream * stream, char * fmt, ...)
{
    unsigned char  color_enabled;
    char buffer[200];
    char * args;

    color_enabled = !ctx->options.color_disabled;
    ctx->n_warnings++;
    _cake_zmem(&buffer, 200);
    _cake_zmem(&args, 4);
    ((void)(args = (char *)(&(fmt)) + 4));
    vsnprintf(buffer, 200, fmt, args);
    ((void)(args = (char *)0));
    print_position(stream->path, stream->line, stream->col, ctx->options.visual_studio_ouput_format, color_enabled);
    if (ctx->options.visual_studio_ouput_format)
    {
        printf("warning: %s\n", buffer);
    }
    else
    {
        if (color_enabled)
        {
            printf("\x1b[95mwarning: \x1b[97m%s\n", buffer);
        }
        else
        {
            printf("warning: %s\n", buffer);
        }
    }
}
static void tokenizer_set_error(struct tokenizer_ctx * ctx, struct stream * stream, char * fmt, ...);

struct token *string_literal(struct tokenizer_ctx * ctx, struct stream * stream)
{
    struct token * p_new_token;
    char * start;

    p_new_token = 0;
    start = stream->current;
    if (1) /*try*/
    {
        if (stream->current[0] == 117)
        {
            stream_match(stream);
            if (stream->current[0] == 56)
            {
                stream_match(stream);
            }
        }
        else
        {
            if (stream->current[0] == 85 || stream->current[0] == 76)
            {
                stream_match(stream);
            }
        }
        stream_match(stream);
        while (stream->current[0] != 34)
        {
            if (stream->current[0] == 0 || stream->current[0] == 10)
            {
                tokenizer_set_error(ctx, stream, "missing terminating \" character");
                goto __L0; /* throw */
            }
            if (stream->current[0] == 92)
            {
                stream_match(stream);
                stream_match(stream);
            }
            else
            {
                stream_match(stream);
            }
        }
        stream_match(stream);
        p_new_token = new_token(start, stream->current, 130);
    }
    else __L0: /*catch*/ 
    {
    }
    return p_new_token;
}



static void tokenizer_set_error(struct tokenizer_ctx * ctx, struct stream * stream, char * fmt, ...)
{
    unsigned char  color_enabled;
    char buffer[200];
    char * args;

    color_enabled = !ctx->options.color_disabled;
    ctx->n_errors++;
    _cake_zmem(&buffer, 200);
    _cake_zmem(&args, 4);
    ((void)(args = (char *)(&(fmt)) + 4));
    vsnprintf(buffer, 200, fmt, args);
    ((void)(args = (char *)0));
    print_position(stream->path, stream->line, stream->col, ctx->options.visual_studio_ouput_format, color_enabled);
    if (ctx->options.visual_studio_ouput_format)
    {
        printf("error: %s\n", buffer);
    }
    else
    {
        if (color_enabled)
        {
            printf("\x1b[91merror: \x1b[97m%s\n", buffer);
        }
        else
        {
            printf("error: %s\n", buffer);
        }
    }
}
struct _iobuf *fopen(char * _FileName, char * _Mode);
unsigned int fread(void * _Buffer, unsigned int _ElementSize, unsigned int _ElementCount, struct _iobuf * _Stream);
int fclose(struct _iobuf * _Stream);

struct token_list embed_tokenizer(struct preprocessor_ctx * ctx, struct token * position, char * filename_opt, int level, int addflags)
{
    struct token_list  list;
    struct _iobuf * file;
    unsigned char  b_first;
    int line;
    int col;
    int count;

    _cake_zmem(&list, 8);
    file = 0;
    b_first = 1;
    line = 1;
    col = 1;
    count = 0;
    if (1) /*try*/
    {
        unsigned char ch;
        char newline[2];
        struct token * p_new_token;

        file = (struct _iobuf *)fopen(filename_opt, "rb");
        if (file == 0)
        {
            preprocessor_diagnostic(1150, ctx, position, "file '%s' not found", filename_opt);
            goto __L0; /* throw */
        }
        ch = 0;
        while (fread(&ch, 1, 1, file))
        {
            char buffer[30];
            int c;
            struct token * p_new_token;

            if (b_first)
            {
                b_first = 0;
            }
            else
            {
                char b[2];
                struct token * p_new_token;

                _cake_memcpy(b, ",", 2);
                p_new_token = new_token(b, &b[1], 44);
                if (p_new_token == 0)
                {
                    goto __L0; /* throw */
                }
                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = 0;
                p_new_token->line = line;
                p_new_token->col = col;
                token_list_add(&list, p_new_token);
                if (count > 0 && count % 25 == 0)
                {
                    char newline[2];
                    struct token * p_new3;

                    _cake_memcpy(newline, "\n", 2);
                    p_new3 = new_token(newline, &newline[1], 10);
                    if (p_new3 == 0)
                    {
                        goto __L0; /* throw */
                    }
                    p_new3->level = level;
                    p_new3->token_origin = 0;
                    p_new3->line = line;
                    p_new3->col = col;
                    token_list_add(&list, p_new3);
                }
            }
            _cake_zmem(&buffer, 30);
            c = snprintf(buffer, 30, "%d", (int)ch);
            p_new_token = new_token(buffer, &buffer[c], 134);
            if (p_new_token == 0)
            {
                goto __L0; /* throw */
            }
            p_new_token->flags |= addflags;
            p_new_token->level = level;
            p_new_token->token_origin = 0;
            p_new_token->line = line;
            p_new_token->col = col;
            token_list_add(&list, p_new_token);
            count++;
        }
        _cake_memcpy(newline, "\n", 2);
        p_new_token = new_token(newline, &newline[1], 10);
        if (p_new_token == 0)
        {
            goto __L0; /* throw */
        }
        p_new_token->level = level;
        p_new_token->token_origin = 0;
        p_new_token->line = line;
        p_new_token->col = col;
        token_list_add(&list, p_new_token);
        ;
    }
    else __L0: /*catch*/ 
    {
    }
    if (file)
    {
        fclose(file);
    }
    return list;
}


int __cdecl isdigit(int _C);
static struct token *ppnumber(struct stream * stream);
static unsigned char set_sliced_flag(struct stream * stream, struct token * p_new_token);
static unsigned char first_of_string_literal(struct stream * stream);
static unsigned char first_of_character_constant(struct stream * stream);

struct token_list tokenizer(struct tokenizer_ctx * ctx, char * text, char * filename_opt, int level, int addflags)
{
    struct token_list  list;
    struct stream  stream;

    _cake_zmem(&list, 8);
    stream.source = text;
    stream.current = text;
    stream.line = 1;
    stream.col = 1;
    stream.line_continuation_count = 0;
    stream.path = filename_opt ? filename_opt : "";
    if (1) /*try*/
    {
        struct token * p_first;
        unsigned char  new_line;
        unsigned char  has_space;

        p_first = 0;
        if (filename_opt != 0)
        {
            char * begin;
            char * end;
            struct token * p_new;

            begin = filename_opt;
            end = filename_opt + strlen(filename_opt);
            p_new = new_token(begin, end, 8998);
            if (p_new == 0)
            {
                goto __L0; /* throw */
            }
            path_normalize(p_new->lexeme);
            p_new->level = level;
            p_first = token_list_add(&list, p_new);
        }
        new_line = 1;
        has_space = 0;
        while (1)
        {
            int line;
            int col;
            char * start;
            int t;

            line = stream.line;
            col = stream.col;
            stream.line_continuation_count = 0;
            if (stream.current[0] == 0)
            {
                stream_match(&stream);
                break;
            }
            if (is_digit(&stream) || (stream.current[0] == 46 && isdigit(stream.current[1])))
            {
                struct token * p_new_token;

                p_new_token = ppnumber(&stream);
                if (p_new_token == 0)
                {
                    goto __L0; /* throw */
                }
                p_new_token->flags |= has_space ? 4 : 0;
                p_new_token->flags |= new_line ? 8 : 0;
                p_new_token->flags |= addflags;
                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = 0;
                has_space = 0;
                continue;
            }
            if (first_of_string_literal(&stream))
            {
                struct token * p_new_token;

                p_new_token = string_literal(ctx, &stream);
                if (p_new_token == 0)
                {
                    goto __L0; /* throw */
                }
                p_new_token->flags |= has_space ? 4 : 0;
                p_new_token->flags |= new_line ? 8 : 0;
                p_new_token->flags |= addflags;
                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = 0;
                has_space = 0;
                continue;
            }
            if (first_of_character_constant(&stream))
            {
                struct token * p_new_token;

                p_new_token = character_constant(ctx, &stream);
                if (p_new_token == 0)
                {
                    goto __L0; /* throw */
                }
                p_new_token->flags |= has_space ? 4 : 0;
                p_new_token->flags |= new_line ? 8 : 0;
                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = 0;
                has_space = 0;
                continue;
            }
            if (is_nondigit(&stream))
            {
                struct token * p_new_token;

                p_new_token = identifier(&stream);
                if (p_new_token == 0)
                {
                    goto __L0; /* throw */
                }
                p_new_token->flags |= has_space ? 4 : 0;
                p_new_token->flags |= new_line ? 8 : 0;
                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                new_line = 0;
                has_space = 0;
                if (set_sliced_flag(&stream, p_new_token))
                {
                    tokenizer_set_warning(ctx, &stream, "token sliced");
                }
                token_list_add(&list, p_new_token);
                continue;
            }
            if (stream.current[0] == 32 || stream.current[0] == 9 || stream.current[0] == 12)
            {
                char * start;
                struct token * p_new_token;

                start = stream.current;
                while (stream.current[0] == 32 || stream.current[0] == 9 || stream.current[0] == 12)
                {
                    stream_match(&stream);
                }
                p_new_token = new_token(start, stream.current, 143);
                if (p_new_token == 0)
                {
                    goto __L0; /* throw */
                }
                p_new_token->flags |= has_space ? 4 : 0;
                p_new_token->flags |= new_line ? 8 : 0;
                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                has_space = 1;
                continue;
            }
            if (stream.current[0] == 47 && stream.current[1] == 47)
            {
                char * start;
                struct token * p_new_token;

                start = stream.current;
                stream_match(&stream);
                stream_match(&stream);
                while (stream.current[0] != 10)
                {
                    stream_match(&stream);
                    if (stream.current[0] == 0)
                    {
                        break;
                    }
                }
                p_new_token = new_token(start, stream.current, 132);
                if (p_new_token == 0)
                {
                    goto __L0; /* throw */
                }
                p_new_token->flags |= has_space ? 4 : 0;
                p_new_token->flags |= new_line ? 8 : 0;
                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = 1;
                has_space = 0;
                if (stream.current[0] == 0)
                {
                    break;
                }
                continue;
            }
            if (stream.current[0] == 47 && stream.current[1] == 42)
            {
                char * start;

                start = stream.current;
                stream_match(&stream);
                stream_match(&stream);
                for (; ; )
                {
                    if (stream.current[0] == 42 && stream.current[1] == 47)
                    {
                        stream_match(&stream);
                        stream_match(&stream);
                        break;
                    }
                    else
                    {
                        if (stream.current[0] == 0)
                        {
                            tokenizer_set_error(ctx, &stream, "missing end of comment");
                            break;
                        }
                        else
                        {
                            stream_match(&stream);
                        }
                    }
                }
                if (ctx->options.comment_to_attribute && start[2] == 33 && start[3] == 119)
                {
                    struct token_list  list2;
                    struct token * p_new_token;

                    list2 = tokenizer(ctx, "[[cake::wN]]", "", level, 0);
                    p_new_token = token_list_pop_front_get(&list2);
                    token_delete(p_new_token);
                    p_new_token = token_list_pop_front_get(&list2);
                    while (p_new_token)
                    {
                        if (strcmp(p_new_token->lexeme, "wN") == 0)
                        {
                            char fmt[10];
                            char * p;

                            free(p_new_token->lexeme);
                            _cake_zmem(&fmt, 10);
                            p = start + 3;
                            {
                                int i;

                                i = 0;
                                for (; i < 10; i++)
                                {
                                    fmt[i] = *p;
                                    if (p == (stream.current - 3))
                                    {
                                        break;
                                    }
                                    p++;
                                }
                            }
                            p_new_token->lexeme = strdup(fmt);
                        }
                        p_new_token->flags |= has_space ? 4 : 0;
                        p_new_token->flags |= new_line ? 8 : 0;
                        p_new_token->flags |= addflags;
                        p_new_token->level = level;
                        p_new_token->token_origin = p_first;
                        p_new_token->line = line;
                        p_new_token->col = col;
                        token_list_add(&list, p_new_token);
                        p_new_token = token_list_pop_front_get(&list2);
                    }
                    token_list_destroy(&list2);
                    new_line = 0;
                    has_space = 0;
                }
                else
                {
                    struct token * p_new_token;

                    p_new_token = new_token(start, stream.current, 133);
                    if (p_new_token == 0)
                    {
                        goto __L0; /* throw */
                    }
                    p_new_token->flags |= has_space ? 4 : 0;
                    p_new_token->flags |= new_line ? 8 : 0;
                    p_new_token->flags |= addflags;
                    p_new_token->level = level;
                    p_new_token->token_origin = p_first;
                    p_new_token->line = line;
                    p_new_token->col = col;
                    token_list_add(&list, p_new_token);
                    new_line = 0;
                    has_space = 0;
                }
                continue;
            }
            if (new_line && stream.current[0] == 35)
            {
                char * start;
                struct token * p_new_token;

                start = stream.current;
                stream_match(&stream);
                p_new_token = new_token(start, stream.current, 35);
                if (p_new_token == 0)
                {
                    goto __L0; /* throw */
                }
                p_new_token->flags |= has_space ? 4 : 0;
                p_new_token->flags |= new_line ? 8 : 0;
                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                p_new_token->type = 127;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = 0;
                has_space = 0;
                continue;
            }
            if (stream.current[0] == 10 || stream.current[0] == 13)
            {
                char newline[2];
                struct token * p_new_token;

                if (stream.current[0] == 13 && stream.current[1] == 10)
                {
                    stream_match(&stream);
                    stream_match(&stream);
                }
                else
                {
                    stream_match(&stream);
                }
                _cake_memcpy(newline, "\n", 2);
                p_new_token = new_token(newline, newline + 1, 10);
                if (p_new_token == 0)
                {
                    goto __L0; /* throw */
                }
                p_new_token->flags |= has_space ? 4 : 0;
                p_new_token->flags |= new_line ? 8 : 0;
                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = 1;
                has_space = 0;
                continue;
            }
            start = stream.current;
            t = is_punctuator(&stream);
            if (t != 0)
            {
                struct token * p_new_token;

                p_new_token = new_token(start, stream.current, t);
                if (p_new_token == 0)
                {
                    goto __L0; /* throw */
                }
                p_new_token->flags |= has_space ? 4 : 0;
                p_new_token->flags |= new_line ? 8 : 0;
                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = 0;
                has_space = 0;
                continue;
            }
            else
            {
                struct token * p_new_token;

                stream_match(&stream);
                p_new_token = new_token(start, stream.current, 135);
                if (p_new_token == 0)
                {
                    goto __L0; /* throw */
                }
                p_new_token->flags |= has_space ? 4 : 0;
                p_new_token->flags |= new_line ? 8 : 0;
                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = 0;
                has_space = 0;
                continue;
            }
            break;
        }
    }
    else __L0: /*catch*/ 
    {
    }
    ;
    return list;
}



static struct token *ppnumber(struct stream * stream)
{
    char * start;
    struct token * p_new_token;

    start = stream->current;
    if (is_digit(stream))
    {
        stream_match(stream);
    }
    else
    {
        if (stream->current[0] == 46)
        {
            stream_match(stream);
            stream_match(stream);
        }
        else
        {
            ;
        }
    }
    for (; ; )
    {
        if (stream->current[0] == 39)
        {
            stream_match(stream);
            if (is_digit(stream))
            {
                stream_match(stream);
            }
            else
            {
                if (is_nondigit(stream))
                {
                    stream_match(stream);
                }
                else
                {
                    ;
                    break;
                }
            }
        }
        else
        {
            if ((stream->current[0] == 101 || stream->current[0] == 69 || stream->current[0] == 112 || stream->current[0] == 80) && (stream->current[1] == 43 || stream->current[1] == 45))
            {
                stream_match(stream);
                stream_match(stream);
            }
            else
            {
                if (stream->current[0] == 46)
                {
                    stream_match(stream);
                }
                else
                {
                    if (is_digit(stream) || is_nondigit(stream))
                    {
                        stream_match(stream);
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }
    }
    p_new_token = new_token(start, stream->current, 134);
    return p_new_token;
}

static unsigned char set_sliced_flag(struct stream * stream, struct token * p_new_token)
{
    if (stream->line_continuation_count > 0)
    {
        p_new_token->flags |= 1024;
        if (stream->line_continuation_count == 1)
        {
            unsigned int l;

            l = strlen(p_new_token->lexeme);
            if (p_new_token->lexeme[l - 1] == 10)
            {
            }
            else
            {
                p_new_token->flags |= 512;
            }
        }
        else
        {
            p_new_token->flags |= 512;
        }
    }
    return ((p_new_token->flags & 512) != 0);
}

static unsigned char first_of_string_literal(struct stream * stream)
{
    return stream->current[0] == 34 || (stream->current[0] == 117 && stream->current[1] == 56 && stream->current[2] == 34) || (stream->current[0] == 117 && stream->current[1] == 34) || (stream->current[0] == 85 && stream->current[1] == 34) || (stream->current[0] == 76 && stream->current[1] == 34);
}

static unsigned char first_of_character_constant(struct stream * stream)
{
    return stream->current[0] == 39 || (stream->current[0] == 117 && stream->current[1] == 56 && stream->current[2] == 39) || (stream->current[0] == 117 && stream->current[1] == 39) || (stream->current[0] == 85 && stream->current[1] == 39) || (stream->current[0] == 76 && stream->current[1] == 39);
}
int __cdecl feof(struct _iobuf * _Stream);

unsigned char fread2(void * buffer, unsigned int size, unsigned int count, struct _iobuf * stream, unsigned int * sz)
{
    unsigned char  result;
    unsigned int n;

    *sz = 0;
    result = 0;
    n = fread(buffer, size, count, stream);
    if (n == count)
    {
        *sz = n;
        result = 1;
    }
    else
    {
        if (n < count)
        {
            if (feof(stream))
            {
                *sz = n;
                result = 1;
            }
        }
    }
    return result;
}


unsigned char preprocessor_token_ahead_is_identifier(struct token * p, char * lexeme);
struct token_list group_part(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level);

struct token_list group_opt(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        if (token_list_is_empty(input_list))
        {
            return r;
        }
        while (!token_list_is_empty(input_list))
        {
            ;
            if (input_list->head->type == 127 && (preprocessor_token_ahead_is_identifier(input_list->head, "endif") || preprocessor_token_ahead_is_identifier(input_list->head, "else") || preprocessor_token_ahead_is_identifier(input_list->head, "elif") || preprocessor_token_ahead_is_identifier(input_list->head, "elifdef") || preprocessor_token_ahead_is_identifier(input_list->head, "elifndef")))
            {
                break;
            }
            else
            {
                struct token_list  r2;

                r2 = group_part(ctx, input_list, is_active, level);
                token_list_append_list(&r, &r2);
                token_list_destroy(&r2);
                if (ctx->n_errors > 0)
                {
                    goto __L0; /* throw */
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}


unsigned char is_parser_token(struct token * p)
{
    return p->type != 133 && p->type != 143 && p->type != 132 && p->type != 10;
}


unsigned char is_never_final(int type)
{
    return type == 8998 || type == 143 || type == 132 || type == 133 || type == 142 || type == 10;
}


struct token *preprocessor_look_ahead_core(struct token * p)
{
    struct token * current;

    current = p->next;
    while (current && (current->type == 143 || current->type == 142 || current->type == 132 || current->type == 133))
    {
        current = current->next;
    }
    return current;
}


unsigned char preprocessor_token_ahead_is(struct token * p, int t)
{
    struct token * p_token;

    p_token = preprocessor_look_ahead_core(p);
    if (p_token != 0 && p_token->type == t)
    {
        return 1;
    }
    return 0;
}


unsigned char preprocessor_token_ahead_is_identifier(struct token * p, char * lexeme)
{
    struct token * p_token;

    ;
    p_token = preprocessor_look_ahead_core(p);
    if (p_token != 0 && p_token->type == 8996)
    {
        return strcmp(p_token->lexeme, lexeme) == 0;
    }
    return 0;
}


void prematch_level(struct token_list * dest, struct token_list * input_list, int level)
{
    if (1)
    {
        struct token * p;

        p = token_list_pop_front_get(input_list);
        if (p)
        {
            token_list_add(dest, p);
        }
    }
    else
    {
        token_list_pop_front(input_list);
    }
}


void prematch(struct token_list * dest, struct token_list * input_list)
{
    struct token * p;

    p = token_list_pop_front_get(input_list);
    if (p)
    {
        token_list_add(dest, p);
    }
}


static void skip_blanks(struct preprocessor_ctx * ctx, struct token_list * dest, struct token_list * input_list);

struct token_list process_defined(struct preprocessor_ctx * ctx, struct token_list * input_list)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        while (input_list->head != 0)
        {
            if (input_list->head->type == 8996 && strcmp(input_list->head->lexeme, "defined") == 0)
            {
                unsigned char  has_parentesis;
                struct macro * macro;
                struct token * p_new_token;
                char * temp;

                token_list_pop_front(input_list);
                skip_blanks(ctx, &r, input_list);
                if (input_list->head == 0)
                {
                    pre_unexpected_end_of_file(r.tail, ctx);
                    goto __L0; /* throw */
                }
                has_parentesis = 0;
                if (input_list->head->type == 40)
                {
                    token_list_pop_front(input_list);
                    has_parentesis = 1;
                }
                skip_blanks(ctx, &r, input_list);
                if (input_list->head == 0)
                {
                    pre_unexpected_end_of_file(r.tail, ctx);
                    goto __L0; /* throw */
                }
                macro = find_macro(ctx, input_list->head->lexeme);
                p_new_token = token_list_pop_front_get(input_list);
                if (p_new_token == 0)
                {
                    goto __L0; /* throw */
                }
                p_new_token->type = 134;
                temp = 0;
                if (macro)
                {
                    temp = strdup("1");
                }
                else
                {
                    temp = strdup("0");
                }
                if (temp == 0)
                {
                    token_delete(p_new_token);
                    goto __L0; /* throw */
                }
                free(p_new_token->lexeme);
                p_new_token->lexeme = temp;
                token_list_add(&r, p_new_token);
                if (has_parentesis)
                {
                    if (input_list->head == 0)
                    {
                        goto __L0; /* throw */
                    }
                    if (input_list->head->type != 41)
                    {
                        preprocessor_diagnostic(1160, ctx, input_list->head, "missing )");
                        goto __L0; /* throw */
                    }
                    token_list_pop_front(input_list);
                }
            }
            else
            {
                if (input_list->head->type == 8996 && (strcmp(input_list->head->lexeme, "__has_include") == 0 || strcmp(input_list->head->lexeme, "__has_embed") == 0))
                {
                    char path[100];
                    unsigned char  is_angle_bracket_form;
                    char fullpath[300];
                    char full_path_result[200];
                    unsigned char  already_included;
                    char * s;
                    unsigned char  has_include;
                    struct token * p_new_token;
                    char * temp;

                    token_list_pop_front(input_list);
                    skip_blanks(ctx, &r, input_list);
                    token_list_pop_front(input_list);
                    skip_blanks(ctx, &r, input_list);
                    _cake_zmem(&path, 100);
                    is_angle_bracket_form = 0;
                    if (input_list->head == 0)
                    {
                        pre_unexpected_end_of_file(r.tail, ctx);
                        goto __L0; /* throw */
                    }
                    if (input_list->head->type == 130)
                    {
                        strcat(path, input_list->head->lexeme);
                        token_list_pop_front(input_list);
                    }
                    else
                    {
                        is_angle_bracket_form = 1;
                        token_list_pop_front(input_list);
                        if (input_list->head == 0)
                        {
                            pre_unexpected_end_of_file(r.tail, ctx);
                            goto __L0; /* throw */
                        }
                        while (input_list->head->type != 62)
                        {
                            strcat(path, input_list->head->lexeme);
                            token_list_pop_front(input_list);
                            if (input_list->head == 0)
                            {
                                pre_unexpected_end_of_file(r.tail, ctx);
                                goto __L0; /* throw */
                            }
                        }
                        token_list_pop_front(input_list);
                    }
                    _cake_zmem(&fullpath, 300);
                    _cake_zmem(&full_path_result, 200);
                    already_included = 0;
                    s = find_and_read_include_file(ctx, path, fullpath, is_angle_bracket_form, &already_included, full_path_result, 200, 0);
                    has_include = s != 0;
                    free((void *)s);
                    p_new_token = calloc(1, 40);
                    if (p_new_token == 0)
                    {
                        goto __L0; /* throw */
                    }
                    p_new_token->type = 134;
                    temp = strdup(has_include ? "1" : "0");
                    if (temp == 0)
                    {
                        token_delete(p_new_token);
                        goto __L0; /* throw */
                    }
                    p_new_token->lexeme = temp;
                    p_new_token->flags |= 1;
                    token_list_add(&r, p_new_token);
                    token_list_pop_front(input_list);
                }
                else
                {
                    if (input_list->head->type == 8996 && strcmp(input_list->head->lexeme, "__has_c_attribute") == 0)
                    {
                        char path[100];
                        char * has_c_attribute_value;
                        struct token * p_new_token;
                        char * temp;

                        token_list_pop_front(input_list);
                        skip_blanks(ctx, &r, input_list);
                        token_list_pop_front(input_list);
                        skip_blanks(ctx, &r, input_list);
                        if (input_list->head == 0)
                        {
                            pre_unexpected_end_of_file(r.tail, ctx);
                            goto __L0; /* throw */
                        }
                        _cake_zmem(&path, 100);
                        while (input_list->head->type != 41)
                        {
                            strcat(path, input_list->head->lexeme);
                            token_list_pop_front(input_list);
                            if (input_list->head == 0)
                            {
                                pre_unexpected_end_of_file(r.tail, ctx);
                                goto __L0; /* throw */
                            }
                        }
                        token_list_pop_front(input_list);
                        has_c_attribute_value = "0";
                        if (strcmp(path, "nodiscard") == 0)
                        {
                            has_c_attribute_value = "202311L";
                        }
                        else
                        {
                            if (strcmp(path, "maybe_unused") == 0)
                            {
                                has_c_attribute_value = "202106L";
                            }
                            else
                            {
                                if (strcmp(path, "deprecated") == 0)
                                {
                                    has_c_attribute_value = "201904L";
                                }
                                else
                                {
                                    if (strcmp(path, "noreturn") == 0)
                                    {
                                        has_c_attribute_value = "202202L";
                                    }
                                    else
                                    {
                                        if (strcmp(path, "reproducible") == 0)
                                        {
                                        }
                                        else
                                        {
                                            if (strcmp(path, "unsequenced") == 0)
                                            {
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        p_new_token = calloc(1, 40);
                        if (p_new_token == 0)
                        {
                            goto __L0; /* throw */
                        }
                        p_new_token->type = 134;
                        temp = strdup(has_c_attribute_value);
                        if (temp == 0)
                        {
                            token_delete(p_new_token);
                            goto __L0; /* throw */
                        }
                        p_new_token->lexeme = temp;
                        p_new_token->flags |= 1;
                        token_list_add(&r, p_new_token);
                        token_list_pop_front(input_list);
                    }
                    else
                    {
                        struct token * tk;

                        tk = token_list_pop_front_get(input_list);
                        if (tk)
                        {
                            token_list_add(&r, tk);
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}



static void skip_blanks(struct preprocessor_ctx * ctx, struct token_list * dest, struct token_list * input_list)
{
    while (input_list->head)
    {
        struct token * p;

        if (!token_is_blank(input_list->head))
        {
            break;
        }
        p = token_list_pop_front_get(input_list);
        ;
        token_list_add(dest, p);
    }
}
struct token_list process_identifiers(struct preprocessor_ctx * ctx, struct token_list * list)
{
    struct token_list  list2;

    ;
    _cake_zmem(&list2, 8);
    if (1) /*try*/
    {
        while (list->head != 0)
        {
            if (list->head->type == 8996 || list->head->type == 8997)
            {
                struct token * p_new_token;

                p_new_token = token_list_pop_front_get(list);
                ;
                p_new_token->type = 134;
                if (strcmp(p_new_token->lexeme, "true") == 0)
                {
                    p_new_token->lexeme[0] = 49;
                    p_new_token->lexeme[1] = 0;
                }
                else
                {
                    if (strcmp(p_new_token->lexeme, "false") == 0)
                    {
                        p_new_token->lexeme[0] = 48;
                        p_new_token->lexeme[1] = 0;
                    }
                    else
                    {
                        char * temp;

                        temp = strdup("0");
                        if (temp == 0)
                        {
                            token_delete(p_new_token);
                            goto __L0; /* throw */
                        }
                        free(p_new_token->lexeme);
                        p_new_token->lexeme = temp;
                    }
                }
                token_list_add(&list2, p_new_token);
            }
            else
            {
                struct token * ptk;

                ptk = token_list_pop_front_get(list);
                ;
                token_list_add(&list2, ptk);
            }
        }
        ;
    }
    else __L0: /*catch*/ 
    {
    }
    return list2;
}


struct token_list ignore_preprocessor_line(struct token_list * input_list)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    while (input_list->head && input_list->head->type != 10)
    {
        struct token * tk;

        tk = token_list_pop_front_get(input_list);
        ;
        token_list_add(&r, tk);
    }
    return r;
}


struct token_list copy_replacement_list(struct preprocessor_ctx * ctx, struct token_list * list);
struct token_list preprocessor(struct preprocessor_ctx * ctx, struct token_list * input_list, int level);
int pre_constant_expression(struct preprocessor_ctx * ctx, long long * pvalue);

long long preprocessor_constant_expression(struct preprocessor_ctx * ctx, struct token_list * output_list, struct token_list * input_list, int level)
{
    struct token * first;
    struct token_list  r;
    struct token_list  list1;
    int flags;
    struct token_list  list2;
    long long value;

    ;
    first = input_list->head;
    ctx->conditional_inclusion = 1;
    _cake_zmem(&r, 8);
    while (input_list->head && input_list->head->type != 10)
    {
        struct token * tk;

        tk = token_list_pop_front_get(input_list);
        ;
        token_list_add(&r, tk);
        ;
        r.tail->flags &= -1025;
    }
    list1 = copy_replacement_list(ctx, &r);
    token_list_swap(output_list, &r);
    flags = ctx->flags;
    ctx->flags |= 1;
    list2 = preprocessor(ctx, &list1, 1);
    ctx->flags = flags;
    value = 0;
    if (list2.head == 0)
    {
        preprocessor_diagnostic(1170, ctx, first, "empty expression");
    }
    else
    {
        struct token_list  list3;
        struct token_list  list4;
        struct preprocessor_ctx  pre_ctx;

        list3 = process_defined(ctx, &list2);
        list4 = process_identifiers(ctx, &list3);
        ;
        _cake_zmem(&pre_ctx, 984);
        pre_ctx.options = ctx->options;
        pre_ctx.input_list = list4;
        pre_ctx.current = pre_ctx.input_list.head;
        if (pre_constant_expression(&pre_ctx, &value) != 0)
        {
            preprocessor_diagnostic(1170, ctx, first, "expression error");
        }
        ctx->conditional_inclusion = 0;
        preprocessor_ctx_destroy(&pre_ctx);
    }
    token_list_destroy(&list1);
    token_list_destroy(&r);
    token_list_destroy(&list2);
    return value;
}


void match_level(struct token_list * dest, struct token_list * input_list, int level)
{
    if (1)
    {
        struct token * tk;

        tk = token_list_pop_front_get(input_list);
        if (tk)
        {
            token_list_add(dest, tk);
        }
    }
    else
    {
        token_list_pop_front(input_list);
    }
}


char *get_diagnostic_friendly_token_name(int tk);

int match_token_level(struct token_list * dest, struct token_list * input_list, int type, int level, struct preprocessor_ctx * ctx)
{
    if (1) /*try*/
    {
        if (input_list->head == 0 || input_list->head->type != type)
        {
            if (type == 10 && input_list->head == 0)
            {
            }
            else
            {
                if (input_list->head)
                {
                    preprocessor_diagnostic(970, ctx, input_list->head, "expected token '%s', got '%s'\n", get_diagnostic_friendly_token_name(type), get_diagnostic_friendly_token_name(input_list->head->type));
                }
                else
                {
                    preprocessor_diagnostic(970, ctx, dest->tail, "expected EOF \n");
                }
                goto __L0; /* throw */
            }
        }
        if (input_list->head != 0)
        {
            if (1)
            {
                token_list_add(dest, token_list_pop_front_get(input_list));
            }
            else
            {
                token_list_pop_front(input_list);
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return ctx->n_errors > 0;
}


static void skip_blanks_level(struct preprocessor_ctx * ctx, struct token_list * dest, struct token_list * input_list, int level);

struct token_list if_group(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level, unsigned char * p_result)
{
    struct token_list  r;

    *p_result = 0;
    ;
    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        struct token_list  r2;

        match_token_level(&r, input_list, 127, level, ctx);
        skip_blanks_level(ctx, &r, input_list, level);
        if (input_list->head == 0)
        {
            goto __L0; /* throw */
        }
        ;
        if (strcmp(input_list->head->lexeme, "ifdef") == 0)
        {
            match_token_level(&r, input_list, 8996, level, ctx);
            skip_blanks_level(ctx, &r, input_list, level);
            if (input_list->head == 0)
            {
                pre_unexpected_end_of_file(r.tail, ctx);
                goto __L0; /* throw */
            }
            if (is_active)
            {
                struct macro * macro;

                macro = find_macro(ctx, input_list->head->lexeme);
                *p_result = (((macro != 0) ? 1 : 0) != 0);
            }
            match_token_level(&r, input_list, 8996, level, ctx);
            skip_blanks_level(ctx, &r, input_list, level);
            match_token_level(&r, input_list, 10, level, ctx);
        }
        else
        {
            if (strcmp(input_list->head->lexeme, "ifndef") == 0)
            {
                match_token_level(&r, input_list, 8996, level, ctx);
                skip_blanks_level(ctx, &r, input_list, level);
                if (input_list->head == 0)
                {
                    pre_unexpected_end_of_file(r.tail, ctx);
                    goto __L0; /* throw */
                }
                if (is_active)
                {
                    struct macro * macro;

                    macro = find_macro(ctx, input_list->head->lexeme);
                    *p_result = (((macro == 0) ? 1 : 0) != 0);
                }
                match_token_level(&r, input_list, 8996, level, ctx);
                skip_blanks_level(ctx, &r, input_list, level);
                match_token_level(&r, input_list, 10, level, ctx);
            }
            else
            {
                if (strcmp(input_list->head->lexeme, "if") == 0)
                {
                    match_token_level(&r, input_list, 8996, level, ctx);
                    skip_blanks_level(ctx, &r, input_list, level);
                    if (is_active)
                    {
                        struct token_list  r0;

                        _cake_zmem(&r0, 8);
                        *p_result = (preprocessor_constant_expression(ctx, &r0, input_list, level) != 0);
                        token_list_append_list(&r, &r0);
                        token_list_destroy(&r0);
                    }
                    else
                    {
                        struct token_list  r0;

                        r0 = ignore_preprocessor_line(input_list);
                        token_list_append_list(&r, &r0);
                        token_list_destroy(&r0);
                    }
                    match_token_level(&r, input_list, 10, level, ctx);
                }
                else
                {
                    preprocessor_diagnostic(650, ctx, input_list->head, "unexpected");
                    goto __L0; /* throw */
                }
            }
        }
        r2 = group_opt(ctx, input_list, is_active && *p_result, level);
        token_list_append_list(&r, &r2);
        ;
        ;
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}



static void skip_blanks_level(struct preprocessor_ctx * ctx, struct token_list * dest, struct token_list * input_list, int level)
{
    while (input_list->head)
    {
        if (!token_is_blank(input_list->head))
        {
            break;
        }
        if (1)
        {
            struct token * p;

            p = token_list_pop_front_get(input_list);
            ;
            token_list_add(dest, p);
        }
        else
        {
            token_list_pop_front(input_list);
        }
    }
}
struct token_list elif_group(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level, unsigned char * p_elif_result)
{
    struct token_list  r;

    *p_elif_result = 0;
    ;
    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        unsigned long long result;
        struct token_list  r2;

        match_token_level(&r, input_list, 127, level, ctx);
        skip_blanks(ctx, &r, input_list);
        if (input_list->head == 0)
        {
            goto __L0; /* throw */
        }
        result = 0;
        if (strcmp(input_list->head->lexeme, "elif") == 0)
        {
            match_token_level(&r, input_list, 8996, level, ctx);
            skip_blanks(ctx, &r, input_list);
            if (is_active)
            {
                struct token_list  r0;

                _cake_zmem(&r0, 8);
                result = preprocessor_constant_expression(ctx, &r0, input_list, level);
                token_list_append_list(&r, &r0);
                token_list_destroy(&r0);
            }
            else
            {
                struct token_list  r0;

                r0 = ignore_preprocessor_line(input_list);
                token_list_append_list(&r, &r0);
                token_list_destroy(&r0);
            }
        }
        else
        {
            if (strcmp(input_list->head->lexeme, "elifdef") == 0)
            {
                match_token_level(&r, input_list, 8996, level, ctx);
                skip_blanks(ctx, &r, input_list);
                if (input_list->head == 0)
                {
                    goto __L0; /* throw */
                }
                if (is_active)
                {
                    result = (hashmap_find(&ctx->macros, input_list->head->lexeme) != 0) ? 1 : 0;
                }
                match_token_level(&r, input_list, 8996, level, ctx);
            }
            else
            {
                if (strcmp(input_list->head->lexeme, "elifndef") == 0)
                {
                    match_token_level(&r, input_list, 8996, level, ctx);
                    skip_blanks(ctx, &r, input_list);
                    if (input_list->head == 0)
                    {
                        goto __L0; /* throw */
                    }
                    if (is_active)
                    {
                        result = (hashmap_find(&ctx->macros, input_list->head->lexeme) == 0) ? 1 : 0;
                    }
                    match_token_level(&r, input_list, 8996, level, ctx);
                }
            }
        }
        *p_elif_result = (result != 0);
        skip_blanks(ctx, &r, input_list);
        match_token_level(&r, input_list, 10, level, ctx);
        r2 = group_opt(ctx, input_list, is_active && *p_elif_result, level);
        token_list_append_list(&r, &r2);
        token_list_destroy(&r2);
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}


struct token_list elif_groups(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level, unsigned char * pelif_result)
{
    struct token_list  r;

    ;
    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        unsigned char  already_found_elif_true;
        unsigned char  elif_result;
        struct token_list  r2;

        already_found_elif_true = 0;
        elif_result = 0;
        r2 = elif_group(ctx, input_list, is_active, level, &elif_result);
        if (input_list->head == 0)
        {
            token_list_destroy(&r2);
            goto __L0; /* throw */
        }
        token_list_append_list(&r, &r2);
        if (elif_result)
        {
            already_found_elif_true = 1;
        }
        if (input_list->head->type == 127 && (preprocessor_token_ahead_is_identifier(input_list->head, "elif") || preprocessor_token_ahead_is_identifier(input_list->head, "elifdef") || preprocessor_token_ahead_is_identifier(input_list->head, "elifndef")))
        {
            struct token_list  r3;

            r3 = elif_groups(ctx, input_list, is_active && !already_found_elif_true, level, &elif_result);
            token_list_append_list(&r, &r3);
            if (elif_result)
            {
                already_found_elif_true = 1;
            }
            token_list_destroy(&r3);
        }
        *pelif_result = already_found_elif_true;
        token_list_destroy(&r2);
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}


struct token_list else_group(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        struct token_list  r2;

        match_token_level(&r, input_list, 127, level, ctx);
        skip_blanks_level(ctx, &r, input_list, level);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        match_token_level(&r, input_list, 8996, level, ctx);
        skip_blanks_level(ctx, &r, input_list, level);
        match_token_level(&r, input_list, 10, level, ctx);
        r2 = group_opt(ctx, input_list, is_active, level);
        token_list_append_list(&r, &r2);
        token_list_destroy(&r2);
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}


struct token_list endif_line(struct preprocessor_ctx * ctx, struct token_list * input_list, int level)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    match_token_level(&r, input_list, 127, level, ctx);
    skip_blanks_level(ctx, &r, input_list, level);
    match_token_level(&r, input_list, 8996, level, ctx);
    skip_blanks_level(ctx, &r, input_list, level);
    match_token_level(&r, input_list, 10, level, ctx);
    return r;
}


static unsigned char is_builtin_macro(char * name);
struct token_list identifier_list(struct preprocessor_ctx * ctx, struct macro * macro, struct token_list * input_list, int level);
void naming_convention_macro(struct preprocessor_ctx * ctx, struct token * token);

struct token_list def_line(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level, struct macro ** pp_macro)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        struct macro * macro;
        struct token * macro_name_token;
        char * temp;
        struct hash_item_set  item;

        macro = calloc(1, 32);
        if (macro == 0)
        {
            preprocessor_diagnostic(650, ctx, ctx->current, "out of mem");
            goto __L0; /* throw */
        }
        macro->def_macro = 1;
        match_token_level(&r, input_list, 127, level, ctx);
        match_token_level(&r, input_list, 8996, level, ctx);
        skip_blanks_level(ctx, &r, input_list, level);
        if (input_list->head == 0)
        {
            macro_delete(macro);
            pre_unexpected_end_of_file(r.tail, ctx);
            goto __L0; /* throw */
        }
        macro_name_token = input_list->head;
        if (is_builtin_macro(macro_name_token->lexeme))
        {
            preprocessor_diagnostic(56, ctx, input_list->head, "redefining built-in macro");
        }
        if (hashmap_find(&ctx->macros, input_list->head->lexeme) != 0)
        {
        }
        temp = strdup(input_list->head->lexeme);
        if (temp == 0)
        {
            macro_delete(macro);
            goto __L0; /* throw */
        }
        ;
        macro->name = temp;
        match_token_level(&r, input_list, 8996, level, ctx);
        if (input_list->head == 0)
        {
            macro_delete(macro);
            pre_unexpected_end_of_file(r.tail, ctx);
            goto __L0; /* throw */
        }
        if (input_list->head->type == 40)
        {
            macro->is_function = 1;
            match_token_level(&r, input_list, 40, level, ctx);
            skip_blanks_level(ctx, &r, input_list, level);
            if (input_list->head == 0)
            {
                macro_delete(macro);
                pre_unexpected_end_of_file(r.tail, ctx);
                goto __L0; /* throw */
            }
            if (input_list->head->type == 3026478)
            {
                struct macro_parameter * p_macro_parameter;
                char * temp2;

                p_macro_parameter = calloc(1, 20);
                if (p_macro_parameter == 0)
                {
                    macro_delete(macro);
                    goto __L0; /* throw */
                }
                temp2 = strdup("__VA_ARGS__");
                if (temp2 == 0)
                {
                    macro_delete(macro);
                    macro_parameters_delete(p_macro_parameter);
                    goto __L0; /* throw */
                }
                p_macro_parameter->name = temp2;
                macro->parameters = p_macro_parameter;
                match_token_level(&r, input_list, 3026478, level, ctx);
                skip_blanks_level(ctx, &r, input_list, level);
                match_token_level(&r, input_list, 41, level, ctx);
            }
            else
            {
                if (input_list->head->type == 41)
                {
                    match_token_level(&r, input_list, 41, level, ctx);
                    skip_blanks_level(ctx, &r, input_list, level);
                }
                else
                {
                    struct token_list  r3;

                    r3 = identifier_list(ctx, macro, input_list, level);
                    token_list_append_list(&r, &r3);
                    token_list_destroy(&r3);
                    skip_blanks_level(ctx, &r, input_list, level);
                    if (input_list->head == 0)
                    {
                        macro_delete(macro);
                        pre_unexpected_end_of_file(r.tail, ctx);
                        goto __L0; /* throw */
                    }
                    if (input_list->head->type == 3026478)
                    {
                        struct macro_parameter * p_macro_parameter;
                        char * temp3;
                        struct macro_parameter * p_last;

                        p_macro_parameter = calloc(1, 20);
                        if (p_macro_parameter == 0)
                        {
                            macro_delete(macro);
                            goto __L0; /* throw */
                        }
                        temp3 = strdup("__VA_ARGS__");
                        if (temp3 == 0)
                        {
                            macro_delete(macro);
                            macro_parameters_delete(p_macro_parameter);
                            goto __L0; /* throw */
                        }
                        p_macro_parameter->name = temp3;
                        p_last = macro->parameters;
                        ;
                        while (p_last->next)
                        {
                            p_last = p_last->next;
                        }
                        p_last->next = p_macro_parameter;
                        match_token_level(&r, input_list, 3026478, level, ctx);
                    }
                    skip_blanks_level(ctx, &r, input_list, level);
                    match_token_level(&r, input_list, 41, level, ctx);
                }
            }
        }
        else
        {
            macro->is_function = 0;
        }
        skip_blanks_level(ctx, &r, input_list, level);
        if (input_list->head == 0)
        {
            macro_delete(macro);
            pre_unexpected_end_of_file(r.tail, ctx);
            goto __L0; /* throw */
        }
        naming_convention_macro(ctx, macro_name_token);
        _cake_zmem(&item, 32);
        item.p_macro = macro;
        hashmap_set(&ctx->macros, macro->name, &item);
        hash_item_set_destroy(&item);
        *pp_macro = macro;
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}



static unsigned char is_builtin_macro(char * name)
{
    if (strcmp(name, "__FILE__") == 0)
    {
        return 1;
    }
    if (strcmp(name, "__CAKE__") == 0)
    {
        return 1;
    }
    return 0;
}
struct token_list replacement_group(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        for (; ; )
        {
            if (input_list->head == 0)
            {
                preprocessor_diagnostic(650, ctx, r.tail, "missing #enddef");
                goto __L0; /* throw */
            }
            if (input_list->head->type == 127 && (preprocessor_token_ahead_is_identifier(input_list->head, "enddef")))
            {
                break;
            }
            prematch_level(&r, input_list, level);
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}


struct token_list enddef_line(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        if (input_list->head == 0)
        {
            pre_unexpected_end_of_file(r.tail, ctx);
            goto __L0; /* throw */
        }
        match_token_level(&r, input_list, 127, level, ctx);
        skip_blanks_level(ctx, &r, input_list, level);
        match_token_level(&r, input_list, 8996, level, ctx);
        skip_blanks_level(ctx, &r, input_list, level);
        match_token_level(&r, input_list, 10, level, ctx);
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}


struct token_list def_section(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        struct macro * p_macro;
        struct token_list  r2;
        struct token_list  r3;
        struct token_list  copy;
        struct token_list  r4;

        p_macro = 0;
        r2 = def_line(ctx, input_list, is_active, level, &p_macro);
        token_list_append_list(&r, &r2);
        if (ctx->n_errors > 0 || p_macro == 0)
        {
            token_list_destroy(&r2);
            goto __L0; /* throw */
        }
        r3 = replacement_group(ctx, input_list, is_active, level);
        if (ctx->n_errors > 0)
        {
            token_list_destroy(&r2);
            token_list_destroy(&r3);
            goto __L0; /* throw */
        }
        copy = copy_replacement_list(ctx, &r3);
        token_list_append_list(&p_macro->replacement_list, &copy);
        token_list_append_list(&r, &r3);
        r4 = enddef_line(ctx, input_list, is_active, level);
        token_list_append_list(&r, &r4);
        token_list_destroy(&r2);
        token_list_destroy(&r3);
        token_list_destroy(&r4);
        token_list_destroy(&copy);
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}


struct token_list if_section(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level)
{
    struct token_list  r;

    ;
    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        unsigned char  if_result;
        struct token_list  r2;
        unsigned char  elif_result;
        struct token_list  r5;

        if_result = 0;
        r2 = if_group(ctx, input_list, is_active, level, &if_result);
        if (ctx->n_errors > 0)
        {
            token_list_destroy(&r2);
            goto __L0; /* throw */
        }
        if (input_list->head == 0)
        {
            token_list_destroy(&r2);
            goto __L0; /* throw */
        }
        token_list_append_list(&r, &r2);
        elif_result = 0;
        if (input_list->head->type == 127 && (preprocessor_token_ahead_is_identifier(input_list->head, "elif") || preprocessor_token_ahead_is_identifier(input_list->head, "elifdef") || preprocessor_token_ahead_is_identifier(input_list->head, "elifndef")))
        {
            struct token_list  r3;

            r3 = elif_groups(ctx, input_list, is_active && !if_result, level, &elif_result);
            token_list_append_list(&r, &r3);
            token_list_destroy(&r3);
        }
        if (input_list->head == 0)
        {
            token_list_destroy(&r2);
            pre_unexpected_end_of_file(r.tail, ctx);
            goto __L0; /* throw */
        }
        if (input_list->head->type == 127 && preprocessor_token_ahead_is_identifier(input_list->head, "else"))
        {
            struct token_list  r4;

            r4 = else_group(ctx, input_list, is_active && !if_result && !elif_result, level);
            token_list_append_list(&r, &r4);
            token_list_destroy(&r4);
        }
        if (ctx->n_errors > 0)
        {
            token_list_destroy(&r2);
            goto __L0; /* throw */
        }
        r5 = endif_line(ctx, input_list, level);
        token_list_append_list(&r, &r5);
        token_list_destroy(&r5);
        token_list_destroy(&r2);
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}


struct token_list identifier_list(struct preprocessor_ctx * ctx, struct macro * macro, struct token_list * input_list, int level)
{
    struct token_list  r;

    ;
    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        struct macro_parameter * p_macro_parameter;
        char * temp;
        struct macro_parameter * p_last_parameter;

        skip_blanks(ctx, &r, input_list);
        if (input_list->head == 0)
        {
            goto __L0; /* throw */
        }
        p_macro_parameter = calloc(1, 20);
        if (p_macro_parameter == 0)
        {
            goto __L0; /* throw */
        }
        temp = strdup(input_list->head->lexeme);
        if (temp == 0)
        {
            macro_parameters_delete(p_macro_parameter);
            goto __L0; /* throw */
        }
        p_macro_parameter->name = temp;
        ;
        macro->parameters = p_macro_parameter;
        p_last_parameter = macro->parameters;
        match_token_level(&r, input_list, 8996, level, ctx);
        skip_blanks(ctx, &r, input_list);
        if (input_list->head == 0)
        {
            goto __L0; /* throw */
        }
        while (input_list->head->type == 44)
        {
            struct macro_parameter * p_new_macro_parameter;
            char * temp2;

            match_token_level(&r, input_list, 44, level, ctx);
            skip_blanks(ctx, &r, input_list);
            if (input_list->head == 0)
            {
                goto __L0; /* throw */
            }
            if (input_list->head->type == 3026478)
            {
                break;
            }
            p_new_macro_parameter = calloc(1, 20);
            if (p_new_macro_parameter == 0)
            {
                goto __L0; /* throw */
            }
            temp2 = strdup(input_list->head->lexeme);
            if (temp2 == 0)
            {
                macro_parameters_delete(p_new_macro_parameter);
                goto __L0; /* throw */
            }
            p_new_macro_parameter->name = temp2;
            ;
            p_last_parameter->next = p_new_macro_parameter;
            p_last_parameter = p_last_parameter->next;
            match_token_level(&r, input_list, 8996, level, ctx);
            skip_blanks(ctx, &r, input_list);
            if (input_list->head == 0)
            {
                goto __L0; /* throw */
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}


struct token_list replacement_list(struct preprocessor_ctx * ctx, struct macro * macro, struct token_list * input_list, int level)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        struct token_list  copy;

        if (input_list->head == 0)
        {
            pre_unexpected_end_of_file(0, ctx);
            goto __L0; /* throw */
        }
        while (input_list->head->type != 10)
        {
            match_level(&r, input_list, level);
            if (input_list->head == 0)
            {
                break;
            }
        }
        ;
        copy = copy_replacement_list(ctx, &r);
        token_list_append_list(&macro->replacement_list, &copy);
        token_list_destroy(&copy);
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}


struct token_list pp_tokens_opt(struct preprocessor_ctx * ctx, struct token_list * input_list, int level)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    while (input_list->head && input_list->head->type != 10)
    {
        prematch_level(&r, input_list, level);
    }
    return r;
}


void print_path(char * path)
{
    char * p;

    p = path;
    while (*p)
    {
        if (*p == 47)
        {
            printf("\\");
        }
        else
        {
            printf("%c", *p);
        }
        p++;
    }
}


char *dirname(char * path);
static unsigned char is_empty_assert(struct token_list * replacement_list);
static void pragma_once_add(struct preprocessor_ctx * ctx, char * path);

struct token_list control_line(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        if (!is_active)
        {
            struct token_list  r7;

            r7 = pp_tokens_opt(ctx, input_list, level);
            token_list_append_list(&r, &r7);
            match_token_level(&r, input_list, 10, level, ctx);
            token_list_destroy(&r7);
            return r;
        }
        if (input_list->head == 0)
        {
            pre_unexpected_end_of_file(r.tail, ctx);
            goto __L0; /* throw */
        }
        match_token_level(&r, input_list, 127, level, ctx);
        skip_blanks_level(ctx, &r, input_list, level);
        if (input_list->head == 0)
        {
            pre_unexpected_end_of_file(r.tail, ctx);
            goto __L0; /* throw */
        }
        if (strcmp(input_list->head->lexeme, "include") == 0 || strcmp(input_list->head->lexeme, "include_next") == 0)
        {
            unsigned char  include_next;
            char path[100];
            unsigned char  is_angle_bracket_form;
            char current_file_dir[300];
            char full_path_result[200];
            unsigned char  already_included;
            char * content;

            include_next = strcmp(input_list->head->lexeme, "include_next") == 0;
            match_token_level(&r, input_list, 8996, level, ctx);
            skip_blanks_level(ctx, &r, input_list, level);
            if (input_list->head == 0)
            {
                pre_unexpected_end_of_file(r.tail, ctx);
                goto __L0; /* throw */
            }
            _cake_zmem(&path, 100);
            is_angle_bracket_form = 0;
            if (input_list->head->type == 130)
            {
                strcat(path, input_list->head->lexeme);
                prematch_level(&r, input_list, level);
            }
            else
            {
                is_angle_bracket_form = 1;
                while (input_list->head->type != 62)
                {
                    strcat(path, input_list->head->lexeme);
                    prematch_level(&r, input_list, level);
                    if (input_list->head == 0)
                    {
                        pre_unexpected_end_of_file(r.tail, ctx);
                        goto __L0; /* throw */
                    }
                }
                strcat(path, input_list->head->lexeme);
                prematch_level(&r, input_list, level);
            }
            while (input_list->head->type != 10)
            {
                prematch_level(&r, input_list, level);
                if (input_list->head == 0)
                {
                    pre_unexpected_end_of_file(r.tail, ctx);
                    goto __L0; /* throw */
                }
            }
            match_token_level(&r, input_list, 10, level, ctx);
            path[strlen(path) - 1] = 0;
            _cake_zmem(&current_file_dir, 300);
            snprintf(current_file_dir, 300, "%s", r.tail->token_origin->lexeme);
            dirname(current_file_dir);
            _cake_zmem(&full_path_result, 200);
            already_included = 0;
            content = find_and_read_include_file(ctx, path + 1, current_file_dir, is_angle_bracket_form, &already_included, full_path_result, 200, include_next);
            if (content != 0)
            {
                struct tokenizer_ctx  tctx;
                struct token_list  list;
                struct token_list  list2;

                if (ctx->options.show_includes)
                {
                    {
                        int i;

                        i = 0;
                        for (; i < (level + 1); i++)
                        printf(".");
                    }
                    print_path(full_path_result);
                    printf("\n");
                }
                _cake_zmem(&tctx, 928);
                list = tokenizer(&tctx, content, full_path_result, level + 1, 0);
                free((void *)content);
                list2 = preprocessor(ctx, &list, level + 1);
                token_list_append_list(&r, &list2);
                token_list_destroy(&list2);
                token_list_destroy(&list);
            }
            else
            {
                if (!already_included)
                {
                    preprocessor_diagnostic(1150, ctx, r.tail, "file %s not found", path + 1);
                    printf("Include directories:\n");
                    {
                        struct include_dir * p;

                        p = ctx->include_dir.head;
                        for (; p; p = p->next)
                        {
                            print_path(p->path);
                            printf("\n");
                        }
                    }
                }
                else
                {
                }
            }
        }
        else
        {
            if (strcmp(input_list->head->lexeme, "embed") == 0)
            {
                struct token_list  discard0;
                struct token_list * p_list;
                struct token * p_embed_token;
                char path[100];
                char fullpath[300];
                int nlevel;
                int f;
                struct token_list  list;

                _cake_zmem(&discard0, 8);
                p_list = &r;
                p_embed_token = input_list->head;
                match_token_level(p_list, input_list, 8996, level, ctx);
                skip_blanks_level(ctx, p_list, input_list, level);
                if (input_list->head == 0)
                {
                    goto __L0; /* throw */
                }
                _cake_zmem(&path, 100);
                if (input_list->head->type == 130)
                {
                    strcat(path, input_list->head->lexeme);
                    prematch_level(p_list, input_list, level);
                }
                else
                {
                    while (input_list->head->type != 62)
                    {
                        strcat(path, input_list->head->lexeme);
                        prematch_level(p_list, input_list, level);
                        if (input_list->head == 0)
                        {
                            goto __L0; /* throw */
                        }
                    }
                    strcat(path, input_list->head->lexeme);
                    prematch_level(p_list, input_list, level);
                }
                if (input_list->head)
                {
                    while (input_list->head->type != 10)
                    {
                        prematch_level(p_list, input_list, level);
                        if (input_list->head == 0)
                        {
                            pre_unexpected_end_of_file(p_list->tail, ctx);
                            goto __L0; /* throw */
                        }
                    }
                }
                match_token_level(p_list, input_list, 10, level, ctx);
                _cake_zmem(&fullpath, 300);
                path[strlen(path) - 1] = 0;
                snprintf(fullpath, 300, "%s", path + 1);
                nlevel = level;
                f = 0;
                f = 1;
                nlevel = nlevel + 1;
                list = embed_tokenizer(ctx, p_embed_token, fullpath, nlevel, f);
                if (ctx->n_errors > 0)
                {
                    token_list_destroy(&list);
                    goto __L0; /* throw */
                }
                token_list_append_list(&r, &list);
                token_list_destroy(&list);
                token_list_destroy(&discard0);
            }
            else
            {
                if (strcmp(input_list->head->lexeme, "define") == 0)
                {
                    struct macro * macro;
                    struct token * macro_name_token;
                    char * temp;
                    struct token_list  r4;
                    struct macro * existing_macro;

                    macro = calloc(1, 32);
                    if (macro == 0)
                    {
                        preprocessor_diagnostic(650, ctx, ctx->current, "out of mem");
                        goto __L0; /* throw */
                    }
                    match_token_level(&r, input_list, 8996, level, ctx);
                    skip_blanks_level(ctx, &r, input_list, level);
                    if (input_list->head == 0)
                    {
                        macro_delete(macro);
                        pre_unexpected_end_of_file(r.tail, ctx);
                        goto __L0; /* throw */
                    }
                    macro_name_token = input_list->head;
                    if (is_builtin_macro(macro_name_token->lexeme))
                    {
                        preprocessor_diagnostic(56, ctx, input_list->head, "redefining built-in macro");
                    }
                    macro->p_name_token = macro_name_token;
                    temp = strdup(input_list->head->lexeme);
                    if (temp == 0)
                    {
                        macro_delete(macro);
                        goto __L0; /* throw */
                    }
                    ;
                    macro->name = temp;
                    match_token_level(&r, input_list, 8996, level, ctx);
                    if (input_list->head == 0)
                    {
                        macro_delete(macro);
                        pre_unexpected_end_of_file(r.tail, ctx);
                        goto __L0; /* throw */
                    }
                    if (input_list->head->type == 40)
                    {
                        macro->is_function = 1;
                        match_token_level(&r, input_list, 40, level, ctx);
                        skip_blanks_level(ctx, &r, input_list, level);
                        if (input_list->head == 0)
                        {
                            macro_delete(macro);
                            pre_unexpected_end_of_file(r.tail, ctx);
                            goto __L0; /* throw */
                        }
                        if (input_list->head->type == 3026478)
                        {
                            struct macro_parameter * p_macro_parameter;
                            char * temp2;

                            p_macro_parameter = calloc(1, 20);
                            if (p_macro_parameter == 0)
                            {
                                macro_delete(macro);
                                goto __L0; /* throw */
                            }
                            temp2 = strdup("__VA_ARGS__");
                            if (temp2 == 0)
                            {
                                macro_delete(macro);
                                macro_parameters_delete(p_macro_parameter);
                                goto __L0; /* throw */
                            }
                            p_macro_parameter->name = temp2;
                            macro->parameters = p_macro_parameter;
                            match_token_level(&r, input_list, 3026478, level, ctx);
                            skip_blanks_level(ctx, &r, input_list, level);
                            match_token_level(&r, input_list, 41, level, ctx);
                        }
                        else
                        {
                            if (input_list->head->type == 41)
                            {
                                match_token_level(&r, input_list, 41, level, ctx);
                                skip_blanks_level(ctx, &r, input_list, level);
                            }
                            else
                            {
                                struct token_list  r3;

                                r3 = identifier_list(ctx, macro, input_list, level);
                                token_list_append_list(&r, &r3);
                                token_list_destroy(&r3);
                                skip_blanks_level(ctx, &r, input_list, level);
                                if (input_list->head == 0)
                                {
                                    macro_delete(macro);
                                    pre_unexpected_end_of_file(r.tail, ctx);
                                    goto __L0; /* throw */
                                }
                                if (input_list->head->type == 3026478)
                                {
                                    struct macro_parameter * p_macro_parameter;
                                    char * temp3;
                                    struct macro_parameter * p_last;

                                    p_macro_parameter = calloc(1, 20);
                                    if (p_macro_parameter == 0)
                                    {
                                        macro_delete(macro);
                                        goto __L0; /* throw */
                                    }
                                    temp3 = strdup("__VA_ARGS__");
                                    if (temp3 == 0)
                                    {
                                        macro_delete(macro);
                                        macro_parameters_delete(p_macro_parameter);
                                        goto __L0; /* throw */
                                    }
                                    p_macro_parameter->name = temp3;
                                    p_last = macro->parameters;
                                    ;
                                    while (p_last->next)
                                    {
                                        p_last = p_last->next;
                                    }
                                    p_last->next = p_macro_parameter;
                                    match_token_level(&r, input_list, 3026478, level, ctx);
                                }
                                skip_blanks_level(ctx, &r, input_list, level);
                                match_token_level(&r, input_list, 41, level, ctx);
                            }
                        }
                    }
                    else
                    {
                        macro->is_function = 0;
                    }
                    skip_blanks_level(ctx, &r, input_list, level);
                    if (input_list->head == 0)
                    {
                        macro_delete(macro);
                        pre_unexpected_end_of_file(r.tail, ctx);
                        goto __L0; /* throw */
                    }
                    r4 = replacement_list(ctx, macro, input_list, level);
                    token_list_append_list(&r, &r4);
                    token_list_destroy(&r4);
                    match_token_level(&r, input_list, 10, level, ctx);
                    if (!ctx->options.disable_assert && strcmp(macro->name, "assert") == 0)
                    {
                        if (!is_empty_assert(&macro->replacement_list))
                        {
                            struct macro_parameter * p_macro_parameter;
                            char * temp2;
                            struct tokenizer_ctx  tctx;

                            macro_parameters_delete(macro->parameters);
                            p_macro_parameter = calloc(1, 20);
                            if (p_macro_parameter == 0)
                            {
                                macro_delete(macro);
                                goto __L0; /* throw */
                            }
                            temp2 = strdup("__VA_ARGS__");
                            if (temp2 == 0)
                            {
                                macro_delete(macro);
                                macro_parameters_delete(p_macro_parameter);
                                goto __L0; /* throw */
                            }
                            p_macro_parameter->name = temp2;
                            macro->parameters = p_macro_parameter;
                            token_list_destroy(&macro->replacement_list);
                            _cake_zmem(&tctx, 928);
                            macro->replacement_list = tokenizer(&tctx, "assert(__VA_ARGS__)", 0, level, 0);
                        }
                    }
                    naming_convention_macro(ctx, macro_name_token);
                    existing_macro = find_macro(ctx, macro->name);
                    if (existing_macro)
                    {
                        if (!macro_is_same(macro, existing_macro))
                        {
                            if (preprocessor_diagnostic(1820, ctx, macro->p_name_token, "macro redefinition"))
                            {
                                preprocessor_diagnostic(0, ctx, existing_macro->p_name_token, "previous definition");
                            }
                            macro_delete(macro);
                            goto __L0; /* throw */
                        }
                        macro_delete(macro);
                    }
                    else
                    {
                        struct hash_item_set  item;

                        _cake_zmem(&item, 32);
                        item.p_macro = macro;
                        hashmap_set(&ctx->macros, macro->name, &item);
                        hash_item_set_destroy(&item);
                    }
                }
                else
                {
                    if (strcmp(input_list->head->lexeme, "undef") == 0)
                    {
                        struct macro * macro;

                        match_token_level(&r, input_list, 8996, level, ctx);
                        skip_blanks_level(ctx, &r, input_list, level);
                        if (input_list->head == 0)
                        {
                            pre_unexpected_end_of_file(r.tail, ctx);
                            goto __L0; /* throw */
                        }
                        macro = (struct macro *)hashmap_remove(&ctx->macros, input_list->head->lexeme, 0);
                        ;
                        if (macro)
                        {
                            macro_delete(macro);
                            match_token_level(&r, input_list, 8996, level, ctx);
                        }
                        else
                        {
                            match_token_level(&r, input_list, 8996, level, ctx);
                        }
                        skip_blanks_level(ctx, &r, input_list, level);
                        match_token_level(&r, input_list, 10, level, ctx);
                    }
                    else
                    {
                        if (strcmp(input_list->head->lexeme, "line") == 0)
                        {
                            struct token_list  r5;

                            match_token_level(&r, input_list, 8996, level, ctx);
                            r5 = pp_tokens_opt(ctx, input_list, level);
                            token_list_append_list(&r, &r5);
                            token_list_destroy(&r5);
                            match_token_level(&r, input_list, 10, level, ctx);
                        }
                        else
                        {
                            if (strcmp(input_list->head->lexeme, "error") == 0)
                            {
                                struct token_list  r6;

                                match_token_level(&r, input_list, 8996, level, ctx);
                                r6 = pp_tokens_opt(ctx, input_list, level);
                                token_list_append_list(&r, &r6);
                                token_list_destroy(&r6);
                                match_token_level(&r, input_list, 10, level, ctx);
                                preprocessor_diagnostic(1180, ctx, r.head, "#error");
                            }
                            else
                            {
                                if (strcmp(input_list->head->lexeme, "warning") == 0)
                                {
                                    struct token_list  r6;

                                    match_token_level(&r, input_list, 8996, level, ctx);
                                    r6 = pp_tokens_opt(ctx, input_list, level);
                                    token_list_append_list(&r, &r6);
                                    match_token_level(&r, input_list, 10, level, ctx);
                                    preprocessor_diagnostic(1, ctx, r.head, "#warning");
                                    token_list_destroy(&r6);
                                }
                                else
                                {
                                    if (strcmp(input_list->head->lexeme, "pragma") == 0)
                                    {
                                        struct token_list  r7;

                                        match_token_level(&r, input_list, 8996, level, ctx);
                                        if (r.tail)
                                        {
                                            r.tail->type = 128;
                                            r.tail->flags |= 1;
                                        }
                                        skip_blanks_level(ctx, &r, input_list, level);
                                        if (input_list->head == 0)
                                        {
                                            pre_unexpected_end_of_file(r.tail, ctx);
                                            goto __L0; /* throw */
                                        }
                                        if (input_list->head->type == 8996 && (strcmp(input_list->head->lexeme, "CAKE") == 0 || strcmp(input_list->head->lexeme, "cake") == 0))
                                        {
                                            match_token_level(&r, input_list, 8996, level, ctx);
                                            if (r.tail)
                                            {
                                                r.tail->flags |= 1;
                                            }
                                            skip_blanks_level(ctx, &r, input_list, level);
                                        }
                                        if (input_list->head == 0)
                                        {
                                            pre_unexpected_end_of_file(r.tail, ctx);
                                            goto __L0; /* throw */
                                        }
                                        if (strcmp(input_list->head->lexeme, "once") == 0)
                                        {
                                            pragma_once_add(ctx, input_list->head->token_origin->lexeme);
                                            match_token_level(&r, input_list, 8996, level, ctx);
                                        }
                                        else
                                        {
                                            if (strcmp(input_list->head->lexeme, "dir") == 0)
                                            {
                                                char path[200];

                                                match_token_level(&r, input_list, 8996, level, ctx);
                                                skip_blanks_level(ctx, &r, input_list, level);
                                                if (input_list->head == 0)
                                                {
                                                    pre_unexpected_end_of_file(r.tail, ctx);
                                                    goto __L0; /* throw */
                                                }
                                                if (input_list->head->type != 130)
                                                {
                                                    preprocessor_diagnostic(650, ctx, input_list->head, "expected string");
                                                    goto __L0; /* throw */
                                                }
                                                _cake_zmem(&path, 200);
                                                strncpy(path, input_list->head->lexeme + 1, strlen(input_list->head->lexeme) - 2);
                                                include_dir_add(&ctx->include_dir, path);
                                                match_token_level(&r, input_list, 130, level, ctx);
                                            }
                                        }
                                        r7 = pp_tokens_opt(ctx, input_list, level);
                                        token_list_append_list(&r, &r7);
                                        match_token_level(&r, input_list, 10, level, ctx);
                                        ;
                                        r.tail->type = 129;
                                        r.tail->flags |= 1;
                                        token_list_destroy(&r7);
                                    }
                                    else
                                    {
                                        if (input_list->head->type == 10)
                                        {
                                            skip_blanks_level(ctx, &r, input_list, level);
                                            match_token_level(&r, input_list, 10, level, ctx);
                                        }
                                        else
                                        {
                                            preprocessor_diagnostic(970, ctx, input_list->head, "unexpected\n");
                                            goto __L0; /* throw */
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}



static unsigned char is_empty_assert(struct token_list * replacement_list)
{
    struct token * token;

    token = replacement_list->head;
    if (token == 0)
    {
        return 0;
    }
    if (strcmp(token->lexeme, "("))
    {
        return 0;
    }
    token = token->next;
    if (token == 0)
    {
        return 0;
    }
    if (strcmp(token->lexeme, "("))
    {
        return 0;
    }
    token = token->next;
    if (token == 0)
    {
        return 0;
    }
    if (strcmp(token->lexeme, "void"))
    {
        return 0;
    }
    token = token->next;
    if (token == 0)
    {
        return 0;
    }
    if (strcmp(token->lexeme, ")"))
    {
        return 0;
    }
    token = token->next;
    if (token == 0)
    {
        return 0;
    }
    if (strcmp(token->lexeme, "0"))
    {
        return 0;
    }
    token = token->next;
    if (token == 0)
    {
        return 0;
    }
    if (strcmp(token->lexeme, ")"))
    {
        return 0;
    }
    token = token->next;
    if (token != 0)
    {
        return 0;
    }
    return 1;
}

static void pragma_once_add(struct preprocessor_ctx * ctx, char * path)
{
    struct hash_item_set  item;

    _cake_zmem(&item, 32);
    item.number = 1;
    hashmap_set(&ctx->pragma_once_map, path, &item);
    hash_item_set_destroy(&item);
}
static struct token_list concatenate(struct preprocessor_ctx * ctx, struct token_list * input_list);
static struct token_list operator_pragma(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level);
static char *decode_pragma_string(char * literal);
void *malloc(unsigned int size);
static unsigned char preprocessor_token_ahead_skiping_blanks_and_new_line(struct token * p, int t);
static unsigned char macro_already_expanded(struct macro_expanded * p_list, char * name);
static struct macro_argument_list collect_macro_arguments(struct preprocessor_ctx * ctx, struct macro * macro, struct token_list * input_list, int level);
static void skip_blanks_including_newline(struct preprocessor_ctx * ctx, struct token_list * dest, struct token_list * input_list);
struct token_list expand_macro(struct preprocessor_ctx * ctx, struct macro_expanded * p_list, struct macro * macro, struct macro_argument_list * arguments, int level, struct token * origin);

struct token_list replacement_list_reexamination(struct preprocessor_ctx * ctx, struct macro_expanded * p_list, struct token_list * oldlist, int level, struct token * origin)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        struct token_list  new_list;

        new_list = concatenate(ctx, oldlist);
        while (new_list.head != 0)
        {
            struct macro * macro;

            if (new_list.head->type == 8996 && strcmp(new_list.head->lexeme, "_Pragma") == 0)
            {
                struct token_list  list;

                list = operator_pragma(ctx, &new_list, 1, level);
                token_list_append_list(&new_list, &list);
                continue;
            }
            macro = 0;
            if (new_list.head->type == 8996)
            {
                macro = find_macro(ctx, new_list.head->lexeme);
                if (macro && macro->is_function && !preprocessor_token_ahead_skiping_blanks_and_new_line(new_list.head, 40))
                {
                    macro = 0;
                }
                if (macro && macro_already_expanded(p_list, new_list.head->lexeme))
                {
                    new_list.head->type = 8997;
                    macro = 0;
                }
                if (ctx->conditional_inclusion)
                {
                    if (r.tail && r.tail->type == 8996 && strcmp(r.tail->lexeme, "defined") == 0)
                    {
                        macro = 0;
                    }
                    else
                    {
                        if (r.tail && r.tail->type == 40)
                        {
                            struct token * previous;

                            previous = r.tail->prev;
                            if (previous != 0 && previous->type == 8996 && strcmp(previous->lexeme, "defined") == 0)
                            {
                                macro = 0;
                            }
                        }
                    }
                }
            }
            if (macro)
            {
                int flags;
                struct macro_argument_list  arguments;
                struct token_list  r3;

                flags = new_list.head->flags;
                arguments = collect_macro_arguments(ctx, macro, &new_list, level);
                if (ctx->n_errors > 0)
                {
                    macro_argument_list_destroy(&arguments);
                    token_list_destroy(&new_list);
                    goto __L0; /* throw */
                }
                r3 = expand_macro(ctx, p_list, macro, &arguments, level, origin);
                if (ctx->n_errors > 0)
                {
                    token_list_destroy(&new_list);
                    token_list_destroy(&r3);
                    macro_argument_list_destroy(&arguments);
                    goto __L0; /* throw */
                }
                if (r3.head)
                {
                    r3.head->flags = flags;
                }
                token_list_append_list_at_beginning(&new_list, &r3);
                macro_argument_list_destroy(&arguments);
                token_list_destroy(&r3);
            }
            else
            {
                new_list.head->level = level;
                new_list.head->flags |= 2;
                prematch(&r, &new_list);
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}



static struct token_list concatenate(struct preprocessor_ctx * ctx, struct token_list * input_list)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        while (input_list->head)
        {
            if (input_list->head->type == 8995)
            {
                struct osstream  ss;
                int level;
                struct tokenizer_ctx  tctx;
                struct token_list  newlist;

                if (r.tail == 0)
                {
                    preprocessor_diagnostic(1210, ctx, input_list->head, "missing macro argument (should be checked before)");
                    break;
                }
                token_list_pop_front(input_list);
                _cake_zmem(&ss, 12);
                if (r.tail->lexeme[0] != 0)
                {
                    ss_fprintf(&ss, "%s", r.tail->lexeme);
                }
                if (input_list->head && input_list->head->lexeme[0] != 0)
                {
                    ss_fprintf(&ss, "%s", input_list->head->lexeme);
                }
                level = input_list->head ? input_list->head->level : 0;
                token_list_pop_front(input_list);
                _cake_zmem(&tctx, 928);
                _cake_zmem(&newlist, 8);
                if (ss.c_str != 0)
                {
                    newlist = tokenizer(&tctx, ss.c_str, 0, level, 0);
                }
                if (newlist.head)
                {
                    newlist.head->flags = r.tail->flags;
                }
                else
                {
                    struct token * p_new_token;
                    char * temp;

                    p_new_token = calloc(1, 40);
                    if (p_new_token == 0)
                    {
                        ss_close(&ss);
                        goto __L0; /* throw */
                    }
                    temp = strdup("");
                    if (temp == 0)
                    {
                        ss_close(&ss);
                        token_delete(p_new_token);
                        goto __L0; /* throw */
                    }
                    p_new_token->lexeme = temp;
                    p_new_token->type = 142;
                    token_list_add(&newlist, p_new_token);
                    ;
                    newlist.head->flags = r.tail->flags;
                }
                token_list_pop_back(&r);
                token_list_append_list(&r, &newlist);
                ss_close(&ss);
                token_list_destroy(&newlist);
                if (input_list->head == 0)
                {
                    break;
                }
            }
            else
            {
                prematch(&r, input_list);
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}

static char *decode_pragma_string(char * literal)
{
    unsigned int len;
    char * p;
    char * result;
    char * out;

    while (*literal != 34)
    literal++;
    literal++;
    len = 0;
    p = literal;
    p = literal;
    while (*p && *p != 34)
    {
        if (*p == 92 && *(p + 1))
        {
            p++;
            /*switch*/
            {
                char __v0 = *p;
                if (__v0 == 34) goto __L2; /*case 34*/
                if (__v0 == 92) goto __L3; /*case 92*/
                goto __L4; /* default */

                {
                    __L2: /*case 34*/ 
                    __L3: /*case 92*/ 
                    goto __L1; /* break */

                    __L4: /* default */ 
                    len++;
                }
                __L1:;
            }
        }
        len++;
        p++;
    }
    result = (char *)malloc(len + 1);
    if (!result)
    {
        return 0;
    }
    out = result;
    p = literal;
    while (*p && *p != 34)
    {
        if (*p == 92 && *(p + 1))
        {
            p++;
            /*switch*/
            {
                char __v1 = *p;
                if (__v1 == 34) goto __L8; /*case 34*/
                if (__v1 == 92) goto __L9; /*case 92*/
                goto __L10; /* default */

                {
                    __L8: /*case 34*/ 
                    __L9: /*case 92*/ 
                    goto __L7; /* break */

                    __L10: /* default */ 
                    *out++ = 92;
                    goto __L7; /* break */

                }
                __L7:;
            }
        }
        *out++ = *p;
        p++;
    }
    *out = 0;
    return result;
}

static struct token_list operator_pragma(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        char * line;
        struct tokenizer_ctx  tctx;
        struct token_list  r0;

        if (input_list->head->type != 8996)
        {
            goto __L0; /* throw */
        }
        prematch(&r, input_list);
        r.tail->type = 128;
        r.tail->flags |= 1;
        skip_blanks_level(ctx, &r, input_list, level);
        if (input_list->head->type != 40)
        {
            preprocessor_diagnostic(970, ctx, input_list->head, "expected (");
            goto __L0; /* throw */
        }
        token_list_pop_front(input_list);
        skip_blanks_level(ctx, &r, input_list, level);
        if (input_list->head->type != 130)
        {
            preprocessor_diagnostic(970, ctx, input_list->head, "expected string");
            goto __L0; /* throw */
        }
        line = decode_pragma_string(input_list->head->lexeme);
        if (line == 0)
        {
            goto __L0; /* throw */
        }
        token_list_pop_front(input_list);
        _cake_zmem(&tctx, 928);
        r0 = tokenizer(&tctx, line, "", 0, 0);
        free(line);
        token_list_pop_front(&r0);
        token_list_append_list(&r, &r0);
        skip_blanks_level(ctx, &r, input_list, level);
        if (input_list->head->type != 41)
        {
            preprocessor_diagnostic(970, ctx, input_list->head, "expected (");
            goto __L0; /* throw */
        }
        prematch(&r, input_list);
        r.tail->type = 129;
        r.tail->flags |= 1;
    }
    else __L0: /*catch*/ 
    {
        token_list_clear(&r);
    }
    return r;
}

static unsigned char preprocessor_token_ahead_skiping_blanks_and_new_line(struct token * p, int t)
{
    struct token * current;

    current = p->next;
    while (current && (current->type == 143 || current->type == 10 || current->type == 142 || current->type == 132 || current->type == 133))
    {
        current = current->next;
    }
    return current && current->type == t;
}

static unsigned char macro_already_expanded(struct macro_expanded * p_list, char * name)
{
    struct macro_expanded * p_item;

    p_item = p_list;
    while (p_item)
    {
        if (strcmp(name, p_item->name) == 0)
        {
            return 1;
        }
        p_item = p_item->p_previous;
    }
    return 0;
}

static void skip_blanks_including_newline(struct preprocessor_ctx * ctx, struct token_list * dest, struct token_list * input_list)
{
    while (input_list->head)
    {
        struct token * p;

        if (!token_is_blank(input_list->head) && input_list->head->type != 10)
        {
            break;
        }
        p = token_list_pop_front_get(input_list);
        ;
        token_list_add(dest, p);
    }
}

static struct macro_argument_list collect_macro_arguments(struct preprocessor_ctx * ctx, struct macro * macro, struct token_list * input_list, int level)
{
    struct macro_argument_list  macro_argument_list;

    _cake_zmem(&macro_argument_list, 16);
    if (1) /*try*/
    {
        struct token * macro_name_token;
        int count;
        struct macro_parameter * p_current_parameter;
        struct macro_argument * p_argument;

        if (input_list->head == 0)
        {
            goto __L0; /* throw */
        }
        ;
        macro_name_token = input_list->head;
        match_token_level(&macro_argument_list.tokens, input_list, 8996, level, ctx);
        if (!macro->is_function)
        {
            return macro_argument_list;
        }
        count = 1;
        skip_blanks_including_newline(ctx, &macro_argument_list.tokens, input_list);
        match_token_level(&macro_argument_list.tokens, input_list, 40, level, ctx);
        skip_blanks_including_newline(ctx, &macro_argument_list.tokens, input_list);
        if (input_list->head == 0)
        {
            pre_unexpected_end_of_file(macro_argument_list.tokens.tail, ctx);
            goto __L0; /* throw */
        }
        if (input_list->head->type == 41)
        {
            if (macro->parameters != 0)
            {
                struct macro_argument * p_argument;
                struct macro_parameter * p_current_parameter;

                p_argument = calloc(1, 16);
                if (p_argument == 0)
                {
                    goto __L0; /* throw */
                }
                p_current_parameter = macro->parameters;
                p_argument->macro_parameter = p_current_parameter;
                argument_list_add(&macro_argument_list, p_argument);
            }
            match_token_level(&macro_argument_list.tokens, input_list, 41, level, ctx);
            return macro_argument_list;
        }
        if (macro->parameters == 0)
        {
            preprocessor_diagnostic(1191, ctx, macro_name_token, "too many arguments provided to function-like macro invocation\n");
            goto __L0; /* throw */
        }
        p_current_parameter = macro->parameters;
        p_argument = calloc(1, 16);
        if (p_argument == 0)
        {
            goto __L0; /* throw */
        }
        p_argument->macro_parameter = p_current_parameter;
        while (input_list->head != 0)
        {
            if (input_list->head->type == 40)
            {
                count++;
                token_list_clone_and_add(&p_argument->tokens, input_list->head);
                match_token_level(&macro_argument_list.tokens, input_list, 40, level, ctx);
            }
            else
            {
                if (input_list->head->type == 41)
                {
                    count--;
                    if (count == 0)
                    {
                        match_token_level(&macro_argument_list.tokens, input_list, 41, level, ctx);
                        argument_list_add(&macro_argument_list, p_argument);
                        p_argument = 0;
                        if (p_current_parameter->next != 0)
                        {
                            p_current_parameter = p_current_parameter->next;
                            if (strcmp(p_current_parameter->name, "__VA_ARGS__") == 0)
                            {
                                p_argument = calloc(1, 16);
                                if (p_argument == 0)
                                {
                                    goto __L0; /* throw */
                                }
                                p_argument->macro_parameter = p_current_parameter;
                                argument_list_add(&macro_argument_list, p_argument);
                                p_argument = 0;
                            }
                            else
                            {
                                preprocessor_diagnostic(1190, ctx, macro_name_token, "too few arguments provided to function-like macro invocation\n");
                                goto __L0; /* throw */
                            }
                        }
                        break;
                    }
                    else
                    {
                        token_list_clone_and_add(&p_argument->tokens, input_list->head);
                        match_token_level(&macro_argument_list.tokens, input_list, 41, level, ctx);
                    }
                }
                else
                {
                    if (count == 1 && input_list->head->type == 44)
                    {
                        if (strcmp(p_current_parameter->name, "__VA_ARGS__") == 0)
                        {
                            token_list_clone_and_add(&p_argument->tokens, input_list->head);
                            match_token_level(&macro_argument_list.tokens, input_list, 44, level, ctx);
                        }
                        else
                        {
                            match_token_level(&macro_argument_list.tokens, input_list, 44, level, ctx);
                            argument_list_add(&macro_argument_list, p_argument);
                            p_argument = 0;
                            p_argument = calloc(1, 16);
                            if (p_argument == 0)
                            {
                                goto __L0; /* throw */
                            }
                            if (p_current_parameter->next == 0)
                            {
                                preprocessor_diagnostic(1191, ctx, macro_argument_list.tokens.tail, "too many arguments provided to function-like macro invocation\n");
                                macro_argument_delete(p_argument);
                                p_argument = 0;
                                goto __L0; /* throw */
                            }
                            p_current_parameter = p_current_parameter->next;
                            p_argument->macro_parameter = p_current_parameter;
                        }
                    }
                    else
                    {
                        token_list_clone_and_add(&p_argument->tokens, input_list->head);
                        prematch_level(&macro_argument_list.tokens, input_list, level);
                    }
                }
            }
        }
        ;
    }
    else __L0: /*catch*/ 
    {
    }
    return macro_argument_list;
}
int lexeme_cmp(char * s1, char * s2)
{
    while (*s1 && *s2)
    {
        while ((s1[0] == 92 && s1[1] == 10))
        {
            s1++;
            s1++;
        }
        while (s2[0] == 92 && s2[1] == 10)
        {
            s2++;
            s2++;
        }
        if (*s1 != *s2)
        {
            break;
        }
        s1++;
        s2++;
    }
    while ((s1[0] == 92 && s1[1] == 10))
    {
        s1++;
        s1++;
    }
    while (s2[0] == 92 && s2[1] == 10)
    {
        s2++;
        s2++;
    }
    return *(unsigned char *)s1 - *(unsigned char *)s2;
}


void remove_line_continuation(char * s)
{
    char * pread;
    char * pwrite;

    pread = s;
    pwrite = s;
    while (*pread)
    {
        if (pread[0] == 92 && (pread[1] == 10 || (pread[1] == 13 && pread[2] == 10)))
        {
            if (pread[1] == 13 && pread[2] == 10)
            {
                pread++;
                pread++;
                pread++;
            }
            else
            {
                pread++;
                pread++;
            }
        }
        else
        {
            *pwrite = *pread;
            pread++;
            pwrite++;
        }
    }
    *pwrite = *pread;
}


struct token_list copy_replacement_list_core(struct preprocessor_ctx * ctx, struct token_list * list, unsigned char  new_line_is_space)
{
    struct token_list  r;
    struct token * current;
    unsigned char  is_first;

    _cake_zmem(&r, 8);
    current = list->head;
    if (!new_line_is_space)
    {
        while (current && token_is_blank(current))
        {
            current = current->next;
        }
    }
    else
    {
        while (current && (token_is_blank(current) || current->type == 10))
        {
            current = current->next;
        }
    }
    is_first = 1;
    for (; current; )
    {
        struct token * token_added;

        if (!new_line_is_space)
        {
            if (current && token_is_blank(current))
            {
                if (current == list->tail)
                {
                    break;
                }
                current = current->next;
                continue;
            }
        }
        else
        {
            if (current && (token_is_blank(current) || current->type == 10))
            {
                if (current == list->tail)
                {
                    break;
                }
                current = current->next;
                continue;
            }
        }
        token_added = token_list_clone_and_add(&r, current);
        if (!ctx->options.preprocess_def_macro && token_added->type == 127)
        {
            token_added->type = 35;
            free(token_added->lexeme);
            token_added->lexeme = strdup("#");
        }
        if (token_added->flags & 8)
        {
            token_added->flags = token_added->flags & -9;
            token_added->flags |= 4;
        }
        if (is_first)
        {
            token_added->flags = token_added->flags & -5;
            token_added->flags = token_added->flags & -9;
            is_first = 0;
        }
        remove_line_continuation(token_added->lexeme);
        if (current == list->tail)
        {
            break;
        }
        current = current->next;
    }
    return r;
}


struct token_list copy_replacement_list(struct preprocessor_ctx * ctx, struct token_list * list)
{
    return copy_replacement_list_core(ctx, list, !ctx->options.preprocess_def_macro);
}


int stringify(char * input, int n, char output[]);

struct token_list macro_copy_replacement_list(struct preprocessor_ctx * ctx, struct macro * macro, struct token * origin)
{
    if (strcmp(macro->name, "__LINE__") == 0)
    {
        struct tokenizer_ctx  tctx;
        char line[50];
        struct token_list  r;

        _cake_zmem(&tctx, 928);
        _cake_zmem(&line, 50);
        ;
        snprintf(line, 50, "%d", origin->line);
        r = tokenizer(&tctx, line, "", 0, 0);
        token_list_pop_front(&r);
        if (r.head != 0)
        {
            r.head->flags = 0;
        }
        return r;
    }
    else
    {
        if (strcmp(macro->name, "__FILE__") == 0)
        {
            char buffer[300];
            struct tokenizer_ctx  tctx;
            struct token_list  r;

            _cake_zmem(&buffer, 300);
            if (stringify(origin->token_origin->lexeme, 300, buffer) < 0)
            {
            }
            _cake_zmem(&tctx, 928);
            r = tokenizer(&tctx, buffer, "", 0, 0);
            token_list_pop_front(&r);
            if (r.head)
            {
                r.head->flags = 0;
            }
            return r;
        }
        else
        {
            if (strcmp(macro->name, "__COUNTER__") == 0)
            {
                char line[50];
                struct tokenizer_ctx  tctx;
                struct token_list  r;

                _cake_zmem(&line, 50);
                snprintf(line, 50, "%d", ctx->count_macro_value);
                ctx->count_macro_value++;
                _cake_zmem(&tctx, 928);
                r = tokenizer(&tctx, line, "", 0, 0);
                token_list_pop_front(&r);
                if (r.head != 0)
                {
                    r.head->flags = 0;
                }
                return r;
            }
        }
    }
    return copy_replacement_list(ctx, &macro->replacement_list);
}


static struct token_list replace_macro_arguments(struct preprocessor_ctx * ctx, struct macro_expanded * p_list, struct token_list * input_list, struct macro_argument_list * arguments, struct token * origin);
static unsigned char has_argument_list_empty_substitution(struct preprocessor_ctx * ctx, struct macro_expanded * p_list, struct macro_argument_list * p_macro_argument_list, struct token * origin);
char *print_preprocessed_to_string2(struct token * p_token);

struct token_list expand_macro(struct preprocessor_ctx * ctx, struct macro_expanded * p_list_of_macro_expanded_opt, struct macro * macro, struct macro_argument_list * arguments, int level, struct token * origin)
{
    struct token_list  r;

    macro->usage++;
    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        ;
        if (macro->is_function)
        {
            struct token_list  copy;
            struct token_list  copy2;
            struct macro_expanded  macro_expanded;
            struct token_list  r2;

            copy = macro_copy_replacement_list(ctx, macro, origin);
            copy2 = replace_macro_arguments(ctx, p_list_of_macro_expanded_opt, &copy, arguments, origin);
            _cake_zmem(&macro_expanded, 8);
            macro_expanded.name = macro->name;
            macro_expanded.p_previous = p_list_of_macro_expanded_opt;
            r2 = replacement_list_reexamination(ctx, &macro_expanded, &copy2, level, origin);
            token_list_append_list(&r, &r2);
            token_list_destroy(&copy);
            token_list_destroy(&copy2);
            token_list_destroy(&r2);
            if (ctx->n_errors > 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            struct token_list  copy;
            struct macro_expanded  macro_expanded;
            struct token_list  r3;

            copy = macro_copy_replacement_list(ctx, macro, origin);
            _cake_zmem(&macro_expanded, 8);
            macro_expanded.name = macro->name;
            macro_expanded.p_previous = p_list_of_macro_expanded_opt;
            r3 = replacement_list_reexamination(ctx, &macro_expanded, &copy, level, origin);
            if (ctx->n_errors > 0)
            {
                token_list_destroy(&copy);
                token_list_destroy(&r3);
                goto __L0; /* throw */
            }
            token_list_append_list(&r, &r3);
            token_list_destroy(&copy);
            token_list_destroy(&r3);
        }
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->options.preprocess_def_macro && macro->def_macro)
        {
            struct token_list  r0;
            struct token_list  list2;
            struct tokenizer_ctx  tctx;
            char * result;
            struct token_list  list3;

            _cake_zmem(&r0, 8);
            token_list_append_list(&r0, &r);
            list2 = preprocessor(ctx, &r0, level + 1);
            _cake_zmem(&tctx, 928);
            result = print_preprocessed_to_string2(list2.head);
            token_list_clear(&r);
            r = tokenizer(&tctx, result, "", 0, 2);
            list3 = copy_replacement_list_core(ctx, &r, 1);
            token_list_swap(&list3, &r);
            free((void *)result);
            token_list_destroy(&list2);
            token_list_destroy(&list3);
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}



static unsigned char has_argument_list_empty_substitution(struct preprocessor_ctx * ctx, struct macro_expanded * p_list, struct macro_argument_list * p_macro_argument_list, struct token * origin)
{
    struct macro_argument * p_va_args_argument;

    if (p_macro_argument_list->head == 0)
    {
        return 1;
    }
    p_va_args_argument = find_macro_argument_by_name(p_macro_argument_list, "__VA_ARGS__");
    if (p_va_args_argument)
    {
        struct token_list  argumentlist;
        struct token_list  r4;
        unsigned char  results_in_empty_substituition;

        if (p_va_args_argument->tokens.head == 0)
        {
            return 1;
        }
        argumentlist = copy_argument_list(p_va_args_argument);
        r4 = replacement_list_reexamination(ctx, p_list, &argumentlist, 0, origin);
        results_in_empty_substituition = (r4.head == 0 || r4.head->type == 142);
        token_list_destroy(&r4);
        token_list_destroy(&argumentlist);
        return results_in_empty_substituition;
    }
    return 0;
}

static struct token_list replace_macro_arguments(struct preprocessor_ctx * ctx, struct macro_expanded * p_list, struct token_list * input_list, struct macro_argument_list * arguments, struct token * origin)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        struct macro_argument * p;

        p = arguments->head;
        while (p)
        {
            struct macro_argument * next;

            next = p->next;
            if (p->macro_parameter)
            {
                p->macro_parameter->already_expanded = 0;
                token_list_clear(&p->macro_parameter->expanded_list);
            }
            p = next;
        }
        while (input_list->head)
        {
            struct macro_argument * p_argument;

            ;
            ;
            ;
            p_argument = 0;
            if (input_list->head->type == 8996)
            {
                if (strcmp(input_list->head->lexeme, "__VA_OPT__") == 0)
                {
                    int parenteses_count;
                    unsigned char  discard_va_opt;

                    token_list_pop_front(input_list);
                    token_list_pop_front(input_list);
                    parenteses_count = 1;
                    discard_va_opt = has_argument_list_empty_substitution(ctx, p_list, arguments, origin);
                    if (discard_va_opt)
                    {
                        while (input_list->head)
                        {
                            if (input_list->head->type == 40)
                            {
                                parenteses_count++;
                            }
                            else
                            {
                                if (input_list->head->type == 41)
                                {
                                    parenteses_count--;
                                }
                            }
                            token_list_pop_front(input_list);
                            if (parenteses_count == 0)
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        struct token * p_token;

                        p_token = input_list->head;
                        for (; p_token; p_token = p_token->next)
                        {
                            if (p_token->type == 40)
                            {
                                parenteses_count++;
                            }
                            else
                            {
                                if (p_token->type == 41)
                                {
                                    parenteses_count--;
                                }
                            }
                            if (parenteses_count == 0)
                            {
                                break;
                            }
                        }
                        token_list_remove(input_list, p_token, p_token);
                    }
                    continue;
                }
                p_argument = find_macro_argument_by_name(arguments, input_list->head->lexeme);
            }
            if (p_argument)
            {
                if (r.tail != 0 && r.tail->type == 35)
                {
                    int flags;
                    struct token_list  argumentlist;
                    char * s;
                    struct token * p_new_token;

                    flags = r.tail->flags;
                    token_list_pop_front(input_list);
                    while (token_is_blank(r.tail))
                    {
                        token_list_pop_back(&r);
                    }
                    token_list_pop_back(&r);
                    argumentlist = copy_argument_list(p_argument);
                    s = token_list_join_tokens(&argumentlist, 1);
                    if (s == 0)
                    {
                        token_list_destroy(&argumentlist);
                        preprocessor_diagnostic(650, ctx, input_list->head, "unexpected");
                        goto __L0; /* throw */
                    }
                    p_new_token = calloc(1, 40);
                    if (p_new_token == 0)
                    {
                        free(s);
                        token_list_destroy(&argumentlist);
                        goto __L0; /* throw */
                    }
                    p_new_token->lexeme = s;
                    p_new_token->type = 130;
                    p_new_token->flags = flags;
                    token_list_add(&r, p_new_token);
                    token_list_destroy(&argumentlist);
                    continue;
                }
                else
                {
                    if (r.tail != 0 && r.tail->type == 8995)
                    {
                        struct token_list  argumentlist;

                        token_list_pop_front(input_list);
                        argumentlist = copy_argument_list(p_argument);
                        token_list_append_list(&r, &argumentlist);
                        token_list_destroy(&argumentlist);
                    }
                    else
                    {
                        if (input_list->head->next && input_list->head->next->type == 8995)
                        {
                            int flags;
                            struct token_list  argumentlist;

                            flags = input_list->head->flags;
                            token_list_pop_front(input_list);
                            argumentlist = copy_argument_list(p_argument);
                            if (argumentlist.head != 0)
                            {
                                argumentlist.head->flags = flags;
                            }
                            token_list_append_list(&r, &argumentlist);
                            prematch(&r, input_list);
                            token_list_destroy(&argumentlist);
                        }
                        else
                        {
                            int flags;
                            struct token_list  copy_list;

                            flags = input_list->head->flags;
                            token_list_pop_front(input_list);
                            if (p_argument->macro_parameter == 0)
                            {
                                goto __L0; /* throw */
                            }
                            if (!p_argument->macro_parameter->already_expanded)
                            {
                                struct token_list  copy_list;
                                struct token_list  r4;

                                copy_list = copy_argument_list(p_argument);
                                r4 = replacement_list_reexamination(ctx, p_list, &copy_list, 0, origin);
                                token_list_swap(&p_argument->macro_parameter->expanded_list, &r4);
                                token_list_destroy(&r4);
                                p_argument->macro_parameter->already_expanded = 1;
                            }
                            copy_list = copy_argument_list_tokens(&p_argument->macro_parameter->expanded_list);
                            if (copy_list.head)
                            {
                                copy_list.head->flags = flags;
                            }
                            token_list_append_list(&r, &copy_list);
                            token_list_destroy(&copy_list);
                            if (ctx->n_errors > 0)
                            {
                                goto __L0; /* throw */
                            }
                        }
                    }
                }
            }
            else
            {
                prematch(&r, input_list);
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}
static struct token_list non_directive(struct preprocessor_ctx * ctx, struct token_list * input_list, int level);
static struct token_list text_line(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level);

struct token_list group_part(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level)
{
    ;
    if (input_list->head->type == 127)
    {
        if (preprocessor_token_ahead_is_identifier(input_list->head, "if") || preprocessor_token_ahead_is_identifier(input_list->head, "ifdef") || preprocessor_token_ahead_is_identifier(input_list->head, "ifndef"))
        {
            return if_section(ctx, input_list, is_active, level);
        }
        else
        {
            if (preprocessor_token_ahead_is_identifier(input_list->head, "def"))
            {
                return def_section(ctx, input_list, is_active, level);
            }
            else
            {
                if (preprocessor_token_ahead_is_identifier(input_list->head, "include") || preprocessor_token_ahead_is_identifier(input_list->head, "include_next") || preprocessor_token_ahead_is_identifier(input_list->head, "embed") || preprocessor_token_ahead_is_identifier(input_list->head, "define") || preprocessor_token_ahead_is_identifier(input_list->head, "undef") || preprocessor_token_ahead_is_identifier(input_list->head, "warning") || preprocessor_token_ahead_is_identifier(input_list->head, "line") || preprocessor_token_ahead_is_identifier(input_list->head, "error") || preprocessor_token_ahead_is_identifier(input_list->head, "pragma") || preprocessor_token_ahead_is(input_list->head, 10))
                {
                    return control_line(ctx, input_list, is_active, level);
                }
                else
                {
                    if (is_active)
                    {
                        struct token * p_token;
                        char * directive_name;

                        p_token = preprocessor_look_ahead_core(input_list->head);
                        directive_name = p_token ? p_token->lexeme : "";
                        preprocessor_diagnostic(1830, ctx, input_list->head, "invalid preprocessor directive '#%s'\n", directive_name);
                    }
                    return non_directive(ctx, input_list, level);
                }
            }
        }
    }
    return text_line(ctx, input_list, is_active, level);
}



static struct token_list non_directive(struct preprocessor_ctx * ctx, struct token_list * input_list, int level)
{
    struct token_list  r;

    r = pp_tokens_opt(ctx, input_list, level);
    skip_blanks_level(ctx, &r, input_list, level);
    match_token_level(&r, input_list, 10, level, ctx);
    return r;
}

static struct token_list text_line(struct preprocessor_ctx * ctx, struct token_list * input_list, unsigned char  is_active, int level)
{
    struct token_list  r;

    _cake_zmem(&r, 8);
    if (1) /*try*/
    {
        while (input_list->head && input_list->head->type != 127)
        {
            struct macro * macro;
            struct token * start_token;
            struct token * origin;

            macro = 0;
            start_token = input_list->head;
            origin = 0;
            if (input_list->head->type == 8996 && strcmp(input_list->head->lexeme, "_Pragma") == 0)
            {
                struct token_list  r0;

                r0 = operator_pragma(ctx, input_list, is_active, level);
                token_list_append_list(&r, &r0);
                continue;
            }
            if (is_active && input_list->head->type == 8996)
            {
                origin = input_list->head;
                macro = find_macro(ctx, input_list->head->lexeme);
                if (macro && macro->is_function && !preprocessor_token_ahead_skiping_blanks_and_new_line(input_list->head, 40))
                {
                    macro = 0;
                }
                if (ctx->conditional_inclusion)
                {
                    if (r.tail && r.tail->type == 8996 && strcmp(r.tail->lexeme, "defined") == 0)
                    {
                        macro = 0;
                    }
                    else
                    {
                        if (r.tail && r.tail->type == 40)
                        {
                            struct token * previous;

                            previous = r.tail->prev;
                            if (previous != 0 && previous->type == 8996 && strcmp(previous->lexeme, "defined") == 0)
                            {
                                macro = 0;
                            }
                        }
                    }
                }
            }
            if (macro)
            {
                int flags;
                struct macro_argument_list  arguments;
                struct token_list  start_macro;

                flags = input_list->head->flags;
                arguments = collect_macro_arguments(ctx, macro, input_list, level);
                if (ctx->n_errors > 0)
                {
                    macro_argument_list_destroy(&arguments);
                    goto __L0; /* throw */
                }
                start_macro = expand_macro(ctx, 0, macro, &arguments, level, origin);
                if (start_macro.head)
                {
                    start_macro.head->flags |= flags;
                }
                token_list_set_file(&start_macro, start_token->token_origin, start_token->line, start_token->col);
                token_list_append_list_at_beginning(input_list, &start_macro);
                if (ctx->flags & 1)
                {
                }
                else
                {
                    if (level == 0 || 1)
                    {
                        token_list_append_list(&r, &arguments.tokens);
                    }
                }
                while (macro)
                {
                    macro = 0;
                    if (input_list->head && input_list->head->type == 8996)
                    {
                        macro = find_macro(ctx, input_list->head->lexeme);
                        if (macro && macro->is_function && !preprocessor_token_ahead_skiping_blanks_and_new_line(input_list->head, 40))
                        {
                            macro = 0;
                        }
                        if (macro)
                        {
                            int flags2;
                            struct macro_argument_list  arguments2;
                            struct token_list  r3;

                            flags2 = input_list->head->flags;
                            arguments2 = collect_macro_arguments(ctx, macro, input_list, level);
                            if (ctx->n_errors > 0)
                            {
                                macro_argument_list_destroy(&arguments2);
                                macro_argument_list_destroy(&arguments);
                                token_list_destroy(&start_macro);
                                goto __L0; /* throw */
                            }
                            if (ctx->flags & 1)
                            {
                            }
                            else
                            {
                                if (level == 0 || 1)
                                {
                                    token_list_append_list(&r, &arguments2.tokens);
                                }
                            }
                            r3 = expand_macro(ctx, 0, macro, &arguments2, level, origin);
                            if (ctx->n_errors > 0)
                            {
                                macro_argument_list_destroy(&arguments2);
                                token_list_destroy(&r3);
                                macro_argument_list_destroy(&arguments);
                                token_list_destroy(&start_macro);
                                goto __L0; /* throw */
                            }
                            token_list_set_file(&r3, start_token->token_origin, start_token->line, start_token->col);
                            if (r3.head)
                            {
                                r3.head->flags = flags2;
                            }
                            token_list_append_list_at_beginning(input_list, &r3);
                            macro_argument_list_destroy(&arguments2);
                            token_list_destroy(&r3);
                        }
                    }
                }
                macro_argument_list_destroy(&arguments);
                token_list_destroy(&start_macro);
                continue;
            }
            else
            {
                unsigned char  blanks;
                unsigned char  is_final;

                if (input_list->head->flags & 1024 && !(input_list->head->flags & 2))
                {
                    if (input_list->head->type == 130)
                    {
                        preprocessor_diagnostic(0, ctx, input_list->head, "you can use \"adjacent\" \"strings\"");
                    }
                    else
                    {
                        if (input_list->head->type == 132)
                        {
                            preprocessor_diagnostic(12, ctx, input_list->head, "multi-line //comment");
                        }
                        else
                        {
                            preprocessor_diagnostic(13, ctx, input_list->head, "unnecessary line-slicing");
                        }
                    }
                }
                blanks = token_is_blank(input_list->head) || input_list->head->type == 10;
                is_final = is_active && !is_never_final(input_list->head->type);
                if (ctx->flags & 1)
                {
                    if (is_final)
                    {
                        prematch(&r, input_list);
                        ;
                        r.tail->flags |= 1;
                    }
                    else
                    {
                        token_list_pop_front(input_list);
                    }
                }
                else
                {
                    if (blanks)
                    {
                        if (level == 0 || 1)
                        {
                            prematch(&r, input_list);
                        }
                        else
                        {
                            token_list_pop_front(input_list);
                        }
                    }
                    else
                    {
                        if (level == 0 || 1)
                        {
                            prematch(&r, input_list);
                            if (is_final)
                            {
                                ;
                                r.tail->flags |= 1;
                            }
                        }
                        else
                        {
                            if (is_final)
                            {
                                prematch(&r, input_list);
                                ;
                                r.tail->flags |= 1;
                            }
                            else
                            {
                                token_list_pop_front(input_list);
                            }
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}
struct token_list preprocessor(struct preprocessor_ctx * ctx, struct token_list * input_list, int level)
{
    struct token_list  r;
    struct token_list  g;

    _cake_zmem(&r, 8);
    if (input_list->head == 0)
    {
        return r;
    }
    if (input_list->head->type == 8998)
    {
        prematch_level(&r, input_list, 1);
    }
    g = group_opt(ctx, input_list, 1, level);
    token_list_append_list(&r, &g);
    token_list_destroy(&g);
    return r;
}


void check_unused_macros(struct hash_map * map)
{
    if (map->table != 0)
    {
        {
            int i;

            i = 0;
            for (; i < map->capacity; i++)
            {
                struct map_entry * pentry;

                pentry = map->table[i];
                while (pentry != 0)
                {
                    struct macro * macro;

                    ;
                    macro = pentry->data.p_macro;
                    if (macro->usage == 0)
                    {
                        printf("%s not used\n", macro->name);
                    }
                    pentry = pentry->next;
                }
            }
        }
    }
}


int get_self_path(char * buffer, int maxsize);
void options_set_clear_all_warnings(struct options * options);
static void mark_macros_as_used(struct hash_map * map);

int include_config_header(struct preprocessor_ctx * ctx, char * file_name)
{
    char local_cakeconfig_path[260];
    char * str;
    struct bitset  w;
    struct tokenizer_ctx  tctx;
    struct token_list  l;
    struct token_list  l10;

    _cake_zmem(&local_cakeconfig_path, 260);
    snprintf(local_cakeconfig_path, 260, "%s", file_name);
    dirname(local_cakeconfig_path);
    snprintf(local_cakeconfig_path, 260, "%s/cakeconfig.h", local_cakeconfig_path);
    str = read_file(local_cakeconfig_path, 1);
    if (str && ctx->options.show_includes)
    {
        printf(".%s\n", local_cakeconfig_path);
    }
    while (str == 0)
    {
        dirname(local_cakeconfig_path);
        dirname(local_cakeconfig_path);
        if (local_cakeconfig_path[0] == 0)
        {
            break;
        }
        str = read_file(local_cakeconfig_path, 1);
        if (str && ctx->options.show_includes)
        {
            printf(".%s\n", local_cakeconfig_path);
        }
    }
    if (str == 0)
    {
        char executable_path[246];
        char root_cakeconfig_path[260];

        _cake_zmem(&executable_path, 246);
        get_self_path(executable_path, 246);
        dirname(executable_path);
        _cake_zmem(&root_cakeconfig_path, 260);
        snprintf(root_cakeconfig_path, 260, "%s/cakeconfig.h", executable_path);
        str = read_file(root_cakeconfig_path, 1);
        if (str && ctx->options.show_includes)
        {
            printf(".%s\n", root_cakeconfig_path);
        }
    }
    if (str == 0)
    {
        if (ctx->options.show_includes)
        {
            printf(".(cakeconfig.h not found)\n");
        }
        return 2;
    }
    w = ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings;
    options_set_clear_all_warnings(&ctx->options);
    _cake_zmem(&tctx, 928);
    l = tokenizer(&tctx, str, "standard macros inclusion", 0, 0);
    l10 = preprocessor(ctx, &l, 0);
    mark_macros_as_used(&ctx->macros);
    token_list_destroy(&l);
    free(str);
    token_list_destroy(&l10);
    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings = w;
    return 0;
}



static void mark_macros_as_used(struct hash_map * map)
{
    if (map->table != 0)
    {
        {
            int i;

            i = 0;
            for (; i < map->capacity; i++)
            {
                struct map_entry * pentry;

                pentry = map->table[i];
                while (pentry != 0)
                {
                    struct macro * macro;

                    ;
                    macro = pentry->data.p_macro;
                    macro->usage = 1;
                    pentry = pentry->next;
                }
            }
        }
    }
}
static long long __cdecl time(long long * _Time);
long long __cdecl _time64(long long * _Time);
static struct tm *__cdecl localtime(long long * _Time);
struct tm *__cdecl _localtime64(long long * _Time);
static void add_define(struct preprocessor_ctx * ctx, char * text);
static char __c1_mon[12][4] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};

char *target_get_predefined_macros(int e);

void add_standard_macros(struct preprocessor_ctx * ctx, int target)
{
    struct diagnostic  w;
    long long now;
    struct tm * tm;
    struct tokenizer_ctx  tctx;
    char datastr[100];
    char timestr[100];
    char * pre_defined_macros_text;
    struct token_list  l;
    struct token_list  l10;

    w = ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index];
    options_set_clear_all_warnings(&ctx->options);
    now = time(0);
    tm = localtime(&now);
    _cake_zmem(&tctx, 928);
    add_define(ctx, "#define __CAKE__  1\n");
    add_define(ctx, "#define __FILE__ \"\" \n");
    add_define(ctx, "#define __LINE__  0 \n");
    add_define(ctx, "#define __COUNTER__  0 \n");
    add_define(ctx, "#define __STDC_VERSION__  202311L \n");
    _cake_zmem(&datastr, 100);
    snprintf(datastr, 100, "#define __DATE__ \"%s %2d %d\"\n", __c1_mon[tm->tm_mon], tm->tm_mday, tm->tm_year + 1900);
    add_define(ctx, datastr);
    _cake_zmem(&timestr, 100);
    snprintf(timestr, 100, "#define __TIME__ \"%02d:%02d:%02d\"\n", tm->tm_hour, tm->tm_min, tm->tm_sec);
    add_define(ctx, datastr);
    pre_defined_macros_text = target_get_predefined_macros(target);
    l = tokenizer(&tctx, pre_defined_macros_text, "standard macros inclusion", 0, 0);
    l10 = preprocessor(ctx, &l, 0);
    mark_macros_as_used(&ctx->macros);
    token_list_destroy(&l);
    token_list_destroy(&l10);
    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] = w;
}



static long long __cdecl time(long long * _Time)
{
    return _time64(_Time);
}

static struct tm *__cdecl localtime(long long * _Time)
{
    return _localtime64(_Time);
}

static void add_define(struct preprocessor_ctx * ctx, char * text)
{
    struct tokenizer_ctx  tctx;
    struct token_list  l2;
    struct token_list  tl2;

    _cake_zmem(&tctx, 928);
    l2 = tokenizer(&tctx, text, "define", 0, 0);
    tl2 = preprocessor(ctx, &l2, 0);
    token_list_destroy(&tl2);
    token_list_destroy(&l2);
}
char *get_token_name(int tk)
{
    /*switch*/
    {
        int __v0 = tk;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 10) goto __L2; /*case 10*/
        if (__v0 == 32) goto __L3; /*case 32*/
        if (__v0 == 33) goto __L4; /*case 33*/
        if (__v0 == 34) goto __L5; /*case 34*/
        if (__v0 == 35) goto __L6; /*case 35*/
        if (__v0 == 36) goto __L7; /*case 36*/
        if (__v0 == 37) goto __L8; /*case 37*/
        if (__v0 == 38) goto __L9; /*case 38*/
        if (__v0 == 39) goto __L10; /*case 39*/
        if (__v0 == 40) goto __L11; /*case 40*/
        if (__v0 == 41) goto __L12; /*case 41*/
        if (__v0 == 42) goto __L13; /*case 42*/
        if (__v0 == 43) goto __L14; /*case 43*/
        if (__v0 == 44) goto __L15; /*case 44*/
        if (__v0 == 45) goto __L16; /*case 45*/
        if (__v0 == 46) goto __L17; /*case 46*/
        if (__v0 == 47) goto __L18; /*case 47*/
        if (__v0 == 58) goto __L19; /*case 58*/
        if (__v0 == 59) goto __L20; /*case 59*/
        if (__v0 == 60) goto __L21; /*case 60*/
        if (__v0 == 61) goto __L22; /*case 61*/
        if (__v0 == 62) goto __L23; /*case 62*/
        if (__v0 == 63) goto __L24; /*case 63*/
        if (__v0 == 64) goto __L25; /*case 64*/
        if (__v0 == 91) goto __L26; /*case 91*/
        if (__v0 == 12079) goto __L27; /*case 12079*/
        if (__v0 == 93) goto __L28; /*case 93*/
        if (__v0 == 94) goto __L29; /*case 94*/
        if (__v0 == 95) goto __L30; /*case 95*/
        if (__v0 == 96) goto __L31; /*case 96*/
        if (__v0 == 123) goto __L32; /*case 123*/
        if (__v0 == 124) goto __L33; /*case 124*/
        if (__v0 == 125) goto __L34; /*case 125*/
        if (__v0 == 126) goto __L35; /*case 126*/
        if (__v0 == 127) goto __L36; /*case 127*/
        if (__v0 == 128) goto __L37; /*case 128*/
        if (__v0 == 130) goto __L38; /*case 130*/
        if (__v0 == 131) goto __L39; /*case 131*/
        if (__v0 == 132) goto __L40; /*case 132*/
        if (__v0 == 133) goto __L41; /*case 133*/
        if (__v0 == 134) goto __L42; /*case 134*/
        if (__v0 == 9046) goto __L43; /*case 9046*/
        if (__v0 == 9047) goto __L44; /*case 9047*/
        if (__v0 == 9053) goto __L45; /*case 9053*/
        if (__v0 == 9054) goto __L46; /*case 9054*/
        if (__v0 == 135) goto __L47; /*case 135*/
        if (__v0 == 136) goto __L48; /*case 136*/
        if (__v0 == 137) goto __L49; /*case 137*/
        if (__v0 == 138) goto __L50; /*case 138*/
        if (__v0 == 139) goto __L51; /*case 139*/
        if (__v0 == 140) goto __L52; /*case 140*/
        if (__v0 == 141) goto __L53; /*case 141*/
        if (__v0 == 142) goto __L54; /*case 142*/
        if (__v0 == 143) goto __L55; /*case 143*/
        if (__v0 == 11051) goto __L56; /*case 11051*/
        if (__v0 == 11565) goto __L57; /*case 11565*/
        if (__v0 == 11582) goto __L58; /*case 11582*/
        if (__v0 == 15420) goto __L59; /*case 15420*/
        if (__v0 == 15934) goto __L60; /*case 15934*/
        if (__v0 == 31868) goto __L61; /*case 31868*/
        if (__v0 == 9766) goto __L62; /*case 9766*/
        if (__v0 == 8995) goto __L63; /*case 8995*/
        if (__v0 == 8996) goto __L64; /*case 8996*/
        if (__v0 == 8997) goto __L65; /*case 8997*/
        if (__v0 == 8998) goto __L66; /*case 8998*/
        if (__v0 == 8999) goto __L67; /*case 8999*/
        if (__v0 == 9000) goto __L68; /*case 9000*/
        if (__v0 == 9001) goto __L69; /*case 9001*/
        if (__v0 == 9002) goto __L70; /*case 9002*/
        if (__v0 == 9003) goto __L71; /*case 9003*/
        if (__v0 == 9004) goto __L72; /*case 9004*/
        if (__v0 == 9005) goto __L73; /*case 9005*/
        if (__v0 == 9006) goto __L74; /*case 9006*/
        if (__v0 == 9007) goto __L75; /*case 9007*/
        if (__v0 == 9008) goto __L76; /*case 9008*/
        if (__v0 == 9009) goto __L77; /*case 9009*/
        if (__v0 == 9010) goto __L78; /*case 9010*/
        if (__v0 == 9011) goto __L79; /*case 9011*/
        if (__v0 == 9012) goto __L80; /*case 9012*/
        if (__v0 == 9013) goto __L81; /*case 9013*/
        if (__v0 == 9014) goto __L82; /*case 9014*/
        if (__v0 == 9015) goto __L83; /*case 9015*/
        if (__v0 == 9016) goto __L84; /*case 9016*/
        if (__v0 == 9017) goto __L85; /*case 9017*/
        if (__v0 == 9018) goto __L86; /*case 9018*/
        if (__v0 == 9019) goto __L87; /*case 9019*/
        if (__v0 == 9020) goto __L88; /*case 9020*/
        if (__v0 == 9021) goto __L89; /*case 9021*/
        if (__v0 == 9022) goto __L90; /*case 9022*/
        if (__v0 == 9023) goto __L91; /*case 9023*/
        if (__v0 == 9024) goto __L92; /*case 9024*/
        if (__v0 == 9025) goto __L93; /*case 9025*/
        if (__v0 == 9026) goto __L94; /*case 9026*/
        if (__v0 == 9027) goto __L95; /*case 9027*/
        if (__v0 == 9028) goto __L96; /*case 9028*/
        if (__v0 == 9029) goto __L97; /*case 9029*/
        if (__v0 == 9030) goto __L98; /*case 9030*/
        if (__v0 == 9032) goto __L99; /*case 9032*/
        if (__v0 == 9033) goto __L100; /*case 9033*/
        if (__v0 == 9034) goto __L101; /*case 9034*/
        if (__v0 == 9035) goto __L102; /*case 9035*/
        if (__v0 == 9036) goto __L103; /*case 9036*/
        if (__v0 == 9037) goto __L104; /*case 9037*/
        if (__v0 == 9038) goto __L105; /*case 9038*/
        if (__v0 == 9039) goto __L106; /*case 9039*/
        if (__v0 == 9040) goto __L107; /*case 9040*/
        if (__v0 == 9041) goto __L108; /*case 9041*/
        if (__v0 == 9042) goto __L109; /*case 9042*/
        if (__v0 == 9043) goto __L110; /*case 9043*/
        if (__v0 == 9044) goto __L111; /*case 9044*/
        if (__v0 == 9045) goto __L112; /*case 9045*/
        if (__v0 == 9056) goto __L113; /*case 9056*/
        if (__v0 == 9057) goto __L114; /*case 9057*/
        if (__v0 == 9058) goto __L115; /*case 9058*/
        if (__v0 == 9059) goto __L116; /*case 9059*/
        if (__v0 == 9064) goto __L117; /*case 9064*/
        if (__v0 == 9065) goto __L118; /*case 9065*/
        if (__v0 == 9066) goto __L119; /*case 9066*/
        if (__v0 == 9067) goto __L120; /*case 9067*/
        if (__v0 == 9068) goto __L121; /*case 9068*/
        if (__v0 == 9069) goto __L122; /*case 9069*/
        if (__v0 == 9070) goto __L123; /*case 9070*/
        if (__v0 == 9071) goto __L124; /*case 9071*/
        if (__v0 == 9072) goto __L125; /*case 9072*/
        if (__v0 == 9073) goto __L126; /*case 9073*/
        if (__v0 == 9074) goto __L127; /*case 9074*/
        if (__v0 == 9075) goto __L128; /*case 9075*/
        if (__v0 == 9076) goto __L129; /*case 9076*/
        if (__v0 == 9077) goto __L130; /*case 9077*/
        if (__v0 == 9078) goto __L131; /*case 9078*/
        if (__v0 == 9079) goto __L132; /*case 9079*/
        if (__v0 == 9080) goto __L133; /*case 9080*/
        if (__v0 == 9081) goto __L134; /*case 9081*/
        if (__v0 == 9082) goto __L135; /*case 9082*/
        if (__v0 == 9083) goto __L136; /*case 9083*/
        if (__v0 == 9084) goto __L137; /*case 9084*/
        if (__v0 == 9085) goto __L138; /*case 9085*/
        if (__v0 == 9086) goto __L139; /*case 9086*/
        if (__v0 == 9087) goto __L140; /*case 9087*/
        if (__v0 == 9088) goto __L141; /*case 9088*/
        if (__v0 == 9089) goto __L142; /*case 9089*/
        if (__v0 == 9090) goto __L143; /*case 9090*/
        if (__v0 == 9091) goto __L144; /*case 9091*/
        if (__v0 == 9092) goto __L145; /*case 9092*/
        if (__v0 == 9093) goto __L146; /*case 9093*/
        if (__v0 == 9094) goto __L147; /*case 9094*/
        if (__v0 == 9095) goto __L148; /*case 9095*/
        if (__v0 == 9096) goto __L149; /*case 9096*/
        if (__v0 == 9097) goto __L150; /*case 9097*/
        if (__v0 == 9098) goto __L151; /*case 9098*/
        if (__v0 == 9099) goto __L152; /*case 9099*/
        if (__v0 == 9100) goto __L153; /*case 9100*/
        if (__v0 == 129) goto __L154; /*case 129*/
        if (__v0 == 9031) goto __L155; /*case 9031*/
        if (__v0 == 11069) goto __L156; /*case 11069*/
        if (__v0 == 11581) goto __L157; /*case 11581*/
        if (__v0 == 10813) goto __L158; /*case 10813*/
        if (__v0 == 12093) goto __L159; /*case 12093*/
        if (__v0 == 9533) goto __L160; /*case 9533*/
        if (__v0 == 3947581) goto __L161; /*case 3947581*/
        if (__v0 == 4079165) goto __L162; /*case 4079165*/
        if (__v0 == 9789) goto __L163; /*case 9789*/
        if (__v0 == 31805) goto __L164; /*case 31805*/
        if (__v0 == 24125) goto __L165; /*case 24125*/
        if (__v0 == 9048) goto __L166; /*case 9048*/
        if (__v0 == 9049) goto __L167; /*case 9049*/
        if (__v0 == 9050) goto __L168; /*case 9050*/
        if (__v0 == 9051) goto __L169; /*case 9051*/
        if (__v0 == 9052) goto __L170; /*case 9052*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            return "TK_NONE";
            __L2: /*case 10*/ 
            return "TK_NEWLINE";
            __L3: /*case 32*/ 
            return "TK_WHITE_SPACE";
            __L4: /*case 33*/ 
            return "TK_EXCLAMATION_MARK";
            __L5: /*case 34*/ 
            return "TK_QUOTATION_MARK";
            __L6: /*case 35*/ 
            return "TK_NUMBER_SIGN";
            __L7: /*case 36*/ 
            return "TK_DOLLAR_SIGN";
            __L8: /*case 37*/ 
            return "TK_PERCENT_SIGN";
            __L9: /*case 38*/ 
            return "TK_AMPERSAND";
            __L10: /*case 39*/ 
            return "TK_APOSTROPHE";
            __L11: /*case 40*/ 
            return "TK_LEFT_PARENTHESIS";
            __L12: /*case 41*/ 
            return "TK_RIGHT_PARENTHESIS";
            __L13: /*case 42*/ 
            return "TK_ASTERISK";
            __L14: /*case 43*/ 
            return "TK_PLUS_SIGN";
            __L15: /*case 44*/ 
            return "TK_COMMA";
            __L16: /*case 45*/ 
            return "TK_HYPHEN_MINUS";
            __L17: /*case 46*/ 
            return "TK_FULL_STOP";
            __L18: /*case 47*/ 
            return "TK_SOLIDUS";
            __L19: /*case 58*/ 
            return "TK_COLON";
            __L20: /*case 59*/ 
            return "TK_SEMICOLON";
            __L21: /*case 60*/ 
            return "TK_LESS_THAN_SIGN";
            __L22: /*case 61*/ 
            return "TK_EQUALS_SIGN";
            __L23: /*case 62*/ 
            return "TK_GREATER_THAN_SIGN";
            __L24: /*case 63*/ 
            return "TK_QUESTION_MARK";
            __L25: /*case 64*/ 
            return "TK_COMMERCIAL_AT";
            __L26: /*case 91*/ 
            return "TK_LEFT_SQUARE_BRACKET";
            __L27: /*case 12079*/ 
            return "TK_REVERSE_SOLIDUS";
            __L28: /*case 93*/ 
            return "TK_RIGHT_SQUARE_BRACKET";
            __L29: /*case 94*/ 
            return "TK_CIRCUMFLEX_ACCENT";
            __L30: /*case 95*/ 
            return "TK_FLOW_LINE";
            __L31: /*case 96*/ 
            return "TK_GRAVE_ACCENT";
            __L32: /*case 123*/ 
            return "TK_LEFT_CURLY_BRACKET";
            __L33: /*case 124*/ 
            return "TK_VERTICAL_LINE";
            __L34: /*case 125*/ 
            return "TK_RIGHT_CURLY_BRACKET";
            __L35: /*case 126*/ 
            return "TK_TILDE";
            __L36: /*case 127*/ 
            return "TK_PREPROCESSOR_LINE";
            __L37: /*case 128*/ 
            return "TK_PRAGMA";
            __L38: /*case 130*/ 
            return "TK_STRING_LITERAL";
            __L39: /*case 131*/ 
            return "TK_CHAR_CONSTANT";
            __L40: /*case 132*/ 
            return "TK_LINE_COMMENT";
            __L41: /*case 133*/ 
            return "TK_COMMENT";
            __L42: /*case 134*/ 
            return "TK_PPNUMBER";
            __L43: /*case 9046*/ 
            return "TK_KEYWORD_GCC__ATTRIBUTE";
            __L44: /*case 9047*/ 
            return "TK_KEYWORD_GCC__BUILTIN_VA_LIST";
            __L45: /*case 9053*/ 
            return "TK_KEYWORD_MSVC__PTR32";
            __L46: /*case 9054*/ 
            return "TK_KEYWORD_MSVC__PTR64";
            __L47: /*case 135*/ 
            return "ANY_OTHER_PP_TOKEN";
            __L48: /*case 136*/ 
            return "TK_COMPILER_DECIMAL_CONSTANT";
            __L49: /*case 137*/ 
            return "TK_COMPILER_OCTAL_CONSTANT";
            __L50: /*case 138*/ 
            return "TK_COMPILER_HEXADECIMAL_CONSTANT";
            __L51: /*case 139*/ 
            return "TK_COMPILER_BINARY_CONSTANT";
            __L52: /*case 140*/ 
            return "TK_COMPILER_DECIMAL_FLOATING_CONSTANT";
            __L53: /*case 141*/ 
            return "TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT";
            __L54: /*case 142*/ 
            return "TK_PLACEMARKER";
            __L55: /*case 143*/ 
            return "TK_BLANKS";
            __L56: /*case 11051*/ 
            return "TK_PLUSPLUS";
            __L57: /*case 11565*/ 
            return "TK_MINUSMINUS";
            __L58: /*case 11582*/ 
            return "TK_ARROW";
            __L59: /*case 15420*/ 
            return "TK_SHIFTLEFT";
            __L60: /*case 15934*/ 
            return "TK_SHIFTRIGHT";
            __L61: /*case 31868*/ 
            return "TK_LOGICAL_OPERATOR_OR";
            __L62: /*case 9766*/ 
            return "TK_LOGICAL_OPERATOR_AND";
            __L63: /*case 8995*/ 
            return "TK_MACRO_CONCATENATE_OPERATOR";
            __L64: /*case 8996*/ 
            return "TK_IDENTIFIER";
            __L65: /*case 8997*/ 
            return "TK_IDENTIFIER_RECURSIVE_MACRO";
            __L66: /*case 8998*/ 
            return "TK_BEGIN_OF_FILE";
            __L67: /*case 8999*/ 
            return "TK_KEYWORD_AUTO";
            __L68: /*case 9000*/ 
            return "TK_KEYWORD_BREAK";
            __L69: /*case 9001*/ 
            return "TK_KEYWORD_CASE";
            __L70: /*case 9002*/ 
            return "TK_KEYWORD_CONSTEXPR";
            __L71: /*case 9003*/ 
            return "TK_KEYWORD_CHAR";
            __L72: /*case 9004*/ 
            return "TK_KEYWORD_CONST";
            __L73: /*case 9005*/ 
            return "TK_KEYWORD_CONTINUE";
            __L74: /*case 9006*/ 
            return "TK_KEYWORD_CAKE_CATCH";
            __L75: /*case 9007*/ 
            return "TK_KEYWORD_DEFAULT";
            __L76: /*case 9008*/ 
            return "TK_KEYWORD_DO";
            __L77: /*case 9009*/ 
            return "TK_KEYWORD_DEFER";
            __L78: /*case 9010*/ 
            return "TK_KEYWORD_DOUBLE";
            __L79: /*case 9011*/ 
            return "TK_KEYWORD_ELSE";
            __L80: /*case 9012*/ 
            return "TK_KEYWORD_ENUM";
            __L81: /*case 9013*/ 
            return "TK_KEYWORD_EXTERN";
            __L82: /*case 9014*/ 
            return "TK_KEYWORD_FLOAT";
            __L83: /*case 9015*/ 
            return "TK_KEYWORD_FOR";
            __L84: /*case 9016*/ 
            return "TK_KEYWORD_GOTO";
            __L85: /*case 9017*/ 
            return "TK_KEYWORD_IF";
            __L86: /*case 9018*/ 
            return "TK_KEYWORD_INLINE";
            __L87: /*case 9019*/ 
            return "TK_KEYWORD_INT";
            __L88: /*case 9020*/ 
            return "TK_KEYWORD_LONG";
            __L89: /*case 9021*/ 
            return "TK_KEYWORD_MSVC__INT8";
            __L90: /*case 9022*/ 
            return "TK_KEYWORD_MSVC__INT16";
            __L91: /*case 9023*/ 
            return "TK_KEYWORD_MSVC__INT32";
            __L92: /*case 9024*/ 
            return "TK_KEYWORD_MSVC__INT64";
            __L93: /*case 9025*/ 
            return "TK_KEYWORD_REGISTER";
            __L94: /*case 9026*/ 
            return "TK_KEYWORD_RESTRICT";
            __L95: /*case 9027*/ 
            return "TK_KEYWORD_RETURN";
            __L96: /*case 9028*/ 
            return "TK_KEYWORD_SHORT";
            __L97: /*case 9029*/ 
            return "TK_KEYWORD_SIGNED";
            __L98: /*case 9030*/ 
            return "TK_KEYWORD_SIZEOF";
            __L99: /*case 9032*/ 
            return "TK_KEYWORD_STATIC";
            __L100: /*case 9033*/ 
            return "TK_KEYWORD_STRUCT";
            __L101: /*case 9034*/ 
            return "TK_KEYWORD_SWITCH";
            __L102: /*case 9035*/ 
            return "TK_KEYWORD_TYPEDEF";
            __L103: /*case 9036*/ 
            return "TK_KEYWORD_CAKE_TRY";
            __L104: /*case 9037*/ 
            return "TK_KEYWORD_CAKE_THROW";
            __L105: /*case 9038*/ 
            return "TK_KEYWORD_UNION";
            __L106: /*case 9039*/ 
            return "TK_KEYWORD_UNSIGNED";
            __L107: /*case 9040*/ 
            return "TK_KEYWORD_VOID";
            __L108: /*case 9041*/ 
            return "TK_KEYWORD_VOLATILE";
            __L109: /*case 9042*/ 
            return "TK_KEYWORD_WHILE";
            __L110: /*case 9043*/ 
            return "TK_KEYWORD__ALIGNAS";
            __L111: /*case 9044*/ 
            return "TK_KEYWORD__ALIGNOF";
            __L112: /*case 9045*/ 
            return "TK_KEYWORD__ATOMIC";
            __L113: /*case 9056*/ 
            return "TK_KEYWORD_MSVC__FASTCALL";
            __L114: /*case 9057*/ 
            return "TK_KEYWORD_MSVC__STDCALL";
            __L115: /*case 9058*/ 
            return "TK_KEYWORD_MSVC__CDECL";
            __L116: /*case 9059*/ 
            return "TK_KEYWORD_MSVC__DECLSPEC";
            __L117: /*case 9064*/ 
            return "TK_KEYWORD__ASM";
            __L118: /*case 9065*/ 
            return "TK_KEYWORD__BOOL";
            __L119: /*case 9066*/ 
            return "TK_KEYWORD__COMPLEX";
            __L120: /*case 9067*/ 
            return "TK_KEYWORD__DECIMAL128";
            __L121: /*case 9068*/ 
            return "TK_KEYWORD__DECIMAL32";
            __L122: /*case 9069*/ 
            return "TK_KEYWORD__DECIMAL64";
            __L123: /*case 9070*/ 
            return "TK_KEYWORD__GENERIC";
            __L124: /*case 9071*/ 
            return "TK_KEYWORD__IMAGINARY";
            __L125: /*case 9072*/ 
            return "TK_KEYWORD__NORETURN";
            __L126: /*case 9073*/ 
            return "TK_KEYWORD__STATIC_ASSERT";
            __L127: /*case 9074*/ 
            return "TK_KEYWORD_ASSERT";
            __L128: /*case 9075*/ 
            return "TK_KEYWORD__THREAD_LOCAL";
            __L129: /*case 9076*/ 
            return "TK_KEYWORD_TYPEOF";
            __L130: /*case 9077*/ 
            return "TK_KEYWORD_TRUE";
            __L131: /*case 9078*/ 
            return "TK_KEYWORD_FALSE";
            __L132: /*case 9079*/ 
            return "TK_KEYWORD_NULLPTR";
            __L133: /*case 9080*/ 
            return "TK_KEYWORD_TYPEOF_UNQUAL";
            __L134: /*case 9081*/ 
            return "TK_KEYWORD__BITINT";
            __L135: /*case 9082*/ 
            return "TK_KEYWORD_CAKE_OWNER";
            __L136: /*case 9083*/ 
            return "TK_KEYWORD__OUT";
            __L137: /*case 9084*/ 
            return "TK_KEYWORD__OBJ_OWNER";
            __L138: /*case 9085*/ 
            return "TK_KEYWORD_CAKE_VIEW";
            __L139: /*case 9086*/ 
            return "TK_KEYWORD_CAKE_OPT";
            __L140: /*case 9087*/ 
            return "TK_KEYWORD_CAKE_STATIC_DEBUG";
            __L141: /*case 9088*/ 
            return "TK_KEYWORD_CAKE_STATIC_DEBUG_EX";
            __L142: /*case 9089*/ 
            return "TK_KEYWORD_STATIC_STATE";
            __L143: /*case 9090*/ 
            return "TK_KEYWORD_STATIC_SET";
            __L144: /*case 9091*/ 
            return "TK_KEYWORD_IS_POINTER";
            __L145: /*case 9092*/ 
            return "TK_KEYWORD_IS_LVALUE";
            __L146: /*case 9093*/ 
            return "TK_KEYWORD_IS_CONST";
            __L147: /*case 9094*/ 
            return "TK_KEYWORD_IS_OWNER";
            __L148: /*case 9095*/ 
            return "TK_KEYWORD_IS_ARRAY";
            __L149: /*case 9096*/ 
            return "TK_KEYWORD_IS_FUNCTION";
            __L150: /*case 9097*/ 
            return "TK_KEYWORD_IS_SCALAR";
            __L151: /*case 9098*/ 
            return "TK_KEYWORD_IS_ARITHMETIC";
            __L152: /*case 9099*/ 
            return "TK_KEYWORD_IS_FLOATING_POINT";
            __L153: /*case 9100*/ 
            return "TK_KEYWORD_IS_INTEGRAL";
            __L154: /*case 129*/ 
            return "TK_PRAGMA_END";
            __L155: /*case 9031*/ 
            return "TK_KEYWORD__COUNTOF";
            __L156: /*case 11069*/ 
            return "TK_PLUS_ASSIGN";
            __L157: /*case 11581*/ 
            return "TK_MINUS_ASSIGN";
            __L158: /*case 10813*/ 
            return "TK_MULTI_ASSIGN";
            __L159: /*case 12093*/ 
            return "TK_DIV_ASSIGN";
            __L160: /*case 9533*/ 
            return "TK_MOD_ASSIGN";
            __L161: /*case 3947581*/ 
            return "TK_SHIFT_LEFT_ASSIGN";
            __L162: /*case 4079165*/ 
            return "TK_SHIFT_RIGHT_ASSIGN";
            __L163: /*case 9789*/ 
            return "TK_AND_ASSIGN";
            __L164: /*case 31805*/ 
            return "TK_OR_ASSIGN";
            __L165: /*case 24125*/ 
            return "TK_NOT_ASSIGN";
            __L166: /*case 9048*/ 
            return "TK_KEYWORD_GCC__BUILTIN_VA_END";
            __L167: /*case 9049*/ 
            return "TK_KEYWORD_GCC__BUILTIN_VA_ARG";
            __L168: /*case 9050*/ 
            return "TK_KEYWORD_GCC__BUILTIN_C23_VA_START";
            __L169: /*case 9051*/ 
            return "TK_KEYWORD_GCC__BUILTIN_VA_COPY";
            __L170: /*case 9052*/ 
            return "TK_KEYWORD_GCC__BUILTIN_OFFSETOF";
        }
        __L0:;
    }
    return "TK_X_MISSING_NAME";
}


char *get_diagnostic_friendly_token_name(int tk)
{
    /*switch*/
    {
        int __v0 = tk;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 10) goto __L2; /*case 10*/
        if (__v0 == 32) goto __L3; /*case 32*/
        if (__v0 == 33) goto __L4; /*case 33*/
        if (__v0 == 34) goto __L5; /*case 34*/
        if (__v0 == 35) goto __L6; /*case 35*/
        if (__v0 == 36) goto __L7; /*case 36*/
        if (__v0 == 37) goto __L8; /*case 37*/
        if (__v0 == 38) goto __L9; /*case 38*/
        if (__v0 == 39) goto __L10; /*case 39*/
        if (__v0 == 40) goto __L11; /*case 40*/
        if (__v0 == 41) goto __L12; /*case 41*/
        if (__v0 == 42) goto __L13; /*case 42*/
        if (__v0 == 43) goto __L14; /*case 43*/
        if (__v0 == 44) goto __L15; /*case 44*/
        if (__v0 == 45) goto __L16; /*case 45*/
        if (__v0 == 46) goto __L17; /*case 46*/
        if (__v0 == 47) goto __L18; /*case 47*/
        if (__v0 == 58) goto __L19; /*case 58*/
        if (__v0 == 59) goto __L20; /*case 59*/
        if (__v0 == 60) goto __L21; /*case 60*/
        if (__v0 == 61) goto __L22; /*case 61*/
        if (__v0 == 62) goto __L23; /*case 62*/
        if (__v0 == 63) goto __L24; /*case 63*/
        if (__v0 == 64) goto __L25; /*case 64*/
        if (__v0 == 91) goto __L26; /*case 91*/
        if (__v0 == 12079) goto __L27; /*case 12079*/
        if (__v0 == 93) goto __L28; /*case 93*/
        if (__v0 == 94) goto __L29; /*case 94*/
        if (__v0 == 95) goto __L30; /*case 95*/
        if (__v0 == 96) goto __L31; /*case 96*/
        if (__v0 == 123) goto __L32; /*case 123*/
        if (__v0 == 124) goto __L33; /*case 124*/
        if (__v0 == 125) goto __L34; /*case 125*/
        if (__v0 == 126) goto __L35; /*case 126*/
        if (__v0 == 127) goto __L36; /*case 127*/
        if (__v0 == 128) goto __L37; /*case 128*/
        if (__v0 == 130) goto __L38; /*case 130*/
        if (__v0 == 131) goto __L39; /*case 131*/
        if (__v0 == 132) goto __L40; /*case 132*/
        if (__v0 == 133) goto __L41; /*case 133*/
        if (__v0 == 134) goto __L42; /*case 134*/
        if (__v0 == 9046) goto __L43; /*case 9046*/
        if (__v0 == 9047) goto __L44; /*case 9047*/
        if (__v0 == 9053) goto __L45; /*case 9053*/
        if (__v0 == 9054) goto __L46; /*case 9054*/
        if (__v0 == 135) goto __L47; /*case 135*/
        if (__v0 == 136) goto __L48; /*case 136*/
        if (__v0 == 137) goto __L49; /*case 137*/
        if (__v0 == 138) goto __L50; /*case 138*/
        if (__v0 == 139) goto __L51; /*case 139*/
        if (__v0 == 140) goto __L52; /*case 140*/
        if (__v0 == 141) goto __L53; /*case 141*/
        if (__v0 == 142) goto __L54; /*case 142*/
        if (__v0 == 143) goto __L55; /*case 143*/
        if (__v0 == 11051) goto __L56; /*case 11051*/
        if (__v0 == 11565) goto __L57; /*case 11565*/
        if (__v0 == 11582) goto __L58; /*case 11582*/
        if (__v0 == 15420) goto __L59; /*case 15420*/
        if (__v0 == 15934) goto __L60; /*case 15934*/
        if (__v0 == 31868) goto __L61; /*case 31868*/
        if (__v0 == 9766) goto __L62; /*case 9766*/
        if (__v0 == 8995) goto __L63; /*case 8995*/
        if (__v0 == 8996) goto __L64; /*case 8996*/
        if (__v0 == 8997) goto __L65; /*case 8997*/
        if (__v0 == 8998) goto __L66; /*case 8998*/
        if (__v0 == 8999) goto __L67; /*case 8999*/
        if (__v0 == 9000) goto __L68; /*case 9000*/
        if (__v0 == 9001) goto __L69; /*case 9001*/
        if (__v0 == 9002) goto __L70; /*case 9002*/
        if (__v0 == 9003) goto __L71; /*case 9003*/
        if (__v0 == 9004) goto __L72; /*case 9004*/
        if (__v0 == 9005) goto __L73; /*case 9005*/
        if (__v0 == 9006) goto __L74; /*case 9006*/
        if (__v0 == 9007) goto __L75; /*case 9007*/
        if (__v0 == 9008) goto __L76; /*case 9008*/
        if (__v0 == 9009) goto __L77; /*case 9009*/
        if (__v0 == 9010) goto __L78; /*case 9010*/
        if (__v0 == 9011) goto __L79; /*case 9011*/
        if (__v0 == 9012) goto __L80; /*case 9012*/
        if (__v0 == 9013) goto __L81; /*case 9013*/
        if (__v0 == 9014) goto __L82; /*case 9014*/
        if (__v0 == 9015) goto __L83; /*case 9015*/
        if (__v0 == 9016) goto __L84; /*case 9016*/
        if (__v0 == 9017) goto __L85; /*case 9017*/
        if (__v0 == 9018) goto __L86; /*case 9018*/
        if (__v0 == 9019) goto __L87; /*case 9019*/
        if (__v0 == 9020) goto __L88; /*case 9020*/
        if (__v0 == 9021) goto __L89; /*case 9021*/
        if (__v0 == 9022) goto __L90; /*case 9022*/
        if (__v0 == 9023) goto __L91; /*case 9023*/
        if (__v0 == 9024) goto __L92; /*case 9024*/
        if (__v0 == 9025) goto __L93; /*case 9025*/
        if (__v0 == 9026) goto __L94; /*case 9026*/
        if (__v0 == 9027) goto __L95; /*case 9027*/
        if (__v0 == 9028) goto __L96; /*case 9028*/
        if (__v0 == 9029) goto __L97; /*case 9029*/
        if (__v0 == 9030) goto __L98; /*case 9030*/
        if (__v0 == 9032) goto __L99; /*case 9032*/
        if (__v0 == 9033) goto __L100; /*case 9033*/
        if (__v0 == 9034) goto __L101; /*case 9034*/
        if (__v0 == 9035) goto __L102; /*case 9035*/
        if (__v0 == 9036) goto __L103; /*case 9036*/
        if (__v0 == 9037) goto __L104; /*case 9037*/
        if (__v0 == 9038) goto __L105; /*case 9038*/
        if (__v0 == 9039) goto __L106; /*case 9039*/
        if (__v0 == 9040) goto __L107; /*case 9040*/
        if (__v0 == 9041) goto __L108; /*case 9041*/
        if (__v0 == 9042) goto __L109; /*case 9042*/
        if (__v0 == 9043) goto __L110; /*case 9043*/
        if (__v0 == 9044) goto __L111; /*case 9044*/
        if (__v0 == 9045) goto __L112; /*case 9045*/
        if (__v0 == 9056) goto __L113; /*case 9056*/
        if (__v0 == 9057) goto __L114; /*case 9057*/
        if (__v0 == 9058) goto __L115; /*case 9058*/
        if (__v0 == 9059) goto __L116; /*case 9059*/
        if (__v0 == 9064) goto __L117; /*case 9064*/
        if (__v0 == 9065) goto __L118; /*case 9065*/
        if (__v0 == 9066) goto __L119; /*case 9066*/
        if (__v0 == 9067) goto __L120; /*case 9067*/
        if (__v0 == 9068) goto __L121; /*case 9068*/
        if (__v0 == 9069) goto __L122; /*case 9069*/
        if (__v0 == 9070) goto __L123; /*case 9070*/
        if (__v0 == 9071) goto __L124; /*case 9071*/
        if (__v0 == 9072) goto __L125; /*case 9072*/
        if (__v0 == 9073) goto __L126; /*case 9073*/
        if (__v0 == 9074) goto __L127; /*case 9074*/
        if (__v0 == 9075) goto __L128; /*case 9075*/
        if (__v0 == 9076) goto __L129; /*case 9076*/
        if (__v0 == 9077) goto __L130; /*case 9077*/
        if (__v0 == 9078) goto __L131; /*case 9078*/
        if (__v0 == 9079) goto __L132; /*case 9079*/
        if (__v0 == 9080) goto __L133; /*case 9080*/
        if (__v0 == 9081) goto __L134; /*case 9081*/
        if (__v0 == 9082) goto __L135; /*case 9082*/
        if (__v0 == 9083) goto __L136; /*case 9083*/
        if (__v0 == 9084) goto __L137; /*case 9084*/
        if (__v0 == 9085) goto __L138; /*case 9085*/
        if (__v0 == 9086) goto __L139; /*case 9086*/
        if (__v0 == 9087) goto __L140; /*case 9087*/
        if (__v0 == 9088) goto __L141; /*case 9088*/
        if (__v0 == 9089) goto __L142; /*case 9089*/
        if (__v0 == 9090) goto __L143; /*case 9090*/
        if (__v0 == 9091) goto __L144; /*case 9091*/
        if (__v0 == 9092) goto __L145; /*case 9092*/
        if (__v0 == 9093) goto __L146; /*case 9093*/
        if (__v0 == 9094) goto __L147; /*case 9094*/
        if (__v0 == 9095) goto __L148; /*case 9095*/
        if (__v0 == 9096) goto __L149; /*case 9096*/
        if (__v0 == 9097) goto __L150; /*case 9097*/
        if (__v0 == 9098) goto __L151; /*case 9098*/
        if (__v0 == 9099) goto __L152; /*case 9099*/
        if (__v0 == 9100) goto __L153; /*case 9100*/
        if (__v0 == 129) goto __L154; /*case 129*/
        if (__v0 == 9031) goto __L155; /*case 9031*/
        if (__v0 == 11069) goto __L156; /*case 11069*/
        if (__v0 == 11581) goto __L157; /*case 11581*/
        if (__v0 == 10813) goto __L158; /*case 10813*/
        if (__v0 == 12093) goto __L159; /*case 12093*/
        if (__v0 == 9533) goto __L160; /*case 9533*/
        if (__v0 == 3947581) goto __L161; /*case 3947581*/
        if (__v0 == 4079165) goto __L162; /*case 4079165*/
        if (__v0 == 9789) goto __L163; /*case 9789*/
        if (__v0 == 31805) goto __L164; /*case 31805*/
        if (__v0 == 24125) goto __L165; /*case 24125*/
        if (__v0 == 9048) goto __L166; /*case 9048*/
        if (__v0 == 9049) goto __L167; /*case 9049*/
        if (__v0 == 9050) goto __L168; /*case 9050*/
        if (__v0 == 9051) goto __L169; /*case 9051*/
        if (__v0 == 9052) goto __L170; /*case 9052*/
        goto __L171; /* default */

        {
            __L1: /*case 0*/ 
            return "?";
            __L2: /*case 10*/ 
            return "new line";
            __L3: /*case 32*/ 
            return "white space";
            __L4: /*case 33*/ 
            return "!";
            __L5: /*case 34*/ 
            return "\"";
            __L6: /*case 35*/ 
            return "#";
            __L7: /*case 36*/ 
            return "$";
            __L8: /*case 37*/ 
            return "%";
            __L9: /*case 38*/ 
            return "&";
            __L10: /*case 39*/ 
            return "\'";
            __L11: /*case 40*/ 
            return "(";
            __L12: /*case 41*/ 
            return ")";
            __L13: /*case 42*/ 
            return "*";
            __L14: /*case 43*/ 
            return "+";
            __L15: /*case 44*/ 
            return ",";
            __L16: /*case 45*/ 
            return "-";
            __L17: /*case 46*/ 
            return ",";
            __L18: /*case 47*/ 
            return "/";
            __L19: /*case 58*/ 
            return ":";
            __L20: /*case 59*/ 
            return ";";
            __L21: /*case 60*/ 
            return "<";
            __L22: /*case 61*/ 
            return "=";
            __L23: /*case 62*/ 
            return ">";
            __L24: /*case 63*/ 
            return "?";
            __L25: /*case 64*/ 
            return "@";
            __L26: /*case 91*/ 
            return "[";
            __L27: /*case 12079*/ 
            return "//";
            __L28: /*case 93*/ 
            return "]";
            __L29: /*case 94*/ 
            return "^";
            __L30: /*case 95*/ 
            return "_";
            __L31: /*case 96*/ 
            return "`";
            __L32: /*case 123*/ 
            return "{";
            __L33: /*case 124*/ 
            return "|";
            __L34: /*case 125*/ 
            return "}";
            __L35: /*case 126*/ 
            return "~";
            __L36: /*case 127*/ 
            return "# preprocessor line";
            __L37: /*case 128*/ 
            return "pragma";
            __L38: /*case 130*/ 
            return "\"literal-string\"";
            __L39: /*case 131*/ 
            return "'char-constant'";
            __L40: /*case 132*/ 
            return "//comment";
            __L41: /*case 133*/ 
            return "/*comment*/";
            __L42: /*case 134*/ 
            return "pp-number";
            __L43: /*case 9046*/ 
            return "__attribute__";
            __L44: /*case 9047*/ 
            return "__builtin_va_list";
            __L45: /*case 9053*/ 
            return "__ptr32";
            __L46: /*case 9054*/ 
            return "__ptr64";
            __L47: /*case 135*/ 
            return "any_other_pp_token";
            __L48: /*case 136*/ 
            return "decimal_constant";
            __L49: /*case 137*/ 
            return "octal_constant";
            __L50: /*case 138*/ 
            return "hexadecimal_constant";
            __L51: /*case 139*/ 
            return "binary_constant";
            __L52: /*case 140*/ 
            return "decimal_floating_constant";
            __L53: /*case 141*/ 
            return "hexadecimal_floating_constant";
            __L54: /*case 142*/ 
            return "place-marker";
            __L55: /*case 143*/ 
            return "blanks";
            __L56: /*case 11051*/ 
            return "++";
            __L57: /*case 11565*/ 
            return "--";
            __L58: /*case 11582*/ 
            return "->";
            __L59: /*case 15420*/ 
            return "<<";
            __L60: /*case 15934*/ 
            return ">>";
            __L61: /*case 31868*/ 
            return "||";
            __L62: /*case 9766*/ 
            return "&&";
            __L63: /*case 8995*/ 
            return "TK_MACRO_CONCATENATE_OPERATOR";
            __L64: /*case 8996*/ 
            return "identifier";
            __L65: /*case 8997*/ 
            return "recursive-macro";
            __L66: /*case 8998*/ 
            return "begin-of-file";
            __L67: /*case 8999*/ 
            return "auto";
            __L68: /*case 9000*/ 
            return "break";
            __L69: /*case 9001*/ 
            return "case";
            __L70: /*case 9002*/ 
            return "constexpr";
            __L71: /*case 9003*/ 
            return "char";
            __L72: /*case 9004*/ 
            return "const";
            __L73: /*case 9005*/ 
            return "continue";
            __L74: /*case 9006*/ 
            return "catch";
            __L75: /*case 9007*/ 
            return "default";
            __L76: /*case 9008*/ 
            return "do";
            __L77: /*case 9009*/ 
            return "defer";
            __L78: /*case 9010*/ 
            return "double";
            __L79: /*case 9011*/ 
            return "else";
            __L80: /*case 9012*/ 
            return "enum";
            __L81: /*case 9013*/ 
            return "extern";
            __L82: /*case 9014*/ 
            return "float";
            __L83: /*case 9015*/ 
            return "for";
            __L84: /*case 9016*/ 
            return "goto";
            __L85: /*case 9017*/ 
            return "if";
            __L86: /*case 9018*/ 
            return "inline";
            __L87: /*case 9019*/ 
            return "int";
            __L88: /*case 9020*/ 
            return "long";
            __L89: /*case 9021*/ 
            return "__int8";
            __L90: /*case 9022*/ 
            return "__int16";
            __L91: /*case 9023*/ 
            return "__int32";
            __L92: /*case 9024*/ 
            return "__int64";
            __L93: /*case 9025*/ 
            return "register";
            __L94: /*case 9026*/ 
            return "restrict";
            __L95: /*case 9027*/ 
            return "return";
            __L96: /*case 9028*/ 
            return "short";
            __L97: /*case 9029*/ 
            return "signed";
            __L98: /*case 9030*/ 
            return "sizeof";
            __L99: /*case 9032*/ 
            return "static";
            __L100: /*case 9033*/ 
            return "struct";
            __L101: /*case 9034*/ 
            return "switch";
            __L102: /*case 9035*/ 
            return "typedef";
            __L103: /*case 9036*/ 
            return "try";
            __L104: /*case 9037*/ 
            return "throw";
            __L105: /*case 9038*/ 
            return "union";
            __L106: /*case 9039*/ 
            return "unsigned";
            __L107: /*case 9040*/ 
            return "void";
            __L108: /*case 9041*/ 
            return "volatile";
            __L109: /*case 9042*/ 
            return "while";
            __L110: /*case 9043*/ 
            return "alignas";
            __L111: /*case 9044*/ 
            return "alingof";
            __L112: /*case 9045*/ 
            return "atomic";
            __L113: /*case 9056*/ 
            return "fastcall";
            __L114: /*case 9057*/ 
            return "stdcall";
            __L115: /*case 9058*/ 
            return "__cdecl";
            __L116: /*case 9059*/ 
            return "__declspec";
            __L117: /*case 9064*/ 
            return "__ASM";
            __L118: /*case 9065*/ 
            return "bool";
            __L119: /*case 9066*/ 
            return "__COMPLEX";
            __L120: /*case 9067*/ 
            return "_DECIMAL128";
            __L121: /*case 9068*/ 
            return "_DECIMAL32";
            __L122: /*case 9069*/ 
            return "_DECIMAL64";
            __L123: /*case 9070*/ 
            return "_Generic";
            __L124: /*case 9071*/ 
            return "_IMAGINARY";
            __L125: /*case 9072*/ 
            return "_Noreturn";
            __L126: /*case 9073*/ 
            return "static_assert";
            __L127: /*case 9074*/ 
            return "assert";
            __L128: /*case 9075*/ 
            return "_THREAD_LOCAL";
            __L129: /*case 9076*/ 
            return "typeof";
            __L130: /*case 9077*/ 
            return "true";
            __L131: /*case 9078*/ 
            return "false";
            __L132: /*case 9079*/ 
            return "nullptr";
            __L133: /*case 9080*/ 
            return "typeof_unqual";
            __L134: /*case 9081*/ 
            return "_BitInt";
            __L135: /*case 9082*/ 
            return "_Owner";
            __L136: /*case 9083*/ 
            return "Out";
            __L137: /*case 9084*/ 
            return "_OBJ_OWNER";
            __L138: /*case 9085*/ 
            return "_view";
            __L139: /*case 9086*/ 
            return "_Opt";
            __L140: /*case 9087*/ 
            return "static_debugex";
            __L141: /*case 9088*/ 
            return "static_debug_ex";
            __L142: /*case 9089*/ 
            return "static_state";
            __L143: /*case 9090*/ 
            return "static_set";
            __L144: /*case 9091*/ 
            return "IS_POINTER";
            __L145: /*case 9092*/ 
            return "IS_LVALUE";
            __L146: /*case 9093*/ 
            return "IS_CONST";
            __L147: /*case 9094*/ 
            return "IS_OWNER";
            __L148: /*case 9095*/ 
            return "_is_array";
            __L149: /*case 9096*/ 
            return "_is_function";
            __L150: /*case 9097*/ 
            return "_is_scalar";
            __L151: /*case 9098*/ 
            return "_is_arithmetic";
            __L152: /*case 9099*/ 
            return "is_floating_point";
            __L153: /*case 9100*/ 
            return "_is_integral";
            __L154: /*case 129*/ 
            return "pragma-end";
            __L155: /*case 9031*/ 
            return "_Countof";
            __L156: /*case 11069*/ 
            return "+=";
            __L157: /*case 11581*/ 
            return "-=";
            __L158: /*case 10813*/ 
            return "*=";
            __L159: /*case 12093*/ 
            return "/=";
            __L160: /*case 9533*/ 
            return "%=";
            __L161: /*case 3947581*/ 
            return "<<=";
            __L162: /*case 4079165*/ 
            return ">>=";
            __L163: /*case 9789*/ 
            return "&=";
            __L164: /*case 31805*/ 
            return "|=";
            __L165: /*case 24125*/ 
            return "^=";
            __L166: /*case 9048*/ 
            return "__builtin_va_end";
            __L167: /*case 9049*/ 
            return "__builtin_va_arg";
            __L168: /*case 9050*/ 
            return "__builtin_c23_va_start";
            __L169: /*case 9051*/ 
            return "__builtin_va_copy";
            __L170: /*case 9052*/ 
            return "__builtin_offsetof";
            __L171: /* default */ 
            goto __L0; /* break */

        }
        __L0:;
    }
    return get_token_name(tk);
}


int stringify(char * input, int n, char output[])
{
    int count;
    char * p;

    count = 0;
    if (count < n)
    {
        output[count++] = 34;
    }
    p = input;
    while (*p)
    {
        if (*p == 34 || *p == 92)
        {
            if (count < n)
            {
                output[count++] = 92;
            }
            if (count < n)
            {
                output[count++] = *p;
            }
            p++;
        }
        else
        {
            if (count < n)
            {
                output[count++] = *p;
            }
            p++;
        }
    }
    if (count < n)
    {
        output[count++] = 34;
    }
    if (count < n)
    {
        output[count++] = 0;
    }
    if (count >= n)
    {
        return -count;
    }
    return count;
}


void print_literal(char * s)
{
    if (s == 0)
    {
        printf("\"");
        printf("\"");
        return;
    }
    printf("\"");
    while (*s)
    {
        /*switch*/
        {
            char __v0 = *s;
            if (__v0 == 10) goto __L2; /*case 10*/
            goto __L3; /* default */

            {
                __L2: /*case 10*/ 
                printf("\\n");
                goto __L1; /* break */

                __L3: /* default */ 
                printf("%c", *s);
            }
            __L1:;
        }
        s++;
    }
    printf("\"");
}


void print_code_as_we_see(struct token_list * list, unsigned char  remove_comments)
{
    struct token * current;

    if (list->head == 0 || list->tail == 0)
    {
        return;
    }
    current = list->head;
    while (current && current != list->tail->next)
    {
        if (current->level == 0 && !(current->flags & 2) && !(current->flags & 64) && current->type != 8998)
        {
            if ((current->flags & 4) && (current->prev != 0 && current->prev->type != 143))
            {
                printf(" ");
            }
            if (remove_comments)
            {
                if (current->type == 132)
                {
                    printf("\n");
                }
                else
                {
                    if (current->type == 133)
                    {
                        printf(" ");
                    }
                    else
                    {
                        printf("%s", current->lexeme);
                    }
                }
            }
            else
            {
                printf("%s", current->lexeme);
            }
        }
        current = current->next;
    }
}


char *get_code_as_we_see(struct token_list * list, unsigned char  remove_comments)
{
    struct osstream  ss;
    struct token * current;
    char * cstr;

    if (list->head == 0 || list->tail == 0)
    {
        return 0;
    }
    _cake_zmem(&ss, 12);
    current = list->head;
    while (current && current != list->tail->next)
    {
        if (current->level == 0 && !(current->flags & 2) && !(current->flags & 64) && current->type != 8998)
        {
            if ((current->flags & 4) && (current->prev != 0 && current->prev->type != 143))
            {
                ss_fprintf(&ss, " ");
            }
            if (remove_comments)
            {
                if (current->type == 132)
                {
                    ss_fprintf(&ss, "\n");
                }
                else
                {
                    if (current->type == 133)
                    {
                        ss_fprintf(&ss, " ");
                    }
                    else
                    {
                        ss_fprintf(&ss, "%s", current->lexeme);
                    }
                }
            }
            else
            {
                ss_fprintf(&ss, "%s", current->lexeme);
            }
        }
        current = current->next;
    }
    cstr = ss.c_str;
    ss.c_str = 0;
    ss_close(&ss);
    return cstr;
}


char *get_code_as_compiler_see(struct token_list * list)
{
    struct osstream  ss;
    struct token * current;

    if (list->head == 0 || list->tail == 0)
    {
        return 0;
    }
    _cake_zmem(&ss, 12);
    current = list->head;
    while (current && current != list->tail->next)
    {
        if (!(current->flags & 64) && current->type != 8998 && (current->flags & 1))
        {
            if (current->flags & 4)
            {
                ss_fprintf(&ss, " ");
            }
            if (current->flags & 8)
            {
                ss_fprintf(&ss, "\n");
            }
            if (current->type == 132)
            {
                ss_fprintf(&ss, "\n");
            }
            else
            {
                if (current->type == 133)
                {
                    ss_fprintf(&ss, " ");
                }
                else
                {
                    ss_fprintf(&ss, "%s", current->lexeme);
                }
            }
        }
        current = current->next;
    }
    return ss.c_str;
}


char *print_preprocessed_to_string2(struct token * p_token)
{
    struct osstream  ss;
    struct token * current;

    if (p_token == 0)
    {
        return strdup("(null)");
    }
    _cake_zmem(&ss, 12);
    current = p_token;
    while (current)
    {
        remove_line_continuation(current->lexeme);
        if (current->flags & 1)
        {
            if (current->level > 0)
            {
                if ((current->flags & 8))
                {
                    ss_fprintf(&ss, "\n");
                }
                else
                {
                    if ((current->flags & 4))
                    {
                        ss_fprintf(&ss, " ");
                    }
                }
            }
            else
            {
                if (current->flags & 2)
                {
                    if ((current->flags & 4))
                    {
                        ss_fprintf(&ss, " ");
                    }
                }
            }
            if (current->type == 128)
            {
                if (strcmp(current->lexeme, "_Pragma") == 0)
                {
                    ss_fprintf(&ss, "\n");
                }
                ss_fprintf(&ss, "#pragma ");
                current = current->next;
                while (current->type != 129)
                {
                    ss_fprintf(&ss, "%s", current->lexeme);
                    current = current->next;
                }
                ss_fprintf(&ss, "\n");
                current = current->next;
                continue;
            }
            if (current->lexeme[0] != 0)
            {
                ss_fprintf(&ss, "%s", current->lexeme);
            }
            current = current->next;
        }
        else
        {
            if (current->level == 0)
            {
                if (current->type == 143 || current->type == 10)
                {
                    ss_fprintf(&ss, "%s", current->lexeme);
                }
            }
            current = current->next;
        }
    }
    return ss.c_str;
}


char *print_preprocessed_to_string(struct token * p_token)
{
    struct osstream  ss;
    struct token * current;
    unsigned char  first;

    _cake_zmem(&ss, 12);
    current = p_token;
    while (!(current->flags & 1) || current->type == 143 || current->type == 133 || current->type == 132 || current->type == 10 || current->type == 127)
    {
        current = current->next;
        if (current == 0)
        {
            return ss.c_str;
        }
    }
    first = 1;
    while (current)
    {
        ;
        if (current->flags & 1)
        {
            if (!first && current->flags & 8)
            {
                ss_fprintf(&ss, "\n");
            }
            else
            {
                if (!first && current->flags & 4)
                {
                    ss_fprintf(&ss, " ");
                }
            }
            if (current->lexeme[0] != 0)
            {
                ss_fprintf(&ss, "%s", current->lexeme);
            }
            first = 0;
            current = current->next;
        }
        else
        {
            current = current->next;
        }
    }
    return ss.c_str;
}


void print_preprocessed(struct token * p_token)
{
    char * s;

    s = print_preprocessed_to_string(p_token);
    if (s)
    {
        printf("%s", s);
        free((void *)s);
    }
}


void print_all_macros(struct preprocessor_ctx * prectx)
{
    {
        int i;

        i = 0;
        for (; i < prectx->macros.capacity; i++)
        {
            struct map_entry * entry;
            struct macro * macro;
            struct token * token;

            entry = prectx->macros.table[i];
            if (entry == 0)
            {
                continue;
            }
            ;
            macro = entry->data.p_macro;
            printf("#define %s", macro->name);
            if (macro->is_function)
            {
                struct macro_parameter * parameter;

                printf("(");
                parameter = macro->parameters;
                while (parameter)
                {
                    printf("%s", parameter->name);
                    if (parameter->next)
                    {
                        printf(",");
                    }
                    parameter = parameter->next;
                }
                printf(")");
            }
            printf(" ");
            token = macro->replacement_list.head;
            while (token)
            {
                printf("%s", token->lexeme);
                if (token == macro->replacement_list.tail)
                {
                    break;
                }
                token = token->next;
            }
            printf("\n");
        }
    }
}


unsigned char is_diagnostic_enabled(struct options * options, int w);
static unsigned char is_screaming_case(char * text);

void naming_convention_macro(struct preprocessor_ctx * ctx, struct token * token)
{
    if (!is_diagnostic_enabled(&ctx->options, 11) || token->level != 0)
    {
        return;
    }
    if (!is_screaming_case(token->lexeme))
    {
        preprocessor_diagnostic(0, ctx, token, "use SCREAMING_CASE for macros");
    }
}



static unsigned char is_screaming_case(char * text)
{
    unsigned char  screaming_case;

    screaming_case = 0;
    while (*text)
    {
        if ((*text >= 65 && *text <= 90) || (*text >= 48 && *text <= 57) || (*text == 95))
        {
            screaming_case = 1;
        }
        else
        {
            return 0;
        }
        text++;
    }
    return screaming_case;
}
void ss_swap(struct osstream * a, struct osstream * b)
{
    struct osstream  r;

    r = *a;
    *a = *b;
    *b = r;
}


void ss_clear(struct osstream * stream)
{
    if (stream->c_str)
    {
        stream->c_str[0] = 0;
    }
    stream->size = 0;
}


void ss_close(struct osstream * stream)
{
    free(stream->c_str);
}


static int reserve(struct osstream * stream, int size);
void *realloc(void * ptr, unsigned int size);
int *__cdecl _errno(void);
static int __cdecl vsprintf(char * _Buffer, char * _Format, char * _ArgList);
static int __cdecl _vsnprintf_l(char * _Buffer, unsigned int _BufferCount, char * _Format, struct __crt_locale_pointers * _Locale, char * _ArgList);

int ss_vafprintf(struct osstream * stream, char * fmt, char * args)
{
    int size;
    char * tmpa;

    ;
    size = 0;
    _cake_zmem(&tmpa, 4);
    ((tmpa) = (args));
    size = vsnprintf(stream->c_str + stream->size, stream->capacity - stream->size, fmt, tmpa);
    ((void)(tmpa = (char *)0));
    if (size < 0)
    {
        return -1;
    }
    if (reserve(stream, stream->size + size) != 0)
    {
        return -1;
    }
    size = vsprintf(stream->c_str + stream->size, fmt, args);
    if (size > 0)
    {
        stream->size += size;
    }
    return size;
}



static int reserve(struct osstream * stream, int size)
{
    int errorcode;

    errorcode = 0;
    if (size > stream->capacity)
    {
        void * pnew;

        pnew = realloc(stream->c_str, (size + 1) * 1);
        if (pnew)
        {
            stream->c_str = pnew;
            stream->capacity = size;
            stream->c_str[size] = 0;
        }
        else
        {
            (*_errno()) = 12;
            errorcode = 1;
        }
    }
    return errorcode;
}

static int __cdecl _vsnprintf_l(char * _Buffer, unsigned int _BufferCount, char * _Format, struct __crt_locale_pointers * _Locale, char * _ArgList)
{
    int _Result;

    _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | 1ULL, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    return _Result < 0 ? -1 : _Result;
}

static int __cdecl vsprintf(char * _Buffer, char * _Format, char * _ArgList)
{
    return _vsnprintf_l(_Buffer, 4294967295, _Format, 0, _ArgList);
}
int ss_putc(char ch, struct osstream * stream)
{
    if (reserve(stream, stream->size + 1) != 0)
    {
        return -1;
    }
    stream->c_str[stream->size] = ch;
    stream->size++;
    return ch;
}


int ss_fprintf(struct osstream * stream, char * fmt, ...)
{
    char * args;
    int size;

    _cake_zmem(&args, 4);
    ((void)(args = (char *)(&(fmt)) + 4));
    size = ss_vafprintf(stream, fmt, args);
    ((void)(args = (char *)0));
    return size;
}


__declspec(selectany) int _Avx2WmemEnabledWeakValue = 0;
int __cdecl tolower(int _C);

unsigned char path_is_normalized(char * path)
{
    {
        char * p;

        p = path;
        for (; *p; p++)
        {
            int before;
            int after;

            before = *p;
            after = tolower(*p);
            if (before != after)
            {
                return 0;
            }
            if (after == 92)
            {
                return 0;
            }
        }
    }
    return 1;
}


void path_normalize(char * path)
{
    {
        char * p;

        p = path;
        for (; *p; p++)
        {
            *p = (char)tolower(*p);
            if (*p == 92)
            {
                *p = 47;
            }
        }
    }
}


unsigned char path_is_absolute(char * path)
{
    char ch;

    ch = (char)tolower(path[0]);
    if (ch >= 97 && ch <= 122)
    {
        if (path[1] == 58 && (path[2] == 92 || path[2] == 47))
        {
            return 1;
        }
    }
    if (path[0] == 92 && path[1] == 92)
    {
        return 1;
    }
    return 0;
}


unsigned char path_is_relative(char * path)
{
    return !path_is_absolute(path);
}


void *__stdcall FindFirstFileA(char * lpFileName, struct _WIN32_FIND_DATAA * lpFindFileData);
int __stdcall FindClose(void * hFindFile);
int windows_error_to_posix(int i);
unsigned long __stdcall GetLastError(void);

struct TAGDIR *opendir(char * name)
{
    struct _WIN32_FIND_DATAA  fdfile;
    char path[260];
    void * handle;

    ;
    _cake_zmem(&fdfile, 320);
    _cake_zmem(&path, 260);
    strcat(path, name);
    strcat(path, "\\*.*");
    handle = FindFirstFileA(path, &fdfile);
    if (handle != ((void *)-1L))
    {
        struct TAGDIR * p;

        p = calloc(1, 272);
        if (p)
        {
            p->handle = handle;
            return p;
        }
        else
        {
            FindClose(handle);
        }
    }
    else
    {
        (*_errno()) = windows_error_to_posix(GetLastError());
    }
    return 0;
}


int closedir(struct TAGDIR * dirp)
{
    FindClose(dirp->handle);
    free(dirp);
    return 0;
}


int __stdcall FindNextFileA(void * hFindFile, struct _WIN32_FIND_DATAA * lpFindFileData);
void *__cdecl memset(void * _Dst, int _Val, unsigned int _Size);

struct dirent *readdir(struct TAGDIR * dirp)
{
    struct _WIN32_FIND_DATAA  fdfile;
    int b;

    _cake_zmem(&fdfile, 320);
    b = FindNextFileA(dirp->handle, &fdfile);
    if (b)
    {
        memset(&dirp->dirent, 0, 268);
        if (fdfile.dwFileAttributes & 16)
        {
            dirp->dirent.d_type |= 4;
        }
        strncpy(dirp->dirent.d_name, fdfile.cFileName, 255);
        return &dirp->dirent;
    }
    else
    {
        (*_errno()) = windows_error_to_posix(GetLastError());
    }
    return 0;
}


char *__cdecl _fullpath(char * _Buffer, char * _Path, unsigned int _BufferCount);

char *realpath(char * path, char * resolved_path)
{
    char * p;

    p = _fullpath(resolved_path, path, 260);
    if (p)
    {
        char * p2;

        p2 = resolved_path;
        while (*p2)
        {
            if (*p2 == 92)
            {
                *p2 = 47;
            }
            p2++;
        }
    }
    return p;
}


unsigned int __cdecl fwrite(void * _Buffer, unsigned int _ElementSize, unsigned int _ElementCount, struct _iobuf * _Stream);

int copy_file(char * pathfrom, char * pathto)
{
    struct _iobuf * fd_from;
    struct _iobuf * fd_to;
    char buf[4096];
    unsigned int nread;

    fd_from = fopen(pathfrom, "rb");
    if (fd_from == 0)
    {
        return -1;
    }
    fd_to = fopen(pathto, "wb");
    if (fd_to == 0)
    {
        fclose(fd_from);
        return -1;
    }
    _cake_zmem(&buf, 4096);
    while (nread = fread(buf, 1, 4096, fd_from), nread > 0)
    {
        char * out_ptr;
        unsigned int nwritten;

        out_ptr = buf;
        do
        {
            nwritten = fwrite(out_ptr, 1, nread, fd_to);
            nread -= nwritten;
            out_ptr += nwritten;
        }
        while (nread > 0);
    }
    if (nread == 0)
    {
        fclose(fd_to);
        fclose(fd_from);
        return 0;
    }
    fclose(fd_to);
    fclose(fd_from);
    return -1;
}


int __cdecl _mkdir(char * _Path);

int copy_folder(char * from, char * to)
{
    int errcode;
    struct TAGDIR * dir;
    struct dirent * dp;

    errcode = _mkdir(to);
    if (errcode != 0)
    {
        return errcode;
    }
    dir = opendir(from);
    if (dir == 0)
    {
        return (*_errno());
    }
    while ((dp = readdir(dir)) != 0)
    {
        char fromlocal[260];
        char tolocal[260];

        if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
        {
            continue;
        }
        _cake_zmem(&fromlocal, 260);
        snprintf(fromlocal, 260, "%s/%s", from, dp->d_name);
        _cake_zmem(&tolocal, 260);
        snprintf(tolocal, 260, "%s/%s", to, dp->d_name);
        if (dp->d_type & 4)
        {
            errcode = copy_folder(fromlocal, tolocal);
        }
        else
        {
            errcode = copy_file(fromlocal, tolocal);
        }
        if (errcode != 0)
        {
            break;
        }
    }
    closedir(dir);
    return errcode;
}


unsigned long __stdcall GetModuleFileNameA(struct HINSTANCE__ * hModule, char * lpFilename, unsigned long nSize);

int get_self_path(char * buffer, int maxsize)
{
    unsigned long r;

    r = GetModuleFileNameA(0, buffer, maxsize);
    return r;
}


char *strrchr_ex(char * s, int c1, int c2)
{
    char * last;
    char * p;

    last = 0;
    p = s;
    while (*p)
    {
        if (*p == c1 || *p == c2)
        {
            last = p;
        }
        p++;
    }
    return (char *)last;
}


void remove_file_extension(char * filename, int n, char out[])
{
    int last_dot_index;
    char * p;
    int count;

    last_dot_index = -1;
    p = filename;
    count = 0;
    while (*p)
    {
        if (n == count)
        {
            break;
        }
        if (*p == 46)
        {
            last_dot_index = count;
        }
        out[count] = *p;
        count++;
        p++;
    }
    out[count] = 0;
    if (last_dot_index > 0)
    {
        out[last_dot_index] = 0;
    }
}


char *basename(char * filename)
{
    char * p;

    p = strrchr_ex(filename, 47, 92);
    return p ? p + 1 : (char *)filename;
}


char *dirname(char * path)
{
    int last;

    last = -1;
    {
        int i;

        i = 0;
        for (; path[i]; i++)
        {
            if (path[i] == 92 || path[i] == 47)
            {
                last = i;
            }
        }
    }
    if (last != -1)
    {
        path[last] = 0;
    }
    else
    {
        path[0] = 0;
    }
    return path;
}


static int __cdecl stat(char * _FileName, struct stat * _Stat);
int __cdecl _stat64i32(char * _FileName, struct _stat64i32 * _Stat);

char *read_file(char * path, unsigned char  append_newline)
{
    char * data;
    struct _iobuf * file;
    struct stat  info;
    unsigned int mem_size_bytes;
    unsigned int bytes_read;
    unsigned int bytes_read_part2;

    data = 0;
    file = 0;
    _cake_zmem(&info, 48);
    if (stat(path, &info) != 0)
    {
        return 0;
    }
    mem_size_bytes = 1 * info.st_size + 1 + 1;
    if (mem_size_bytes < 4)
    {
        mem_size_bytes = 4;
    }
    data = malloc(mem_size_bytes);
    if (data == 0)
    {
        return 0;
    }
    file = fopen(path, "r");
    if (file == 0)
    {
        free(data);
        return 0;
    }
    bytes_read = fread(data, 1, 3, file);
    if (bytes_read < 3)
    {
        data[bytes_read] = 0;
        if (feof(file))
        {
            fclose(file);
            return data;
        }
        free(data);
        fclose(file);
        return 0;
    }
    bytes_read_part2 = 0;
    if ((unsigned char)data[0] == 239 && (unsigned char)data[1] == 187 && (unsigned char)data[2] == 191)
    {
        bytes_read_part2 = fread(&data[0], 1, info.st_size - 3, file);
    }
    else
    {
        bytes_read_part2 = fread(&data[3], 1, info.st_size - 3, file);
        bytes_read_part2 = bytes_read_part2 + 3;
    }
    data[bytes_read_part2] = 0;
    if (append_newline && data[bytes_read_part2 - 1] != 10)
    {
        data[bytes_read_part2] = 10;
        ;
        data[bytes_read_part2 + 1] = 0;
    }
    fclose(file);
    return data;
}



static int __cdecl stat(char * _FileName, struct stat * _Stat)
{
    return _stat64i32(_FileName, (struct _stat64i32 *)_Stat);
}
static int bitset_get(struct bitset * b, int pos);

unsigned char is_diagnostic_enabled(struct options * options, int w)
{
    if (w == 0)
    {
        return 1;
    }
    if (w >= 128)
    {
        return 1;
    }
    return bitset_get(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].errors, w) || bitset_get(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].warnings, w) || bitset_get(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].notes, w);
}



static int bitset_get(struct bitset * b, int pos)
{
    int word;
    int bit;

    if (pos < 0 || pos >= 128)
    {
        return 0;
    }
    word = pos / 32;
    bit = pos % 32;
    return (b->bits[word] >> bit) & 1L;
}
unsigned char is_diagnostic_note(int id)
{
    if (id == 0)
    {
        return 1;
    }
    return 0;
}


unsigned char is_diagnostic_warning(int id)
{
    if (id == 0)
    {
        return 0;
    }
    return id < 128;
}


unsigned char is_diagnostic_error(int id)
{
    if (id == 0)
    {
        return 0;
    }
    return id >= 128;
}


unsigned char is_diagnostic_configurable(int id)
{
    if (id == 0)
    {
        return 0;
    }
    return id >= 0 && id < 128;
}


int diagnostic_id_stack_push(struct diagnostic_id_stack * diagnostic_stack, int id)
{
    if (diagnostic_stack->size < 10)
    {
        diagnostic_stack->stack[diagnostic_stack->size] = id;
        diagnostic_stack->size++;
    }
    return 0;
}


void diagnostic_id_stack_pop(struct diagnostic_id_stack * diagnostic_stack)
{
    if (diagnostic_stack->size > 0)
    {
        diagnostic_stack->size--;
    }
    else
    {
        ;
    }
}


static void bitset_clear(struct bitset * b);

int diagnostic_stack_push_empty(struct diagnostic_stack * diagnostic_stack)
{
    int index;

    if (diagnostic_stack->top_index >= 10)
    {
        ;
        return 0;
    }
    index = diagnostic_stack->top_index;
    diagnostic_stack->top_index++;
    bitset_clear(&diagnostic_stack->stack[diagnostic_stack->top_index].errors);
    bitset_clear(&diagnostic_stack->stack[diagnostic_stack->top_index].warnings);
    bitset_clear(&diagnostic_stack->stack[diagnostic_stack->top_index].notes);
    return index;
}



static void bitset_clear(struct bitset * b)
{
    {
        int i;

        i = 0;
        for (; i < 4; ++i)
        b->bits[i] = 0;
    }
}
void diagnostic_stack_pop(struct diagnostic_stack * diagnostic_stack)
{
    if (diagnostic_stack->top_index > 0)
    {
        diagnostic_stack->top_index--;
    }
    else
    {
        ;
    }
}


static void bitset_set(struct bitset * b, int pos, int value);

void diagnostic_remove(struct diagnostic * d, int w)
{
    if (!is_diagnostic_configurable(w))
    {
        return;
    }
    bitset_set(&d->warnings, w, 0);
    bitset_set(&d->errors, w, 0);
    bitset_set(&d->notes, w, 0);
}



static void bitset_set(struct bitset * b, int pos, int value)
{
    int word;
    int bit;
    unsigned long mask;

    if (pos < 0 || pos >= 128)
    {
        return;
    }
    word = pos / 32;
    bit = pos % 32;
    mask = 1L << bit;
    if (value)
    {
        b->bits[word] |= mask;
    }
    else
    {
        b->bits[word] &= ~mask;
    }
}
int get_diagnostic_type(struct diagnostic * d, int w)
{
    if (w == 0)
    {
        return 1;
    }
    if (is_diagnostic_configurable(w))
    {
        if (bitset_get(&d->errors, w))
        {
            return 3;
        }
        if (bitset_get(&d->warnings, w))
        {
            return 2;
        }
        if (bitset_get(&d->notes, w))
        {
            return 1;
        }
    }
    return 3;
}


int get_diagnostic_phase(int w)
{
    /*switch*/
    {
        int __v0 = w;
        if (__v0 == 35) goto __L1; /*case 35*/
        if (__v0 == 29) goto __L2; /*case 29*/
        if (__v0 == 30) goto __L3; /*case 30*/
        if (__v0 == 32) goto __L4; /*case 32*/
        if (__v0 == 33) goto __L5; /*case 33*/
        if (__v0 == 34) goto __L6; /*case 34*/
        if (__v0 == 28) goto __L7; /*case 28*/
        if (__v0 == 31) goto __L8; /*case 31*/
        if (__v0 == 36) goto __L9; /*case 36*/
        goto __L10; /* default */

        {
            __L1: /*case 35*/ 
            __L2: /*case 29*/ 
            __L3: /*case 30*/ 
            __L4: /*case 32*/ 
            __L5: /*case 33*/ 
            __L6: /*case 34*/ 
            __L7: /*case 28*/ 
            __L8: /*case 31*/ 
            __L9: /*case 36*/ 
            return 2;
            __L10: /* default */ 
            goto __L0; /* break */

        }
        __L0:;
    }
    return 0;
}


void options_set_all_warnings(struct options * options);
void options_set_warning(struct options * options, int w, unsigned char  value);
char *__cdecl strcpy(char * _Destination, char * _Source);
int __cdecl atoi(char * _String);
static int has_prefix(char * str, char * prefix);
int __cdecl strncmp(char * _Str1, char * _Str2, unsigned int _MaxCount);
int parse_target(char * targetstr, int * target);
void print_target_options();

int fill_options(struct options * options, int argc, char ** argv)
{
    options->target = 1;
    options_set_all_warnings(options);
    options_set_warning(options, 33, 0);
    options_set_warning(options, 35, 0);
    options_set_warning(options, 6, 0);
    options_set_warning(options, 2, 0);
    options_set_warning(options, 11, 0);
    {
        int i;

        i = 1;
        for (; i < argc; i++)
        {
            if (argv[i][0] != 45)
            {
                continue;
            }
            if (argv[i][1] == 73 || argv[i][1] == 68)
            {
                continue;
            }
            if (strcmp(argv[i], "-no-output") == 0)
            {
                options->no_output = 1;
                continue;
            }
            if (strcmp(argv[i], "-const-literal") == 0)
            {
                options->const_literal = 1;
                continue;
            }
            if (strcmp(argv[i], "-o") == 0)
            {
                if (i + 1 < argc)
                {
                    strcpy(options->output, argv[i + 1]);
                    i++;
                }
                else
                {
                }
                continue;
            }
            if (strcmp(argv[i], "-sarif-path") == 0)
            {
                if (i + 1 < argc)
                {
                    strcpy(options->sarifpath, argv[i + 1]);
                    i++;
                }
                else
                {
                }
                continue;
            }
            if (strcmp(argv[i], "-H") == 0)
            {
                options->show_includes = 1;
                continue;
            }
            if (strcmp(argv[i], "-E") == 0)
            {
                options->preprocess_only = 1;
                continue;
            }
            if (strcmp(argv[i], "-preprocess-def-macro") == 0)
            {
                options->preprocess_def_macro = 1;
                continue;
            }
            if (strcmp(argv[i], "-sarif") == 0)
            {
                options->sarif_output = 1;
                continue;
            }
            if (strcmp(argv[i], "-fanalyzer") == 0)
            {
                options->flow_analysis = 1;
                continue;
            }
            if (strcmp(argv[i], "-nullchecks") == 0)
            {
                options->null_checks_enabled = 1;
                continue;
            }
            if (strcmp(argv[i], "-debug") == 0)
            {
                options->do_static_debug = 1;
                if (i + 1 < argc)
                {
                    i++;
                    options->static_debug_lines = atoi(argv[i]);
                }
                else
                {
                }
                continue;
            }
            if (has_prefix(argv[i], "-ownership="))
            {
                if (strcmp(argv[i], "-ownership=enable") == 0)
                {
                    options->ownership_enabled = 1;
                    continue;
                }
                if (strcmp(argv[i], "-ownership=disable") == 0)
                {
                    options->ownership_enabled = 0;
                    continue;
                }
                printf("Invalid option. Options are: enable, disable\n");
                continue;
            }
            if (strcmp(argv[i], "-comment-to-attr") == 0)
            {
                options->comment_to_attribute = 1;
                continue;
            }
            if (strcmp(argv[i], "-test-mode") == 0)
            {
                options->test_mode = 1;
                continue;
            }
            if (strcmp(argv[i], "-test-mode-in-out") == 0)
            {
                options->test_mode = 1;
                options->test_mode_inout = 1;
                continue;
            }
            if (has_prefix(argv[i], "-fdiagnostics"))
            {
                if (strcmp(argv[i], "-fdiagnostics-color=never") == 0)
                {
                    options->color_disabled = 1;
                    continue;
                }
                if (strcmp(argv[i], "-fdiagnostics-format=msvc") == 0)
                {
                    options->visual_studio_ouput_format = 1;
                    continue;
                }
                printf("Invalid. Valid options are:-fdiagnostics-color=never -fdiagnostics-format=msvc\n");
            }
            if (strcmp(argv[i], "-msvc-output") == 0)
            {
                options->visual_studio_ouput_format = 1;
                continue;
            }
            if (has_prefix(argv[i], "-style"))
            {
                if (strcmp(argv[i], "-style=cake") == 0)
                {
                    options->style = 0;
                    continue;
                }
                if (strcmp(argv[i], "-style=gnu") == 0)
                {
                    options->style = 7;
                    continue;
                }
                if (strcmp(argv[i], "-style=microsoft") == 0)
                {
                    options->style = 7;
                    continue;
                }
                printf("Invalid style. Options are: cake, gnu, microsoft\n");
            }
            if (has_prefix(argv[i], "-nullable="))
            {
                if (strcmp(argv[i], "-nullable=disable") == 0)
                {
                    options->null_checks_enabled = 0;
                    continue;
                }
                if (strcmp(argv[i], "-nullable=enabled") == 0)
                {
                    options->null_checks_enabled = 1;
                    continue;
                }
                printf("Invalid option. Options are: disable, enabled\n");
                continue;
            }
            if (strcmp(argv[i], "-autoconfig") == 0 || strcmp(argv[i], "-auto-config") == 0)
            {
                options->auto_config = 1;
                continue;
            }
            if (has_prefix(argv[i], "-target="))
            {
                int r;

                r = parse_target(argv[i] + 8, &options->target);
                if (r != 0)
                {
                    printf("Invalid target. Options: ");
                    print_target_options();
                    printf("\n");
                }
                continue;
            }
            if (strcmp(argv[i], "-std=c2x") == 0 || strcmp(argv[i], "-std=c23") == 0)
            {
                options->input = 0;
                continue;
            }
            if (strcmp(argv[i], "-std=cxx") == 0)
            {
                options->input = 2;
                continue;
            }
            if (argv[i][1] == 119)
            {
                unsigned char  enable_warning;
                int w;

                if (strcmp(argv[i], "-wall") == 0)
                {
                    options_set_all_warnings(options);
                    continue;
                }
                enable_warning = (argv[i][2] != 100);
                w = atoi(argv[i] + 3);
                if (!is_diagnostic_configurable(w))
                {
                    printf("diagnostic '%d' is not configurable", w);
                    return 1;
                }
                options_set_warning(options, w, enable_warning);
                continue;
            }
            if (strcmp(argv[i], "-dump-tokens") == 0)
            {
                options->dump_tokens = 1;
                continue;
            }
            if (strcmp(argv[i], "-dump-pp-tokens") == 0)
            {
                options->dump_pptokens = 1;
                continue;
            }
            if (strcmp(argv[i], "-disable-assert") == 0)
            {
                options->disable_assert = 1;
                continue;
            }
            printf("unknown option '%s'", argv[i]);
            return 1;
        }
    }
    return 0;
}



static int has_prefix(char * str, char * prefix)
{
    unsigned int len_prefix;

    len_prefix = strlen(prefix);
    return strncmp(str, prefix, len_prefix) == 0;
}
static void print_option(char * option, char * description);

void print_help()
{
    char * sample;

    sample = "\x1b[92mUsage : \x1b[0mcake \x1b[34;1m[OPTIONS] source1.c source2.c ...\n\x1b[0m\n\x1b[92mSamples:\n\x1b[0m\n\x1b[97m    cake source.c\n\x1b[0m    Compiles source.c and outputs /out/source.c\n\n\x1b[97m    cake file.c -o file.cc && cl file.cc\n\x1b[0m    Compiles file.c and outputs file.cc then use cl to compile file.cc\n\n\x1b[92mOptions:\n\n\x1b[0m";
    printf("%s", sample);
    print_option("-I", "Adds a directory to the list of directories searched for include files");
    print_option("-auto-config", "Generates cakeconfig.h with include directories");
    print_option("-no-output", "Cake will not generate output");
    print_option("-D", "Defines a preprocessing symbol for a source file");
    print_option("-E", "Copies preprocessor output to standard output");
    print_option("-o name", "Defines the output name when compiling one file");
    print_option("-no-discard", "Makes [[nodiscard]] default implicitly");
    print_option("-w -wd", "Enables or disable warning number");
    print_option("-wall", "Enables all warnings");
    print_option("-fanalyzer ", "Runs flow analysis -  required for ownership");
    print_option("-sarif ", "Generates sarif files");
    print_option("-H", "Print the name of each header file used");
    print_option("-sarif-path", "Set sarif output dir");
    print_option("-msvc-output", "Output is compatible with visual studio");
    print_option("-fdiagnostics-color=never", "Output will not use colors");
    print_option("-dump-tokens", "Output tokens before preprocessor");
    print_option("-dump-pp-tokens", "Output tokens after preprocessor");
    print_option("-disable-assert", "disables built-in assert");
    print_option("-const-literal", "literal string becomes const");
    print_option("-preprocess-def-macro", "preprocess def macros after expansion");
    print_option("-comment-to-attr", "convert comments /*!w#*/ into attributes [[cake::w#]]");
    print_option("-style=name", "Set the style used in w011 style warnings. Options are `-style=cake`, `-style=gnu`, `-style=microsoft`");
    print_option("-selftest", "Runs Cake's internal tests. The code must be compiled with -DTEST.");
    print_option("-disable-assert", "Disable cake assert extension.");
    print_option("-const-literal", "Makes the compiler handle string literals as const char[] rather than char[].");
    printf("\n");
    printf("More details at http://cakecc.org/manual.html\n");
}



static void print_option(char * option, char * description)
{
    char * p;
    int count;
    int first_colum;
    unsigned char  breakline;

    p = option;
    count = 0;
    first_colum = 28;
    printf("\x1b[36;1m ");
    while (*p)
    {
        printf("%c", *p);
        count++;
        p++;
    }
    printf("%s", "\x1b[0m");
    for (; count < first_colum; count++)
    printf(" ");
    p = description;
    breakline = 0;
    while (*p)
    {
        printf("%c", *p);
        count++;
        if (count > 70)
        {
            breakline = 1;
        }
        if (breakline && *p == 32)
        {
            breakline = 0;
            printf("\n ");
            count = 0;
            for (; count < first_colum; count++)
            printf(" ");
        }
        p++;
    }
    printf("%s\n", "\x1b[0m");
}
void options_set_error(struct options * options, int w, unsigned char  value)
{
    bitset_set(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].warnings, w, 0);
    bitset_set(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].notes, w, 0);
    bitset_set(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].errors, w, value);
}


void options_set_warning(struct options * options, int w, unsigned char  value)
{
    bitset_set(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].errors, w, 0);
    bitset_set(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].notes, w, 0);
    bitset_set(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].warnings, w, value);
}


static void bitset_setall(struct bitset * b);

void options_set_all_warnings(struct options * options)
{
    bitset_setall(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].warnings);
}



static void bitset_setall(struct bitset * b)
{
    unsigned long mask;

    mask = 4294967295L;
    {
        int i;

        i = 0;
        for (; i < 4; ++i)
        b->bits[i] = mask;
    }
}
void options_set_clear_all_warnings(struct options * options)
{
    bitset_clear(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].warnings);
}


void options_set_note(struct options * options, int w, unsigned char  value)
{
    bitset_set(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].errors, w, 0);
    bitset_set(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].warnings, w, 0);
    bitset_set(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].notes, w, value);
}


unsigned char options_diagnostic_is_error(struct options * options, int w)
{
    if (w == 0)
    {
        return 0;
    }
    if (w >= 128)
    {
        return 1;
    }
    return (bitset_get(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].errors, w) != 0);
}


unsigned char options_diagnostic_is_warning(struct options * options, int w)
{
    if (w == 0)
    {
        return 0;
    }
    if (w >= 128)
    {
        return 0;
    }
    return (bitset_get(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].warnings, w) != 0);
}


unsigned char options_diagnostic_is_note(struct options * options, int w)
{
    if (w == 0)
    {
        return 0;
    }
    if (w >= 128)
    {
        return 0;
    }
    return (bitset_get(&options->diagnostic_stack.stack[options->diagnostic_stack.top_index].notes, w) != 0);
}


unsigned char unsigned_long_long_sub(unsigned long long * result, unsigned long long a, unsigned long long b)
{
    *result = 0;
    if (a < b)
    {
        return 0;
    }
    *result = a - b;
    return 1;
}


unsigned char unsigned_long_long_mul(unsigned long long * result, unsigned long long a, unsigned long long b)
{
    *result = 0;
    if (b == 0)
    {
        *result = 0;
        return 1;
    }
    if (a > 18446744073709551615ULL / b)
    {
        return 0;
    }
    *result = a * b;
    return 1;
}


unsigned char unsigned_long_long_add(unsigned long long * result, unsigned long long a, unsigned long long b)
{
    *result = 0;
    if (a > 18446744073709551615ULL - b)
    {
        return 0;
    }
    *result = a + b;
    return 1;
}


unsigned char signed_long_long_sub(signed long long * result, signed long long a, signed long long b)
{
    *result = 0;
    if (a >= 0 && b >= 0)
    {
    }
    else
    {
        if (a < 0 && b < 0)
        {
        }
        else
        {
            if (a < 0)
            {
                if (a < -9223372036854775808LL + b)
                {
                    return 0;
                }
            }
            else
            {
                if (b == -9223372036854775808LL)
                {
                    return 0;
                }
                if (a > 9223372036854775807LL - (-b))
                {
                    return 0;
                }
            }
        }
    }
    *result = a - b;
    return 1;
}


unsigned char signed_long_long_add(signed long long * result, signed long long a, signed long long b)
{
    *result = 0;
    if (a >= 0 && b >= 0)
    {
        if (a > 9223372036854775807LL - b)
        {
            return 0;
        }
    }
    else
    {
        if (a < 0 && b < 0)
        {
            if (a == -9223372036854775808LL || b == -9223372036854775808LL)
            {
                return 0;
            }
            if (a < -9223372036854775808LL - b)
            {
                return 0;
            }
        }
        else
        {
        }
    }
    *result = a + b;
    return 1;
}


unsigned char signed_long_long_mul(signed long long * result, signed long long a, signed long long b)
{
    *result = 0;
    if (a > 0 && b > 0)
    {
        if (a > 9223372036854775807LL / b)
        {
            return 0;
        }
    }
    else
    {
        if (a < 0 && b < 0)
        {
            if (a == -9223372036854775808LL || b == -9223372036854775808LL)
            {
                return 0;
            }
            if (-a > 9223372036854775807LL / -b)
            {
                return 0;
            }
        }
        else
        {
            if (a == 0 || b == 0)
            {
                *result = 0;
                return 1;
            }
            if (b > 0)
            {
                if (a < -9223372036854775808LL / b)
                {
                    return 0;
                }
            }
            else
            {
                if (b < -9223372036854775808LL / a)
                {
                    return 0;
                }
            }
        }
    }
    *result = a * b;
    return 1;
}


void object_list_push(struct object_list * list, struct object * pnew)
{
    if (list->head == 0)
    {
        list->head = pnew;
        list->tail = pnew;
    }
    else
    {
        ;
        list->tail->next = pnew;
        list->tail = pnew;
    }
    list->count++;
}


void object_swap(struct object * a, struct object * b)
{
    struct object  temp;

    temp = *a;
    *a = *b;
    *b = temp;
}


void type_destroy(struct type * p_type);
void object_delete(struct object * p);

void object_destroy(struct object * p)
{
    struct object * item;

    ;
    type_destroy(&p->type);
    free((void *)p->member_designator);
    item = p->members.head;
    while (item)
    {
        struct object * next;

        next = item->next;
        item->next = 0;
        object_delete(item);
        item = next;
    }
}


void object_delete(struct object * p)
{
    if (p)
    {
        object_destroy(p);
        free(p);
    }
}


struct object *object_get_referenced(struct object * p_object);

unsigned char object_has_constant_value(struct object * a)
{
    a = object_get_referenced(a);
    return a->state == 2;
}


struct platform *get_platform(int target);
int target_get_num_of_bits(int target, int type);
static unsigned long long wrap_unsigned_integer(unsigned long long value, int bits);

struct object object_make_size_t(int target, unsigned long long value)
{
    struct object  r;
    int bits;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = get_platform(target)->size_t_type;
    bits = target_get_num_of_bits(target, r.value_type);
    r.value.host_u_long_long = wrap_unsigned_integer(value, bits);
    return r;
}



static unsigned long long wrap_unsigned_integer(unsigned long long value, int bits)
{
    unsigned long long mask;

    ;
    if (bits == 0 || bits >= 64)
    {
        return value;
    }
    mask = (1ULL << bits) - 1;
    return value & mask;
}
struct object object_make_nullptr(int target)
{
    struct object  r;
    int bits;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = get_platform(target)->size_t_type;
    bits = target_get_num_of_bits(target, r.value_type);
    r.value.host_u_long_long = wrap_unsigned_integer(0, bits);
    return r;
}


static unsigned char object_type_is_signed_integer(int type);
static long long wrap_signed_integer(long long value, int bits);

struct object object_make_char(int target, int value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = get_platform(target)->char_t_type;
    if (object_type_is_signed_integer(r.value_type))
    {
        r.value.host_long_long = wrap_signed_integer(value, get_platform(target)->char_n_bits);
    }
    else
    {
        r.value.host_u_long_long = wrap_unsigned_integer(value, get_platform(target)->char_n_bits);
    }
    return r;
}



static unsigned char object_type_is_signed_integer(int type)
{
    /*switch*/
    {
        int __v0 = type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            return 1;
            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            goto __L0; /* break */

        }
        __L0:;
    }
    return 0;
}

static long long wrap_signed_integer(long long value, int bits)
{
    unsigned long long mask;
    unsigned long long wrapped;

    ;
    if (bits == 0 || bits >= 64)
    {
        return value;
    }
    mask = (1ULL << bits) - 1;
    wrapped = (unsigned long long)value & mask;
    if (wrapped & (1ULL << (bits - 1)))
    {
        return (long long)(wrapped | ~mask);
    }
    return (long long)wrapped;
}
struct object object_make_wchar_t(int target, int value)
{
    struct object  r;
    int bits;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = get_platform(target)->wchar_t_type;
    bits = target_get_num_of_bits(target, r.value_type);
    r.value.host_u_long_long = wrap_unsigned_integer(value, bits);
    return r;
}


struct object object_make_bool(int target, unsigned char  value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = get_platform(target)->bool_type;
    if (object_type_is_signed_integer(r.value_type))
    {
        r.value.host_long_long = wrap_signed_integer(value, get_platform(target)->bool_n_bits);
    }
    else
    {
        r.value.host_u_long_long = wrap_unsigned_integer(value, get_platform(target)->bool_n_bits);
    }
    return r;
}


int object_to_str(struct object * a, int n, char str[])
{
    str[0] = 0;
    a = object_get_referenced(a);
    /*switch*/
    {
        int __v0 = a->value_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            snprintf(str, n, "%lld", a->value.host_long_long);
            goto __L0; /* break */

            goto __L0; /* break */

            __L4: /*case 6*/ 
            snprintf(str, n, "%lldL", a->value.host_long_long);
            goto __L0; /* break */

            __L5: /*case 8*/ 
            snprintf(str, n, "%lldLL", a->value.host_long_long);
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            snprintf(str, n, "%lluU", a->value.host_u_long_long);
            goto __L0; /* break */

            __L9: /*case 7*/ 
            snprintf(str, n, "%lluUL", a->value.host_u_long_long);
            goto __L0; /* break */

            __L10: /*case 9*/ 
            snprintf(str, n, "%lluULL", a->value.host_u_long_long);
            goto __L0; /* break */

            __L11: /*case 10*/ 
            snprintf(str, n, "%Lff", a->value.host_long_double);
            goto __L0; /* break */

            __L12: /*case 11*/ 
            snprintf(str, n, "%Lf", a->value.host_long_double);
            goto __L0; /* break */

            __L13: /*case 12*/ 
            snprintf(str, n, "%LfLF", a->value.host_long_double);
            goto __L0; /* break */

        }
        __L0:;
    }
    return 0;
}


unsigned char object_is_true(struct object * a)
{
    a = object_get_referenced(a);
    /*switch*/
    {
        int __v0 = a->value_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            return (a->value.host_long_long != 0);
            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            return (a->value.host_u_long_long != 0);
            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            return (a->value.host_long_double != 0);
        }
        __L0:;
    }
    ;
    return 0;
}


struct object object_make_signed_char(signed char value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = 0;
    r.value.host_long_long = wrap_signed_integer(value, get_platform(1)->char_n_bits);
    return r;
}


static long double resize_floating_point(long double value, int bits);

void object_increment_value(int target, struct object * a)
{
    /*switch*/
    {
        int __v0 = a->value_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            a->value.host_long_long = wrap_signed_integer(a->value.host_long_long + 1, target_get_num_of_bits(target, a->value_type));
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            a->value.host_u_long_long = wrap_signed_integer(a->value.host_u_long_long + 1, target_get_num_of_bits(target, a->value_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            a->value.host_long_double++;
            a->value.host_long_double = resize_floating_point(a->value.host_long_double, target_get_num_of_bits(target, a->value_type));
            goto __L0; /* break */

        }
        __L0:;
    }
}



static long double resize_floating_point(long double value, int bits)
{
    /*switch*/
    {
        int __v0 = bits;
        if (__v0 == 64) goto __L1; /*case 64*/
        if (__v0 == 32) goto __L2; /*case 32*/
        goto __L0;

        {
            __L1: /*case 64*/ 
            do
            {
            }
            while (0);
            return (double)value;
            __L2: /*case 32*/ 
            do
            {
            }
            while (0);
            return (float)value;
        }
        __L0:;
    }
    return value;
}
struct object object_make_unsigned_char(int target, unsigned char value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = 1;
    r.value.host_u_long_long = wrap_unsigned_integer(value, get_platform(target)->char_n_bits);
    return r;
}


struct object object_make_signed_short(signed short value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = 2;
    r.value.host_long_long = wrap_signed_integer(value, 16);
    return r;
}


static int to_unsigned(int t);

struct object object_make_uint8(int target, unsigned char value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.value_type = to_unsigned(get_platform(target)->int8_type);
    r.value.host_u_long_long = wrap_unsigned_integer(value, 8);
    return r;
}



static int to_unsigned(int t)
{
    /*switch*/
    {
        int __v0 = t;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 10) goto __L6; /*case 10*/
        if (__v0 == 11) goto __L7; /*case 11*/
        if (__v0 == 12) goto __L8; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            return 1;
            __L2: /*case 2*/ 
            return 3;
            __L3: /*case 4*/ 
            return 5;
            __L4: /*case 6*/ 
            return 7;
            __L5: /*case 8*/ 
            return 9;
            __L6: /*case 10*/ 
            __L7: /*case 11*/ 
            __L8: /*case 12*/ 
            return t;
        }
        __L0:;
    }
    ;
    return t;
}
struct object object_make_uint16(int target, unsigned short value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.value_type = to_unsigned(get_platform(target)->int16_type);
    r.value.host_u_long_long = wrap_unsigned_integer(value, 16);
    return r;
}


struct object object_make_uint32(int target, unsigned int value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.value_type = to_unsigned(get_platform(target)->int32_type);
    r.value.host_u_long_long = wrap_unsigned_integer(value, 32);
    return r;
}


struct object object_make_signed_int(int target, long long value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = 4;
    r.value.host_long_long = wrap_signed_integer(value, get_platform(target)->int_n_bits);
    return r;
}


struct object object_make_unsigned_int(int target, unsigned long long value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = 5;
    r.value.host_long_long = wrap_unsigned_integer(value, get_platform(target)->int_n_bits);
    return r;
}


struct object object_make_signed_long(int target, signed long long value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = 6;
    r.value.host_long_long = wrap_signed_integer(value, get_platform(target)->long_n_bits);
    return r;
}


struct object object_make_unsigned_long(int target, unsigned long long value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = 7;
    r.value.host_u_long_long = wrap_unsigned_integer(value, get_platform(target)->long_n_bits);
    return r;
}


struct object object_make_signed_long_long(int target, signed long long value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = 8;
    r.value.host_long_long = wrap_signed_integer(value, get_platform(target)->long_long_n_bits);
    return r;
}


signed long long object_to_signed_long_long(struct object * a)
{
    a = object_get_referenced(a);
    /*switch*/
    {
        int __v0 = a->value_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            return a->value.host_long_long;
            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            return a->value.host_u_long_long;
            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            return (long long)a->value.host_long_double;
        }
        __L0:;
    }
    ;
    return 0;
}


struct object object_make_unsigned_long_long(int target, unsigned long long value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = 9;
    r.value.host_u_long_long = value;
    return r;
}


unsigned long long object_to_unsigned_long_long(struct object * a)
{
    a = object_get_referenced(a);
    /*switch*/
    {
        int __v0 = a->value_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            return a->value.host_long_long;
            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            return a->value.host_u_long_long;
            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            return (unsigned long long)a->value.host_long_double;
        }
        __L0:;
    }
    ;
    return 0;
}


struct object object_make_float(int target, long double value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = 10;
    r.value.host_long_double = resize_floating_point(value, target_get_num_of_bits(target, 10));
    return r;
}


struct object object_make_double(int target, long double value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = 11;
    r.value.host_long_double = resize_floating_point(value, target_get_num_of_bits(target, 11));
    return r;
}


struct object object_make_long_double(int target, long double value)
{
    struct object  r;

    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = 12;
    r.value.host_long_double = resize_floating_point(value, target_get_num_of_bits(target, 12));
    return r;
}


struct object *object_get_non_const_referenced(struct object * p_object);

struct object object_make_pointer(struct object * object)
{
    struct object  r;

    object = object_get_non_const_referenced(object);
    _cake_zmem(&r, 120);
    r.state = 4;
    r.value_type = 9;
    r.value.host_u_long_long = (unsigned long long)object;
    return r;
}


struct object object_make_reference(struct object * object)
{
    struct object  r;

    object = object_get_non_const_referenced(object);
    _cake_zmem(&r, 120);
    r.state = 4;
    r.value_type = 9;
    r.value.host_u_long_long = (unsigned long long)object;
    r.p_ref = object;
    return r;
}


static unsigned char object_type_is_unsigned_integer(int type);

struct object object_cast(int target, int dest_type, struct object * v)
{
    int source_type;
    struct object  r;
    int dest_n_bits;

    v = object_get_referenced(v);
    if (v->value_type == dest_type)
    {
        return *v;
    }
    source_type = v->value_type;
    _cake_zmem(&r, 120);
    r.state = 2;
    r.value_type = dest_type;
    dest_n_bits = target_get_num_of_bits(target, dest_type);
    if (object_type_is_signed_integer(source_type))
    {
        if (object_type_is_signed_integer(dest_type))
        {
            r.value.host_long_long = wrap_signed_integer(v->value.host_long_long, dest_n_bits);
        }
        else
        {
            if (object_type_is_unsigned_integer(dest_type))
            {
                r.value.host_long_long = wrap_unsigned_integer(v->value.host_long_long, dest_n_bits);
            }
            else
            {
                r.value.host_long_double = resize_floating_point((long double)v->value.host_long_long, dest_n_bits);
            }
        }
        return r;
    }
    if (object_type_is_unsigned_integer(source_type))
    {
        if (object_type_is_signed_integer(dest_type))
        {
            r.value.host_long_long = wrap_signed_integer(v->value.host_u_long_long, dest_n_bits);
        }
        else
        {
            if (object_type_is_unsigned_integer(dest_type))
            {
                r.value.host_u_long_long = wrap_unsigned_integer(v->value.host_u_long_long, dest_n_bits);
            }
            else
            {
                r.value.host_long_double = resize_floating_point((long double)v->value.host_u_long_long, dest_n_bits);
            }
        }
        return r;
    }
    if (source_type == 10)
    {
        if (object_type_is_signed_integer(dest_type))
        {
            r.value.host_long_long = wrap_signed_integer((long long)v->value.host_long_double, dest_n_bits);
        }
        else
        {
            if (object_type_is_unsigned_integer(dest_type))
            {
                r.value.host_u_long_long = wrap_unsigned_integer((unsigned long long)v->value.host_long_double, dest_n_bits);
            }
            else
            {
                r.value.host_long_double = resize_floating_point(v->value.host_long_double, dest_n_bits);
            }
        }
        return r;
    }
    if (source_type == 11)
    {
        if (object_type_is_signed_integer(dest_type))
        {
            r.value.host_long_long = wrap_signed_integer((long long)v->value.host_long_double, dest_n_bits);
        }
        else
        {
            if (object_type_is_unsigned_integer(dest_type))
            {
                r.value.host_u_long_long = wrap_unsigned_integer((long long)v->value.host_long_double, dest_n_bits);
            }
            else
            {
                r.value.host_long_double = resize_floating_point(v->value.host_long_double, dest_n_bits);
            }
        }
        return r;
    }
    if (source_type == 12)
    {
        if (object_type_is_signed_integer(dest_type))
        {
            r.value.host_long_long = wrap_signed_integer((long long)v->value.host_long_double, dest_n_bits);
        }
        else
        {
            if (object_type_is_unsigned_integer(dest_type))
            {
                r.value.host_u_long_long = wrap_unsigned_integer((long long)v->value.host_long_double, dest_n_bits);
            }
            else
            {
                r.value.host_long_double = v->value.host_long_double;
                r.value.host_long_double = resize_floating_point(v->value.host_long_double, dest_n_bits);
            }
        }
        return r;
    }
    ;
    return r;
}



static unsigned char object_type_is_unsigned_integer(int type)
{
    /*switch*/
    {
        int __v0 = type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            return 1;
            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            goto __L0; /* break */

        }
        __L0:;
    }
    return 0;
}
unsigned char type_is_union(struct type * p_type);

void object_default_initialization(struct object * p_object, unsigned char  is_constant)
{
    if (p_object->members.head == 0)
    {
        if (is_constant)
        {
            p_object->state = 2;
        }
        else
        {
            p_object->state = 4;
        }
        p_object->value.host_u_long_long = 0;
    }
    if (type_is_union(&p_object->type))
    {
        struct object * p;

        p = p_object->members.head;
        if (p)
        {
            object_default_initialization(p, is_constant);
        }
    }
    else
    {
        struct object * p;

        p = p_object->members.head;
        while (p)
        {
            object_default_initialization(p, is_constant);
            p = p->next;
        }
    }
}


struct object *object_get_non_const_referenced(struct object * p_object)
{
    if (p_object->p_ref != 0)
    {
        p_object = p_object->p_ref;
    }
    return p_object;
}


struct object *object_get_referenced(struct object * p_object)
{
    if (p_object->p_ref != 0)
    {
        p_object = p_object->p_ref;
    }
    return p_object;
}


int get_rank(int t)
{
    if (t == 8 || t == 9)
    {
        return 80;
    }
    else
    {
        if (t == 6 || t == 7)
        {
            return 60;
        }
        else
        {
            if (t == 4 || t == 5)
            {
                return 40;
            }
            else
            {
                if (t == 2 || t == 3)
                {
                    return 30;
                }
                else
                {
                    if (t == 0 || t == 1)
                    {
                        return 20;
                    }
                }
            }
        }
    }
    return 0;
}


int target_sizeof(int target, int t)
{
    return target_get_num_of_bits(target, t) / 8;
}


unsigned char is_signed(int t)
{
    /*switch*/
    {
        int __v0 = t;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 11) goto __L6; /*case 11*/
        if (__v0 == 12) goto __L7; /*case 12*/
        goto __L8; /* default */

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            __L6: /*case 11*/ 
            return 1;
            __L7: /*case 12*/ 
            return 1;
            __L8: /* default */ 
            goto __L0; /* break */

        }
        __L0:;
    }
    return 0;
}


unsigned char is_unsigned(int t)
{
    /*switch*/
    {
        int __v0 = t;
        if (__v0 == 1) goto __L1; /*case 1*/
        if (__v0 == 3) goto __L2; /*case 3*/
        if (__v0 == 5) goto __L3; /*case 5*/
        if (__v0 == 7) goto __L4; /*case 7*/
        if (__v0 == 9) goto __L5; /*case 9*/
        goto __L6; /* default */

        {
            __L1: /*case 1*/ 
            __L2: /*case 3*/ 
            __L3: /*case 5*/ 
            __L4: /*case 7*/ 
            __L5: /*case 9*/ 
            return 1;
            __L6: /* default */ 
            goto __L0; /* break */

        }
        __L0:;
    }
    return 0;
}


void object_set_any(struct object * p_object)
{
    struct object * p;

    p_object = object_get_non_const_referenced(p_object);
    p_object->state = 1;
    p = p_object->members.head;
    while (p)
    {
        object_set_any(p);
        p = p->next;
    }
}


unsigned char object_is_zero(struct object * p_object)
{
    p_object = (struct object *)object_get_referenced(p_object);
    if (!object_has_constant_value(p_object))
    {
        return 0;
    }
    /*switch*/
    {
        int __v0 = p_object->value_type;
        if (__v0 == 0) goto __L2; /*case 0*/
        if (__v0 == 2) goto __L3; /*case 2*/
        if (__v0 == 4) goto __L4; /*case 4*/
        if (__v0 == 6) goto __L5; /*case 6*/
        if (__v0 == 8) goto __L6; /*case 8*/
        if (__v0 == 1) goto __L7; /*case 1*/
        if (__v0 == 3) goto __L8; /*case 3*/
        if (__v0 == 5) goto __L9; /*case 5*/
        if (__v0 == 7) goto __L10; /*case 7*/
        if (__v0 == 9) goto __L11; /*case 9*/
        if (__v0 == 10) goto __L12; /*case 10*/
        if (__v0 == 11) goto __L13; /*case 11*/
        if (__v0 == 12) goto __L14; /*case 12*/
        goto __L1;

        {
            __L2: /*case 0*/ 
            __L3: /*case 2*/ 
            __L4: /*case 4*/ 
            __L5: /*case 6*/ 
            __L6: /*case 8*/ 
            return p_object->value.host_long_long == 0;
            __L7: /*case 1*/ 
            __L8: /*case 3*/ 
            __L9: /*case 5*/ 
            __L10: /*case 7*/ 
            __L11: /*case 9*/ 
            return p_object->value.host_u_long_long == 0;
            __L12: /*case 10*/ 
            __L13: /*case 11*/ 
            __L14: /*case 12*/ 
            return p_object->value.host_long_double == 0.0;
        }
        __L1:;
    }
    ;
    return 0;
}


unsigned char object_is_one(struct object * p_object)
{
    p_object = (struct object *)object_get_referenced(p_object);
    if (!object_has_constant_value(p_object))
    {
        return 0;
    }
    /*switch*/
    {
        int __v0 = p_object->value_type;
        if (__v0 == 0) goto __L2; /*case 0*/
        if (__v0 == 2) goto __L3; /*case 2*/
        if (__v0 == 4) goto __L4; /*case 4*/
        if (__v0 == 6) goto __L5; /*case 6*/
        if (__v0 == 8) goto __L6; /*case 8*/
        if (__v0 == 1) goto __L7; /*case 1*/
        if (__v0 == 3) goto __L8; /*case 3*/
        if (__v0 == 5) goto __L9; /*case 5*/
        if (__v0 == 7) goto __L10; /*case 7*/
        if (__v0 == 9) goto __L11; /*case 9*/
        if (__v0 == 10) goto __L12; /*case 10*/
        if (__v0 == 11) goto __L13; /*case 11*/
        if (__v0 == 12) goto __L14; /*case 12*/
        goto __L1;

        {
            __L2: /*case 0*/ 
            __L3: /*case 2*/ 
            __L4: /*case 4*/ 
            __L5: /*case 6*/ 
            __L6: /*case 8*/ 
            return p_object->value.host_long_long == 1;
            __L7: /*case 1*/ 
            __L8: /*case 3*/ 
            __L9: /*case 5*/ 
            __L10: /*case 7*/ 
            __L11: /*case 9*/ 
            return p_object->value.host_u_long_long == 1;
            __L12: /*case 10*/ 
            __L13: /*case 11*/ 
            __L14: /*case 12*/ 
            return p_object->value.host_long_double == 1.0;
        }
        __L1:;
    }
    ;
    return 0;
}


unsigned char object_is_derived(struct object * p_object)
{
    if (p_object->p_ref != 0)
    {
        return 0;
    }
    return p_object->members.head != 0;
}


unsigned char object_is_reference(struct object * p_object)
{
    return p_object->p_ref != 0;
}


struct object *object_get_member(struct object * p_object, unsigned int index)
{
    struct object * it;
    unsigned int count;

    p_object = (struct object *)object_get_referenced(p_object);
    if (p_object->members.head == 0)
    {
        return 0;
    }
    it = p_object->members.head;
    count = 0;
    while (it)
    {
        if (index == count)
        {
            return it;
        }
        count++;
        it = it->next;
    }
    return 0;
}


unsigned char type_is_pointer_or_array(struct type * p_type);
unsigned char type_is_function(struct type * p_type);
unsigned char compiler_diagnostic(int w, struct parser_ctx * ctx, struct token * p_token, struct marker * p_marker, char * fmt, ...);

int object_set(struct parser_ctx * ctx, struct object * to, struct expression * p_init_expression, struct object * from, unsigned char  is_constant, unsigned char  requires_constant_initialization)
{
    if (1) /*try*/
    {
        from = object_get_referenced(from);
        to->p_init_expression = p_init_expression;
        if (object_is_derived(to))
        {
            struct object * it_to;
            struct object * it_from;

            it_to = to->members.head;
            it_from = from->members.head;
            while (it_from && it_to)
            {
                object_set(ctx, it_to, 0, it_from, is_constant, requires_constant_initialization);
                it_to = it_to->next;
                it_from = it_from->next;
            }
        }
        else
        {
            ;
            to->state = from->state;
            to->value = object_cast(ctx->options.target, to->value_type, from).value;
            if (requires_constant_initialization && !object_has_constant_value(from))
            {
                if (!type_is_pointer_or_array(&p_init_expression->type) && !type_is_function(&p_init_expression->type))
                {
                    struct token * tk;

                    tk = p_init_expression ? p_init_expression->first_token : ctx->current;
                    compiler_diagnostic(1860, ctx, tk, 0, "requires a compile time object");
                    goto __L0; /* throw */
                }
            }
            if (is_constant && from->state == 2)
            {
                to->state = 2;
            }
            else
            {
                if (to->state == 2)
                {
                    to->state = 4;
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        return 1;
    }
    return 0;
}


struct type type_dup(struct type * p_type);
struct type get_array_item_type(struct type * p_type);
int type_to_object_type(struct type * type, int target);
struct struct_or_union_specifier *get_complete_struct_or_union_specifier(struct struct_or_union_specifier * p_struct_or_union_specifier);

struct object *make_object_ptr_core(struct type * p_type, char * member_designator, int target)
{
    struct object * p_object;

    p_object = 0;
    if (1) /*try*/
    {
        struct struct_or_union_specifier * p_struct_or_union_specifier;
        struct member_declaration * p_member_declaration;

        if (p_type->category == 1)
        {
            p_object = calloc(1, 120);
            if (p_object == 0)
            {
                goto __L0; /* throw */
            }
            p_object->member_designator = strdup(member_designator);
            p_object->type = type_dup(p_type);
            return p_object;
        }
        if (p_type->category == 3)
        {
            p_object = calloc(1, 120);
            if (p_object == 0)
            {
                goto __L0; /* throw */
            }
            *p_object = object_make_nullptr(target);
            p_object->state = 0;
            ;
            p_object->member_designator = strdup(member_designator);
            type_destroy(&p_object->type);
            p_object->type = type_dup(p_type);
            return p_object;
        }
        if (p_type->category == 2)
        {
            p_object = calloc(1, 120);
            if (p_object == 0)
            {
                goto __L0; /* throw */
            }
            p_object->type = type_dup(p_type);
            p_object->member_designator = strdup(member_designator);
            if (p_type->num_of_elements > 0)
            {
                struct type  array_item_type;
                unsigned long long max_elements;

                array_item_type = get_array_item_type(p_type);
                max_elements = p_type->num_of_elements > 1000 ? 1000 : p_type->num_of_elements;
                {
                    unsigned long long i;

                    i = 0;
                    for (; i < max_elements; i++)
                    {
                        char buffer[200];
                        struct object * p_member_obj;

                        _cake_zmem(&buffer, 200);
                        snprintf(buffer, 200, "%s[%llu]", member_designator, i);
                        p_member_obj = make_object_ptr_core(&array_item_type, buffer, target);
                        if (p_member_obj == 0)
                        {
                            type_destroy(&array_item_type);
                            goto __L0; /* throw */
                        }
                        p_member_obj->parent = p_object;
                        free((void *)p_member_obj->member_designator);
                        p_member_obj->member_designator = strdup(buffer);
                        object_list_push(&p_object->members, p_member_obj);
                    }
                }
                type_destroy(&array_item_type);
            }
            return p_object;
        }
        if (p_type->struct_or_union_specifier == 0)
        {
            p_object = calloc(1, 120);
            if (p_object == 0)
            {
                goto __L0; /* throw */
            }
            p_object->state = 0;
            p_object->value_type = type_to_object_type(p_type, target);
            p_object->value.host_long_long = -1;
            p_object->member_designator = strdup(member_designator);
            p_object->type = type_dup(p_type);
            return p_object;
        }
        p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
        if (p_struct_or_union_specifier == 0)
        {
            goto __L0; /* throw */
        }
        p_object = calloc(1, 120);
        if (p_object == 0)
        {
            goto __L0; /* throw */
        }
        p_object->member_designator = strdup(member_designator);
        p_object->type = type_dup(p_type);
        p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
        while (p_member_declaration)
        {
            if (p_member_declaration->member_declarator_list_opt)
            {
                struct member_declarator * p_member_declarator;

                p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                while (p_member_declarator)
                {
                    if (p_member_declarator->declarator)
                    {
                        char buffer[200];
                        struct object * p_member_obj;

                        _cake_zmem(&buffer, 200);
                        snprintf(buffer, 200, "%s.%s", member_designator, p_member_declarator->declarator->name_opt->lexeme);
                        p_member_obj = make_object_ptr_core(&p_member_declarator->declarator->type, buffer, target);
                        if (p_member_obj == 0)
                        {
                            goto __L0; /* throw */
                        }
                        p_member_obj->parent = p_object;
                        free((void *)p_member_obj->member_designator);
                        p_member_obj->member_designator = strdup(buffer);
                        object_list_push(&p_object->members, p_member_obj);
                    }
                    p_member_declarator = p_member_declarator->next;
                }
            }
            else
            {
                if (p_member_declaration->specifier_qualifier_list != 0)
                {
                    if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type  t;
                        char buffer[200];
                        struct object * p_member_obj;

                        _cake_zmem(&t, 68);
                        t.category = 0;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = 32768;
                        _cake_zmem(&buffer, 200);
                        snprintf(buffer, 200, ".%s", member_designator);
                        p_member_obj = make_object_ptr_core(&t, buffer, target);
                        if (p_member_obj == 0)
                        {
                            goto __L0; /* throw */
                        }
                        free((void *)p_member_obj->member_designator);
                        p_member_obj->member_designator = strdup(buffer);
                        p_member_obj->parent = p_object;
                        object_list_push(&p_object->members, p_member_obj);
                        type_destroy(&t);
                    }
                }
            }
            p_member_declaration = p_member_declaration->next;
        }
        return p_object;
    }
    else __L0: /*catch*/ 
    {
        object_delete(p_object);
        p_object = 0;
    }
    return 0;
}


struct object *make_object_ptr(struct type * p_type, int target)
{
    return make_object_ptr_core(p_type, "", target);
}


static void object_fix_parent(struct object * p_object, struct object * parent);

int make_object_with_member_designator(struct type * p_type, struct object * obj, char * name, int target)
{
    struct object * p;

    p = make_object_ptr_core(p_type, name, target);
    if (p)
    {
        *obj = *p;
        object_fix_parent(obj, obj);
        free(p);
        return 0;
    }
    return 1;
}



static void object_fix_parent(struct object * p_object, struct object * parent)
{
    struct object * it;

    it = p_object->members.head;
    while (it)
    {
        it->parent = parent;
        it = it->next;
    }
}
struct object object_dup(struct object * src)
{
    struct object  result;

    ;
    result = *src;
    result.type = type_dup(&src->type);
    if (src->member_designator)
    {
        result.member_designator = strdup(src->member_designator);
    }
    result.next = 0;
    return result;
}


int make_object(struct type * p_type, struct object * obj, int target)
{
    return make_object_with_member_designator(p_type, obj, "", target);
}


int object_type_to_type_specifier(int type)
{
    /*switch*/
    {
        int __v0 = type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 1) goto __L2; /*case 1*/
        if (__v0 == 2) goto __L3; /*case 2*/
        if (__v0 == 3) goto __L4; /*case 3*/
        if (__v0 == 4) goto __L5; /*case 4*/
        if (__v0 == 5) goto __L6; /*case 5*/
        if (__v0 == 6) goto __L7; /*case 6*/
        if (__v0 == 7) goto __L8; /*case 7*/
        if (__v0 == 8) goto __L9; /*case 8*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            return 130;
            __L2: /*case 1*/ 
            return 258;
            __L3: /*case 2*/ 
            return 4;
            __L4: /*case 3*/ 
            return 260;
            __L5: /*case 4*/ 
            return 8;
            __L6: /*case 5*/ 
            return 264;
            __L7: /*case 6*/ 
            return 16;
            __L8: /*case 7*/ 
            return 272;
            __L9: /*case 8*/ 
            return 4194304;
            __L10: /*case 9*/ 
            return 4194560;
            __L11: /*case 10*/ 
            return 32;
            __L12: /*case 11*/ 
            return 64;
            __L13: /*case 12*/ 
            return 80;
        }
        __L0:;
    }
    ;
    return 0;
}


int type_specifier_to_object_type(int type_specifier_flags, int target)
{
    if (type_specifier_flags & 512)
    {
        return get_platform(target)->bool_type;
    }
    if (type_specifier_flags & 32)
    {
        return 10;
    }
    if (type_specifier_flags & 64)
    {
        if (type_specifier_flags & 16)
        {
            return 12;
        }
        return 11;
    }
    if (type_specifier_flags & 256)
    {
        if (type_specifier_flags & 2)
        {
            return 1;
        }
        if (type_specifier_flags & 4)
        {
            return 3;
        }
        if (type_specifier_flags & 16)
        {
            return 7;
        }
        if (type_specifier_flags & 8)
        {
            return 5;
        }
        if (type_specifier_flags & 4194304)
        {
            return 9;
        }
    }
    else
    {
        if (type_specifier_flags & 2)
        {
            return 0;
        }
        if (type_specifier_flags & 4)
        {
            return 2;
        }
        if (type_specifier_flags & 16)
        {
            return 6;
        }
        if (type_specifier_flags & 8)
        {
            return 4;
        }
        if (type_specifier_flags & 4194304)
        {
            return 8;
        }
    }
    return 4;
}


unsigned char type_is_pointer(struct type * p_type);

int type_to_object_type(struct type * type, int target)
{
    if (type_is_pointer(type))
    {
        return get_platform(target)->size_t_type;
    }
    return type_specifier_to_object_type(type->type_specifier_flags, target);
}


void object_print_value_debug(struct object * a)
{
    a = object_get_referenced(a);
    /*switch*/
    {
        int __v0 = a->value_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 1) goto __L2; /*case 1*/
        if (__v0 == 2) goto __L3; /*case 2*/
        if (__v0 == 3) goto __L4; /*case 3*/
        if (__v0 == 4) goto __L5; /*case 4*/
        if (__v0 == 5) goto __L6; /*case 5*/
        if (__v0 == 6) goto __L7; /*case 6*/
        if (__v0 == 7) goto __L8; /*case 7*/
        if (__v0 == 8) goto __L9; /*case 8*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            printf("%lld (signed char)", a->value.host_long_long);
            goto __L0; /* break */

            __L2: /*case 1*/ 
            printf("%llu (unsigned char)", a->value.host_u_long_long);
            goto __L0; /* break */

            __L3: /*case 2*/ 
            printf("%lld (short)", a->value.host_long_long);
            goto __L0; /* break */

            __L4: /*case 3*/ 
            printf("%llu (unsigned short)", a->value.host_u_long_long);
            goto __L0; /* break */

            __L5: /*case 4*/ 
            printf("%lld (int)", a->value.host_long_long);
            goto __L0; /* break */

            __L6: /*case 5*/ 
            printf("%llu (unsigned int)", a->value.host_u_long_long);
            goto __L0; /* break */

            __L7: /*case 6*/ 
            printf("%lld (long)", a->value.host_long_long);
            goto __L0; /* break */

            __L8: /*case 7*/ 
            printf("%llu (unsigned long)", a->value.host_u_long_long);
            goto __L0; /* break */

            __L9: /*case 8*/ 
            printf("%lld (long long)", a->value.host_long_long);
            goto __L0; /* break */

            __L10: /*case 9*/ 
            printf("%llu (unsigned long long)", a->value.host_u_long_long);
            goto __L0; /* break */

            __L11: /*case 10*/ 
            printf("%Lf (float)", a->value.host_long_double);
            goto __L0; /* break */

            __L12: /*case 11*/ 
            printf("%Lf (double)", a->value.host_long_double);
            goto __L0; /* break */

            __L13: /*case 12*/ 
            printf("%Lf (long double)", a->value.host_long_double);
            goto __L0; /* break */

        }
        __L0:;
    }
}


void type_print(struct type * a, int target);

void object_print_to_debug_core(struct object * object, int n, int target)
{
    if (object_is_reference(object))
    {
        object = object_get_referenced(object);
    }
    {
        int i;

        i = 0;
        for (; i < n; i++)
        printf("  ");
    }
    if (object->member_designator)
    {
        printf("%s ", object->member_designator);
    }
    if (object->members.head != 0)
    {
        struct object * member;

        type_print(&object->type, target);
        printf(" {\n");
        member = object->members.head;
        while (member)
        {
            object_print_to_debug_core(member, n + 1, target);
            member = member->next;
        }
        {
            int i;

            i = 0;
            for (; i < n; i++)
            printf("  ");
        }
        printf("}\n");
    }
    else
    {
        type_print(&object->type, target);
        printf(" = ");
        object_print_value_debug(object);
        /*switch*/
        {
            int __v0 = object->state;
            if (__v0 == 0) goto __L4; /*case 0*/
            if (__v0 == 1) goto __L5; /*case 1*/
            if (__v0 == 4) goto __L6; /*case 4*/
            if (__v0 == 2) goto __L7; /*case 2*/
            goto __L3;

            {
                __L4: /*case 0*/ 
                printf(" uninitialized ");
                goto __L3; /* break */

                __L5: /*case 1*/ 
                printf(" unknown ");
                goto __L3; /* break */

                __L6: /*case 4*/ 
                printf(" exact ");
                goto __L3; /* break */

                __L7: /*case 2*/ 
                printf(" constant_exact ");
                goto __L3; /* break */

            }
            __L3:;
        }
        printf("\n");
    }
}


void object_print_to_debug(struct object * object, int target)
{
    int n;

    n = 0;
    object_print_to_debug_core(object, n, target);
}


struct object *object_extend_array_to_index(struct type * p_type, struct object * a, unsigned int max_index, unsigned char  is_constant, int target)
{
    if (1) /*try*/
    {
        {
            unsigned int count;

            count = a->members.count;
            for (; count < (max_index + 1); count++)
            {
                char name[50];
                struct object * p;

                _cake_zmem(&name, 50);
                snprintf(name, 50, "[%zu]", count);
                p = make_object_ptr_core(p_type, name, target);
                if (p == 0)
                {
                    goto __L0; /* throw */
                }
                p->parent = a;
                object_default_initialization(p, is_constant);
                object_list_push(&a->members, p);
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return a->members.tail;
}


unsigned char object_is_promoted(struct object * a)
{
    if (a->value_type == 0 || a->value_type == 1 || a->value_type == 2 || a->value_type == 3)
    {
        return 1;
    }
    return 0;
}


int object_common(int target, struct object * a, struct object * b)
{
    int a_type;
    int b_type;
    int signed_promoted;
    int unsigned_promoted;

    a_type = a->value_type;
    b_type = b->value_type;
    if (a_type == 12 || b_type == 12)
    {
        return 12;
    }
    if (a_type == 11 || b_type == 11)
    {
        return 11;
    }
    if (a_type == 10 || b_type == 10)
    {
        return 10;
    }
    if (object_is_promoted(a))
    {
        a_type = 4;
    }
    if (object_is_promoted(b))
    {
        b_type = 4;
    }
    if (a_type == b_type)
    {
        return a_type;
    }
    if (is_signed(a_type) == is_signed(b_type))
    {
        if (get_rank(a_type) > get_rank(b_type))
        {
            return a_type;
        }
        return b_type;
    }
    signed_promoted = is_signed(a_type) ? a_type : b_type;
    unsigned_promoted = is_unsigned(a_type) ? a_type : b_type;
    if (get_rank(unsigned_promoted) >= get_rank(signed_promoted))
    {
        return unsigned_promoted;
    }
    if (target_sizeof(target, signed_promoted) > target_sizeof(target, unsigned_promoted))
    {
        return signed_promoted;
    }
    return to_unsigned(signed_promoted);
}


void objects_destroy(struct objects * arr)
{
    free(arr->items);
}


int objects_push(struct objects * arr, struct object * obj)
{
    if (arr->items == 0)
    {
        arr->items = malloc(32);
        if (!arr->items)
        {
            arr->size = 0;
            arr->capacity = 0;
            return 12;
        }
        arr->size = 0;
        arr->capacity = 8;
    }
    if (arr->size == arr->capacity)
    {
        unsigned int new_capacity;
        struct object ** new_items;

        new_capacity = arr->capacity ? arr->capacity * 2 : 8;
        new_items = realloc(arr->items, new_capacity * 4);
        if (!new_items)
        {
            return 12;
        }
        arr->items = new_items;
        arr->capacity = (int)new_capacity;
    }
    arr->items[arr->size++] = obj;
    return 0;
}


short __cdecl _fdclass(float _X);
short __cdecl _dclass(double _X);
short __cdecl _ldclass(long double _X);

void object_print_value(struct osstream * ss, struct object * a, int target)
{
    a = object_get_referenced(a);
    /*switch*/
    {
        int __v0 = a->value_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 1) goto __L2; /*case 1*/
        if (__v0 == 2) goto __L3; /*case 2*/
        if (__v0 == 3) goto __L4; /*case 3*/
        if (__v0 == 4) goto __L5; /*case 4*/
        if (__v0 == 6) goto __L6; /*case 6*/
        if (__v0 == 7) goto __L7; /*case 7*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 8) goto __L9; /*case 8*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            ss_fprintf(ss, "%lld", a->value.host_long_long);
            goto __L0; /* break */

            __L2: /*case 1*/ 
            ss_fprintf(ss, "%llu", a->value.host_u_long_long);
            goto __L0; /* break */

            __L3: /*case 2*/ 
            ss_fprintf(ss, "%lld", a->value.host_long_long);
            goto __L0; /* break */

            __L4: /*case 3*/ 
            ss_fprintf(ss, "%llu", a->value.host_u_long_long);
            goto __L0; /* break */

            __L5: /*case 4*/ 
            ss_fprintf(ss, "%lld", a->value.host_long_long);
            goto __L0; /* break */

            __L6: /*case 6*/ 
            ss_fprintf(ss, "%lldL", a->value.host_long_long);
            goto __L0; /* break */

            __L7: /*case 7*/ 
            ss_fprintf(ss, "%lluL", a->value.host_u_long_long);
            goto __L0; /* break */

            __L8: /*case 5*/ 
            ss_fprintf(ss, "%llu", a->value.host_u_long_long);
            goto __L0; /* break */

            __L9: /*case 8*/ 
            ss_fprintf(ss, "%lldLL", a->value.host_long_long);
            goto __L0; /* break */

            __L10: /*case 9*/ 
            ss_fprintf(ss, "%lluULL", a->value.host_u_long_long);
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            if (((0 ? _fdclass((float)(a->value.host_long_double)) : 1 ? _dclass((double)(a->value.host_long_double)) : _ldclass((long double)(a->value.host_long_double))) == 1))
            {
                ss_fprintf(ss, ".7976931348623157E+308");
            }
            else
            {
                char temp[64];
                char * p;
                unsigned char  dot_found;

                _cake_zmem(&temp, 64);
                snprintf(temp, 64, "%.17Lg", a->value.host_long_double);
                p = temp;
                dot_found = 0;
                while (*p)
                {
                    if (*p == 101 || *p == 69)
                    {
                        dot_found = 1;
                    }
                    if (*p == 46)
                    {
                        dot_found = 1;
                        break;
                    }
                    p++;
                }
                if (!dot_found)
                {
                    *p = 46;
                    p++;
                    *p = 48;
                    p++;
                    *p = 0;
                }
                ss_fprintf(ss, "%s", temp);
            }
            if (a->value_type == 10)
            {
                ss_fprintf(ss, "f");
            }
            else
            {
                if (a->value_type == 12)
                {
                    ss_fprintf(ss, "Lf");
                }
            }
            goto __L0; /* break */

        }
        __L0:;
    }
}


struct object object_equal(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = 4;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long == b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long == b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            r.value.host_u_long_long = (a0.value.host_long_double == b0.value.host_long_double);
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_not_equal(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long != b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long != b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            r.value.host_u_long_long = (a0.value.host_long_double != b0.value.host_long_double);
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_greater_than_or_equal(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long >= b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long >= b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            r.value.host_u_long_long = (a0.value.host_long_double >= b0.value.host_long_double);
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_greater_than(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long > b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long > b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            r.value.host_u_long_long = (a0.value.host_long_double > b0.value.host_long_double);
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_smaller_than_or_equal(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long <= b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long <= b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            r.value.host_u_long_long = (a0.value.host_long_double <= b0.value.host_long_double);
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_smaller_than(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long < b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long < b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            r.value.host_u_long_long = (a0.value.host_long_double < b0.value.host_long_double);
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_add(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L8; /*case 1*/
        if (__v0 == 3) goto __L9; /*case 3*/
        if (__v0 == 5) goto __L10; /*case 5*/
        if (__v0 == 7) goto __L11; /*case 7*/
        if (__v0 == 9) goto __L12; /*case 9*/
        if (__v0 == 10) goto __L15; /*case 10*/
        if (__v0 == 11) goto __L16; /*case 11*/
        if (__v0 == 12) goto __L17; /*case 12*/
        goto __L0;

        {
            unsigned long long exact_result;

            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                signed long long exact_result;

                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long + b0.value.host_long_long, target_get_num_of_bits(target, common_type));
                if (signed_long_long_add(&exact_result, a0.value.host_long_long, b0.value.host_long_long))
                {
                    if (r.value.host_long_long != exact_result)
                    {
                        snprintf(warning_message, 200, "integer overflow results in '%lld'. The exact result is '%lld'.", r.value.host_long_long, exact_result);
                    }
                }
                else
                {
                    snprintf(warning_message, 200, "integer overflow");
                }
            }
            goto __L0; /* break */

            __L8: /*case 1*/ 
            __L9: /*case 3*/ 
            __L10: /*case 5*/ 
            __L11: /*case 7*/ 
            __L12: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long + b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            if (unsigned_long_long_add(&exact_result, a0.value.host_u_long_long, b0.value.host_u_long_long))
            {
                if (r.value.host_u_long_long != exact_result)
                {
                    snprintf(warning_message, 200, "integer wrap-around results in '%llu'. The exact result is '%llu'.", r.value.host_u_long_long, exact_result);
                }
            }
            else
            {
                snprintf(warning_message, 200, "integer wrap-around results in '%llu'. ", r.value.host_u_long_long);
            }
            goto __L0; /* break */

            __L15: /*case 10*/ 
            __L16: /*case 11*/ 
            __L17: /*case 12*/ 
            r.value.host_long_double = a0.value.host_long_double + b0.value.host_long_double;
            r.value.host_long_double = resize_floating_point(r.value.host_long_double, target_get_num_of_bits(target, common_type));
        }
        __L0:;
    }
    return r;
}


struct object object_sub(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L8; /*case 1*/
        if (__v0 == 3) goto __L9; /*case 3*/
        if (__v0 == 5) goto __L10; /*case 5*/
        if (__v0 == 7) goto __L11; /*case 7*/
        if (__v0 == 9) goto __L12; /*case 9*/
        if (__v0 == 10) goto __L15; /*case 10*/
        if (__v0 == 11) goto __L16; /*case 11*/
        if (__v0 == 12) goto __L17; /*case 12*/
        goto __L0;

        {
            unsigned long long exact_result;

            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                signed long long exact_result;

                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long - b0.value.host_long_long, target_get_num_of_bits(target, common_type));
                if (signed_long_long_sub(&exact_result, a0.value.host_long_long, b0.value.host_long_long))
                {
                    if (r.value.host_long_long != exact_result)
                    {
                        snprintf(warning_message, 200, "integer overflow results in '%lld'. The exact result is '%lld'.", r.value.host_long_long, exact_result);
                    }
                }
                else
                {
                    snprintf(warning_message, 200, "integer overflow");
                }
            }
            goto __L0; /* break */

            __L8: /*case 1*/ 
            __L9: /*case 3*/ 
            __L10: /*case 5*/ 
            __L11: /*case 7*/ 
            __L12: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long - b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            if (unsigned_long_long_sub(&exact_result, a0.value.host_u_long_long, b0.value.host_u_long_long))
            {
                if (r.value.host_u_long_long != exact_result)
                {
                    snprintf(warning_message, 200, "integer wrap-around results in '%llu'. The exact result is '%llu'.", r.value.host_u_long_long, exact_result);
                }
            }
            else
            {
                snprintf(warning_message, 200, "integer wrap-around results in '%llu'. ", r.value.host_u_long_long);
            }
            goto __L0; /* break */

            __L15: /*case 10*/ 
            __L16: /*case 11*/ 
            __L17: /*case 12*/ 
            r.value.host_long_double = a0.value.host_long_double - b0.value.host_long_double;
            r.value.host_long_double = resize_floating_point(r.value.host_long_double, target_get_num_of_bits(target, common_type));
        }
        __L0:;
    }
    return r;
}


struct object object_mul(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L8; /*case 1*/
        if (__v0 == 3) goto __L9; /*case 3*/
        if (__v0 == 5) goto __L10; /*case 5*/
        if (__v0 == 7) goto __L11; /*case 7*/
        if (__v0 == 9) goto __L12; /*case 9*/
        if (__v0 == 10) goto __L15; /*case 10*/
        if (__v0 == 11) goto __L16; /*case 11*/
        if (__v0 == 12) goto __L17; /*case 12*/
        goto __L0;

        {
            unsigned long long exact_result;

            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                signed long long exact_result;

                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long * b0.value.host_long_long, target_get_num_of_bits(target, common_type));
                if (signed_long_long_mul(&exact_result, a0.value.host_long_long, b0.value.host_long_long))
                {
                    if (r.value.host_long_long != exact_result)
                    {
                        snprintf(warning_message, 200, "integer overflow results in '%lld'. The exact result is '%lld'.", r.value.host_long_long, exact_result);
                    }
                }
                else
                {
                    snprintf(warning_message, 200, "integer overflow");
                }
            }
            goto __L0; /* break */

            __L8: /*case 1*/ 
            __L9: /*case 3*/ 
            __L10: /*case 5*/ 
            __L11: /*case 7*/ 
            __L12: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long * b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            if (unsigned_long_long_mul(&exact_result, a0.value.host_u_long_long, b0.value.host_u_long_long))
            {
                if (r.value.host_u_long_long != exact_result)
                {
                    snprintf(warning_message, 200, "integer wrap-around results in '%llu'. The exact result is '%llu'.", r.value.host_u_long_long, exact_result);
                }
            }
            else
            {
                snprintf(warning_message, 200, "integer wrap-around results in '%llu'. ", r.value.host_u_long_long);
            }
            goto __L0; /* break */

            __L15: /*case 10*/ 
            __L16: /*case 11*/ 
            __L17: /*case 12*/ 
            r.value.host_long_double = a0.value.host_long_double * b0.value.host_long_double;
            r.value.host_long_double = resize_floating_point(r.value.host_long_double, target_get_num_of_bits(target, common_type));
        }
        __L0:;
    }
    return r;
}


struct object object_div(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L7; /*case 1*/
        if (__v0 == 3) goto __L8; /*case 3*/
        if (__v0 == 5) goto __L9; /*case 5*/
        if (__v0 == 7) goto __L10; /*case 7*/
        if (__v0 == 9) goto __L11; /*case 9*/
        if (__v0 == 10) goto __L13; /*case 10*/
        if (__v0 == 11) goto __L14; /*case 11*/
        if (__v0 == 12) goto __L15; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                if (b0.value.host_long_long == 0)
                {
                    snprintf(warning_message, 200, "division by zero");
                    return r;
                }
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long / b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L7: /*case 1*/ 
            __L8: /*case 3*/ 
            __L9: /*case 5*/ 
            __L10: /*case 7*/ 
            __L11: /*case 9*/ 
            if (b0.value.host_u_long_long == 0)
            {
                snprintf(warning_message, 200, "division by zero");
                return r;
            }
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long / b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L13: /*case 10*/ 
            __L14: /*case 11*/ 
            __L15: /*case 12*/ 
            r.value.host_long_double = a0.value.host_long_double / b0.value.host_long_double;
            r.value.host_long_double = resize_floating_point(r.value.host_long_double, target_get_num_of_bits(target, common_type));
        }
        __L0:;
    }
    return r;
}


struct object object_mod(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L7; /*case 1*/
        if (__v0 == 3) goto __L8; /*case 3*/
        if (__v0 == 5) goto __L9; /*case 5*/
        if (__v0 == 7) goto __L10; /*case 7*/
        if (__v0 == 9) goto __L11; /*case 9*/
        if (__v0 == 10) goto __L13; /*case 10*/
        if (__v0 == 11) goto __L14; /*case 11*/
        if (__v0 == 12) goto __L15; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                if (b0.value.host_long_long == 0)
                {
                    snprintf(warning_message, 200, "division by zero");
                    return r;
                }
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long % b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L7: /*case 1*/ 
            __L8: /*case 3*/ 
            __L9: /*case 5*/ 
            __L10: /*case 7*/ 
            __L11: /*case 9*/ 
            if (b0.value.host_u_long_long == 0)
            {
                snprintf(warning_message, 200, "division by zero");
                return r;
            }
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long % b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L13: /*case 10*/ 
            __L14: /*case 11*/ 
            __L15: /*case 12*/ 
            ;
            snprintf(warning_message, 200, " invalid operands for");
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


int object_is_equal(int target, struct object * a, struct object * b)
{
    char message[200];
    struct object  r;

    r = object_equal(target, a, b, message);
    return r.value.host_long_long != 0;
}


int object_is_not_equal(int target, struct object * a, struct object * b)
{
    char message[200];
    struct object  r;

    r = object_not_equal(target, a, b, message);
    return r.value.host_long_long != 0;
}


int object_is_greater_than_or_equal(int target, struct object * a, struct object * b)
{
    char message[200];
    struct object  r;

    r = object_greater_than_or_equal(target, a, b, message);
    return r.value.host_long_long != 0;
}


int object_is_smaller_than_or_equal(int target, struct object * a, struct object * b)
{
    char message[200];
    struct object  r;

    r = object_smaller_than_or_equal(target, a, b, message);
    return r.value.host_long_long != 0;
}


struct object object_logical_not(int target, struct object * a, char warning_message[200])
{
    struct object  r;
    int common_type;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    _cake_zmem(&r, 120);
    r.value_type = 4;
    r.state = 2;
    common_type = a->value_type;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(!a->value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(!a->value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            r.value.host_u_long_long = (!a->value.host_long_double);
            r.value.host_long_double = resize_floating_point(r.value.host_long_double, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_bitwise_not(int target, struct object * a, char warning_message[200])
{
    struct object  r;
    int common_type;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    _cake_zmem(&r, 120);
    r.state = 2;
    common_type = a->value_type;
    r.value_type = common_type;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(~a->value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(~a->value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            snprintf(warning_message, 200, "invalid operand");
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_unary_minus(int target, struct object * a, char warning_message[200])
{
    struct object  r;
    int common_type;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    _cake_zmem(&r, 120);
    r.state = 2;
    common_type = a->value_type;
    r.value_type = common_type;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(-(a->value.host_long_long), target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(-(a->value.host_u_long_long), target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            r.value.host_long_double = -(a->value.host_long_double);
            r.value.host_long_double = resize_floating_point(r.value.host_long_double, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_unary_plus(int target, struct object * a, char warning_message[200])
{
    struct object  r;
    int common_type;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    _cake_zmem(&r, 120);
    r.state = 2;
    common_type = a->value_type;
    r.value_type = common_type;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(+(a->value.host_long_long), target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(+(a->value.host_u_long_long), target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            r.value.host_long_double = +(a->value.host_long_double);
            r.value.host_long_double = resize_floating_point(r.value.host_long_double, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_bitwise_xor(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long ^ b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long ^ b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            ;
            snprintf(warning_message, 200, " invalid operands");
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_bitwise_or(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long | b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long | b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            ;
            snprintf(warning_message, 200, " invalid operands");
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_bitwise_and(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long & b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long & b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            ;
            snprintf(warning_message, 200, " invalid operands");
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_shift_left(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long << b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long << b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            ;
            snprintf(warning_message, 200, " invalid operands");
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct object object_shift_right(int target, struct object * a, struct object * b, char warning_message[200])
{
    int common_type;
    struct object  a0;
    struct object  b0;
    struct object  r;

    warning_message[0] = 0;
    a = object_get_referenced(a);
    b = object_get_referenced(b);
    common_type = object_common(target, a, b);
    a0 = object_cast(target, common_type, a);
    b0 = object_cast(target, common_type, b);
    _cake_zmem(&r, 120);
    r.value_type = common_type;
    r.state = 2;
    /*switch*/
    {
        int __v0 = common_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 4) goto __L3; /*case 4*/
        if (__v0 == 6) goto __L4; /*case 6*/
        if (__v0 == 8) goto __L5; /*case 8*/
        if (__v0 == 1) goto __L6; /*case 1*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 7) goto __L9; /*case 7*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 2*/ 
            __L3: /*case 4*/ 
            __L4: /*case 6*/ 
            __L5: /*case 8*/ 
            {
                r.value.host_long_long = wrap_signed_integer(a0.value.host_long_long >> b0.value.host_long_long, target_get_num_of_bits(target, common_type));
            }
            goto __L0; /* break */

            __L6: /*case 1*/ 
            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 7*/ 
            __L10: /*case 9*/ 
            r.value.host_u_long_long = wrap_unsigned_integer(a0.value.host_u_long_long >> b0.value.host_u_long_long, target_get_num_of_bits(target, common_type));
            goto __L0; /* break */

            __L11: /*case 10*/ 
            __L12: /*case 11*/ 
            __L13: /*case 12*/ 
            ;
            snprintf(warning_message, 200, " invalid operands");
            goto __L0; /* break */

        }
        __L0:;
    }
    return r;
}


struct enumerator *find_enumerator(struct parser_ctx * ctx, char * lexeme, struct scope ** ppscope_opt);

unsigned char is_enumeration_constant(struct parser_ctx * ctx)
{
    unsigned char  is_enumerator;

    if (ctx->current == 0)
    {
        return 0;
    }
    if (ctx->current->type != 8996)
    {
        return 0;
    }
    if (ctx->current->flags & 128)
    {
        return 1;
    }
    if (ctx->current->flags & 256)
    {
        return 0;
    }
    is_enumerator = find_enumerator(ctx, ctx->current->lexeme, 0) != 0;
    if (is_enumerator)
    {
        ctx->current->flags |= 128;
    }
    else
    {
        ctx->current->flags |= 256;
    }
    return is_enumerator;
}


unsigned char is_first_of_floating_constant(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 140 || ctx->current->type == 141;
}


unsigned char is_first_of_integer_constant(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 136 || ctx->current->type == 137 || ctx->current->type == 138 || ctx->current->type == 139;
}


unsigned char is_predefined_constant(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 9077 || ctx->current->type == 9078 || ctx->current->type == 9079;
}


unsigned char is_first_of_constant(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return is_first_of_integer_constant(ctx) || is_first_of_floating_constant(ctx) || is_enumeration_constant(ctx) || (ctx->current->type == 131) || is_predefined_constant(ctx);
}


unsigned char is_first_of_primary_expression(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 8996 || is_first_of_constant(ctx) || ctx->current->type == 130 || ctx->current->type == 40 || ctx->current->type == 9070;
}


void unexpected_end_of_file(struct parser_ctx * ctx);
void parser_match(struct parser_ctx * ctx);
unsigned char first_of_type_name(struct parser_ctx * ctx);
struct type_name *type_name(struct parser_ctx * ctx);
struct type make_type_using_declarator(struct parser_ctx * ctx, struct declarator * pdeclarator);
int parser_match_tk(struct parser_ctx * ctx, int type);
struct expression *assignment_expression(struct parser_ctx * ctx, int eval_mode);
void generic_association_delete(struct generic_association * p);

struct generic_association *generic_association(struct parser_ctx * ctx, int eval_mode)
{
    struct generic_association * p_generic_association;

    p_generic_association = 0;
    if (1) /*try*/
    {
        struct expression * p_expression_temp;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_generic_association = calloc(1, 88);
        if (p_generic_association == 0)
        {
            goto __L0; /* throw */
        }
        p_generic_association->first_token = ctx->current;
        if (ctx->current->type == 9007)
        {
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
        }
        else
        {
            if (first_of_type_name(ctx))
            {
                unsigned char  old;

                old = ctx->inside_generic_association;
                ctx->inside_generic_association = 1;
                p_generic_association->p_type_name = type_name(ctx);
                if (p_generic_association->p_type_name == 0)
                {
                    goto __L0; /* throw */
                }
                ;
                ctx->inside_generic_association = old;
                p_generic_association->type = make_type_using_declarator(ctx, p_generic_association->p_type_name->abstract_declarator);
            }
            else
            {
                compiler_diagnostic(650, ctx, ctx->current, 0, "unexpected");
            }
        }
        if (parser_match_tk(ctx, 58) != 0)
        {
            goto __L0; /* throw */
        }
        p_expression_temp = assignment_expression(ctx, eval_mode);
        if (p_expression_temp == 0)
        {
            goto __L0; /* throw */
        }
        p_generic_association->expression = p_expression_temp;
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_generic_association->last_token = ctx->current;
    }
    else __L0: /*catch*/ 
    {
        generic_association_delete(p_generic_association);
        p_generic_association = 0;
    }
    return p_generic_association;
}


void generic_assoc_list_add(struct generic_assoc_list * p, struct generic_association * item);

struct generic_assoc_list generic_association_list(struct parser_ctx * ctx, int eval_mode)
{
    struct generic_assoc_list  list;

    _cake_zmem(&list, 8);
    if (1) /*try*/
    {
        struct generic_association * p_default_generic_association;
        struct generic_association * p_generic_association;

        p_default_generic_association = 0;
        p_generic_association = generic_association(ctx, 1);
        if (p_generic_association == 0)
        {
            goto __L0; /* throw */
        }
        if (p_generic_association->first_token->type == 9007)
        {
            p_default_generic_association = p_generic_association;
        }
        generic_assoc_list_add(&list, p_generic_association);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        while (ctx->current->type == 44)
        {
            struct generic_association * p_generic_association2;

            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            p_generic_association2 = generic_association(ctx, eval_mode);
            if (p_generic_association2 == 0)
            {
                goto __L0; /* throw */
            }
            if (p_generic_association2->first_token->type == 9007)
            {
                if (p_default_generic_association != 0)
                {
                    if (compiler_diagnostic(1570, ctx, p_generic_association2->first_token, 0, "duplicate default generic association."))
                    {
                        compiler_diagnostic(0, ctx, p_default_generic_association->first_token, 0, "previous default generic association");
                    }
                }
                else
                {
                    p_default_generic_association = p_generic_association2;
                }
            }
            generic_assoc_list_add(&list, p_generic_association2);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return list;
}


void type_name_delete(struct type_name * p);
void expression_delete(struct expression * p);

void generic_association_delete(struct generic_association * p)
{
    if (p)
    {
        ;
        type_name_delete(p->p_type_name);
        expression_delete(p->expression);
        type_destroy(&p->type);
        free(p);
    }
}


void generic_assoc_list_add(struct generic_assoc_list * list, struct generic_association * pitem)
{
    if (list->head == 0)
    {
        list->head = pitem;
    }
    else
    {
        ;
        ;
        list->tail->next = pitem;
    }
    list->tail = pitem;
}


void generic_assoc_list_destroy(struct generic_assoc_list * p)
{
    struct generic_association * item;

    item = p->head;
    while (item)
    {
        struct generic_association * next;

        next = item->next;
        item->next = 0;
        generic_association_delete(item);
        item = next;
    }
}


void generic_selection_delete(struct generic_selection * p)
{
    if (p)
    {
        expression_delete(p->expression);
        type_name_delete(p->type_name);
        generic_assoc_list_destroy(&p->generic_assoc_list);
        free(p);
    }
}


unsigned char expression_is_subjected_to_lvalue_conversion(struct expression *);
struct type type_lvalue_conversion(struct type * p_type, unsigned char  nullchecks_enabled);
unsigned char type_is_same(struct type * a, struct type * b, unsigned char  compare_qualifiers);

struct generic_selection *generic_selection(struct parser_ctx * ctx, int eval_mode)
{
    struct generic_selection * p_generic_selection;

    p_generic_selection = 0;
    if (1) /*try*/
    {
        struct type  lvalue_type;
        struct type * p_type;
        struct generic_association * current;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_generic_selection = calloc(1, 28);
        if (p_generic_selection == 0)
        {
            goto __L0; /* throw */
        }
        p_generic_selection->first_token = ctx->current;
        if (parser_match_tk(ctx, 9070) != 0)
        {
            goto __L0; /* throw */
        }
        if (parser_match_tk(ctx, 40) != 0)
        {
            goto __L0; /* throw */
        }
        if (first_of_type_name(ctx))
        {
            p_generic_selection->type_name = type_name(ctx);
            if (p_generic_selection->type_name == 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            p_generic_selection->expression = assignment_expression(ctx, eval_mode);
            if (p_generic_selection->expression == 0)
            {
                goto __L0; /* throw */
            }
        }
        if (parser_match_tk(ctx, 44) != 0)
        {
            goto __L0; /* throw */
        }
        p_generic_selection->generic_assoc_list = generic_association_list(ctx, eval_mode);
        if (p_generic_selection->generic_assoc_list.head == 0)
        {
            goto __L0; /* throw */
        }
        _cake_zmem(&lvalue_type, 68);
        p_type = 0;
        if (p_generic_selection->expression)
        {
            p_type = &p_generic_selection->expression->type;
            if (expression_is_subjected_to_lvalue_conversion(p_generic_selection->expression))
            {
                lvalue_type = type_lvalue_conversion(&p_generic_selection->expression->type, ctx->options.null_checks_enabled);
                p_type = &lvalue_type;
            }
        }
        else
        {
            if (p_generic_selection->type_name)
            {
                p_type = &p_generic_selection->type_name->abstract_declarator->type;
            }
            else
            {
                goto __L0; /* throw */
            }
        }
        current = p_generic_selection->generic_assoc_list.head;
        while (current)
        {
            if (current->p_type_name)
            {
                if (type_is_same(p_type, &current->type, 1))
                {
                    p_generic_selection->p_view_selected_expression = current->expression;
                    break;
                }
            }
            else
            {
                p_generic_selection->p_view_selected_expression = current->expression;
            }
            current = current->next;
        }
        type_destroy(&lvalue_type);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_generic_selection->last_token = ctx->current;
        if (parser_match_tk(ctx, 41) != 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        generic_selection_delete(p_generic_selection);
        p_generic_selection = 0;
    }
    return p_generic_selection;
}


unsigned long long target_unsigned_max(int target, int type);
long long target_signed_max(int target, int type);

struct expression *character_constant_expression(struct parser_ctx * ctx)
{
    struct expression * p_expression_node;
    unsigned long long wchar_max_value;
    unsigned long long int_max_value;

    p_expression_node = 0;
    wchar_max_value = target_unsigned_max(ctx->options.target, get_platform(ctx->options.target)->wchar_t_type);
    int_max_value = target_signed_max(ctx->options.target, 4);
    if (1) /*try*/
    {
        unsigned char * p;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_expression_node = calloc(1, 256);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        p_expression_node->expression_type = 5;
        p_expression_node->first_token = ctx->current;
        p_expression_node->last_token = p_expression_node->first_token;
        p_expression_node->type.attributes_flags |= 67108864;
        p_expression_node->type.category = 0;
        p = (unsigned char *)ctx->current->lexeme;
        if (p[0] == 117 && p[1] == 56)
        {
            unsigned int c;

            p++;
            p++;
            p++;
            p_expression_node->type.type_specifier_flags = 258;
            c = 0;
            p = utf8_decode(p, &c);
            if (p == 0)
            {
                goto __L0; /* throw */
            }
            if (c == 92)
            {
                p = escape_sequences_decode_opt(p, &c);
                if (p == 0)
                {
                    goto __L0; /* throw */
                }
            }
            if (*p != 39)
            {
                compiler_diagnostic(1370, ctx, ctx->current, 0, "Unicode character literals may not contain multiple characters.");
            }
            if (c > 128)
            {
                compiler_diagnostic(1360, ctx, ctx->current, 0, "character not encodable in a single code unit.");
            }
            p_expression_node->object = object_make_unsigned_char(ctx->options.target, (unsigned char)c);
        }
        else
        {
            if (p[0] == 117)
            {
                unsigned int c;

                p++;
                p++;
                p_expression_node->type.type_specifier_flags = 260;
                c = 0;
                p = utf8_decode(p, &c);
                if (p == 0)
                {
                    goto __L0; /* throw */
                }
                if (c == 92)
                {
                    p = escape_sequences_decode_opt(p, &c);
                    if (p == 0)
                    {
                        goto __L0; /* throw */
                    }
                }
                if (*p != 39)
                {
                    compiler_diagnostic(41, ctx, ctx->current, 0, "Unicode character literals may not contain multiple characters.");
                }
                if (c > 65535)
                {
                    compiler_diagnostic(41, ctx, ctx->current, 0, "Character too large for enclosing character literal type.");
                }
                p_expression_node->object = object_make_wchar_t(ctx->options.target, c);
            }
            else
            {
                if (p[0] == 85)
                {
                    unsigned int c;

                    p++;
                    p++;
                    p_expression_node->type.type_specifier_flags = 264;
                    c = 0;
                    p = utf8_decode(p, &c);
                    if (p == 0)
                    {
                        goto __L0; /* throw */
                    }
                    if (c == 92)
                    {
                        p = escape_sequences_decode_opt(p, &c);
                        if (p == 0)
                        {
                            goto __L0; /* throw */
                        }
                    }
                    if (*p != 39)
                    {
                        compiler_diagnostic(41, ctx, ctx->current, 0, "Unicode character literals may not contain multiple characters.");
                    }
                    if (c > 1114111 || c > 4294967295)
                    {
                        compiler_diagnostic(41, ctx, ctx->current, 0, "Character too large for enclosing character literal type.");
                    }
                    p_expression_node->object = object_make_wchar_t(ctx->options.target, c);
                }
                else
                {
                    if (p[0] == 76)
                    {
                        long long value;

                        p++;
                        p++;
                        p_expression_node->type.type_specifier_flags = object_type_to_type_specifier(get_platform(ctx->options.target)->wchar_t_type);
                        value = 0;
                        while (*p != 39)
                        {
                            unsigned int c;

                            c = 0;
                            p = utf8_decode(p, &c);
                            if (p == 0)
                            {
                                goto __L0; /* throw */
                            }
                            if (c == 92)
                            {
                                p = escape_sequences_decode_opt(p, &c);
                                if (p == 0)
                                {
                                    goto __L0; /* throw */
                                }
                            }
                            if (c < 128)
                            {
                                value = value * 256 + c;
                            }
                            else
                            {
                                value = c;
                            }
                            if (value > (long long)wchar_max_value)
                            {
                                compiler_diagnostic(42, ctx, ctx->current, 0, "character constant too long for its type", ctx->current->lexeme);
                                break;
                            }
                        }
                        p_expression_node->object = object_make_wchar_t(ctx->options.target, (unsigned int)value);
                    }
                    else
                    {
                        unsigned char  multi_character_literal;
                        long long value;

                        p++;
                        p_expression_node->type.type_specifier_flags = 8;
                        multi_character_literal = 0;
                        value = 0;
                        while (*p != 39)
                        {
                            unsigned int c;

                            c = 0;
                            p = utf8_decode(p, &c);
                            if (p == 0)
                            {
                                goto __L0; /* throw */
                            }
                            if (c == 92)
                            {
                                p = escape_sequences_decode_opt(p, &c);
                                if (p == 0)
                                {
                                    goto __L0; /* throw */
                                }
                            }
                            if (multi_character_literal)
                            {
                                value = ((unsigned long long)value) * 256 + c;
                            }
                            else
                            {
                                struct object  obj;

                                obj = object_make_char(ctx->options.target, (int)c);
                                value = obj.value.host_long_long;
                                object_destroy(&obj);
                            }
                            if (value > (long long)int_max_value)
                            {
                                compiler_diagnostic(42, ctx, ctx->current, 0, "character constant too long for its type", ctx->current->lexeme);
                                break;
                            }
                            multi_character_literal = 1;
                        }
                        p_expression_node->object = object_make_signed_int(ctx->options.target, value);
                    }
                }
            }
        }
        parser_match(ctx);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}


unsigned long long strtoull(char * _String, char ** _EndPtr, int _Radix);
double strtod(char * _String, char ** _EndPtr);

int convert_to_number(struct parser_ctx * ctx, struct expression * p_expression_node, unsigned char  disabled, int target)
{
    unsigned long long unsigned_int_max_value;
    unsigned long long signed_int_max_value;
    unsigned long long signed_long_max_value;
    unsigned long long unsigned_long_max_value;
    unsigned long long signed_long_long_max_value;
    unsigned long long unsigned_long_long_max_value;
    struct token * token;
    int c;
    char buffer[260];
    char * s;
    char errormsg[100];
    char suffix[4];
    int r;

    unsigned_int_max_value = target_unsigned_max(ctx->options.target, 5);
    signed_int_max_value = target_signed_max(ctx->options.target, 4);
    signed_long_max_value = target_signed_max(ctx->options.target, 6);
    unsigned_long_max_value = target_unsigned_max(ctx->options.target, 7);
    signed_long_long_max_value = target_signed_max(ctx->options.target, 8);
    unsigned_long_long_max_value = target_unsigned_max(ctx->options.target, 9);
    (*_errno()) = 0;
    if (ctx->current == 0)
    {
        unexpected_end_of_file(ctx);
        return 1;
    }
    token = ctx->current;
    c = 0;
    _cake_zmem(&buffer, 260);
    s = token->lexeme;
    while (*s)
    {
        if (*s != 39)
        {
            buffer[c] = *s;
            c++;
        }
        s++;
    }
    _cake_zmem(&errormsg, 100);
    _cake_zmem(&suffix, 4);
    r = parse_number(buffer, suffix, errormsg);
    if (r == 0)
    {
        compiler_diagnostic(1380, ctx, token, 0, errormsg);
        return 0;
    }
    /*switch*/
    {
        int __v0 = token->type;
        if (__v0 == 136) goto __L4; /*case 136*/
        if (__v0 == 137) goto __L5; /*case 137*/
        if (__v0 == 138) goto __L6; /*case 138*/
        if (__v0 == 139) goto __L7; /*case 139*/
        if (__v0 == 140) goto __L24; /*case 140*/
        if (__v0 == 141) goto __L25; /*case 141*/
        goto __L36; /* default */

        {
            __L4: /*case 136*/ 
            __L5: /*case 137*/ 
            __L6: /*case 138*/ 
            __L7: /*case 139*/ 
            {
                unsigned long long value;

                value = 0;
                /*switch*/
                {
                    int __v1 = token->type;
                    if (__v1 == 136) goto __L9; /*case 136*/
                    if (__v1 == 137) goto __L10; /*case 137*/
                    if (__v1 == 138) goto __L12; /*case 138*/
                    if (__v1 == 139) goto __L13; /*case 139*/
                    goto __L14; /* default */

                    {
                        __L9: /*case 136*/ 
                        value = strtoull(buffer, 0, 10);
                        goto __L8; /* break */

                        __L10: /*case 137*/ 
                        if (buffer[1] == 111 || buffer[1] == 79)
                        {
                            value = strtoull(buffer + 2, 0, 8);
                        }
                        else
                        {
                            value = strtoull(buffer + 1, 0, 8);
                        }
                        goto __L8; /* break */

                        __L12: /*case 138*/ 
                        value = strtoull(buffer + 2, 0, 16);
                        goto __L8; /* break */

                        __L13: /*case 139*/ 
                        value = strtoull(buffer + 2, 0, 2);
                        goto __L8; /* break */

                        __L14: /* default */ 
                        goto __L8; /* break */

                    }
                    __L8:;
                }
                if (value == unsigned_long_long_max_value && (*_errno()) == 34)
                {
                    compiler_diagnostic(1350, ctx, token, 0, "integer literal is too large to be represented in any integer type");
                }
                if (suffix[0] == 85)
                {
                    if (value <= unsigned_int_max_value && suffix[1] != 76)
                    {
                        object_destroy(&p_expression_node->object);
                        p_expression_node->object = object_make_unsigned_int(ctx->options.target, value);
                        p_expression_node->type.type_specifier_flags = 264;
                    }
                    else
                    {
                        if (value <= unsigned_long_max_value && suffix[2] != 76)
                        {
                            object_destroy(&p_expression_node->object);
                            p_expression_node->object = object_make_unsigned_long(target, value);
                            p_expression_node->type.type_specifier_flags = 272;
                        }
                        else
                        {
                            object_destroy(&p_expression_node->object);
                            p_expression_node->object = object_make_unsigned_long_long(ctx->options.target, value);
                            p_expression_node->type.type_specifier_flags = 4194560;
                        }
                    }
                }
                else
                {
                    if (value <= signed_int_max_value && suffix[0] != 76)
                    {
                        object_destroy(&p_expression_node->object);
                        p_expression_node->object = object_make_signed_int(ctx->options.target, value);
                        p_expression_node->type.type_specifier_flags = 8;
                    }
                    else
                    {
                        if (value <= signed_int_max_value && suffix[1] != 76)
                        {
                            object_destroy(&p_expression_node->object);
                            p_expression_node->object = object_make_signed_long(target, value);
                            p_expression_node->type.type_specifier_flags = 16;
                        }
                        else
                        {
                            if ((target == 1 || target == 2) && (value <= unsigned_long_max_value) && suffix[1] != 76)
                            {
                                object_destroy(&p_expression_node->object);
                                p_expression_node->object = object_make_unsigned_long(target, value);
                                p_expression_node->type.type_specifier_flags = 272;
                            }
                            else
                            {
                                if (value <= signed_long_max_value && suffix[1] != 76)
                                {
                                    object_destroy(&p_expression_node->object);
                                    p_expression_node->object = object_make_signed_long(target, value);
                                    p_expression_node->type.type_specifier_flags = 16;
                                }
                                else
                                {
                                    if (value <= signed_long_long_max_value)
                                    {
                                        object_destroy(&p_expression_node->object);
                                        p_expression_node->object = object_make_signed_long_long(ctx->options.target, value);
                                        p_expression_node->type.type_specifier_flags = 4194304;
                                    }
                                    else
                                    {
                                        compiler_diagnostic(50, ctx, token, 0, "integer literal is too large to be represented in a signed integer type, interpreting as unsigned");
                                        object_destroy(&p_expression_node->object);
                                        p_expression_node->object = object_make_unsigned_long_long(ctx->options.target, value);
                                        p_expression_node->type.type_specifier_flags = 4194560;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            goto __L3; /* break */

            __L24: /*case 140*/ 
            __L25: /*case 141*/ 
            {
                if (suffix[0] == 70)
                {
                    double value;

                    value = strtod(buffer, 0);
                    if ((*_errno()) == 34)
                    {
                        if (((0 ? _fdclass((float)(value)) : 1 ? _dclass((double)(value)) : _ldclass((long double)(value))) == 1))
                        {
                            compiler_diagnostic(63, ctx, token, 0, "floating constant exceeds range of float");
                        }
                        else
                        {
                            compiler_diagnostic(63, ctx, token, 0, "floating constant truncated to zero");
                        }
                    }
                    else
                    {
                        if ((value > 0 && value > 3.4028234663852886e+38) || (value < 0 && value < 3.4028234663852886e+38))
                        {
                            compiler_diagnostic(63, ctx, token, 0, "floating constant exceeds range of float");
                        }
                        else
                        {
                            if (value > 0 && value < 1.1754943508222875e-38)
                            {
                                compiler_diagnostic(63, ctx, token, 0, "floating constant is too small for float.");
                            }
                        }
                    }
                    p_expression_node->type.type_specifier_flags = 32;
                    object_destroy(&p_expression_node->object);
                    p_expression_node->object = object_make_float(ctx->options.target, value);
                }
                else
                {
                    if (suffix[0] == 76)
                    {
                        long double value;

                        value = strtod(buffer, 0);
                        if ((*_errno()) == 34)
                        {
                            if (((0 ? _fdclass((float)(value)) : 1 ? _dclass((double)(value)) : _ldclass((long double)(value))) == 1))
                            {
                                compiler_diagnostic(63, ctx, token, 0, "floating constant exceeds range of long double");
                            }
                            else
                            {
                                compiler_diagnostic(63, ctx, token, 0, "floating constant truncated to zero");
                            }
                        }
                        p_expression_node->type.type_specifier_flags = 80;
                        object_destroy(&p_expression_node->object);
                        p_expression_node->object = object_make_long_double(ctx->options.target, value);
                    }
                    else
                    {
                        double value;

                        value = strtod(buffer, 0);
                        if ((*_errno()) == 34)
                        {
                            if (((0 ? _fdclass((float)(value)) : 1 ? _dclass((double)(value)) : _ldclass((long double)(value))) == 1))
                            {
                                compiler_diagnostic(63, ctx, token, 0, "floating constant exceeds range of double");
                            }
                            else
                            {
                                compiler_diagnostic(63, ctx, token, 0, "floating constant truncated to zero");
                            }
                        }
                        object_destroy(&p_expression_node->object);
                        p_expression_node->object = object_make_double(ctx->options.target, value);
                        p_expression_node->type.type_specifier_flags = 64;
                    }
                }
            }
            goto __L3; /* break */

            __L36: /* default */ 
            ;
        }
        __L3:;
    }
    return 0;
}


struct map_entry *find_variables(struct parser_ctx * ctx, char * lexeme, struct scope ** ppscope_opt);
struct type type_make_enumerator(struct enum_specifier * enum_specifier);
unsigned char type_is_deprecated(struct type * p_type);
struct type type_make_literal_string(int size, int chartype, int qualifiers, int target);
static unsigned char is_integer_or_floating_constant(int type);
struct expression *expression(struct parser_ctx * ctx, int eval_mode);

struct expression *primary_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;

    if (ctx->current == 0)
    {
        unexpected_end_of_file(ctx);
        return 0;
    }
    p_expression_node = 0;
    if (1) /*try*/
    {
        if (ctx->current->type == 8996)
        {
            struct scope * p_scope;
            struct map_entry * p_entry;

            p_expression_node = calloc(1, 256);
            if (p_expression_node == 0)
            {
                goto __L1; /* throw */
            }
            p_expression_node->first_token = ctx->current;
            p_expression_node->last_token = ctx->current;
            p_scope = 0;
            p_entry = find_variables(ctx, ctx->current->lexeme, &p_scope);
            if (p_entry && p_entry->type == 3)
            {
                struct enumerator * p_enumerator;

                ;
                p_enumerator = p_entry->data.p_enumerator;
                p_expression_node->expression_type = 1;
                p_expression_node->object = p_enumerator->value;
                p_expression_node->type = type_make_enumerator(p_enumerator->enum_specifier);
            }
            else
            {
                if (p_entry && (p_entry->type == 4 || p_entry->type == 5))
                {
                    struct declarator * p_declarator;
                    struct init_declarator * p_init_declarator;

                    p_declarator = 0;
                    p_init_declarator = 0;
                    if (p_entry->type == 5)
                    {
                        ;
                        p_init_declarator = p_entry->data.p_init_declarator;
                        p_declarator = p_init_declarator->p_declarator;
                    }
                    else
                    {
                        p_declarator = p_entry->data.p_declarator;
                    }
                    ;
                    if (type_is_deprecated(&p_declarator->type))
                    {
                        compiler_diagnostic(3, ctx, ctx->current, 0, "'%s' is deprecated", ctx->current->lexeme);
                    }
                    if (p_scope->scope_level == 0)
                    {
                    }
                    else
                    {
                        if ((p_declarator->type.storage_class_specifier_flags & 4) || (p_declarator->type.storage_class_specifier_flags & 8))
                        {
                        }
                        else
                        {
                            if (ctx->p_current_function_scope_opt)
                            {
                                unsigned char  b_type_is_function;

                                b_type_is_function = type_is_function(&p_declarator->type);
                                if (eval_mode == 2 && !b_type_is_function)
                                {
                                    unsigned char  inside_current_function_scope;

                                    inside_current_function_scope = 0;
                                    while (p_scope)
                                    {
                                        if (ctx->p_current_function_scope_opt == p_scope)
                                        {
                                            inside_current_function_scope = 1;
                                            break;
                                        }
                                        p_scope = p_scope->previous;
                                    }
                                    if (!inside_current_function_scope)
                                    {
                                        compiler_diagnostic(1870, ctx, p_expression_node->first_token, 0, "'%s' cannot be evaluated in this scope", ctx->current->lexeme);
                                    }
                                }
                            }
                        }
                    }
                    p_declarator->num_uses++;
                    p_expression_node->declarator = p_declarator;
                    p_expression_node->p_init_declarator = p_init_declarator;
                    p_expression_node->expression_type = 2;
                    p_expression_node->type = type_dup(&p_declarator->type);
                    p_expression_node->object = object_make_reference(&p_declarator->object);
                }
                else
                {
                    if (ctx->p_current_function_opt && strcmp(ctx->current->lexeme, "__func__") == 0)
                    {
                        char * func_name;

                        func_name = ctx->p_current_function_opt->name_opt ? ctx->p_current_function_opt->name_opt->lexeme : "unnamed";
                        p_expression_node->expression_type = 4;
                        p_expression_node->first_token = ctx->current;
                        p_expression_node->last_token = ctx->current;
                        p_expression_node->type = type_make_literal_string((int)strlen(func_name) + 1, 2, 1, ctx->options.target);
                    }
                    else
                    {
                        compiler_diagnostic(680, ctx, p_expression_node->first_token, 0, "identifier '%s' not declared", ctx->current->lexeme);
                        goto __L1; /* throw */
                    }
                }
            }
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L1; /* throw */
            }
        }
        else
        {
            if (ctx->current->type == 130)
            {
                int char_type_specifiers;
                unsigned char  is_bigger_than_char;
                unsigned char  is_wide;
                unsigned char  is_u8;
                unsigned char  is_u32;
                unsigned char  is_u16;
                unsigned int number_of_elements_including_zero;
                struct object * last;
                struct object * p_new;
                int lit_flags;

                p_expression_node = calloc(1, 256);
                if (p_expression_node == 0)
                {
                    goto __L1; /* throw */
                }
                p_expression_node->expression_type = 3;
                p_expression_node->first_token = ctx->current;
                p_expression_node->last_token = ctx->current;
                char_type_specifiers = 2;
                is_bigger_than_char = 0;
                is_wide = 0;
                is_u8 = 0;
                is_u32 = 0;
                is_u16 = 0;
                if (ctx->current->lexeme[0] == 76)
                {
                    is_wide = 1;
                    is_bigger_than_char = 1;
                    char_type_specifiers = object_type_to_type_specifier(get_platform(ctx->options.target)->wchar_t_type);
                }
                else
                {
                    if (ctx->current->lexeme[0] == 117 && ctx->current->lexeme[1] == 56)
                    {
                        is_u8 = 1;
                        char_type_specifiers = 2;
                    }
                    else
                    {
                        if (ctx->current->lexeme[0] == 117)
                        {
                            is_u16 = 1;
                            is_bigger_than_char = 1;
                            char_type_specifiers = 256 | object_type_to_type_specifier(get_platform(ctx->options.target)->int16_type);
                        }
                        else
                        {
                            if (ctx->current->lexeme[0] == 85)
                            {
                                is_u32 = 1;
                                is_bigger_than_char = 1;
                                char_type_specifiers = 256 | object_type_to_type_specifier(get_platform(ctx->options.target)->int32_type);
                            }
                            else
                            {
                                char_type_specifiers = 2;
                            }
                        }
                    }
                }
                number_of_elements_including_zero = 0;
                last = 0;
                while (ctx->current->type == 130)
                {
                    unsigned char * it;
                    unsigned int value;

                    it = (unsigned char *)ctx->current->lexeme;
                    while (*it != 34)
                    it++;
                    ;
                    it++;
                    value = 0;
                    while (it && *it != 34)
                    {
                        unsigned int c;
                        struct object * p_new;

                        c = 0;
                        if (is_bigger_than_char)
                        {
                            it = utf8_decode(it, &c);
                            if (it == 0)
                            {
                                goto __L1; /* throw */
                            }
                        }
                        else
                        {
                            c = *it;
                            it++;
                        }
                        if (c == 92)
                        {
                            it = escape_sequences_decode_opt(it, &value);
                        }
                        else
                        {
                            value = c;
                        }
                        p_new = calloc(1, 120);
                        if (p_new == 0)
                        {
                            goto __L1; /* throw */
                        }
                        if (is_wide)
                        {
                            *p_new = object_make_wchar_t(ctx->options.target, value);
                        }
                        else
                        {
                            if (is_u8)
                            {
                                *p_new = object_make_uint8(ctx->options.target, (unsigned char)value);
                            }
                            else
                            {
                                if (is_u16)
                                {
                                    *p_new = object_make_uint16(ctx->options.target, (unsigned short)value);
                                }
                                else
                                {
                                    if (is_u32)
                                    {
                                        *p_new = object_make_uint32(ctx->options.target, (unsigned int)value);
                                    }
                                    else
                                    {
                                        *p_new = object_make_char(ctx->options.target, value);
                                    }
                                }
                            }
                        }
                        number_of_elements_including_zero++;
                        if (p_expression_node->object.members.head == 0)
                        {
                            p_expression_node->object.members.head = p_new;
                        }
                        else
                        {
                            if (last)
                            {
                                last->next = p_new;
                            }
                        }
                        last = p_new;
                    }
                    parser_match(ctx);
                    if (ctx->current == 0)
                    {
                        unexpected_end_of_file(ctx);
                        goto __L1; /* throw */
                    }
                }
                p_new = calloc(1, 120);
                if (p_new == 0)
                {
                    goto __L1; /* throw */
                }
                if (is_wide)
                {
                    *p_new = object_make_wchar_t(ctx->options.target, 0);
                }
                else
                {
                    if (is_u8)
                    {
                        *p_new = object_make_uint8(ctx->options.target, 0);
                    }
                    else
                    {
                        if (is_u16)
                        {
                            *p_new = object_make_uint16(ctx->options.target, 0);
                        }
                        else
                        {
                            if (is_u32)
                            {
                                *p_new = object_make_uint32(ctx->options.target, 0);
                            }
                            else
                            {
                                *p_new = object_make_char(ctx->options.target, 0);
                            }
                        }
                    }
                }
                number_of_elements_including_zero++;
                if (last == 0)
                {
                    p_expression_node->object.members.head = p_new;
                }
                else
                {
                    last->next = p_new;
                }
                lit_flags = ctx->options.const_literal ? 1 : 0;
                p_expression_node->type = type_make_literal_string(number_of_elements_including_zero, char_type_specifiers, lit_flags, ctx->options.target);
            }
            else
            {
                if (ctx->current->type == 131)
                {
                    p_expression_node = character_constant_expression(ctx);
                }
                else
                {
                    if (ctx->current->type == 9077 || ctx->current->type == 9078)
                    {
                        p_expression_node = calloc(1, 256);
                        if (p_expression_node == 0)
                        {
                            goto __L1; /* throw */
                        }
                        p_expression_node->expression_type = 6;
                        p_expression_node->first_token = ctx->current;
                        p_expression_node->last_token = ctx->current;
                        p_expression_node->object = object_make_bool(ctx->options.target, ctx->current->type == 9077);
                        p_expression_node->type.type_specifier_flags = 512;
                        p_expression_node->type.type_qualifier_flags = 0;
                        parser_match(ctx);
                        if (ctx->current == 0)
                        {
                            unexpected_end_of_file(ctx);
                            goto __L1; /* throw */
                        }
                    }
                    else
                    {
                        if (ctx->current->type == 9079)
                        {
                            p_expression_node = calloc(1, 256);
                            if (p_expression_node == 0)
                            {
                                goto __L1; /* throw */
                            }
                            p_expression_node->expression_type = 6;
                            p_expression_node->first_token = ctx->current;
                            p_expression_node->last_token = ctx->current;
                            p_expression_node->object = object_make_nullptr(ctx->options.target);
                            p_expression_node->type.type_specifier_flags = 16777216;
                            p_expression_node->type.type_qualifier_flags = 0;
                            parser_match(ctx);
                            if (ctx->current == 0)
                            {
                                unexpected_end_of_file(ctx);
                                goto __L1; /* throw */
                            }
                        }
                        else
                        {
                            if (is_integer_or_floating_constant(ctx->current->type))
                            {
                                p_expression_node = calloc(1, 256);
                                if (p_expression_node == 0)
                                {
                                    goto __L1; /* throw */
                                }
                                p_expression_node->first_token = ctx->current;
                                p_expression_node->last_token = ctx->current;
                                p_expression_node->expression_type = 8;
                                convert_to_number(ctx, p_expression_node, 0, ctx->options.target);
                                parser_match(ctx);
                                if (ctx->current == 0)
                                {
                                    unexpected_end_of_file(ctx);
                                    goto __L1; /* throw */
                                }
                            }
                            else
                            {
                                if (ctx->current->type == 9070)
                                {
                                    p_expression_node = calloc(1, 256);
                                    if (p_expression_node == 0)
                                    {
                                        goto __L1; /* throw */
                                    }
                                    p_expression_node->first_token = ctx->current;
                                    p_expression_node->expression_type = 7;
                                    p_expression_node->generic_selection = generic_selection(ctx, eval_mode);
                                    if (p_expression_node->generic_selection == 0)
                                    {
                                        goto __L1; /* throw */
                                    }
                                    p_expression_node->last_token = p_expression_node->generic_selection->last_token;
                                    if (p_expression_node->generic_selection->p_view_selected_expression)
                                    {
                                        p_expression_node->type = type_dup(&p_expression_node->generic_selection->p_view_selected_expression->type);
                                        p_expression_node->object = p_expression_node->generic_selection->p_view_selected_expression->object;
                                    }
                                    else
                                    {
                                        compiler_diagnostic(690, ctx, ctx->current, 0, "no match for generic");
                                    }
                                }
                                else
                                {
                                    if (ctx->current->type == 40)
                                    {
                                        p_expression_node = calloc(1, 256);
                                        if (p_expression_node == 0)
                                        {
                                            goto __L1; /* throw */
                                        }
                                        p_expression_node->expression_type = 9;
                                        p_expression_node->first_token = ctx->current;
                                        parser_match(ctx);
                                        if (ctx->current == 0)
                                        {
                                            unexpected_end_of_file(ctx);
                                            goto __L1; /* throw */
                                        }
                                        p_expression_node->right = expression(ctx, eval_mode);
                                        if (p_expression_node->right == 0)
                                        {
                                            goto __L1; /* throw */
                                        }
                                        p_expression_node->type = type_dup(&p_expression_node->right->type);
                                        p_expression_node->object = p_expression_node->right->object;
                                        if (ctx->current == 0)
                                        {
                                            unexpected_end_of_file(ctx);
                                            goto __L1; /* throw */
                                        }
                                        p_expression_node->last_token = ctx->current;
                                        if (parser_match_tk(ctx, 41) != 0)
                                        {
                                            goto __L1; /* throw */
                                        }
                                    }
                                    else
                                    {
                                        compiler_diagnostic(650, ctx, ctx->current, 0, "unexpected");
                                        goto __L1; /* throw */
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    else __L1: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    ;
    return p_expression_node;
}



static unsigned char is_integer_or_floating_constant(int type)
{
    return type == 136 || type == 137 || type == 138 || type == 139 || type == 140 || type == 141;
}
void argument_expression_delete(struct argument_expression * p)
{
    if (p)
    {
        expression_delete(p->expression);
        ;
        free(p);
    }
}


void argument_expression_list_push(struct argument_expression_list * list, struct argument_expression * p);

struct argument_expression_list argument_expression_list(struct parser_ctx * ctx, int eval_mode)
{
    struct argument_expression_list  list;
    struct argument_expression * p_argument_expression;

    _cake_zmem(&list, 8);
    p_argument_expression = 0;
    if (1) /*try*/
    {
        struct expression * p_assignment_expression;

        p_argument_expression = calloc(1, 12);
        if (p_argument_expression == 0)
        {
            goto __L0; /* throw */
        }
        p_assignment_expression = assignment_expression(ctx, eval_mode);
        if (p_assignment_expression == 0)
        {
            argument_expression_delete(p_argument_expression);
            goto __L0; /* throw */
        }
        p_argument_expression->expression = p_assignment_expression;
        argument_expression_list_push(&list, p_argument_expression);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        while (ctx->current->type == 44)
        {
            struct argument_expression * p_argument_expression_2;
            struct expression * p_assignment_expression_2;

            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            p_argument_expression_2 = calloc(1, 12);
            if (p_argument_expression_2 == 0)
            {
                goto __L0; /* throw */
            }
            p_assignment_expression_2 = assignment_expression(ctx, eval_mode);
            if (p_assignment_expression_2 == 0)
            {
                argument_expression_delete(p_argument_expression_2);
                goto __L0; /* throw */
            }
            p_argument_expression_2->expression = p_assignment_expression_2;
            argument_expression_list_push(&list, p_argument_expression_2);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return list;
}


unsigned char first_of_type_name_ahead(struct parser_ctx * ctx);

unsigned char first_of_postfix_expression(struct parser_ctx * ctx)
{
    if (first_of_type_name_ahead(ctx))
    {
        return 1;
    }
    return is_first_of_primary_expression(ctx);
}


struct type type_remove_pointer(struct type * p_type);
unsigned char type_is_array(struct type * p_type);
unsigned char type_is_integer(struct type * p_type);
unsigned char type_is_function_or_function_pointer(struct type * p_type);
struct type get_function_return_type(struct type * p_type);
static int compare_function_arguments(struct parser_ctx * ctx, struct type * p_type, struct argument_expression_list * p_argument_expression_list);
struct param_list *type_get_func_or_func_ptr_params(struct type * p_type);
unsigned char type_is_void(struct type * p_type);
void check_assigment(struct parser_ctx * ctx, struct type * left_type, struct expression * right, int assigment_type);
struct struct_or_union_specifier *find_struct_or_union_specifier(struct parser_ctx * ctx, char * lexeme);
struct member_declarator *find_member_declarator(struct member_declaration_list * list, char * name, int * p_member_index);
static void fix_member_type(struct type * p_type, struct type * struct_type, struct type * member_type);
struct object *find_object_declarator_by_index(struct object * p_object, struct member_declaration_list * list, int member_index);
unsigned char type_is_struct_or_union(struct type * p_type);
static void fix_arrow_member_type(struct type * p_type, struct type * left, struct type * member_type);
unsigned char type_is_owner(struct type * p_type);
unsigned char expression_is_lvalue(struct expression * expr);
struct token *previous_parser_token(struct token * token);

struct expression *postfix_expression_tail(struct parser_ctx * ctx, struct expression * p_expression_node_param, int eval_mode)
{
    struct expression * p_expression_node;

    p_expression_node = p_expression_node_param;
    if (1) /*try*/
    {
        while (ctx->current != 0)
        {
            if (ctx->current->type == 91)
            {
                struct expression * p_expression_node_new;

                p_expression_node_new = calloc(1, 256);
                if (p_expression_node_new == 0)
                {
                    goto __L0; /* throw */
                }
                p_expression_node->last_token = ctx->current;
                p_expression_node_new->first_token = ctx->current;
                p_expression_node_new->expression_type = 13;
                if (!type_is_pointer_or_array(&p_expression_node->type))
                {
                    compiler_diagnostic(700, ctx, ctx->current, 0, "subscripted value is neither array nor pointer");
                }
                if (type_is_pointer(&p_expression_node->type))
                {
                    p_expression_node_new->type = type_remove_pointer(&p_expression_node->type);
                }
                else
                {
                    if (type_is_array(&p_expression_node->type))
                    {
                        p_expression_node_new->type = get_array_item_type(&p_expression_node->type);
                    }
                }
                parser_match(ctx);
                if (ctx->current == 0)
                {
                    unexpected_end_of_file(ctx);
                    expression_delete(p_expression_node_new);
                    goto __L0; /* throw */
                }
                p_expression_node_new->right = expression(ctx, eval_mode);
                if (p_expression_node_new->right == 0)
                {
                    expression_delete(p_expression_node_new);
                    goto __L0; /* throw */
                }
                if (!type_is_integer(&p_expression_node_new->right->type))
                {
                    compiler_diagnostic(1560, ctx, p_expression_node_new->right->first_token, 0, "array subscript is not an integer");
                }
                if (object_has_constant_value(&p_expression_node_new->right->object))
                {
                    unsigned long long index;

                    index = object_to_unsigned_long_long(&p_expression_node_new->right->object);
                    if (type_is_array(&p_expression_node->type))
                    {
                        if (p_expression_node->type.num_of_elements > 0)
                        {
                            struct object * it;

                            if (index >= (unsigned long long)p_expression_node->type.num_of_elements)
                            {
                                compiler_diagnostic(42, ctx, ctx->current, 0, "index %d is past the end of the array", index);
                            }
                            it = object_get_member(&p_expression_node->object, (int)index);
                            if (it != 0)
                            {
                                p_expression_node_new->object = object_make_reference(it);
                            }
                        }
                    }
                }
                if (parser_match_tk(ctx, 93) != 0)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = 0;
                    goto __L0; /* throw */
                }
                p_expression_node_new->left = p_expression_node;
                p_expression_node = p_expression_node_new;
            }
            else
            {
                if (ctx->current->type == 40)
                {
                    struct expression * p_expression_node_new;

                    p_expression_node_new = calloc(1, 256);
                    if (p_expression_node_new == 0)
                    {
                        goto __L0; /* throw */
                    }
                    p_expression_node->last_token = ctx->current;
                    p_expression_node_new->first_token = p_expression_node->first_token;
                    p_expression_node_new->expression_type = 12;
                    if (!type_is_function_or_function_pointer(&p_expression_node->type))
                    {
                        compiler_diagnostic(710, ctx, ctx->current, 0, "called object is not a function or function pointer");
                    }
                    p_expression_node_new->type = get_function_return_type(&p_expression_node->type);
                    parser_match(ctx);
                    if (ctx->current == 0)
                    {
                        unexpected_end_of_file(ctx);
                        expression_delete(p_expression_node_new);
                        p_expression_node_new = 0;
                        goto __L0; /* throw */
                    }
                    if (ctx->current->type != 41)
                    {
                        p_expression_node_new->argument_expression_list = argument_expression_list(ctx, eval_mode);
                    }
                    if (parser_match_tk(ctx, 41) != 0)
                    {
                        expression_delete(p_expression_node_new);
                        p_expression_node_new = 0;
                        goto __L0; /* throw */
                    }
                    compare_function_arguments(ctx, &p_expression_node->type, &p_expression_node_new->argument_expression_list);
                    if (ctx->previous == 0)
                    {
                        expression_delete(p_expression_node_new);
                        p_expression_node_new = 0;
                        goto __L0; /* throw */
                    }
                    make_object(&p_expression_node_new->type, &p_expression_node_new->object, ctx->options.target);
                    p_expression_node_new->last_token = ctx->previous;
                    p_expression_node_new->left = p_expression_node;
                    p_expression_node = p_expression_node_new;
                }
                else
                {
                    if (ctx->current->type == 46)
                    {
                        struct expression * p_expression_node_new;

                        p_expression_node_new = calloc(1, 256);
                        if (p_expression_node_new == 0)
                        {
                            goto __L0; /* throw */
                        }
                        p_expression_node->last_token = ctx->current;
                        p_expression_node_new->first_token = ctx->current;
                        p_expression_node_new->expression_type = 14;
                        p_expression_node_new->left = p_expression_node;
                        p_expression_node = 0;
                        p_expression_node_new->declarator = p_expression_node_new->left->declarator;
                        parser_match(ctx);
                        if (ctx->current == 0)
                        {
                            unexpected_end_of_file(ctx);
                            expression_delete(p_expression_node_new);
                            p_expression_node_new = 0;
                            goto __L0; /* throw */
                        }
                        if (p_expression_node_new->left->type.type_specifier_flags & 32768)
                        {
                            struct struct_or_union_specifier * p_complete;

                            ;
                            p_complete = find_struct_or_union_specifier(ctx, p_expression_node_new->left->type.struct_or_union_specifier->tag_name);
                            if (p_complete)
                            {
                                p_complete = get_complete_struct_or_union_specifier(p_complete);
                            }
                            if (p_complete)
                            {
                                int member_index;
                                struct member_declarator * p_member_declarator;

                                ;
                                member_index = 0;
                                p_member_declarator = find_member_declarator(&p_complete->member_declaration_list, ctx->current->lexeme, &member_index);
                                if (p_member_declarator)
                                {
                                    struct object * object;

                                    p_expression_node_new->member_index = member_index;
                                    if (p_member_declarator->declarator)
                                    {
                                        p_expression_node_new->type = make_type_using_declarator(ctx, p_member_declarator->declarator);
                                    }
                                    else
                                    {
                                    }
                                    if (p_member_declarator->declarator != 0)
                                    {
                                        fix_member_type(&p_expression_node_new->type, &p_expression_node_new->left->type, &p_member_declarator->declarator->type);
                                    }
                                    object = find_object_declarator_by_index(&p_expression_node_new->left->object, &p_complete->member_declaration_list, member_index);
                                    if (object)
                                    {
                                        p_expression_node_new->object = object_make_reference(object);
                                    }
                                    else
                                    {
                                    }
                                }
                                else
                                {
                                    compiler_diagnostic(720, ctx, ctx->current, 0, "member '%s' not found in 'struct %s'", ctx->current->lexeme, p_complete->tag_name);
                                }
                            }
                            else
                            {
                                compiler_diagnostic(720, ctx, ctx->current, 0, "incomplete struct type '%s'", p_expression_node_new->left->type.struct_or_union_specifier->tag_name);
                            }
                            if (parser_match_tk(ctx, 8996) != 0)
                            {
                                expression_delete(p_expression_node_new);
                                p_expression_node_new = 0;
                                goto __L0; /* throw */
                            }
                        }
                        else
                        {
                            compiler_diagnostic(730, ctx, ctx->current, 0, "structure or union required");
                        }
                        p_expression_node = p_expression_node_new;
                    }
                    else
                    {
                        if (ctx->current->type == 11582)
                        {
                            struct expression * p_expression_node_new;

                            p_expression_node_new = calloc(1, 256);
                            if (p_expression_node_new == 0)
                            {
                                goto __L0; /* throw */
                            }
                            p_expression_node->last_token = ctx->current;
                            p_expression_node_new->first_token = p_expression_node->first_token;
                            p_expression_node_new->last_token = ctx->current;
                            p_expression_node_new->expression_type = 15;
                            parser_match(ctx);
                            if (ctx->current == 0)
                            {
                                expression_delete(p_expression_node_new);
                                p_expression_node_new = 0;
                                goto __L0; /* throw */
                            }
                            if (type_is_pointer_or_array(&p_expression_node->type))
                            {
                                struct type  item_type;

                                _cake_zmem(&item_type, 68);
                                if (type_is_array(&p_expression_node->type))
                                {
                                    compiler_diagnostic(20, ctx, ctx->current, 0, "using indirection '->' in array");
                                    item_type = get_array_item_type(&p_expression_node->type);
                                }
                                else
                                {
                                    item_type = type_remove_pointer(&p_expression_node->type);
                                }
                                if (type_is_struct_or_union(&item_type))
                                {
                                    struct struct_or_union_specifier * p_complete;

                                    ;
                                    ;
                                    p_complete = get_complete_struct_or_union_specifier(p_expression_node->type.next->struct_or_union_specifier);
                                    if (p_complete)
                                    {
                                        int member_index;
                                        struct member_declarator * p_member_declarator;

                                        member_index = 0;
                                        p_member_declarator = find_member_declarator(&p_complete->member_declaration_list, ctx->current->lexeme, &member_index);
                                        if (p_member_declarator)
                                        {
                                            if (p_member_declarator->declarator)
                                            {
                                                p_expression_node_new->member_index = member_index;
                                                p_expression_node_new->type = make_type_using_declarator(ctx, p_member_declarator->declarator);
                                                fix_arrow_member_type(&p_expression_node_new->type, &p_expression_node->type, &p_expression_node_new->type);
                                            }
                                            else
                                            {
                                                ;
                                            }
                                        }
                                        else
                                        {
                                            compiler_diagnostic(720, ctx, ctx->current, 0, "member '%s' not found in struct '%s'", ctx->current->lexeme, p_expression_node->type.next->struct_or_union_specifier->tag_name);
                                        }
                                    }
                                    else
                                    {
                                        compiler_diagnostic(740, ctx, ctx->current, 0, "struct '%s' is incomplete.", ctx->current->lexeme);
                                    }
                                    if (parser_match_tk(ctx, 8996) != 0)
                                    {
                                        type_destroy(&item_type);
                                        expression_delete(p_expression_node_new);
                                        p_expression_node_new = 0;
                                        goto __L0; /* throw */
                                    }
                                }
                                else
                                {
                                    compiler_diagnostic(730, ctx, ctx->current, 0, "structure or union required");
                                }
                                type_destroy(&item_type);
                            }
                            else
                            {
                                compiler_diagnostic(730, ctx, ctx->current, 0, "structure or union required");
                            }
                            p_expression_node_new->left = p_expression_node;
                            p_expression_node = p_expression_node_new;
                        }
                        else
                        {
                            if (ctx->current->type == 11051)
                            {
                                struct expression * p_expression_node_new;

                                p_expression_node->last_token = ctx->current;
                                if (type_is_owner(&p_expression_node->type))
                                {
                                    compiler_diagnostic(1310, ctx, p_expression_node->first_token, 0, "operator ++ cannot be used in _Owner pointers");
                                }
                                if (!expression_is_lvalue(p_expression_node))
                                {
                                    compiler_diagnostic(1230, ctx, p_expression_node->first_token, 0, "lvalue required as increment operand");
                                }
                                p_expression_node_new = calloc(1, 256);
                                if (p_expression_node_new == 0)
                                {
                                    goto __L0; /* throw */
                                }
                                p_expression_node->last_token = ctx->current;
                                p_expression_node_new->first_token = ctx->current;
                                p_expression_node_new->expression_type = 16;
                                p_expression_node_new->type = type_dup(&p_expression_node->type);
                                parser_match(ctx);
                                if (ctx->current == 0)
                                {
                                    unexpected_end_of_file(ctx);
                                    expression_delete(p_expression_node_new);
                                    p_expression_node_new = 0;
                                    goto __L0; /* throw */
                                }
                                p_expression_node_new->left = p_expression_node;
                                p_expression_node = p_expression_node_new;
                            }
                            else
                            {
                                if (ctx->current->type == 11565)
                                {
                                    struct expression * p_expression_node_new;

                                    p_expression_node->last_token = ctx->current;
                                    if (type_is_owner(&p_expression_node->type))
                                    {
                                        compiler_diagnostic(1320, ctx, p_expression_node->first_token, 0, "operator -- cannot be used in owner pointers");
                                    }
                                    if (!expression_is_lvalue(p_expression_node))
                                    {
                                        compiler_diagnostic(1230, ctx, p_expression_node->first_token, 0, "lvalue required as decrement operand");
                                    }
                                    p_expression_node_new = calloc(1, 256);
                                    if (p_expression_node_new == 0)
                                    {
                                        goto __L0; /* throw */
                                    }
                                    p_expression_node_new->first_token = ctx->current;
                                    p_expression_node_new->expression_type = 17;
                                    p_expression_node_new->type = type_dup(&p_expression_node->type);
                                    parser_match(ctx);
                                    if (ctx->current == 0)
                                    {
                                        unexpected_end_of_file(ctx);
                                        expression_delete(p_expression_node_new);
                                        p_expression_node_new = 0;
                                        goto __L0; /* throw */
                                    }
                                    p_expression_node_new->left = p_expression_node;
                                    p_expression_node = p_expression_node_new;
                                }
                                else
                                {
                                    struct token * p_last;

                                    p_last = previous_parser_token(ctx->current);
                                    if (p_last == 0)
                                    {
                                        goto __L0; /* throw */
                                    }
                                    p_expression_node->last_token = p_last;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return p_expression_node;
}



static int compare_function_arguments(struct parser_ctx * ctx, struct type * p_type, struct argument_expression_list * p_argument_expression_list)
{
    if (1) /*try*/
    {
        struct param * p_current_parameter_type;
        struct param_list * p_param_list;
        struct argument_expression * p_current_argument;

        p_current_parameter_type = 0;
        p_param_list = type_get_func_or_func_ptr_params(p_type);
        if (p_param_list == 0)
        {
            goto __L0; /* throw */
        }
        p_current_parameter_type = p_param_list->head;
        p_current_argument = p_argument_expression_list->head;
        if (p_current_parameter_type && type_is_void(&p_current_parameter_type->type))
        {
            p_current_parameter_type = 0;
        }
        while (p_current_argument && p_current_parameter_type)
        {
            check_assigment(ctx, &p_current_parameter_type->type, p_current_argument->expression, 1);
            p_current_argument = p_current_argument->next;
            p_current_parameter_type = p_current_parameter_type->next;
        }
        if (p_current_parameter_type == 0 && p_type->name_opt && strncmp(p_type->name_opt, "__builtin", 9) == 0)
        {
            return 0;
        }
        if (p_current_argument != 0 && !p_param_list->is_var_args)
        {
            compiler_diagnostic(660, ctx, p_current_argument->expression->first_token, 0, "too many arguments");
            goto __L0; /* throw */
        }
        if (p_current_parameter_type != 0 && !p_param_list->is_void)
        {
            if (p_argument_expression_list->tail)
            {
                compiler_diagnostic(670, ctx, p_argument_expression_list->tail->expression->first_token, 0, "too few arguments");
            }
            else
            {
                compiler_diagnostic(670, ctx, ctx->current, 0, "too few arguments");
            }
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        return 1;
    }
    return 0;
}

static void fix_member_type(struct type * p_type, struct type * struct_type, struct type * member_type)
{
    if (struct_type->type_qualifier_flags & 1)
    {
        p_type->type_qualifier_flags |= 1;
    }
    p_type->storage_class_specifier_flags = struct_type->storage_class_specifier_flags;
    if (struct_type->type_qualifier_flags & 32)
    {
        p_type->type_qualifier_flags &= -17;
    }
    if (struct_type->type_qualifier_flags & 64)
    {
        p_type->type_qualifier_flags |= 64;
    }
}

static void fix_arrow_member_type(struct type * p_type, struct type * left, struct type * member_type)
{
    struct type  t;

    t = type_remove_pointer(left);
    if (t.type_qualifier_flags & 1)
    {
        p_type->type_qualifier_flags |= 1;
    }
    if (t.type_qualifier_flags & 64)
    {
        p_type->type_qualifier_flags |= 64;
    }
    if (t.type_qualifier_flags & 32)
    {
        p_type->type_qualifier_flags &= -17;
    }
    type_destroy(&t);
}
struct declarator *declarator_get_innert_function_declarator(struct declarator * p);
void scope_list_push(struct scope_list * list, struct scope * s);
struct compound_statement *function_body(struct parser_ctx * ctx);
void scope_list_pop(struct scope_list * list);
struct braced_initializer *braced_initializer(struct parser_ctx * ctx);
unsigned char type_is_const_or_constexpr(struct type * p_type);
int initializer_init_new(struct parser_ctx * ctx, struct type * p_current_object_type, struct object * p_current_object, struct initializer * braced_initializer, unsigned char  is_constant, unsigned char  requires_constant_initialization);

struct expression *postfix_expression_type_name(struct parser_ctx * ctx, struct type_name * p_type_name_par, int eval_mode)
{
    struct type_name * p_type_name;
    struct expression * p_expression_node;

    p_type_name = p_type_name_par;
    p_expression_node = 0;
    if (1) /*try*/
    {
        struct token * p_previous;

        p_expression_node = calloc(1, 256);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        ;
        p_previous = previous_parser_token(p_type_name->first_token);
        if (p_previous == 0)
        {
            goto __L0; /* throw */
        }
        p_expression_node->first_token = p_previous;
        ;
        p_expression_node->type_name = p_type_name;
        p_type_name = 0;
        p_expression_node->type = make_type_using_declarator(ctx, p_expression_node->type_name->abstract_declarator);
        if (type_is_function(&p_expression_node->type_name->abstract_declarator->type))
        {
            struct declarator * inner;
            struct scope * parameters_scope;
            struct declarator * p_current_function_opt;
            struct scope * p_current_function_scope_opt;

            inner = declarator_get_innert_function_declarator(p_expression_node->type_name->abstract_declarator);
            if (inner->direct_declarator->function_declarator == 0)
            {
                compiler_diagnostic(650, ctx, p_expression_node->type_name->first_token, 0, "missing function declarator");
                goto __L0; /* throw */
            }
            p_expression_node->expression_type = 10;
            parameters_scope = &p_expression_node->type_name->abstract_declarator->direct_declarator->function_declarator->parameters_scope;
            scope_list_push(&ctx->scopes, parameters_scope);
            p_current_function_opt = ctx->p_current_function_opt;
            ctx->p_current_function_opt = p_expression_node->type_name->abstract_declarator;
            p_current_function_scope_opt = ctx->p_current_function_scope_opt;
            ctx->p_current_function_scope_opt = ctx->scopes.tail;
            p_expression_node->compound_statement = function_body(ctx);
            scope_list_pop(&ctx->scopes);
            ctx->p_current_function_opt = p_current_function_opt;
            ctx->p_current_function_scope_opt = p_current_function_scope_opt;
        }
        else
        {
            unsigned char  is_constant;
            struct initializer  initializer;
            unsigned char  requires_constant_initialization;

            p_expression_node->expression_type = 11;
            p_expression_node->braced_initializer = braced_initializer(ctx);
            p_expression_node->type = type_dup(&p_expression_node->type_name->type);
            if (p_expression_node->type.storage_class_specifier_flags & 1)
            {
            }
            else
            {
                int er;

                er = make_object(&p_expression_node->type, &p_expression_node->object, ctx->options.target);
                if (er != 0)
                {
                    compiler_diagnostic(740, ctx, p_expression_node->first_token, 0, "incomplete struct/union type");
                    goto __L0; /* throw */
                }
            }
            is_constant = type_is_const_or_constexpr(&p_expression_node->type);
            object_default_initialization(&p_expression_node->object, is_constant);
            _cake_zmem(&initializer, 12);
            initializer.braced_initializer = p_expression_node->braced_initializer;
            initializer.first_token = p_expression_node->first_token;
            requires_constant_initialization = 0;
            initializer_init_new(ctx, &p_expression_node->type, &p_expression_node->object, &initializer, is_constant, 0);
        }
        if (ctx->previous == 0)
        {
            goto __L0; /* throw */
        }
        p_expression_node->last_token = ctx->previous;
        p_expression_node = postfix_expression_tail(ctx, p_expression_node, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    type_name_delete(p_type_name);
    return p_expression_node;
}


struct compound_statement *compound_statement(struct parser_ctx * ctx);

struct expression *postfix_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;

    p_expression_node = 0;
    if (1) /*try*/
    {
        if (first_of_type_name_ahead(ctx))
        {
            ;
            p_expression_node = calloc(1, 256);
            if (p_expression_node == 0)
            {
                goto __L0; /* throw */
            }
            ;
            p_expression_node->first_token = ctx->current;
            if (parser_match_tk(ctx, 40) != 0)
            {
                goto __L0; /* throw */
            }
            p_expression_node->type_name = type_name(ctx);
            if (p_expression_node->type_name == 0)
            {
                goto __L0; /* throw */
            }
            p_expression_node->type = make_type_using_declarator(ctx, p_expression_node->type_name->abstract_declarator);
            if (parser_match_tk(ctx, 41) != 0)
            {
                goto __L0; /* throw */
            }
            if (type_is_function(&p_expression_node->type))
            {
                p_expression_node->expression_type = 10;
                p_expression_node->compound_statement = compound_statement(ctx);
                if (p_expression_node->compound_statement == 0)
                {
                    goto __L0; /* throw */
                }
                p_expression_node->last_token = p_expression_node->compound_statement->last_token;
            }
            else
            {
                p_expression_node->expression_type = 11;
                p_expression_node->braced_initializer = braced_initializer(ctx);
                if (p_expression_node->braced_initializer == 0)
                {
                    goto __L0; /* throw */
                }
                if (ctx->current == 0)
                {
                    unexpected_end_of_file(ctx);
                    goto __L0; /* throw */
                }
                p_expression_node->last_token = ctx->current;
            }
        }
        else
        {
            p_expression_node = primary_expression(ctx, eval_mode);
            if (p_expression_node == 0)
            {
                goto __L0; /* throw */
            }
        }
        p_expression_node = postfix_expression_tail(ctx, p_expression_node, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}


unsigned char is_first_of_compiler_function(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 9092 || ctx->current->type == 9094 || ctx->current->type == 9093 || ctx->current->type == 9091 || ctx->current->type == 9095 || ctx->current->type == 9096 || ctx->current->type == 9074 || ctx->current->type == 9097 || ctx->current->type == 9098 || ctx->current->type == 9099 || ctx->current->type == 9100;
}


struct token *parser_look_ahead(struct parser_ctx * ctx);

unsigned char is_first_of_unary_expression(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    if (ctx->current->type == 9004)
    {
        struct token * ahead;

        ahead = parser_look_ahead(ctx);
        if (ahead && ahead->type == 40)
        {
            return 1;
        }
    }
    return first_of_postfix_expression(ctx) || ctx->current->type == 11051 || ctx->current->type == 11565 || ctx->current->type == 38 || ctx->current->type == 42 || ctx->current->type == 43 || ctx->current->type == 45 || ctx->current->type == 126 || ctx->current->type == 33 || ctx->current->type == 9030 || ctx->current->type == 9031 || ctx->current->type == 9044 || ctx->current->type == 9048 || ctx->current->type == 9049 || ctx->current->type == 9050 || ctx->current->type == 9051 || ctx->current->type == 9052 || is_first_of_compiler_function(ctx);
}


struct expression *cast_expression(struct parser_ctx * ctx, int eval_mode);
static char warning_message[200] = {0};

struct type type_make_int_bool_like();
void type_integer_promotion(struct type * a);
struct type type_common(struct type * p_type1, struct type * p_type2, int target);
struct type type_add_pointer(struct type * p_type, unsigned char  null_checks_enabled);
struct type make_void_type();
struct type make_size_t_type(int target);
int type_get_offsetof(struct type * p_type, char * member, unsigned int * size, int target);
static int check_sizeof_argument(struct parser_ctx * ctx, struct expression * p_expression, struct type * p_type);
int type_get_category(struct type * p_type);
unsigned char type_is_vla(struct type * p_type);
int type_get_sizeof(struct type * p_type, unsigned int * size, int target);
struct type type_make_size_t(int target);
unsigned char type_is_enum(struct type * p_type);
struct enum_specifier *get_complete_enum_specifier(struct enum_specifier * p_enum_specifier);
struct expression *constant_expression(struct parser_ctx * ctx, unsigned char  show_error_if_not_constant, int eval_mode);
unsigned int type_get_alignof(struct type * p_type, int target);
unsigned char type_is_const(struct type * p_type);
unsigned char type_is_arithmetic(struct type * p_type);
unsigned char type_is_scalar(struct type * p_type);
unsigned char type_is_floating_point(struct type * p_type);

struct expression *unary_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;

    p_expression_node = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 11051 || ctx->current->type == 11565)
        {
            struct expression * new_expression;

            new_expression = calloc(1, 256);
            if (new_expression == 0)
            {
                goto __L0; /* throw */
            }
            new_expression->first_token = ctx->current;
            if (ctx->current->type == 11051)
            {
                new_expression->expression_type = 34;
            }
            else
            {
                new_expression->expression_type = 35;
            }
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                goto __L0; /* throw */
            }
            new_expression->right = unary_expression(ctx, eval_mode);
            if (new_expression->right == 0)
            {
                expression_delete(new_expression);
                goto __L0; /* throw */
            }
            new_expression->type = type_dup(&new_expression->right->type);
            p_expression_node = new_expression;
        }
        else
        {
            if (ctx->current->type == 38 || ctx->current->type == 42 || ctx->current->type == 43 || ctx->current->type == 45 || ctx->current->type == 126 || ctx->current->type == 33)
            {
                struct expression * new_expression;
                struct token * op_position;
                int op;

                new_expression = calloc(1, 256);
                if (new_expression == 0)
                {
                    goto __L0; /* throw */
                }
                new_expression->first_token = ctx->current;
                op_position = ctx->current;
                op = ctx->current->type;
                parser_match(ctx);
                if (ctx->current == 0)
                {
                    unexpected_end_of_file(ctx);
                    expression_delete(new_expression);
                    goto __L0; /* throw */
                }
                new_expression->right = cast_expression(ctx, eval_mode);
                if (new_expression->right == 0)
                {
                    expression_delete(new_expression);
                    goto __L0; /* throw */
                }
                new_expression->last_token = new_expression->right->last_token;
                if (op == 33)
                {
                    new_expression->expression_type = 36;
                    if (eval_mode == 2 && object_has_constant_value(&new_expression->right->object))
                    {
                        new_expression->object = object_logical_not(ctx->options.target, &new_expression->right->object, warning_message);
                    }
                    new_expression->type = type_make_int_bool_like();
                }
                else
                {
                    if (op == 126)
                    {
                        struct type  promoted;

                        if (!type_is_integer(&new_expression->right->type))
                        {
                            compiler_diagnostic(850, ctx, op_position, 0, "requires integer type");
                            expression_delete(new_expression);
                            goto __L0; /* throw */
                        }
                        new_expression->expression_type = 37;
                        promoted = type_dup(&new_expression->right->type);
                        type_integer_promotion(&promoted);
                        new_expression->type = promoted;
                        if (eval_mode == 2 && object_has_constant_value(&new_expression->right->object))
                        {
                            new_expression->object = object_bitwise_not(ctx->options.target, &new_expression->right->object, warning_message);
                        }
                    }
                    else
                    {
                        if (op == 45 || op == 43)
                        {
                            if (op == 45)
                            {
                                new_expression->expression_type = 38;
                            }
                            else
                            {
                                new_expression->expression_type = 39;
                            }
                            new_expression->type = type_common(&new_expression->right->type, &new_expression->right->type, ctx->options.target);
                            if (eval_mode == 2 && object_has_constant_value(&new_expression->right->object))
                            {
                                if (op == 45)
                                {
                                    new_expression->object = object_unary_minus(ctx->options.target, &new_expression->right->object, warning_message);
                                }
                                else
                                {
                                    if (op == 43)
                                    {
                                        new_expression->object = object_unary_plus(ctx->options.target, &new_expression->right->object, warning_message);
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (op == 42)
                            {
                                new_expression->expression_type = 40;
                                if (!type_is_pointer_or_array(&new_expression->right->type))
                                {
                                    compiler_diagnostic(780, ctx, op_position, 0, "indirection requires pointer operand");
                                }
                                if (type_is_pointer(&new_expression->right->type))
                                {
                                    new_expression->type = type_remove_pointer(&new_expression->right->type);
                                }
                                else
                                {
                                    compiler_diagnostic(20, ctx, op_position, 0, "array indirection");
                                    new_expression->type = get_array_item_type(&new_expression->right->type);
                                }
                            }
                            else
                            {
                                if (op == 38)
                                {
                                    new_expression->expression_type = 41;
                                    if (!expression_is_lvalue(new_expression->right))
                                    {
                                        compiler_diagnostic(1220, ctx, new_expression->right->first_token, 0, "lvalue required as unary '&' operand");
                                    }
                                    if (new_expression->right->type.storage_class_specifier_flags & 32)
                                    {
                                        char * variable_name;

                                        variable_name = "?";
                                        if (new_expression->right->declarator && new_expression->right->declarator->name_opt)
                                        {
                                            variable_name = new_expression->right->declarator->name_opt->lexeme;
                                        }
                                        compiler_diagnostic(1220, ctx, new_expression->right->first_token, 0, "address of register variable 'x' requested", variable_name);
                                    }
                                    new_expression->type = type_add_pointer(&new_expression->right->type, ctx->options.null_checks_enabled);
                                    new_expression->type.address_of = 1;
                                }
                                else
                                {
                                    expression_delete(new_expression);
                                    compiler_diagnostic(790, ctx, ctx->current, 0, "invalid token");
                                    goto __L0; /* throw */
                                }
                            }
                        }
                    }
                }
                p_expression_node = new_expression;
            }
            else
            {
                if (ctx->current->type == 9050)
                {
                    struct expression * new_expression;

                    new_expression = calloc(1, 256);
                    if (new_expression == 0)
                    {
                        goto __L0; /* throw */
                    }
                    new_expression->first_token = ctx->current;
                    new_expression->expression_type = 21;
                    parser_match(ctx);
                    if (ctx->current == 0)
                    {
                        unexpected_end_of_file(ctx);
                        expression_delete(new_expression);
                        goto __L0; /* throw */
                    }
                    if (parser_match_tk(ctx, 40) != 0)
                    {
                        expression_delete(new_expression);
                        goto __L0; /* throw */
                    }
                    new_expression->left = unary_expression(ctx, eval_mode);
                    if (new_expression->left == 0)
                    {
                        expression_delete(new_expression);
                        goto __L0; /* throw */
                    }
                    if (ctx->current->type == 44)
                    {
                        parser_match(ctx);
                        new_expression->right = unary_expression(ctx, eval_mode);
                        if (new_expression->right == 0)
                        {
                            expression_delete(new_expression);
                            goto __L0; /* throw */
                        }
                    }
                    if (parser_match_tk(ctx, 41) != 0)
                    {
                        expression_delete(new_expression);
                        goto __L0; /* throw */
                    }
                    new_expression->type = make_void_type();
                    return new_expression;
                }
                else
                {
                    if (ctx->current->type == 9048)
                    {
                        struct expression * new_expression;

                        new_expression = calloc(1, 256);
                        if (new_expression == 0)
                        {
                            goto __L0; /* throw */
                        }
                        new_expression->first_token = ctx->current;
                        new_expression->expression_type = 22;
                        parser_match(ctx);
                        if (ctx->current == 0)
                        {
                            unexpected_end_of_file(ctx);
                            expression_delete(new_expression);
                            goto __L0; /* throw */
                        }
                        if (parser_match_tk(ctx, 40) != 0)
                        {
                            expression_delete(new_expression);
                            goto __L0; /* throw */
                        }
                        new_expression->left = unary_expression(ctx, eval_mode);
                        if (new_expression->left == 0)
                        {
                            expression_delete(new_expression);
                            goto __L0; /* throw */
                        }
                        if (parser_match_tk(ctx, 41) != 0)
                        {
                            expression_delete(new_expression);
                            goto __L0; /* throw */
                        }
                        new_expression->type = make_void_type();
                        return new_expression;
                    }
                    else
                    {
                        if (ctx->current->type == 9049)
                        {
                            struct expression * new_expression;

                            new_expression = calloc(1, 256);
                            if (new_expression == 0)
                            {
                                goto __L0; /* throw */
                            }
                            new_expression->first_token = ctx->current;
                            new_expression->expression_type = 24;
                            parser_match(ctx);
                            if (ctx->current == 0)
                            {
                                unexpected_end_of_file(ctx);
                                expression_delete(new_expression);
                                goto __L0; /* throw */
                            }
                            if (parser_match_tk(ctx, 40) != 0)
                            {
                                expression_delete(new_expression);
                                goto __L0; /* throw */
                            }
                            new_expression->left = unary_expression(ctx, eval_mode);
                            if (new_expression->left == 0)
                            {
                                expression_delete(new_expression);
                                goto __L0; /* throw */
                            }
                            if (parser_match_tk(ctx, 44) != 0)
                            {
                                expression_delete(new_expression);
                                goto __L0; /* throw */
                            }
                            new_expression->type_name = type_name(ctx);
                            if (new_expression->type_name == 0)
                            {
                                expression_delete(new_expression);
                                goto __L0; /* throw */
                            }
                            if (parser_match_tk(ctx, 41) != 0)
                            {
                                expression_delete(new_expression);
                                goto __L0; /* throw */
                            }
                            new_expression->type = type_dup(&new_expression->type_name->type);
                            return new_expression;
                        }
                        else
                        {
                            if (ctx->current->type == 9051)
                            {
                                struct expression * new_expression;

                                new_expression = calloc(1, 256);
                                if (new_expression == 0)
                                {
                                    goto __L0; /* throw */
                                }
                                new_expression->first_token = ctx->current;
                                new_expression->expression_type = 23;
                                parser_match(ctx);
                                if (ctx->current == 0)
                                {
                                    unexpected_end_of_file(ctx);
                                    expression_delete(new_expression);
                                    goto __L0; /* throw */
                                }
                                if (parser_match_tk(ctx, 40) != 0)
                                {
                                    expression_delete(new_expression);
                                    goto __L0; /* throw */
                                }
                                new_expression->left = unary_expression(ctx, eval_mode);
                                if (new_expression->left == 0)
                                {
                                    expression_delete(new_expression);
                                    goto __L0; /* throw */
                                }
                                if (parser_match_tk(ctx, 44) != 0)
                                {
                                    expression_delete(new_expression);
                                    goto __L0; /* throw */
                                }
                                new_expression->right = unary_expression(ctx, eval_mode);
                                if (new_expression->right == 0)
                                {
                                    expression_delete(new_expression);
                                    goto __L0; /* throw */
                                }
                                if (parser_match_tk(ctx, 41) != 0)
                                {
                                    expression_delete(new_expression);
                                    goto __L0; /* throw */
                                }
                                new_expression->type = make_void_type();
                                return new_expression;
                            }
                            else
                            {
                                if (ctx->current->type == 9052)
                                {
                                    struct expression * new_expression;
                                    unsigned int offset_of;
                                    int e;

                                    new_expression = calloc(1, 256);
                                    if (new_expression == 0)
                                    {
                                        goto __L0; /* throw */
                                    }
                                    new_expression->first_token = ctx->current;
                                    new_expression->expression_type = 25;
                                    parser_match(ctx);
                                    if (ctx->current == 0)
                                    {
                                        unexpected_end_of_file(ctx);
                                        expression_delete(new_expression);
                                        goto __L0; /* throw */
                                    }
                                    if (parser_match_tk(ctx, 40) != 0)
                                    {
                                        expression_delete(new_expression);
                                        goto __L0; /* throw */
                                    }
                                    new_expression->type_name = type_name(ctx);
                                    if (new_expression->type_name == 0)
                                    {
                                        expression_delete(new_expression);
                                        goto __L0; /* throw */
                                    }
                                    if (parser_match_tk(ctx, 44) != 0)
                                    {
                                        expression_delete(new_expression);
                                        goto __L0; /* throw */
                                    }
                                    if (ctx->current == 0)
                                    {
                                        unexpected_end_of_file(ctx);
                                        expression_delete(new_expression);
                                        goto __L0; /* throw */
                                    }
                                    if (ctx->current->type != 8996)
                                    {
                                        expression_delete(new_expression);
                                        goto __L0; /* throw */
                                    }
                                    new_expression->offsetof_member_designator = ctx->current;
                                    parser_match(ctx);
                                    if (parser_match_tk(ctx, 41) != 0)
                                    {
                                        expression_delete(new_expression);
                                        goto __L0; /* throw */
                                    }
                                    new_expression->type = make_size_t_type(ctx->options.target);
                                    offset_of = 0;
                                    e = type_get_offsetof(&new_expression->type_name->type, new_expression->offsetof_member_designator->lexeme, &offset_of, ctx->options.target);
                                    if (e != 0)
                                    {
                                        expression_delete(new_expression);
                                        goto __L0; /* throw */
                                    }
                                    new_expression->object = object_make_size_t(ctx->options.target, offset_of);
                                    return new_expression;
                                }
                                else
                                {
                                    if (ctx->current->type == 9030)
                                    {
                                        struct expression * new_expression;

                                        parser_match(ctx);
                                        if (ctx->current == 0)
                                        {
                                            unexpected_end_of_file(ctx);
                                            goto __L0; /* throw */
                                        }
                                        new_expression = calloc(1, 256);
                                        if (new_expression == 0)
                                        {
                                            goto __L0; /* throw */
                                        }
                                        new_expression->first_token = ctx->current;
                                        if (first_of_type_name_ahead(ctx))
                                        {
                                            new_expression->expression_type = 19;
                                            if (parser_match_tk(ctx, 40) != 0)
                                            {
                                                expression_delete(new_expression);
                                                goto __L0; /* throw */
                                            }
                                            new_expression->type_name = type_name(ctx);
                                            if (new_expression->type_name == 0)
                                            {
                                                expression_delete(new_expression);
                                                goto __L0; /* throw */
                                            }
                                            new_expression->type = make_size_t_type(ctx->options.target);
                                            if (ctx->current == 0)
                                            {
                                                unexpected_end_of_file(ctx);
                                                expression_delete(new_expression);
                                                goto __L0; /* throw */
                                            }
                                            new_expression->last_token = ctx->current;
                                            if (parser_match_tk(ctx, 41) != 0)
                                            {
                                                expression_delete(new_expression);
                                                goto __L0; /* throw */
                                            }
                                            if (check_sizeof_argument(ctx, new_expression, &new_expression->type_name->type) != 0)
                                            {
                                            }
                                            else
                                            {
                                                if (type_is_vla(&new_expression->type_name->abstract_declarator->type))
                                                {
                                                }
                                                else
                                                {
                                                    unsigned int type_sizeof;

                                                    type_sizeof = 0;
                                                    if (type_get_sizeof(&new_expression->type_name->abstract_declarator->type, &type_sizeof, ctx->options.target) != 0)
                                                    {
                                                        expression_delete(new_expression);
                                                        goto __L0; /* throw */
                                                    }
                                                    new_expression->object = object_make_size_t(ctx->options.target, type_sizeof);
                                                }
                                            }
                                        }
                                        else
                                        {
                                            new_expression->right = unary_expression(ctx, 1);
                                            if (new_expression->right == 0)
                                            {
                                                expression_delete(new_expression);
                                                goto __L0; /* throw */
                                            }
                                            new_expression->expression_type = 18;
                                            if (check_sizeof_argument(ctx, new_expression->right, &new_expression->right->type) != 0)
                                            {
                                                expression_delete(new_expression);
                                                goto __L0; /* throw */
                                            }
                                            if (type_is_vla(&new_expression->right->type))
                                            {
                                            }
                                            else
                                            {
                                                unsigned int sz;

                                                sz = 0;
                                                if (type_get_sizeof(&new_expression->right->type, &sz, ctx->options.target) != 0)
                                                {
                                                    expression_delete(new_expression);
                                                    goto __L0; /* throw */
                                                }
                                                new_expression->object = object_make_size_t(ctx->options.target, sz);
                                            }
                                        }
                                        type_destroy(&new_expression->type);
                                        new_expression->type = type_make_size_t(ctx->options.target);
                                        p_expression_node = new_expression;
                                    }
                                    else
                                    {
                                        if (ctx->current->type == 9031)
                                        {
                                            struct expression * new_expression;

                                            new_expression = calloc(1, 256);
                                            if (new_expression == 0)
                                            {
                                                goto __L0; /* throw */
                                            }
                                            new_expression->first_token = ctx->current;
                                            parser_match(ctx);
                                            if (ctx->current == 0)
                                            {
                                                unexpected_end_of_file(ctx);
                                                expression_delete(new_expression);
                                                goto __L0; /* throw */
                                            }
                                            new_expression->expression_type = 20;
                                            if (first_of_type_name_ahead(ctx))
                                            {
                                                if (parser_match_tk(ctx, 40) != 0)
                                                {
                                                    expression_delete(new_expression);
                                                    goto __L0; /* throw */
                                                }
                                                new_expression->type_name = type_name(ctx);
                                                if (new_expression->type_name == 0)
                                                {
                                                    expression_delete(new_expression);
                                                    goto __L0; /* throw */
                                                }
                                                new_expression->type = make_size_t_type(ctx->options.target);
                                                if (ctx->current == 0)
                                                {
                                                    unexpected_end_of_file(ctx);
                                                    expression_delete(new_expression);
                                                    goto __L0; /* throw */
                                                }
                                                new_expression->last_token = ctx->current;
                                                if (parser_match_tk(ctx, 41) != 0)
                                                {
                                                    expression_delete(new_expression);
                                                    goto __L0; /* throw */
                                                }
                                                if (type_is_enum(&new_expression->type_name->abstract_declarator->type))
                                                {
                                                    struct enum_specifier * p_enum_specifier;
                                                    unsigned int nelements;

                                                    p_enum_specifier = get_complete_enum_specifier(new_expression->type_name->type.enum_specifier);
                                                    nelements = 0;
                                                    if (p_enum_specifier)
                                                    {
                                                        struct enumerator * p;

                                                        p = p_enum_specifier->enumerator_list.head;
                                                        while (p)
                                                        {
                                                            nelements++;
                                                            p = p->next;
                                                        }
                                                    }
                                                    new_expression->object = object_make_size_t(ctx->options.target, nelements);
                                                }
                                                else
                                                {
                                                    if (type_is_array(&new_expression->type_name->abstract_declarator->type))
                                                    {
                                                        unsigned int nelements;

                                                        nelements = new_expression->type_name->abstract_declarator->type.num_of_elements;
                                                        if (nelements > 0)
                                                        {
                                                            new_expression->object = object_make_size_t(ctx->options.target, nelements);
                                                        }
                                                    }
                                                    else
                                                    {
                                                        compiler_diagnostic(1390, ctx, new_expression->type_name->first_token, 0, "argument of _Countof must be an array");
                                                        expression_delete(new_expression);
                                                        goto __L0; /* throw */
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                if (parser_match_tk(ctx, 40) != 0)
                                                {
                                                    expression_delete(new_expression);
                                                    goto __L0; /* throw */
                                                }
                                                new_expression->right = unary_expression(ctx, 1);
                                                if (new_expression->right == 0)
                                                {
                                                    expression_delete(new_expression);
                                                    goto __L0; /* throw */
                                                }
                                                if (ctx->current == 0)
                                                {
                                                    unexpected_end_of_file(ctx);
                                                    expression_delete(new_expression);
                                                    goto __L0; /* throw */
                                                }
                                                new_expression->last_token = ctx->current;
                                                if (parser_match_tk(ctx, 41) != 0)
                                                {
                                                    expression_delete(new_expression);
                                                    goto __L0; /* throw */
                                                }
                                                if (type_is_enum(&new_expression->right->type))
                                                {
                                                    struct enum_specifier * p_enum_specifier;
                                                    unsigned int nelements;

                                                    p_enum_specifier = get_complete_enum_specifier(new_expression->right->type.enum_specifier);
                                                    nelements = 0;
                                                    if (p_enum_specifier)
                                                    {
                                                        struct enumerator * p;

                                                        p = p_enum_specifier->enumerator_list.head;
                                                        while (p)
                                                        {
                                                            nelements++;
                                                            p = p->next;
                                                        }
                                                    }
                                                    new_expression->object = object_make_size_t(ctx->options.target, nelements);
                                                }
                                                else
                                                {
                                                    if (type_is_array(&new_expression->right->type))
                                                    {
                                                        unsigned int nelements;

                                                        nelements = new_expression->right->type.num_of_elements;
                                                        if (nelements > 0)
                                                        {
                                                            new_expression->object = object_make_size_t(ctx->options.target, nelements);
                                                        }
                                                        else
                                                        {
                                                        }
                                                    }
                                                    else
                                                    {
                                                        compiler_diagnostic(1390, ctx, new_expression->right->first_token, 0, "argument of _Countof must be an array");
                                                        expression_delete(new_expression);
                                                        goto __L0; /* throw */
                                                    }
                                                }
                                            }
                                            type_destroy(&new_expression->type);
                                            new_expression->type = type_make_size_t(ctx->options.target);
                                            p_expression_node = new_expression;
                                        }
                                        else
                                        {
                                            if (ctx->current->type == 9074)
                                            {
                                                struct expression * new_expression;

                                                new_expression = calloc(1, 256);
                                                if (new_expression == 0)
                                                {
                                                    goto __L0; /* throw */
                                                }
                                                new_expression->expression_type = 32;
                                                new_expression->first_token = ctx->current;
                                                parser_match(ctx);
                                                if (ctx->current == 0 || parser_match_tk(ctx, 40) != 0)
                                                {
                                                    expression_delete(new_expression);
                                                    goto __L0; /* throw */
                                                }
                                                new_expression->right = expression(ctx, eval_mode);
                                                if (parser_match_tk(ctx, 41) != 0)
                                                {
                                                    expression_delete(new_expression);
                                                    goto __L0; /* throw */
                                                }
                                                return new_expression;
                                            }
                                            else
                                            {
                                                if (ctx->current->type == 9004)
                                                {
                                                    struct expression * new_expression;

                                                    new_expression = calloc(1, 256);
                                                    if (new_expression == 0)
                                                    {
                                                        goto __L0; /* throw */
                                                    }
                                                    new_expression->expression_type = 33;
                                                    new_expression->first_token = ctx->current;
                                                    parser_match(ctx);
                                                    if (ctx->current == 0 || parser_match_tk(ctx, 40) != 0)
                                                    {
                                                        expression_delete(new_expression);
                                                        goto __L0; /* throw */
                                                    }
                                                    new_expression->right = constant_expression(ctx, 1, eval_mode);
                                                    if (parser_match_tk(ctx, 41) != 0)
                                                    {
                                                        expression_delete(new_expression);
                                                        goto __L0; /* throw */
                                                    }
                                                    return new_expression;
                                                }
                                                else
                                                {
                                                    if (ctx->current->type == 9044)
                                                    {
                                                        struct expression * new_expression;

                                                        parser_match(ctx);
                                                        if (ctx->current == 0)
                                                        {
                                                            unexpected_end_of_file(ctx);
                                                            goto __L0; /* throw */
                                                        }
                                                        new_expression = calloc(1, 256);
                                                        if (new_expression == 0)
                                                        {
                                                            goto __L0; /* throw */
                                                        }
                                                        new_expression->first_token = ctx->current;
                                                        if (first_of_type_name_ahead(ctx))
                                                        {
                                                            new_expression->expression_type = 30;
                                                            if (parser_match_tk(ctx, 40) != 0)
                                                            {
                                                                expression_delete(new_expression);
                                                                goto __L0; /* throw */
                                                            }
                                                            new_expression->type_name = type_name(ctx);
                                                            if (new_expression->type_name == 0)
                                                            {
                                                                expression_delete(new_expression);
                                                                goto __L0; /* throw */
                                                            }
                                                            new_expression->type = make_size_t_type(ctx->options.target);
                                                            if (ctx->current == 0)
                                                            {
                                                                unexpected_end_of_file(ctx);
                                                                expression_delete(new_expression);
                                                                goto __L0; /* throw */
                                                            }
                                                            new_expression->last_token = ctx->current;
                                                            if (parser_match_tk(ctx, 41) != 0)
                                                            {
                                                                expression_delete(new_expression);
                                                                goto __L0; /* throw */
                                                            }
                                                            if (check_sizeof_argument(ctx, new_expression, &new_expression->type_name->type) != 0)
                                                            {
                                                            }
                                                            else
                                                            {
                                                                if (type_is_vla(&new_expression->type_name->abstract_declarator->type))
                                                                {
                                                                }
                                                                else
                                                                {
                                                                    unsigned int type_alignof;

                                                                    type_alignof = 0;
                                                                    type_alignof = type_get_alignof(&new_expression->type_name->abstract_declarator->type, ctx->options.target);
                                                                    new_expression->object = object_make_size_t(ctx->options.target, type_alignof);
                                                                }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            new_expression->right = unary_expression(ctx, 1);
                                                            if (new_expression->right == 0)
                                                            {
                                                                expression_delete(new_expression);
                                                                goto __L0; /* throw */
                                                            }
                                                            new_expression->expression_type = 31;
                                                            if (check_sizeof_argument(ctx, new_expression->right, &new_expression->right->type) != 0)
                                                            {
                                                                expression_delete(new_expression);
                                                                goto __L0; /* throw */
                                                            }
                                                            if (type_is_vla(&new_expression->right->type))
                                                            {
                                                            }
                                                            else
                                                            {
                                                                unsigned int sz;

                                                                sz = 0;
                                                                sz = type_get_alignof(&new_expression->right->type, ctx->options.target);
                                                                new_expression->object = object_make_size_t(ctx->options.target, sz);
                                                            }
                                                        }
                                                        type_destroy(&new_expression->type);
                                                        new_expression->type = type_make_size_t(ctx->options.target);
                                                        p_expression_node = new_expression;
                                                    }
                                                    else
                                                    {
                                                        if (ctx->current->type == 9092 || ctx->current->type == 9094 || ctx->current->type == 9093 || ctx->current->type == 9091 || ctx->current->type == 9095 || ctx->current->type == 9096 || ctx->current->type == 9098 || ctx->current->type == 9097 || ctx->current->type == 9099 || ctx->current->type == 9100)
                                                        {
                                                            struct token * traits_token;
                                                            struct expression * new_expression;
                                                            struct type * p_type;

                                                            traits_token = ctx->current;
                                                            new_expression = calloc(1, 256);
                                                            if (new_expression == 0)
                                                            {
                                                                goto __L0; /* throw */
                                                            }
                                                            new_expression->first_token = ctx->current;
                                                            new_expression->expression_type = 27;
                                                            parser_match(ctx);
                                                            if (ctx->current == 0)
                                                            {
                                                                unexpected_end_of_file(ctx);
                                                                expression_delete(new_expression);
                                                                goto __L0; /* throw */
                                                            }
                                                            p_type = 0;
                                                            if (first_of_type_name_ahead(ctx))
                                                            {
                                                                if (parser_match_tk(ctx, 40) != 0)
                                                                {
                                                                    expression_delete(new_expression);
                                                                    goto __L0; /* throw */
                                                                }
                                                                new_expression->type_name = type_name(ctx);
                                                                if (new_expression->type_name == 0)
                                                                {
                                                                    expression_delete(new_expression);
                                                                    goto __L0; /* throw */
                                                                }
                                                                if (ctx->current == 0)
                                                                {
                                                                    unexpected_end_of_file(ctx);
                                                                    expression_delete(new_expression);
                                                                    goto __L0; /* throw */
                                                                }
                                                                new_expression->last_token = ctx->current;
                                                                if (parser_match_tk(ctx, 41) != 0)
                                                                {
                                                                    expression_delete(new_expression);
                                                                    goto __L0; /* throw */
                                                                }
                                                                p_type = &new_expression->type_name->abstract_declarator->type;
                                                            }
                                                            else
                                                            {
                                                                new_expression->right = unary_expression(ctx, 1);
                                                                if (new_expression->right == 0)
                                                                {
                                                                    expression_delete(new_expression);
                                                                    goto __L0; /* throw */
                                                                }
                                                                p_type = &new_expression->right->type;
                                                                if (ctx->previous == 0)
                                                                {
                                                                    expression_delete(new_expression);
                                                                    goto __L0; /* throw */
                                                                }
                                                                new_expression->last_token = ctx->previous;
                                                            }
                                                            /*switch*/
                                                            {
                                                                int __v0 = traits_token->type;
                                                                if (__v0 == 9092) goto __L135; /*case 9092*/
                                                                if (__v0 == 9093) goto __L136; /*case 9093*/
                                                                if (__v0 == 9094) goto __L137; /*case 9094*/
                                                                if (__v0 == 9091) goto __L138; /*case 9091*/
                                                                if (__v0 == 9096) goto __L139; /*case 9096*/
                                                                if (__v0 == 9095) goto __L140; /*case 9095*/
                                                                if (__v0 == 9098) goto __L141; /*case 9098*/
                                                                if (__v0 == 9097) goto __L142; /*case 9097*/
                                                                if (__v0 == 9099) goto __L143; /*case 9099*/
                                                                if (__v0 == 9100) goto __L144; /*case 9100*/
                                                                goto __L145; /* default */

                                                                {
                                                                    __L135: /*case 9092*/ 
                                                                    ;
                                                                    new_expression->object = object_make_signed_int(ctx->options.target, expression_is_lvalue(new_expression->right));
                                                                    goto __L134; /* break */

                                                                    __L136: /*case 9093*/ 
                                                                    new_expression->object = object_make_signed_int(ctx->options.target, type_is_const(p_type));
                                                                    goto __L134; /* break */

                                                                    __L137: /*case 9094*/ 
                                                                    new_expression->object = object_make_signed_int(ctx->options.target, type_is_owner(p_type));
                                                                    goto __L134; /* break */

                                                                    __L138: /*case 9091*/ 
                                                                    new_expression->object = object_make_signed_int(ctx->options.target, type_is_pointer(p_type));
                                                                    goto __L134; /* break */

                                                                    __L139: /*case 9096*/ 
                                                                    new_expression->object = object_make_signed_int(ctx->options.target, type_is_function(p_type));
                                                                    goto __L134; /* break */

                                                                    __L140: /*case 9095*/ 
                                                                    new_expression->object = object_make_signed_int(ctx->options.target, type_is_array(p_type));
                                                                    goto __L134; /* break */

                                                                    __L141: /*case 9098*/ 
                                                                    new_expression->object = object_make_signed_int(ctx->options.target, type_is_arithmetic(p_type));
                                                                    goto __L134; /* break */

                                                                    __L142: /*case 9097*/ 
                                                                    new_expression->object = object_make_signed_int(ctx->options.target, type_is_scalar(p_type));
                                                                    goto __L134; /* break */

                                                                    __L143: /*case 9099*/ 
                                                                    new_expression->object = object_make_signed_int(ctx->options.target, type_is_floating_point(p_type));
                                                                    goto __L134; /* break */

                                                                    __L144: /*case 9100*/ 
                                                                    new_expression->object = object_make_signed_int(ctx->options.target, type_is_integer(p_type));
                                                                    goto __L134; /* break */

                                                                    __L145: /* default */ 
                                                                    ;
                                                                }
                                                                __L134:;
                                                            }
                                                            new_expression->type = type_make_int_bool_like();
                                                            p_expression_node = new_expression;
                                                        }
                                                        else
                                                        {
                                                            p_expression_node = postfix_expression(ctx, eval_mode);
                                                            if (p_expression_node == 0)
                                                            {
                                                                goto __L0; /* throw */
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}



static int check_sizeof_argument(struct parser_ctx * ctx, struct expression * p_expression, struct type * p_type)
{
    int category;

    category = type_get_category(p_type);
    if (category == 1)
    {
    }
    else
    {
        if (category == 0 && p_type->type_specifier_flags & 32768)
        {
            struct struct_or_union_specifier * p_complete;

            ;
            p_complete = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
            if (p_complete == 0)
            {
                compiler_diagnostic(740, ctx, p_expression->first_token, 0, "struct is incomplete type");
                return -1;
            }
        }
        else
        {
            if (category == 2)
            {
                if (type_is_vla(p_type))
                {
                    return 0;
                }
                if (p_type->storage_class_specifier_flags & 2048)
                {
                    compiler_diagnostic(47, ctx, p_expression->first_token, 0, "sizeof applied to array function parameter");
                }
            }
        }
    }
    return 0;
}
unsigned char type_is_nullptr_t(struct type * p_type);
unsigned char type_is_bool(struct type * p_type);
unsigned char expression_is_null_pointer_constant(struct expression * expression);

struct expression *cast_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;

    p_expression_node = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (first_of_type_name_ahead(ctx))
        {
            p_expression_node = calloc(1, 256);
            if (p_expression_node == 0)
            {
                goto __L0; /* throw */
            }
            p_expression_node->first_token = ctx->current;
            p_expression_node->expression_type = 42;
            if (parser_match_tk(ctx, 40) != 0)
            {
                goto __L0; /* throw */
            }
            p_expression_node->type_name = type_name(ctx);
            if (p_expression_node->type_name == 0)
            {
                expression_delete(p_expression_node);
                p_expression_node = 0;
                goto __L0; /* throw */
            }
            p_expression_node->type = type_dup(&p_expression_node->type_name->type);
            if (parser_match_tk(ctx, 41) != 0)
            {
                goto __L0; /* throw */
            }
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            if (ctx->current->type == 123)
            {
                struct expression * new_expression;

                new_expression = postfix_expression_type_name(ctx, p_expression_node->type_name, eval_mode);
                p_expression_node->type_name = 0;
                if (new_expression == 0)
                {
                    goto __L0; /* throw */
                }
                expression_delete(p_expression_node);
                p_expression_node = new_expression;
            }
            else
            {
                if (is_first_of_unary_expression(ctx))
                {
                    p_expression_node->left = cast_expression(ctx, eval_mode);
                    if (p_expression_node->left == 0)
                    {
                        expression_delete(p_expression_node);
                        p_expression_node = 0;
                        goto __L0; /* throw */
                    }
                    if (type_is_floating_point(&p_expression_node->type) && type_is_pointer(&p_expression_node->left->type))
                    {
                        compiler_diagnostic(1790, ctx, p_expression_node->first_token, 0, "pointer type cannot be converted to any floating type");
                    }
                    else
                    {
                        if (type_is_pointer(&p_expression_node->type) && type_is_floating_point(&p_expression_node->left->type))
                        {
                            compiler_diagnostic(1800, ctx, p_expression_node->first_token, 0, "A floating type cannot be converted to any pointer type");
                        }
                        else
                        {
                            if (type_is_nullptr_t(&p_expression_node->left->type))
                            {
                                if (type_is_void(&p_expression_node->type) || type_is_bool(&p_expression_node->type) || type_is_pointer(&p_expression_node->type))
                                {
                                }
                                else
                                {
                                    compiler_diagnostic(1810, ctx, p_expression_node->first_token, 0, "cannot cast nullptr_t to this type");
                                }
                            }
                            else
                            {
                                if (type_is_nullptr_t(&p_expression_node->type))
                                {
                                    if (expression_is_null_pointer_constant(p_expression_node->left) || type_is_nullptr_t(&p_expression_node->left->type))
                                    {
                                    }
                                    else
                                    {
                                        compiler_diagnostic(1810, ctx, p_expression_node->left->first_token, 0, "cannot cast this expression to nullptr_t");
                                    }
                                }
                            }
                        }
                    }
                    if (p_expression_node->left->type.storage_class_specifier_flags & 8192 && type_is_owner(&p_expression_node->left->type))
                    {
                        if (!type_is_owner(&p_expression_node->type))
                        {
                            if (type_is_pointer(&p_expression_node->left->type))
                            {
                                compiler_diagnostic(26, ctx, p_expression_node->first_token, 0, "discarding _Owner pointer");
                            }
                            else
                            {
                                compiler_diagnostic(26, ctx, p_expression_node->first_token, 0, "discarding _Owner");
                            }
                        }
                    }
                    type_destroy(&p_expression_node->type);
                    p_expression_node->type = make_type_using_declarator(ctx, p_expression_node->type_name->abstract_declarator);
                    if (type_is_same(&p_expression_node->type, &p_expression_node->left->type, 1))
                    {
                        if (p_expression_node->first_token->flags & 2)
                        {
                        }
                        else
                        {
                            if ((p_expression_node->type.storage_class_specifier_flags & 1) || (p_expression_node->left->type.storage_class_specifier_flags & 1))
                            {
                            }
                            else
                            {
                            }
                        }
                    }
                    if (eval_mode == 2 && object_has_constant_value(&p_expression_node->left->object))
                    {
                        int vt;

                        vt = type_to_object_type(&p_expression_node->type, ctx->options.target);
                        p_expression_node->object = object_cast(ctx->options.target, vt, &p_expression_node->left->object);
                    }
                    p_expression_node->type.storage_class_specifier_flags = p_expression_node->left->type.storage_class_specifier_flags;
                }
                else
                {
                    compiler_diagnostic(650, ctx, ctx->current, 0, "expected expression");
                }
            }
        }
        else
        {
            if (is_first_of_unary_expression(ctx))
            {
                p_expression_node = unary_expression(ctx, eval_mode);
                if (p_expression_node == 0)
                {
                    goto __L0; /* throw */
                }
            }
            else
            {
                compiler_diagnostic(650, ctx, ctx->current, 0, "expected expression");
                ;
                goto __L0; /* throw */
            }
        }
        if (ctx->current == 0 || ctx->previous == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_expression_node->last_token = ctx->previous;
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}


struct expression *multiplicative_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;

    p_expression_node = 0;
    if (1) /*try*/
    {
        p_expression_node = cast_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 42 || ctx->current->type == 47 || ctx->current->type == 37))
        {
            struct expression * new_expression;
            int op;

            new_expression = calloc(1, 256);
            if (new_expression == 0)
            {
                expression_delete(p_expression_node);
                p_expression_node = 0;
                goto __L0; /* throw */
            }
            new_expression->first_token = ctx->current;
            op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                goto __L0; /* throw */
            }
            /*switch*/
            {
                int __v0 = op;
                if (__v0 == 42) goto __L5; /*case 42*/
                if (__v0 == 47) goto __L6; /*case 47*/
                if (__v0 == 37) goto __L7; /*case 37*/
                goto __L8; /* default */

                {
                    __L5: /*case 42*/ 
                    new_expression->expression_type = 43;
                    goto __L4; /* break */

                    __L6: /*case 47*/ 
                    new_expression->expression_type = 44;
                    goto __L4; /* break */

                    __L7: /*case 37*/ 
                    new_expression->expression_type = 45;
                    goto __L4; /* break */

                    __L8: /* default */ 
                    ;
                    goto __L4; /* break */

                }
                __L4:;
            }
            new_expression->left = p_expression_node;
            p_expression_node = 0;
            new_expression->right = cast_expression(ctx, eval_mode);
            if (new_expression->right == 0)
            {
                expression_delete(new_expression);
                goto __L0; /* throw */
            }
            new_expression->last_token = new_expression->right->last_token;
            if (op == 37)
            {
                if (!type_is_integer(&new_expression->left->type))
                {
                    compiler_diagnostic(840, ctx, new_expression->left->first_token, 0, "left is not an integer type");
                }
                if (!type_is_integer(&new_expression->right->type))
                {
                    compiler_diagnostic(850, ctx, new_expression->right->first_token, 0, "right is not an integer type");
                }
            }
            else
            {
                if (!type_is_arithmetic(&new_expression->left->type))
                {
                    compiler_diagnostic(820, ctx, new_expression->left->first_token, 0, "left is not an arithmetic type");
                }
                if (!type_is_arithmetic(&new_expression->right->type))
                {
                    compiler_diagnostic(830, ctx, new_expression->right->first_token, 0, "right is not an arithmetic type");
                }
            }
            new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);
            if (eval_mode == 2)
            {
                if (object_has_constant_value(&new_expression->left->object) && object_has_constant_value(&new_expression->right->object))
                {
                    struct marker  m;

                    m.file = 0;
                    m.line = 0;
                    m.start_col = 0;
                    m.end_col = 0;
                    m.p_token_caret = 0;
                    m.p_token_begin = new_expression->left->first_token;
                    m.p_token_end = new_expression->right->last_token;
                    if (op == 42)
                    {
                        new_expression->object = object_mul(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                        if (warning_message[0] != 0)
                        {
                            compiler_diagnostic(51, ctx, 0, &m, "%s", warning_message);
                        }
                    }
                    else
                    {
                        if (op == 47)
                        {
                            new_expression->object = object_div(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                            if (warning_message[0] != 0)
                            {
                                compiler_diagnostic(37, ctx, 0, &m, "%s", warning_message);
                            }
                        }
                        else
                        {
                            if (op == 37)
                            {
                                new_expression->object = object_mod(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                                if (warning_message[0] != 0)
                                {
                                    compiler_diagnostic(37, ctx, 0, &m, "%s", warning_message);
                                }
                            }
                        }
                    }
                }
            }
            p_expression_node = new_expression;
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}


unsigned char type_is_scalar_decay(struct type * p_type);
struct type type_make_ptrdiff_t(int target);

struct expression *additive_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;

    p_expression_node = 0;
    if (1) /*try*/
    {
        p_expression_node = multiplicative_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 43 || ctx->current->type == 45))
        {
            struct token * operator_position;
            struct expression * new_expression;
            int op;
            unsigned char  b_left_is_arithmetic;
            unsigned char  b_right_is_arithmetic;
            int left_category;
            int right_category;

            operator_position = ctx->current;
            new_expression = calloc(1, 256);
            if (new_expression == 0)
            {
                compiler_diagnostic(1260, ctx, ctx->current, 0, "out of mem");
                goto __L0; /* throw */
            }
            new_expression->first_token = ctx->current;
            op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                goto __L0; /* throw */
            }
            new_expression->left = p_expression_node;
            p_expression_node = 0;
            new_expression->right = multiplicative_expression(ctx, eval_mode);
            if (new_expression->right == 0)
            {
                expression_delete(new_expression);
                goto __L0; /* throw */
            }
            new_expression->last_token = new_expression->right->last_token;
            if (!type_is_scalar_decay(&new_expression->left->type))
            {
                compiler_diagnostic(870, ctx, operator_position, 0, "left operator is not scalar");
            }
            if (!type_is_scalar_decay(&new_expression->right->type))
            {
                compiler_diagnostic(880, ctx, operator_position, 0, "right operator is not scalar");
            }
            b_left_is_arithmetic = type_is_arithmetic(&new_expression->left->type);
            b_right_is_arithmetic = type_is_arithmetic(&new_expression->right->type);
            left_category = type_get_category(&new_expression->left->type);
            right_category = type_get_category(&new_expression->right->type);
            if (op == 43)
            {
                new_expression->expression_type = 46;
                if (b_left_is_arithmetic && b_right_is_arithmetic)
                {
                    new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);
                    if (eval_mode == 2)
                    {
                        if (object_has_constant_value(&new_expression->left->object) && object_has_constant_value(&new_expression->right->object))
                        {
                            struct marker  m;

                            m.file = 0;
                            m.line = 0;
                            m.start_col = 0;
                            m.end_col = 0;
                            m.p_token_caret = 0;
                            m.p_token_begin = new_expression->left->first_token;
                            m.p_token_end = new_expression->right->last_token;
                            new_expression->object = object_add(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                            if (warning_message[0] != 0)
                            {
                                compiler_diagnostic(51, ctx, 0, &m, "%s", warning_message);
                            }
                        }
                    }
                }
                else
                {
                    if (left_category == 3 || left_category == 2)
                    {
                        if (type_is_integer(&new_expression->right->type))
                        {
                            if (left_category == 2)
                            {
                                struct type  t;

                                t = get_array_item_type(&new_expression->left->type);
                                new_expression->type = type_add_pointer(&t, ctx->options.null_checks_enabled);
                                type_destroy(&t);
                            }
                            else
                            {
                                new_expression->type = type_dup(&new_expression->left->type);
                            }
                        }
                        else
                        {
                            compiler_diagnostic(850, ctx, ctx->current, 0, "expected integer type on right");
                        }
                    }
                    else
                    {
                        if (right_category == 3 || right_category == 2)
                        {
                            if (type_is_integer(&new_expression->left->type))
                            {
                                if (right_category == 2)
                                {
                                    new_expression->type = get_array_item_type(&new_expression->right->type);
                                }
                                else
                                {
                                    new_expression->type = type_dup(&new_expression->right->type);
                                }
                            }
                            else
                            {
                                compiler_diagnostic(840, ctx, ctx->current, 0, "expected integer type on left");
                            }
                        }
                        else
                        {
                            compiler_diagnostic(860, ctx, ctx->current, 0, "invalid types additive expression");
                        }
                    }
                }
            }
            else
            {
                if (op == 45)
                {
                    new_expression->expression_type = 47;
                    if (b_left_is_arithmetic && b_right_is_arithmetic)
                    {
                        new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);
                        if (eval_mode == 2)
                        {
                            if (object_has_constant_value(&new_expression->left->object) && object_has_constant_value(&new_expression->right->object))
                            {
                                struct marker  m;

                                m.file = 0;
                                m.line = 0;
                                m.start_col = 0;
                                m.end_col = 0;
                                m.p_token_caret = 0;
                                m.p_token_begin = new_expression->left->first_token;
                                m.p_token_end = new_expression->right->last_token;
                                new_expression->object = object_sub(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                                if (warning_message[0] != 0)
                                {
                                    compiler_diagnostic(51, ctx, 0, &m, "%s", warning_message);
                                }
                            }
                        }
                    }
                    else
                    {
                        if (left_category == 3 || left_category == 2)
                        {
                            if (right_category == 3 || right_category == 2)
                            {
                                struct type  t1;
                                struct type  t2;

                                t1 = type_lvalue_conversion(&new_expression->left->type, ctx->options.null_checks_enabled);
                                t2 = type_lvalue_conversion(&new_expression->right->type, ctx->options.null_checks_enabled);
                                if (!type_is_same(&t1, &t2, 0))
                                {
                                    compiler_diagnostic(890, ctx, ctx->current, 0, "incompatible pointer types");
                                }
                                new_expression->type = type_make_ptrdiff_t(ctx->options.target);
                                type_destroy(&t1);
                                type_destroy(&t2);
                            }
                            else
                            {
                                if (type_is_integer(&new_expression->right->type))
                                {
                                    new_expression->type = type_dup(&new_expression->left->type);
                                }
                                else
                                {
                                    compiler_diagnostic(850, ctx, ctx->current, 0, "right must be integer type");
                                }
                            }
                        }
                        else
                        {
                            compiler_diagnostic(860, ctx, ctx->current, 0, "invalid types for operator -");
                        }
                    }
                }
            }
            p_expression_node = new_expression;
            new_expression = 0;
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}


struct expression *shift_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;

    p_expression_node = 0;
    if (1) /*try*/
    {
        p_expression_node = additive_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 15934 || ctx->current->type == 15420))
        {
            struct expression * new_expression;
            int op;

            new_expression = calloc(1, 256);
            if (new_expression == 0)
            {
                goto __L0; /* throw */
            }
            new_expression->first_token = ctx->current;
            op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                new_expression = 0;
                goto __L0; /* throw */
            }
            new_expression->left = p_expression_node;
            p_expression_node = 0;
            new_expression->right = multiplicative_expression(ctx, eval_mode);
            if (new_expression->right == 0)
            {
                expression_delete(new_expression);
                goto __L0; /* throw */
            }
            new_expression->last_token = new_expression->right->last_token;
            if (op == 15934)
            {
                new_expression->expression_type = 48;
            }
            else
            {
                if (op == 15420)
                {
                    new_expression->expression_type = 49;
                }
            }
            new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);
            if (!type_is_integer(&new_expression->left->type))
            {
                compiler_diagnostic(840, ctx, ctx->current, 0, "left type must be an integer type");
                goto __L0; /* throw */
            }
            if (!type_is_integer(&new_expression->right->type))
            {
                compiler_diagnostic(850, ctx, ctx->current, 0, "right type must be an integer type");
                goto __L0; /* throw */
            }
            if (object_has_constant_value(&new_expression->left->object) && object_has_constant_value(&new_expression->right->object))
            {
                if (op == 15420)
                {
                    new_expression->object = object_shift_left(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                }
                else
                {
                    new_expression->object = object_shift_right(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                }
            }
            p_expression_node = new_expression;
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}


static void check_comparison(struct parser_ctx * ctx, struct expression * p_a_expression, struct expression * p_b_expression, struct token * op_token);
unsigned char expression_is_zero(struct expression * expression);
unsigned char type_is_essential_bool(struct type * p_type);
void check_diferent_enuns(struct parser_ctx * ctx, struct token * operator_token, struct expression * left, struct expression * right, char * message);

struct expression *relational_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;
    struct expression * new_expression;

    p_expression_node = 0;
    new_expression = 0;
    if (1) /*try*/
    {
        p_expression_node = shift_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 62 || ctx->current->type == 60 || ctx->current->type == 15933 || ctx->current->type == 15421))
        {
            struct token * optk;
            int op;

            ;
            new_expression = calloc(1, 256);
            if (new_expression == 0)
            {
                goto __L0; /* throw */
            }
            new_expression->first_token = ctx->current;
            optk = ctx->current;
            op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            new_expression->left = p_expression_node;
            p_expression_node = 0;
            new_expression->right = shift_expression(ctx, eval_mode);
            if (new_expression->right == 0)
            {
                expression_delete(new_expression);
                new_expression = 0;
                goto __L0; /* throw */
            }
            new_expression->last_token = new_expression->right->last_token;
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                expression_delete(new_expression);
                new_expression = 0;
                goto __L0; /* throw */
            }
            check_comparison(ctx, new_expression->left, new_expression->right, optk);
            if (op == 62)
            {
                new_expression->expression_type = 50;
            }
            else
            {
                if (op == 60)
                {
                    new_expression->expression_type = 51;
                }
                else
                {
                    if (op == 15933)
                    {
                        new_expression->expression_type = 52;
                    }
                    else
                    {
                        if (op == 15421)
                        {
                            new_expression->expression_type = 53;
                        }
                    }
                }
            }
            if (type_is_arithmetic(&new_expression->left->type) && type_is_arithmetic(&new_expression->right->type))
            {
                new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);
                if (eval_mode == 2)
                {
                    if (object_has_constant_value(&new_expression->left->object) && object_has_constant_value(&new_expression->right->object))
                    {
                        struct marker  m;
                        int warning_id;

                        m.file = 0;
                        m.line = 0;
                        m.start_col = 0;
                        m.end_col = 0;
                        m.p_token_caret = 0;
                        m.p_token_begin = new_expression->left->first_token;
                        m.p_token_end = new_expression->right->last_token;
                        warning_id = 0;
                        if (op == 15933)
                        {
                            new_expression->object = object_greater_than_or_equal(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                            warning_id = 51;
                            if (warning_message[0] != 0)
                            {
                                compiler_diagnostic(warning_id, ctx, 0, &m, "%s", warning_message);
                            }
                        }
                        else
                        {
                            if (op == 15421)
                            {
                                new_expression->object = object_smaller_than_or_equal(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                                warning_id = 51;
                                if (warning_message[0] != 0)
                                {
                                    compiler_diagnostic(warning_id, ctx, 0, &m, "%s", warning_message);
                                }
                            }
                            else
                            {
                                if (op == 62)
                                {
                                    new_expression->object = object_greater_than(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                                    warning_id = 51;
                                    if (warning_message[0] != 0)
                                    {
                                        compiler_diagnostic(warning_id, ctx, 0, &m, "%s", warning_message);
                                    }
                                }
                                else
                                {
                                    if (op == 60)
                                    {
                                        new_expression->object = object_smaller_than(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                                        warning_id = 51;
                                        if (warning_message[0] != 0)
                                        {
                                            compiler_diagnostic(warning_id, ctx, 0, &m, "%s", warning_message);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            type_destroy(&new_expression->type);
            new_expression->type = type_make_int_bool_like();
            p_expression_node = new_expression;
            new_expression = 0;
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(new_expression);
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}



static void check_comparison(struct parser_ctx * ctx, struct expression * p_a_expression, struct expression * p_b_expression, struct token * op_token)
{
    unsigned char  equal_not_equal;
    struct type * p_a_type;
    struct type * p_b_type;

    equal_not_equal = op_token->type == 8509 || op_token->type == 15677;
    p_a_type = &p_a_expression->type;
    p_b_type = &p_b_expression->type;
    if (type_is_pointer(p_a_type) && type_is_integer(p_b_type))
    {
        if (expression_is_zero(p_b_expression))
        {
        }
        else
        {
            compiler_diagnostic(4, ctx, op_token, 0, "comparison between pointer and integer");
        }
    }
    if (type_is_bool(p_a_type) && !(type_is_bool(p_b_type) || type_is_essential_bool(p_b_type)))
    {
        if (equal_not_equal && (object_is_zero(&p_b_expression->object) || object_is_one(&p_b_expression->object)))
        {
        }
        else
        {
            compiler_diagnostic(58, ctx, op_token, 0, "comparison bool with non bool");
        }
    }
    if (type_is_bool(p_b_type) && !(type_is_bool(p_a_type) || type_is_essential_bool(p_a_type)))
    {
        if (equal_not_equal && (object_is_zero(&p_a_expression->object) || object_is_one(&p_a_expression->object)))
        {
        }
        else
        {
            compiler_diagnostic(58, ctx, op_token, 0, "comparison bool with non bool");
        }
    }
    check_diferent_enuns(ctx, op_token, p_a_expression, p_b_expression, "comparing different enums.");
}
void check_diferent_enuns(struct parser_ctx * ctx, struct token * operator_token, struct expression * left, struct expression * right, char * message)
{
    if (left->type.type_specifier_flags & 65536 && right->type.type_specifier_flags & 65536)
    {
        ;
        ;
        if (get_complete_enum_specifier(left->type.enum_specifier) != get_complete_enum_specifier(right->type.enum_specifier))
        {
            char * lefttag;
            char * righttag;
            char finalmessage[200];

            ;
            ;
            lefttag = "";
            if (left->type.enum_specifier->tag_token)
            {
                lefttag = left->type.enum_specifier->tag_token->lexeme;
            }
            righttag = "";
            if (right->type.enum_specifier->tag_token)
            {
                righttag = right->type.enum_specifier->tag_token->lexeme;
            }
            _cake_zmem(&finalmessage, 200);
            snprintf(finalmessage, 200, "%s (enum %s, enum %s)", message, lefttag, righttag);
            compiler_diagnostic(4, ctx, operator_token, 0, finalmessage, lefttag, righttag);
        }
    }
}


struct expression *equality_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;
    struct expression * new_expression;

    p_expression_node = 0;
    new_expression = 0;
    if (1) /*try*/
    {
        p_expression_node = relational_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 15677 || ctx->current->type == 8509))
        {
            struct token * p_token_operator;
            struct token * operator_token;

            p_token_operator = ctx->current;
            ;
            new_expression = calloc(1, 256);
            if (new_expression == 0)
            {
                goto __L0; /* throw */
            }
            new_expression->first_token = ctx->current;
            operator_token = ctx->current;
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            if (operator_token->type == 15677)
            {
                new_expression->expression_type = 54;
            }
            else
            {
                new_expression->expression_type = 55;
            }
            new_expression->left = p_expression_node;
            p_expression_node = 0;
            new_expression->right = relational_expression(ctx, eval_mode);
            if (new_expression->right == 0)
            {
                goto __L0; /* throw */
            }
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            check_comparison(ctx, new_expression->left, new_expression->right, p_token_operator);
            new_expression->last_token = new_expression->right->last_token;
            new_expression->first_token = operator_token;
            if (object_has_constant_value(&new_expression->left->object) && object_has_constant_value(&new_expression->right->object))
            {
                if (eval_mode == 2)
                {
                    if (p_token_operator->type == 15677)
                    {
                        new_expression->object = object_equal(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                    }
                    else
                    {
                        new_expression->object = object_not_equal(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
                    }
                }
            }
            new_expression->type = type_make_int_bool_like();
            p_expression_node = new_expression;
            new_expression = 0;
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    expression_delete(new_expression);
    return p_expression_node;
}


struct expression *and_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;
    struct expression * new_expression;

    p_expression_node = 0;
    new_expression = 0;
    if (1) /*try*/
    {
        p_expression_node = equality_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && ctx->current->type == 38)
        {
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            ;
            new_expression = calloc(1, 256);
            if (new_expression == 0)
            {
                goto __L0; /* throw */
            }
            new_expression->first_token = ctx->current;
            new_expression->expression_type = 56;
            new_expression->left = p_expression_node;
            p_expression_node = 0;
            new_expression->right = equality_expression(ctx, eval_mode);
            if (new_expression->right == 0)
            {
                goto __L0; /* throw */
            }
            new_expression->last_token = new_expression->right->last_token;
            new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);
            if (!type_is_integer(&new_expression->left->type))
            {
                compiler_diagnostic(840, ctx, ctx->current, 0, "left type must be an integer type");
                goto __L0; /* throw */
            }
            if (!type_is_integer(&new_expression->right->type))
            {
                compiler_diagnostic(850, ctx, ctx->current, 0, "right type must be an integer type");
                goto __L0; /* throw */
            }
            if (object_has_constant_value(&new_expression->left->object) && object_has_constant_value(&new_expression->right->object))
            {
                new_expression->object = object_bitwise_and(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
            }
            p_expression_node = new_expression;
            new_expression = 0;
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    expression_delete(new_expression);
    return p_expression_node;
}


struct expression *exclusive_or_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;
    struct expression * new_expression;

    p_expression_node = 0;
    new_expression = 0;
    if (1) /*try*/
    {
        p_expression_node = and_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 94))
        {
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            ;
            new_expression = calloc(1, 256);
            if (new_expression == 0)
            {
                goto __L0; /* throw */
            }
            new_expression->first_token = ctx->current;
            new_expression->expression_type = 57;
            new_expression->left = p_expression_node;
            p_expression_node = 0;
            new_expression->right = and_expression(ctx, eval_mode);
            if (new_expression->right == 0)
            {
                goto __L0; /* throw */
            }
            new_expression->last_token = new_expression->right->last_token;
            new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);
            if (!type_is_integer(&new_expression->left->type))
            {
                compiler_diagnostic(840, ctx, ctx->current, 0, "left type must be an integer type");
                goto __L0; /* throw */
            }
            if (!type_is_integer(&new_expression->right->type))
            {
                compiler_diagnostic(850, ctx, ctx->current, 0, "right type must be an integer type");
                goto __L0; /* throw */
            }
            if (object_has_constant_value(&new_expression->left->object) && object_has_constant_value(&new_expression->right->object))
            {
                new_expression->object = object_bitwise_xor(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
            }
            p_expression_node = new_expression;
            new_expression = 0;
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    expression_delete(new_expression);
    return p_expression_node;
}


struct expression *inclusive_or_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;

    p_expression_node = 0;
    if (1) /*try*/
    {
        p_expression_node = exclusive_or_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 124))
        {
            struct token * operator_token;
            struct expression * new_expression;

            operator_token = ctx->current;
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            new_expression = calloc(1, 256);
            if (new_expression == 0)
            {
                goto __L0; /* throw */
            }
            new_expression->first_token = ctx->current;
            new_expression->expression_type = 58;
            new_expression->left = p_expression_node;
            p_expression_node = 0;
            new_expression->right = exclusive_or_expression(ctx, eval_mode);
            if (new_expression->right == 0)
            {
                expression_delete(new_expression);
                goto __L0; /* throw */
            }
            check_diferent_enuns(ctx, operator_token, new_expression->left, new_expression->right, "operator '|' between enumerations of different types.");
            new_expression->last_token = new_expression->right->last_token;
            new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type, ctx->options.target);
            if (!type_is_integer(&new_expression->left->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic(840, ctx, ctx->current, 0, "left type must be an integer type");
                goto __L0; /* throw */
            }
            if (!type_is_integer(&new_expression->right->type))
            {
                compiler_diagnostic(850, ctx, ctx->current, 0, "right type must be an integer type");
                goto __L0; /* throw */
            }
            if (object_has_constant_value(&new_expression->left->object) && object_has_constant_value(&new_expression->right->object))
            {
                new_expression->object = object_bitwise_or(ctx->options.target, &new_expression->left->object, &new_expression->right->object, warning_message);
            }
            p_expression_node = new_expression;
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}


struct expression *logical_and_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;

    p_expression_node = 0;
    if (1) /*try*/
    {
        p_expression_node = inclusive_or_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 9766))
        {
            struct expression * new_expression;
            unsigned char  right_evaluation_is_disabled;

            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            new_expression = calloc(1, 256);
            if (new_expression == 0)
            {
                goto __L0; /* throw */
            }
            new_expression->first_token = ctx->current;
            new_expression->expression_type = 60;
            new_expression->left = p_expression_node;
            p_expression_node = 0;
            right_evaluation_is_disabled = 0;
            if (object_has_constant_value(&new_expression->left->object))
            {
                if (!object_is_true(&new_expression->left->object))
                {
                    right_evaluation_is_disabled = 1;
                }
            }
            new_expression->right = inclusive_or_expression(ctx, right_evaluation_is_disabled ? 1 : 2);
            if (new_expression->right == 0)
            {
                expression_delete(new_expression);
                goto __L0; /* throw */
            }
            new_expression->last_token = new_expression->right->last_token;
            if (eval_mode == 2)
            {
                if (object_has_constant_value(&new_expression->left->object))
                {
                    unsigned char  a;

                    a = object_is_true(&new_expression->left->object);
                    if (a == 0)
                    {
                        new_expression->object = object_make_signed_int(ctx->options.target, 0);
                    }
                    else
                    {
                        if (object_has_constant_value(&new_expression->right->object))
                        {
                            unsigned char  b;

                            b = object_is_true(&new_expression->right->object);
                            new_expression->object = object_make_signed_int(ctx->options.target, a && b);
                        }
                    }
                }
            }
            if (!type_is_scalar_decay(&new_expression->left->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic(870, ctx, ctx->current, 0, "left type is not scalar for or expression");
                goto __L0; /* throw */
            }
            if (!type_is_scalar_decay(&new_expression->right->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic(880, ctx, ctx->current, 0, "right type is not scalar for or expression");
                goto __L0; /* throw */
            }
            new_expression->type = type_make_int_bool_like();
            p_expression_node = new_expression;
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}


struct expression *logical_or_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;

    p_expression_node = 0;
    if (1) /*try*/
    {
        int current_eval_mode;

        p_expression_node = logical_and_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        current_eval_mode = eval_mode;
        while (ctx->current != 0 && (ctx->current->type == 31868))
        {
            struct expression * new_expression;
            unsigned char  right_evaluation_is_disabled;

            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            new_expression = calloc(1, 256);
            if (new_expression == 0)
            {
                goto __L0; /* throw */
            }
            new_expression->first_token = ctx->current;
            new_expression->expression_type = 59;
            new_expression->left = p_expression_node;
            p_expression_node = 0;
            right_evaluation_is_disabled = 0;
            if (object_has_constant_value(&new_expression->left->object))
            {
                if (object_is_true(&new_expression->left->object))
                {
                    right_evaluation_is_disabled = 1;
                }
            }
            /*switch*/
            {
                int __v0 = current_eval_mode;
                if (__v0 == 0) goto __L7; /*case 0*/
                if (__v0 == 1) goto __L8; /*case 1*/
                if (__v0 == 2) goto __L9; /*case 2*/
                goto __L6;

                {
                    __L7: /*case 0*/ 
                    __L8: /*case 1*/ 
                    goto __L6; /* break */

                    __L9: /*case 2*/ 
                    if (right_evaluation_is_disabled)
                    {
                        current_eval_mode = 1;
                    }
                    goto __L6; /* break */

                }
                __L6:;
            }
            new_expression->right = logical_and_expression(ctx, current_eval_mode);
            if (new_expression->right == 0)
            {
                expression_delete(new_expression);
                goto __L0; /* throw */
            }
            new_expression->last_token = new_expression->right->last_token;
            if (eval_mode == 2)
            {
                if (object_has_constant_value(&new_expression->left->object))
                {
                    unsigned char  a;

                    a = object_is_true(&new_expression->left->object);
                    if (a == 1)
                    {
                        new_expression->object = object_make_signed_int(ctx->options.target, 1);
                    }
                    else
                    {
                        if (object_has_constant_value(&new_expression->right->object))
                        {
                            unsigned char  b;

                            b = object_is_true(&new_expression->right->object);
                            new_expression->object = object_make_signed_int(ctx->options.target, a || b);
                        }
                    }
                }
            }
            if (!type_is_scalar_decay(&new_expression->left->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic(870, ctx, ctx->current, 0, "left type is not scalar for or expression");
                goto __L0; /* throw */
            }
            if (!type_is_scalar_decay(&new_expression->right->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic(880, ctx, ctx->current, 0, "right type is not scalar for or expression");
                goto __L0; /* throw */
            }
            new_expression->type = type_make_int_bool_like();
            p_expression_node = new_expression;
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}


struct expression *conditional_expression(struct parser_ctx * ctx, int eval_mode);

struct expression *assignment_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;

    p_expression_node = 0;
    if (1) /*try*/
    {
        p_expression_node = conditional_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        ;
        while (ctx->current != 0 && (ctx->current->type == 61 || ctx->current->type == 10813 || ctx->current->type == 12093 || ctx->current->type == 9533 || ctx->current->type == 11069 || ctx->current->type == 11581 || ctx->current->type == 3947581 || ctx->current->type == 4079165 || ctx->current->type == 9789 || ctx->current->type == 24125 || ctx->current->type == 31805))
        {
            struct token * op_token;
            struct expression * new_expression;
            struct marker  left_operand_marker;

            op_token = ctx->current;
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            new_expression = calloc(1, 256);
            if (new_expression == 0)
            {
                goto __L0; /* throw */
            }
            new_expression->first_token = ctx->current;
            /*switch*/
            {
                int __v0 = op_token->type;
                if (__v0 == 61) goto __L5; /*case 61*/
                if (__v0 == 10813) goto __L6; /*case 10813*/
                if (__v0 == 12093) goto __L7; /*case 12093*/
                if (__v0 == 9533) goto __L8; /*case 9533*/
                if (__v0 == 11069) goto __L9; /*case 11069*/
                if (__v0 == 11581) goto __L10; /*case 11581*/
                if (__v0 == 3947581) goto __L11; /*case 3947581*/
                if (__v0 == 4079165) goto __L12; /*case 4079165*/
                if (__v0 == 9789) goto __L13; /*case 9789*/
                if (__v0 == 24125) goto __L14; /*case 24125*/
                if (__v0 == 31805) goto __L15; /*case 31805*/
                goto __L16; /* default */

                {
                    __L5: /*case 61*/ 
                    new_expression->expression_type = 61;
                    goto __L4; /* break */

                    __L6: /*case 10813*/ 
                    new_expression->expression_type = 64;
                    goto __L4; /* break */

                    __L7: /*case 12093*/ 
                    new_expression->expression_type = 65;
                    goto __L4; /* break */

                    __L8: /*case 9533*/ 
                    new_expression->expression_type = 66;
                    goto __L4; /* break */

                    __L9: /*case 11069*/ 
                    new_expression->expression_type = 62;
                    goto __L4; /* break */

                    __L10: /*case 11581*/ 
                    new_expression->expression_type = 63;
                    goto __L4; /* break */

                    __L11: /*case 3947581*/ 
                    new_expression->expression_type = 67;
                    goto __L4; /* break */

                    __L12: /*case 4079165*/ 
                    new_expression->expression_type = 68;
                    goto __L4; /* break */

                    __L13: /*case 9789*/ 
                    new_expression->expression_type = 69;
                    goto __L4; /* break */

                    __L14: /*case 24125*/ 
                    new_expression->expression_type = 71;
                    goto __L4; /* break */

                    __L15: /*case 31805*/ 
                    new_expression->expression_type = 70;
                    goto __L4; /* break */

                    __L16: /* default */ 
                    ;
                    goto __L4; /* break */

                }
                __L4:;
            }
            new_expression->left = p_expression_node;
            p_expression_node = 0;
            left_operand_marker.file = 0;
            left_operand_marker.line = 0;
            left_operand_marker.start_col = 0;
            left_operand_marker.end_col = 0;
            left_operand_marker.p_token_caret = 0;
            left_operand_marker.p_token_begin = new_expression->left->first_token;
            left_operand_marker.p_token_end = new_expression->left->last_token;
            if (type_is_function(&new_expression->left->type))
            {
                compiler_diagnostic(900, ctx, 0, &left_operand_marker, "assignment of function");
            }
            else
            {
                if (type_is_array(&new_expression->left->type))
                {
                    if (new_expression->left->type.storage_class_specifier_flags & 2048)
                    {
                        compiler_diagnostic(43, ctx, 0, &left_operand_marker, "assignment to array parameter");
                    }
                    else
                    {
                        compiler_diagnostic(910, ctx, 0, &left_operand_marker, "assignment to expression with array type");
                    }
                }
            }
            if (type_is_const(&new_expression->left->type))
            {
                compiler_diagnostic(920, ctx, 0, &left_operand_marker, "assignment of read-only object");
            }
            if (!expression_is_lvalue(new_expression->left))
            {
                compiler_diagnostic(1230, ctx, 0, &left_operand_marker, "lvalue required as left operand of assignment");
            }
            new_expression->right = assignment_expression(ctx, eval_mode);
            if (new_expression->right == 0)
            {
                expression_delete(new_expression);
                goto __L0; /* throw */
            }
            if (op_token->type == 61)
            {
                check_assigment(ctx, &new_expression->left->type, new_expression->right, 2);
            }
            new_expression->last_token = new_expression->right->last_token;
            new_expression->type = type_dup(&new_expression->left->type);
            new_expression->type.storage_class_specifier_flags &= -8193;
            new_expression->type.storage_class_specifier_flags &= -16385;
            check_diferent_enuns(ctx, op_token, new_expression->left, new_expression->right, "assignment of different enums.");
            new_expression->left->is_assignment_expression = 1;
            if (new_expression->left->left)
            {
                new_expression->left->left->is_assignment_expression = 1;
            }
            p_expression_node = new_expression;
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}


void argument_expression_list_push(struct argument_expression_list * list, struct argument_expression * pitem)
{
    if (list->head == 0)
    {
        list->head = pitem;
    }
    else
    {
        ;
        ;
        list->tail->next = pitem;
    }
    list->tail = pitem;
}


void argument_expression_list_destroy(struct argument_expression_list * p)
{
    struct argument_expression * item;

    item = p->head;
    while (item)
    {
        struct argument_expression * next;

        next = item->next;
        item->next = 0;
        argument_expression_delete(item);
        item = next;
    }
}


unsigned char expression_is_malloc(struct expression * p)
{
    if (p->expression_type == 12 && p->left && p->left->declarator && p->left->declarator->name_opt)
    {
        if (strcmp(p->left->declarator->name_opt->lexeme, "malloc") == 0)
        {
            return 1;
        }
    }
    return 0;
}


unsigned char expression_is_calloc(struct expression * p)
{
    if (p->expression_type == 12 && p->left && p->left->declarator && p->left->declarator->name_opt)
    {
        if (strcmp(p->left->declarator->name_opt->lexeme, "calloc") == 0)
        {
            return 1;
        }
    }
    return 0;
}


void compound_statement_delete(struct compound_statement * p);
void braced_initializer_delete(struct braced_initializer * p);

void expression_delete(struct expression * p)
{
    if (p)
    {
        expression_delete(p->condition_expr);
        compound_statement_delete(p->compound_statement);
        type_name_delete(p->type_name);
        expression_delete(p->right);
        expression_delete(p->left);
        braced_initializer_delete(p->braced_initializer);
        generic_selection_delete(p->generic_selection);
        type_destroy(&p->type);
        argument_expression_list_destroy(&p->argument_expression_list);
        free(p);
    }
}


struct expression *expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;

    p_expression_node = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_expression_node = assignment_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 44)
        {
            while (ctx->current->type == 44)
            {
                struct expression * p_expression_node_new;

                parser_match(ctx);
                if (ctx->current == 0)
                {
                    unexpected_end_of_file(ctx);
                    goto __L0; /* throw */
                }
                p_expression_node_new = calloc(1, 256);
                if (p_expression_node_new == 0)
                {
                    goto __L0; /* throw */
                }
                p_expression_node_new->first_token = ctx->current;
                p_expression_node_new->expression_type = 72;
                p_expression_node_new->left = p_expression_node;
                p_expression_node = 0;
                p_expression_node_new->right = expression(ctx, eval_mode);
                if (p_expression_node_new->right == 0)
                {
                    expression_delete(p_expression_node_new);
                    goto __L0; /* throw */
                }
                p_expression_node_new->object = object_dup(&p_expression_node_new->right->object);
                if (p_expression_node_new->object.state == 2)
                {
                    p_expression_node_new->object.state = 4;
                }
                p_expression_node_new->left->last_token = p_expression_node_new->right->last_token;
                p_expression_node = p_expression_node_new;
                if (ctx->current == 0)
                {
                    unexpected_end_of_file(ctx);
                    goto __L0; /* throw */
                }
            }
            type_destroy(&p_expression_node->type);
            p_expression_node->type = type_dup(&p_expression_node->right->type);
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    return p_expression_node;
}


unsigned char is_first_of_conditional_expression(struct parser_ctx * ctx)
{
    return is_first_of_unary_expression(ctx) || is_first_of_primary_expression(ctx);
}


unsigned char expression_is_one(struct expression * expression)
{
    if (expression->expression_type == 8)
    {
        return (object_has_constant_value(&expression->object) && object_is_one(&expression->object));
    }
    return 0;
}


unsigned char expression_is_zero(struct expression * expression)
{
    if (expression->expression_type == 8)
    {
        return (object_has_constant_value(&expression->object) && object_is_zero(&expression->object));
    }
    return 0;
}


unsigned char type_is_void_ptr(struct type * p_type);

unsigned char expression_is_null_pointer_constant(struct expression * expression)
{
    if (type_is_integer(&expression->type) && object_has_constant_value(&expression->object) && object_is_zero(&expression->object))
    {
        return 1;
    }
    if (type_is_void_ptr(&expression->type) && object_has_constant_value(&expression->object) && object_is_zero(&expression->object))
    {
        return 1;
    }
    if (type_is_nullptr_t(&expression->type))
    {
        return 1;
    }
    return 0;
}


void type_swap(struct type * a, struct type * b);

struct expression *conditional_expression(struct parser_ctx * ctx, int eval_mode)
{
    struct expression * p_expression_node;
    struct type  left_type;
    struct type  right_type;

    p_expression_node = 0;
    _cake_zmem(&left_type, 68);
    _cake_zmem(&right_type, 68);
    if (1) /*try*/
    {
        p_expression_node = logical_or_expression(ctx, eval_mode);
        if (p_expression_node == 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current && ctx->current->type == 63)
        {
            struct expression * p_conditional_expression;
            unsigned char  constant_expression_is_true;
            unsigned char  has_constant_expression;
            int true_eval_mode;
            int false_eval_mode;
            struct expression * p_left;
            struct expression * p_right;

            p_conditional_expression = calloc(1, 256);
            if (p_conditional_expression == 0)
            {
                goto __L0; /* throw */
            }
            p_conditional_expression->first_token = ctx->current;
            p_conditional_expression->expression_type = 73;
            p_conditional_expression->condition_expr = p_expression_node;
            p_expression_node = 0;
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                expression_delete(p_conditional_expression);
                goto __L0; /* throw */
            }
            constant_expression_is_true = 0;
            has_constant_expression = 0;
            if (object_has_constant_value(&p_conditional_expression->condition_expr->object))
            {
                has_constant_expression = 1;
                if (object_is_true(&p_conditional_expression->condition_expr->object))
                {
                    constant_expression_is_true = 1;
                }
            }
            true_eval_mode = eval_mode;
            false_eval_mode = eval_mode;
            /*switch*/
            {
                int __v0 = eval_mode;
                if (__v0 == 0) goto __L8; /*case 0*/
                if (__v0 == 1) goto __L9; /*case 1*/
                if (__v0 == 2) goto __L10; /*case 2*/
                goto __L7;

                {
                    __L8: /*case 0*/ 
                    __L9: /*case 1*/ 
                    goto __L7; /* break */

                    __L10: /*case 2*/ 
                    if (has_constant_expression && constant_expression_is_true)
                    {
                        true_eval_mode = 2;
                        false_eval_mode = 0;
                    }
                    else
                    {
                        true_eval_mode = 0;
                        false_eval_mode = 2;
                    }
                    goto __L7; /* break */

                }
                __L7:;
            }
            p_left = expression(ctx, true_eval_mode);
            if (p_left == 0)
            {
                expression_delete(p_conditional_expression);
                goto __L0; /* throw */
            }
            p_conditional_expression->left = p_left;
            if (parser_match_tk(ctx, 58) != 0)
            {
                unexpected_end_of_file(ctx);
                expression_delete(p_conditional_expression);
                goto __L0; /* throw */
            }
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                expression_delete(p_conditional_expression);
                goto __L0; /* throw */
            }
            p_right = conditional_expression(ctx, false_eval_mode);
            if (p_right == 0)
            {
                expression_delete(p_conditional_expression);
                goto __L0; /* throw */
            }
            p_conditional_expression->right = p_right;
            if (object_has_constant_value(&p_conditional_expression->condition_expr->object))
            {
                if (object_is_true(&p_conditional_expression->condition_expr->object))
                {
                    p_conditional_expression->object = object_make_reference(&p_conditional_expression->left->object);
                }
                else
                {
                    p_conditional_expression->object = object_make_reference(&p_conditional_expression->right->object);
                }
            }
            if (expression_is_subjected_to_lvalue_conversion(p_conditional_expression->left))
            {
                left_type = type_lvalue_conversion(&p_conditional_expression->left->type, ctx->options.null_checks_enabled);
            }
            else
            {
                left_type = type_dup(&p_conditional_expression->left->type);
            }
            if (expression_is_subjected_to_lvalue_conversion(p_conditional_expression->right))
            {
                right_type = type_lvalue_conversion(&p_conditional_expression->right->type, ctx->options.null_checks_enabled);
            }
            else
            {
                right_type = type_dup(&p_conditional_expression->right->type);
            }
            if (!type_is_scalar_decay(&p_conditional_expression->condition_expr->type))
            {
                compiler_diagnostic(940, ctx, ctx->current, 0, "condition must have scalar type");
            }
            else
            {
                if (type_is_arithmetic(&left_type) && type_is_arithmetic(&right_type))
                {
                    type_destroy(&p_conditional_expression->type);
                    p_conditional_expression->type = type_common(&left_type, &right_type, ctx->options.target);
                }
                else
                {
                    if (type_is_struct_or_union(&left_type) && type_is_struct_or_union(&right_type))
                    {
                        if (!type_is_same(&left_type, &right_type, 1))
                        {
                            compiler_diagnostic(950, ctx, p_conditional_expression->condition_expr->first_token, 0, "incompatible types");
                        }
                        type_swap(&p_conditional_expression->type, &right_type);
                    }
                    else
                    {
                        if (type_is_void(&left_type) && type_is_void(&right_type))
                        {
                            type_swap(&p_conditional_expression->type, &right_type);
                        }
                        else
                        {
                            if (type_is_nullptr_t(&left_type) && type_is_nullptr_t(&right_type))
                            {
                                type_swap(&p_conditional_expression->type, &right_type);
                            }
                            else
                            {
                                if (type_is_pointer(&left_type))
                                {
                                    if (expression_is_null_pointer_constant(p_conditional_expression->right) || type_is_nullptr_t(&right_type) || type_is_void_ptr(&right_type))
                                    {
                                        type_swap(&p_conditional_expression->type, &left_type);
                                    }
                                    else
                                    {
                                        if (type_is_pointer(&right_type))
                                        {
                                            if (type_is_nullptr_t(&left_type) || type_is_void_ptr(&left_type))
                                            {
                                                type_swap(&p_conditional_expression->type, &left_type);
                                            }
                                            else
                                            {
                                                if (!type_is_same(&left_type, &right_type, 0))
                                                {
                                                    compiler_diagnostic(950, ctx, ctx->current, 0, "incompatible types");
                                                }
                                                else
                                                {
                                                    type_swap(&p_conditional_expression->type, &right_type);
                                                }
                                            }
                                        }
                                        else
                                        {
                                            compiler_diagnostic(950, ctx, p_conditional_expression->condition_expr->first_token, 0, "incompatible types");
                                        }
                                    }
                                }
                                else
                                {
                                    if (type_is_pointer(&right_type))
                                    {
                                        if (expression_is_null_pointer_constant(p_conditional_expression->left) || type_is_nullptr_t(&left_type) || type_is_void_ptr(&left_type))
                                        {
                                            type_swap(&p_conditional_expression->type, &right_type);
                                        }
                                        else
                                        {
                                            if (type_is_pointer(&left_type))
                                            {
                                                if (type_is_nullptr_t(&left_type) || type_is_void_ptr(&left_type))
                                                {
                                                    type_swap(&p_conditional_expression->type, &right_type);
                                                }
                                                else
                                                {
                                                    if (!type_is_same(&left_type, &right_type, 0))
                                                    {
                                                        compiler_diagnostic(950, ctx, p_conditional_expression->condition_expr->first_token, 0, "incompatible types");
                                                    }
                                                    else
                                                    {
                                                        type_swap(&p_conditional_expression->type, &right_type);
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                compiler_diagnostic(950, ctx, p_conditional_expression->condition_expr->first_token, 0, "incompatible types");
                                            }
                                        }
                                    }
                                    else
                                    {
                                        compiler_diagnostic(950, ctx, p_conditional_expression->condition_expr->first_token, 0, "incompatible types");
                                    }
                                }
                            }
                        }
                    }
                }
            }
            p_expression_node = p_conditional_expression;
        }
    }
    else __L0: /*catch*/ 
    {
        expression_delete(p_expression_node);
        p_expression_node = 0;
    }
    type_destroy(&left_type);
    type_destroy(&right_type);
    return p_expression_node;
}


struct expression *constant_expression(struct parser_ctx * ctx, unsigned char  show_error_if_not_constant, int eval_mode)
{
    struct expression * p_expression;

    p_expression = conditional_expression(ctx, eval_mode);
    if (show_error_if_not_constant && p_expression && !object_has_constant_value(&p_expression->object))
    {
        compiler_diagnostic(960, ctx, ctx->current, 0, "expected constant expression");
    }
    return p_expression;
}


unsigned char expression_get_variables(struct expression * expr, int n, struct object *variables[])
{
    int count;

    count = 0;
    /*switch*/
    {
        int __v0 = expr->expression_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 1) goto __L2; /*case 1*/
        if (__v0 == 2) goto __L3; /*case 2*/
        if (__v0 == 3) goto __L6; /*case 3*/
        if (__v0 == 4) goto __L7; /*case 4*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 6) goto __L9; /*case 6*/
        if (__v0 == 7) goto __L10; /*case 7*/
        if (__v0 == 8) goto __L11; /*case 8*/
        if (__v0 == 9) goto __L12; /*case 9*/
        if (__v0 == 10) goto __L13; /*case 10*/
        if (__v0 == 11) goto __L14; /*case 11*/
        if (__v0 == 12) goto __L15; /*case 12*/
        if (__v0 == 13) goto __L16; /*case 13*/
        if (__v0 == 14) goto __L17; /*case 14*/
        if (__v0 == 15) goto __L18; /*case 15*/
        if (__v0 == 16) goto __L19; /*case 16*/
        if (__v0 == 17) goto __L20; /*case 17*/
        if (__v0 == 18) goto __L21; /*case 18*/
        if (__v0 == 19) goto __L22; /*case 19*/
        if (__v0 == 20) goto __L23; /*case 20*/
        if (__v0 == 27) goto __L24; /*case 27*/
        if (__v0 == 28) goto __L25; /*case 28*/
        if (__v0 == 29) goto __L26; /*case 29*/
        if (__v0 == 30) goto __L27; /*case 30*/
        if (__v0 == 31) goto __L28; /*case 31*/
        if (__v0 == 32) goto __L29; /*case 32*/
        if (__v0 == 34) goto __L30; /*case 34*/
        if (__v0 == 35) goto __L31; /*case 35*/
        if (__v0 == 36) goto __L32; /*case 36*/
        if (__v0 == 37) goto __L33; /*case 37*/
        if (__v0 == 38) goto __L34; /*case 38*/
        if (__v0 == 39) goto __L35; /*case 39*/
        if (__v0 == 40) goto __L36; /*case 40*/
        if (__v0 == 41) goto __L37; /*case 41*/
        if (__v0 == 42) goto __L38; /*case 42*/
        if (__v0 == 43) goto __L39; /*case 43*/
        if (__v0 == 44) goto __L40; /*case 44*/
        if (__v0 == 45) goto __L41; /*case 45*/
        if (__v0 == 46) goto __L42; /*case 46*/
        if (__v0 == 47) goto __L43; /*case 47*/
        if (__v0 == 48) goto __L44; /*case 48*/
        if (__v0 == 49) goto __L45; /*case 49*/
        if (__v0 == 50) goto __L46; /*case 50*/
        if (__v0 == 51) goto __L47; /*case 51*/
        if (__v0 == 52) goto __L48; /*case 52*/
        if (__v0 == 53) goto __L49; /*case 53*/
        if (__v0 == 54) goto __L50; /*case 54*/
        if (__v0 == 55) goto __L51; /*case 55*/
        if (__v0 == 56) goto __L52; /*case 56*/
        if (__v0 == 57) goto __L53; /*case 57*/
        if (__v0 == 58) goto __L54; /*case 58*/
        if (__v0 == 59) goto __L55; /*case 59*/
        if (__v0 == 60) goto __L56; /*case 60*/
        if (__v0 == 61) goto __L57; /*case 61*/
        if (__v0 == 62) goto __L58; /*case 62*/
        if (__v0 == 63) goto __L59; /*case 63*/
        if (__v0 == 64) goto __L60; /*case 64*/
        if (__v0 == 65) goto __L61; /*case 65*/
        if (__v0 == 66) goto __L62; /*case 66*/
        if (__v0 == 67) goto __L63; /*case 67*/
        if (__v0 == 68) goto __L64; /*case 68*/
        if (__v0 == 69) goto __L65; /*case 69*/
        if (__v0 == 70) goto __L66; /*case 70*/
        if (__v0 == 71) goto __L67; /*case 71*/
        if (__v0 == 72) goto __L68; /*case 72*/
        if (__v0 == 73) goto __L69; /*case 73*/
        if (__v0 == 21) goto __L70; /*case 21*/
        if (__v0 == 22) goto __L71; /*case 22*/
        if (__v0 == 23) goto __L72; /*case 23*/
        if (__v0 == 24) goto __L73; /*case 24*/
        if (__v0 == 25) goto __L74; /*case 25*/
        if (__v0 == 33) goto __L75; /*case 33*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            goto __L0; /* break */

            __L2: /*case 1*/ 
            goto __L0; /* break */

            __L3: /*case 2*/ 
            if (!object_has_constant_value(&expr->object))
            {
                if (count < n)
                {
                    variables[count] = object_get_non_const_referenced(&expr->object);
                    count++;
                }
            }
            goto __L0; /* break */

            __L6: /*case 3*/ 
            goto __L0; /* break */

            __L7: /*case 4*/ 
            goto __L0; /* break */

            __L8: /*case 5*/ 
            goto __L0; /* break */

            __L9: /*case 6*/ 
            goto __L0; /* break */

            __L10: /*case 7*/ 
            goto __L0; /* break */

            __L11: /*case 8*/ 
            goto __L0; /* break */

            __L12: /*case 9*/ 
            ;
            count += expression_get_variables(expr->right, n, variables);
            goto __L0; /* break */

            __L13: /*case 10*/ 
            goto __L0; /* break */

            __L14: /*case 11*/ 
            goto __L0; /* break */

            __L15: /*case 12*/ 
            goto __L0; /* break */

            __L16: /*case 13*/ 
            goto __L0; /* break */

            __L17: /*case 14*/ 
            goto __L0; /* break */

            __L18: /*case 15*/ 
            goto __L0; /* break */

            __L19: /*case 16*/ 
            goto __L0; /* break */

            __L20: /*case 17*/ 
            goto __L0; /* break */

            __L21: /*case 18*/ 
            goto __L0; /* break */

            __L22: /*case 19*/ 
            goto __L0; /* break */

            __L23: /*case 20*/ 
            goto __L0; /* break */

            __L24: /*case 27*/ 
            goto __L0; /* break */

            __L25: /*case 28*/ 
            goto __L0; /* break */

            __L26: /*case 29*/ 
            goto __L0; /* break */

            __L27: /*case 30*/ 
            goto __L0; /* break */

            __L28: /*case 31*/ 
            goto __L0; /* break */

            __L29: /*case 32*/ 
            goto __L0; /* break */

            __L30: /*case 34*/ 
            goto __L0; /* break */

            __L31: /*case 35*/ 
            goto __L0; /* break */

            __L32: /*case 36*/ 
            goto __L0; /* break */

            __L33: /*case 37*/ 
            goto __L0; /* break */

            __L34: /*case 38*/ 
            goto __L0; /* break */

            __L35: /*case 39*/ 
            goto __L0; /* break */

            __L36: /*case 40*/ 
            goto __L0; /* break */

            __L37: /*case 41*/ 
            goto __L0; /* break */

            __L38: /*case 42*/ 
            goto __L0; /* break */

            __L39: /*case 43*/ 
            __L40: /*case 44*/ 
            __L41: /*case 45*/ 
            ;
            ;
            count += expression_get_variables(expr->left, n, variables);
            count += expression_get_variables(expr->right, n, variables);
            goto __L0; /* break */

            __L42: /*case 46*/ 
            __L43: /*case 47*/ 
            ;
            ;
            count += expression_get_variables(expr->left, n, variables);
            count += expression_get_variables(expr->right, n, variables);
            goto __L0; /* break */

            __L44: /*case 48*/ 
            __L45: /*case 49*/ 
            __L46: /*case 50*/ 
            __L47: /*case 51*/ 
            __L48: /*case 52*/ 
            __L49: /*case 53*/ 
            __L50: /*case 54*/ 
            __L51: /*case 55*/ 
            ;
            ;
            count += expression_get_variables(expr->left, n, variables);
            count += expression_get_variables(expr->right, n, variables);
            goto __L0; /* break */

            __L52: /*case 56*/ 
            goto __L0; /* break */

            __L53: /*case 57*/ 
            goto __L0; /* break */

            __L54: /*case 58*/ 
            goto __L0; /* break */

            __L55: /*case 59*/ 
            __L56: /*case 60*/ 
            ;
            ;
            count += expression_get_variables(expr->left, n, variables);
            count += expression_get_variables(expr->right, n, variables);
            goto __L0; /* break */

            __L57: /*case 61*/ 
            goto __L0; /* break */

            __L58: /*case 62*/ 
            goto __L0; /* break */

            __L59: /*case 63*/ 
            goto __L0; /* break */

            __L60: /*case 64*/ 
            goto __L0; /* break */

            __L61: /*case 65*/ 
            goto __L0; /* break */

            __L62: /*case 66*/ 
            goto __L0; /* break */

            __L63: /*case 67*/ 
            goto __L0; /* break */

            __L64: /*case 68*/ 
            goto __L0; /* break */

            __L65: /*case 69*/ 
            goto __L0; /* break */

            __L66: /*case 70*/ 
            goto __L0; /* break */

            __L67: /*case 71*/ 
            goto __L0; /* break */

            __L68: /*case 72*/ 
            goto __L0; /* break */

            __L69: /*case 73*/ 
            goto __L0; /* break */

            __L70: /*case 21*/ 
            __L71: /*case 22*/ 
            __L72: /*case 23*/ 
            __L73: /*case 24*/ 
            __L74: /*case 25*/ 
            __L75: /*case 33*/ 
            goto __L0; /* break */

        }
        __L0:;
    }
    return (count != 0);
}


unsigned char expression_is_lvalue(struct expression * expr)
{
    /*switch*/
    {
        int __v0 = expr->expression_type;
        if (__v0 == 2) goto __L1; /*case 2*/
        if (__v0 == 4) goto __L2; /*case 4*/
        if (__v0 == 3) goto __L3; /*case 3*/
        if (__v0 == 13) goto __L4; /*case 13*/
        if (__v0 == 15) goto __L5; /*case 15*/
        if (__v0 == 11) goto __L6; /*case 11*/
        if (__v0 == 40) goto __L7; /*case 40*/
        goto __L8; /* default */

        {
            __L1: /*case 2*/ 
            __L2: /*case 4*/ 
            __L3: /*case 3*/ 
            __L4: /*case 13*/ 
            __L5: /*case 15*/ 
            __L6: /*case 11*/ 
            __L7: /*case 40*/ 
            return 1;
            __L8: /* default */ 
            goto __L0; /* break */

        }
        __L0:;
    }
    if (expr->expression_type == 9 && expr->right)
    {
        return expression_is_lvalue(expr->right);
    }
    else
    {
        if (expr->expression_type == 14 && expr->left)
        {
            return expression_is_lvalue(expr->left);
        }
    }
    return 0;
}


unsigned char expression_is_subjected_to_lvalue_conversion(struct expression * expression)
{
    /*switch*/
    {
        int __v0 = expression->expression_type;
        if (__v0 == 41) goto __L1; /*case 41*/
        if (__v0 == 34) goto __L2; /*case 34*/
        if (__v0 == 35) goto __L3; /*case 35*/
        if (__v0 == 16) goto __L4; /*case 16*/
        if (__v0 == 17) goto __L5; /*case 17*/
        goto __L6; /* default */

        {
            __L1: /*case 41*/ 
            __L2: /*case 34*/ 
            __L3: /*case 35*/ 
            __L4: /*case 16*/ 
            __L5: /*case 17*/ 
            return 0;
            __L6: /* default */ 
            if (expression->type.storage_class_specifier_flags & 2048)
            {
                return 1;
            }
        }
        __L0:;
    }
    return 1;
}


unsigned char type_is_owner_or_pointer_to_dtor(struct type * p_type);
unsigned char is_automatic_variable(int f);
unsigned char type_is_pointed_dtor(struct type * p_type);
unsigned char type_is_opt(struct type * p_type, unsigned char  nullable_enabled);

void check_assigment(struct parser_ctx * ctx, struct type * p_a_type, struct expression * p_b_expression, int assignment_type)
{
    struct type * p_b_type;
    unsigned char  is_null_pointer_constant;
    struct type  b_type_lvalue;

    p_b_type = &p_b_expression->type;
    is_null_pointer_constant = expression_is_null_pointer_constant(p_b_expression);
    if (type_is_pointer(p_a_type))
    {
        if (!type_is_nullptr_t(p_b_type) && !type_is_pointer_or_array(p_b_type) && !type_is_function(p_b_type))
        {
            if (is_null_pointer_constant)
            {
                if (p_b_expression->expression_type == 8)
                {
                    compiler_diagnostic(11, ctx, p_b_expression->first_token, 0, "use NULL instead of 0");
                }
                else
                {
                    compiler_diagnostic(46, ctx, p_b_expression->first_token, 0, "unusual expression/type used as null pointer constant");
                }
            }
            else
            {
                compiler_diagnostic(1340, ctx, p_b_expression->first_token, 0, "non-pointer to pointer");
            }
        }
    }
    if (type_is_bool(p_a_type) && type_is_nullptr_t(p_b_type))
    {
        struct marker  marker;

        marker.file = 0;
        marker.line = 0;
        marker.start_col = 0;
        marker.end_col = 0;
        marker.p_token_caret = 0;
        marker.p_token_begin = p_b_expression->first_token;
        marker.p_token_end = p_b_expression->first_token;
        compiler_diagnostic(49, ctx, 0, &marker, "implicit conversion of nullptr constant to 'bool'");
    }
    _cake_zmem(&b_type_lvalue, 68);
    if (expression_is_subjected_to_lvalue_conversion(p_b_expression))
    {
        b_type_lvalue = type_lvalue_conversion(p_b_type, ctx->options.null_checks_enabled);
    }
    else
    {
        b_type_lvalue = type_dup(p_b_type);
    }
    if (type_is_owner(p_a_type) && !type_is_owner(&p_b_expression->type))
    {
        if (!is_null_pointer_constant)
        {
            compiler_diagnostic(25, ctx, p_b_expression->first_token, 0, "cannot assign a non-owner to owner");
            type_destroy(&b_type_lvalue);
            return;
        }
    }
    if (!type_is_owner(p_a_type) && type_is_owner_or_pointer_to_dtor(&p_b_expression->type))
    {
        if (p_b_expression->type.storage_class_specifier_flags & 8192)
        {
            compiler_diagnostic(23, ctx, p_b_expression->first_token, 0, "cannot assign a temporary owner to non-owner object.");
            type_destroy(&b_type_lvalue);
            return;
        }
    }
    if (assignment_type == 0)
    {
        if (!type_is_owner(p_a_type) && type_is_owner_or_pointer_to_dtor(&p_b_expression->type))
        {
            if (is_automatic_variable(p_b_expression->type.storage_class_specifier_flags))
            {
                compiler_diagnostic(1280, ctx, p_b_expression->first_token, 0, "cannot return a automatic storage duration _Owner to non-owner");
                type_destroy(&b_type_lvalue);
                return;
            }
        }
    }
    if (type_is_pointed_dtor(p_a_type) && type_is_pointer(p_a_type))
    {
        if (type_is_owner(p_b_type))
        {
        }
        else
        {
            if (!p_b_type->address_of)
            {
                compiler_diagnostic(19, ctx, p_b_expression->first_token, 0, "source expression of _Dtor must be addressof");
            }
        }
    }
    if (type_is_pointer(p_a_type) && !type_is_opt(p_a_type, ctx->options.null_checks_enabled) && is_null_pointer_constant)
    {
        compiler_diagnostic(60, ctx, p_b_expression->first_token, 0, "cannot convert a null pointer constant to non-nullable pointer");
        type_destroy(&b_type_lvalue);
        return;
    }
    if (type_is_enum(p_b_type) && type_is_enum(p_a_type))
    {
        if (!type_is_same(p_b_type, p_a_type, 0))
        {
            compiler_diagnostic(40, ctx, p_b_expression->first_token, 0, " incompatible types ");
        }
        type_destroy(&b_type_lvalue);
        return;
    }
    if (type_is_arithmetic(p_b_type) && type_is_arithmetic(p_a_type))
    {
        type_destroy(&b_type_lvalue);
        return;
    }
    if (is_null_pointer_constant && type_is_pointer(p_a_type))
    {
        type_destroy(&b_type_lvalue);
        return;
    }
    if (is_null_pointer_constant && type_is_array(p_a_type))
    {
        compiler_diagnostic(39, ctx, p_b_expression->first_token, 0, " passing null as array");
        type_destroy(&b_type_lvalue);
        return;
    }
    if (type_is_pointer_or_array(p_b_type) && type_is_pointer_or_array(p_a_type))
    {
        struct type  a_type_lvalue;

        if (type_is_void_ptr(p_b_type))
        {
            type_destroy(&b_type_lvalue);
            return;
        }
        if (type_is_void_ptr(p_a_type))
        {
            type_destroy(&b_type_lvalue);
            return;
        }
        _cake_zmem(&a_type_lvalue, 68);
        if (type_is_array(p_a_type))
        {
            if (assignment_type == 1)
            {
                unsigned int parameter_array_size;

                parameter_array_size = p_a_type->num_of_elements;
                if (type_is_array(p_b_type))
                {
                    unsigned int argument_array_size;

                    argument_array_size = p_b_type->num_of_elements;
                    if (parameter_array_size != 0 && argument_array_size < parameter_array_size)
                    {
                        compiler_diagnostic(1130, ctx, p_b_expression->first_token, 0, " argument of size [%d] is smaller than parameter of size [%d]", argument_array_size, parameter_array_size);
                    }
                }
                else
                {
                    if (is_null_pointer_constant || type_is_nullptr_t(p_b_type))
                    {
                        compiler_diagnostic(39, ctx, p_b_expression->first_token, 0, " passing null as array");
                    }
                }
            }
            a_type_lvalue = type_lvalue_conversion(p_a_type, ctx->options.null_checks_enabled);
        }
        else
        {
            a_type_lvalue = type_dup(p_a_type);
        }
        if (!type_is_same(&b_type_lvalue, &a_type_lvalue, 0))
        {
            type_print(&b_type_lvalue, ctx->options.target);
            type_print(&a_type_lvalue, ctx->options.target);
            compiler_diagnostic(54, ctx, p_b_expression->first_token, 0, " incompatible types");
        }
        if (assignment_type == 1)
        {
            if (type_is_pointer(&b_type_lvalue) && type_is_pointer(&a_type_lvalue))
            {
                struct type  b_pointed_type_lvalue;
                struct type  a_lvalue_pointed_type;

                b_pointed_type_lvalue = type_remove_pointer(&b_type_lvalue);
                a_lvalue_pointed_type = type_remove_pointer(&a_type_lvalue);
                if (type_is_const(&b_pointed_type_lvalue) && !type_is_const(&a_lvalue_pointed_type))
                {
                    compiler_diagnostic(15, ctx, p_b_expression->first_token, 0, " discarding const at argument ");
                }
                type_destroy(&b_pointed_type_lvalue);
                type_destroy(&a_lvalue_pointed_type);
            }
        }
        else
        {
            if (type_is_pointer(p_a_type) && type_is_pointer(&b_type_lvalue))
            {
                struct type  b_pointed_type;
                struct type  a_pointed_type;

                b_pointed_type = type_remove_pointer(&b_type_lvalue);
                a_pointed_type = type_remove_pointer(p_a_type);
                if (type_is_const(&b_pointed_type) && !type_is_const(&a_pointed_type))
                {
                    compiler_diagnostic(15, ctx, p_b_expression->first_token, 0, " discarding const");
                }
                type_destroy(&b_pointed_type);
                type_destroy(&a_pointed_type);
            }
        }
        type_destroy(&a_type_lvalue);
    }
    if (!type_is_same(p_a_type, &b_type_lvalue, 0))
    {
    }
    type_destroy(&b_type_lvalue);
}


static void pre_conditional_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_logical_or_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_logical_and_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_inclusive_or_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_exclusive_or_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_and_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_equality_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_relational_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_shift_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_additive_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_multiplicative_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_cast_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_unary_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static struct token *pre_match(struct preprocessor_ctx * ctx);
static void pre_postfix_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_primary_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static struct object char_constant_to_value(char * s, char error_message[], int error_message_sz_bytes, int target);
static int ppnumber_to_longlong(struct preprocessor_ctx * ctx, struct token * token, long long * result, int target);
static void pre_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);
static void pre_assignment_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx);

int pre_constant_expression(struct preprocessor_ctx * ctx, long long * pvalue)
{
    struct pre_expression_ctx  ectx;

    _cake_zmem(&ectx, 8);
    pre_conditional_expression(ctx, &ectx);
    *pvalue = ectx.value;
    return ctx->n_errors > 0;
}



static struct token *pre_match(struct preprocessor_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    ctx->current = ctx->current->next;
    while (ctx->current && token_is_blank(ctx->current))
    {
        ctx->current = ctx->current->next;
    }
    return ctx->current;
}

static struct object char_constant_to_value(char * s, char error_message[], int error_message_sz_bytes, int target)
{
    unsigned char * p;
    unsigned long long wchar_max_value;
    struct object  empty;

    error_message[0] = 0;
    p = (unsigned char *)s;
    wchar_max_value = target_unsigned_max(target, get_platform(target)->wchar_t_type);
    if (1) /*try*/
    {
        if (p[0] == 117 && p[1] == 56)
        {
            unsigned int c;

            p++;
            p++;
            p++;
            c = 0;
            p = utf8_decode(p, &c);
            if (p == 0)
            {
                goto __L0; /* throw */
            }
            if (c == 92)
            {
                p = escape_sequences_decode_opt(p, &c);
                if (p == 0)
                {
                    goto __L0; /* throw */
                }
            }
            if (*p != 39)
            {
                snprintf(error_message, error_message_sz_bytes, "Unicode character literals may not contain multiple characters.");
            }
            if (c > 128)
            {
                snprintf(error_message, error_message_sz_bytes, "Character too large for enclosing character literal type.");
            }
            return object_make_wchar_t(target, c);
        }
        else
        {
            if (p[0] == 117)
            {
                unsigned int c;

                p++;
                p++;
                c = 0;
                p = utf8_decode(p, &c);
                if (p == 0)
                {
                    goto __L0; /* throw */
                }
                if (c == 92)
                {
                    p = escape_sequences_decode_opt(p, &c);
                    if (p == 0)
                    {
                        goto __L0; /* throw */
                    }
                }
                if (*p != 39)
                {
                    snprintf(error_message, error_message_sz_bytes, "Unicode character literals may not contain multiple characters.");
                }
                if ((int)c > wchar_max_value)
                {
                    snprintf(error_message, error_message_sz_bytes, "Character too large for enclosing character literal type.");
                }
                return object_make_wchar_t(target, c);
            }
            else
            {
                if (p[0] == 85)
                {
                    unsigned int c;

                    p++;
                    p++;
                    c = 0;
                    p = utf8_decode(p, &c);
                    if (p == 0)
                    {
                        goto __L0; /* throw */
                    }
                    if (c == 92)
                    {
                        p = escape_sequences_decode_opt(p, &c);
                        if (p == 0)
                        {
                            goto __L0; /* throw */
                        }
                    }
                    if (*p != 39)
                    {
                        snprintf(error_message, error_message_sz_bytes, "Unicode character literals may not contain multiple characters.");
                    }
                    if (c > 4294967295L)
                    {
                        snprintf(error_message, error_message_sz_bytes, "Character too large for enclosing character literal type.");
                    }
                    return object_make_wchar_t(target, c);
                }
                else
                {
                    if (p[0] == 76)
                    {
                        long long value;

                        p++;
                        p++;
                        value = 0;
                        while (*p != 39)
                        {
                            unsigned int c;

                            c = 0;
                            p = utf8_decode(p, &c);
                            if (p == 0)
                            {
                                goto __L0; /* throw */
                            }
                            if (c == 92)
                            {
                                p = escape_sequences_decode_opt(p, &c);
                                if (p == 0)
                                {
                                    goto __L0; /* throw */
                                }
                            }
                            value = value * 256 + c;
                            if (value > (long long)wchar_max_value)
                            {
                                snprintf(error_message, error_message_sz_bytes, "character constant too long for its type");
                                break;
                            }
                        }
                        return object_make_wchar_t(target, (int)value);
                    }
                    else
                    {
                        long long value;

                        p++;
                        value = 0;
                        while (*p != 39)
                        {
                            unsigned int c;

                            c = 0;
                            p = utf8_decode(p, &c);
                            if (p == 0)
                            {
                                goto __L0; /* throw */
                            }
                            if (c == 92)
                            {
                                p = escape_sequences_decode_opt(p, &c);
                                if (p == 0)
                                {
                                    goto __L0; /* throw */
                                }
                            }
                            if (c < 128)
                            {
                                value = value * 256 + c;
                            }
                            else
                            {
                                value = c;
                            }
                            if (value > 2147483647)
                            {
                                snprintf(error_message, error_message_sz_bytes, "character constant too long for its type");
                                break;
                            }
                        }
                        return object_make_wchar_t(target, (int)value);
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    _cake_zmem(&empty, 120);
    return empty;
}

static int ppnumber_to_longlong(struct preprocessor_ctx * ctx, struct token * token, long long * result, int target)
{
    int c;
    char buffer[260];
    char * s;
    char errormsg[100];
    char suffix[4];
    int type;
    unsigned long long value;

    c = 0;
    _cake_zmem(&buffer, 260);
    s = token->lexeme;
    while (*s)
    {
        if (*s != 39)
        {
            buffer[c] = *s;
            c++;
        }
        s++;
    }
    _cake_zmem(&suffix, 4);
    type = parse_number(token->lexeme, suffix, errormsg);
    if (type == 0)
    {
        preprocessor_diagnostic(1380, ctx, token, "%s", errormsg);
        return 0;
    }
    value = 0;
    /*switch*/
    {
        int __v0 = type;
        if (__v0 == 136) goto __L3; /*case 136*/
        if (__v0 == 137) goto __L4; /*case 137*/
        if (__v0 == 138) goto __L5; /*case 138*/
        if (__v0 == 139) goto __L6; /*case 139*/
        goto __L7; /* default */

        {
            __L3: /*case 136*/ 
            value = strtoull(buffer, 0, 10);
            goto __L2; /* break */

            __L4: /*case 137*/ 
            value = strtoull(buffer + 1, 0, 8);
            goto __L2; /* break */

            __L5: /*case 138*/ 
            value = strtoull(buffer + 2, 0, 16);
            goto __L2; /* break */

            __L6: /*case 139*/ 
            value = strtoull(buffer + 2, 0, 2);
            goto __L2; /* break */

            __L7: /* default */ 
            goto __L2; /* break */

        }
        __L2:;
    }
    *result = value;
    return 0;
}

static void pre_assignment_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_conditional_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 61 || ctx->current->type == 10813 || ctx->current->type == 12093 || ctx->current->type == 11069 || ctx->current->type == 11581 || ctx->current->type == 3947581 || ctx->current->type == 4079165 || ctx->current->type == 9789 || ctx->current->type == 24125 || ctx->current->type == 31805))
        {
            preprocessor_diagnostic(1140, ctx, ctx->current, "token '%s' is not valid in preprocessor expressions", ctx->current->lexeme);
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_assignment_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current && ctx->current->type == 44)
        {
            pre_match(ctx);
            pre_expression(ctx, ectx);
            if (ctx->n_errors > 0)
            {
                goto __L0; /* throw */
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_primary_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            pre_unexpected_end_of_file(ctx->input_list.tail, ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 131)
        {
            char * p;
            char errmsg[200];
            struct object  v;

            p = ctx->current->lexeme + 1;
            _cake_zmem(&errmsg, 200);
            v = char_constant_to_value(p, errmsg, 200, ctx->options.target);
            if (errmsg[0] != 0)
            {
                preprocessor_diagnostic(650, ctx, ctx->current, "%s", errmsg);
            }
            ectx->value = object_to_signed_long_long(&v);
            pre_match(ctx);
            object_destroy(&v);
        }
        else
        {
            if (ctx->current->type == 134)
            {
                ppnumber_to_longlong(ctx, ctx->current, &ectx->value, ctx->options.target);
                pre_match(ctx);
            }
            else
            {
                if (ctx->current->type == 40)
                {
                    pre_match(ctx);
                    pre_expression(ctx, ectx);
                    if (ctx->n_errors > 0)
                    {
                        goto __L0; /* throw */
                    }
                    if (ctx->current && ctx->current->type != 41)
                    {
                        preprocessor_diagnostic(650, ctx, ctx->current, "expected )");
                        goto __L0; /* throw */
                    }
                    pre_match(ctx);
                }
                else
                {
                    preprocessor_diagnostic(1140, ctx, ctx->current, "token '%s' is not valid in preprocessor expressions", ctx->current->lexeme);
                    goto __L0; /* throw */
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_postfix_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_primary_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_unary_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        if (ctx->current && (ctx->current->type == 11051 || ctx->current->type == 11565))
        {
            preprocessor_diagnostic(1140, ctx, ctx->current, "token '%s' is not valid in preprocessor expressions", ctx->current->lexeme);
            goto __L0; /* throw */
        }
        else
        {
            if (ctx->current != 0 && (ctx->current->type == 38 || ctx->current->type == 42 || ctx->current->type == 43 || ctx->current->type == 45 || ctx->current->type == 126 || ctx->current->type == 33))
            {
                struct token * p_old;
                int op;

                p_old = ctx->current;
                op = ctx->current->type;
                pre_match(ctx);
                pre_cast_expression(ctx, ectx);
                if (ctx->n_errors > 0)
                {
                    goto __L0; /* throw */
                }
                if (op == 33)
                {
                    ectx->value = !ectx->value;
                }
                else
                {
                    if (op == 126)
                    {
                        ectx->value = ~ectx->value;
                    }
                    else
                    {
                        if (op == 45)
                        {
                            ectx->value = -ectx->value;
                        }
                        else
                        {
                            if (op == 43)
                            {
                                ectx->value = +ectx->value;
                            }
                            else
                            {
                                if (op == 42)
                                {
                                    preprocessor_diagnostic(1140, ctx, p_old, "token '%s' is not valid in preprocessor expressions", p_old->lexeme);
                                }
                                else
                                {
                                    if (op == 38)
                                    {
                                        preprocessor_diagnostic(1140, ctx, p_old, "token '%s' is not valid in preprocessor expressions", p_old->lexeme);
                                    }
                                    else
                                    {
                                        preprocessor_diagnostic(1140, ctx, p_old, "token '%s' is not valid in preprocessor expressions", p_old->lexeme);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                pre_postfix_expression(ctx, ectx);
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_cast_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    pre_unary_expression(ctx, ectx);
}

static void pre_multiplicative_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_cast_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 42 || ctx->current->type == 47 || ctx->current->type == 37))
        {
            struct token * op_token;
            int op;
            long long left_value;

            op_token = ctx->current;
            op = ctx->current->type;
            pre_match(ctx);
            left_value = ectx->value;
            pre_cast_expression(ctx, ectx);
            if (ctx->n_errors > 0)
            {
                goto __L0; /* throw */
            }
            if (op == 42)
            {
                ectx->value = (left_value * ectx->value);
            }
            else
            {
                if (op == 47)
                {
                    if (ectx->value == 0)
                    {
                        preprocessor_diagnostic(1330, ctx, op_token, "division by zero");
                        goto __L0; /* throw */
                    }
                    else
                    {
                        ectx->value = (left_value / ectx->value);
                    }
                }
                else
                {
                    if (op == 37)
                    {
                        ectx->value = (left_value % ectx->value);
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_additive_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_multiplicative_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 43 || ctx->current->type == 45))
        {
            struct token * p_op_token;
            long long left_value;

            p_op_token = ctx->current;
            pre_match(ctx);
            if (ctx->current == 0)
            {
                pre_unexpected_end_of_file(ctx->input_list.tail, ctx);
                goto __L0; /* throw */
            }
            left_value = ectx->value;
            pre_multiplicative_expression(ctx, ectx);
            if (ctx->n_errors > 0)
            {
                goto __L0; /* throw */
            }
            if (p_op_token->type == 43)
            {
                ectx->value = left_value + ectx->value;
            }
            else
            {
                if (p_op_token->type == 45)
                {
                    ectx->value = left_value - ectx->value;
                }
                else
                {
                    goto __L0; /* throw */
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_shift_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_additive_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 15934 || ctx->current->type == 15420))
        {
            int op;
            long long left_value;

            op = ctx->current->type;
            pre_match(ctx);
            left_value = ectx->value;
            pre_multiplicative_expression(ctx, ectx);
            if (ctx->n_errors > 0)
            {
                goto __L0; /* throw */
            }
            if (op == 15934)
            {
                ectx->value = left_value >> ectx->value;
            }
            else
            {
                if (op == 15420)
                {
                    ectx->value = left_value << ectx->value;
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_relational_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_shift_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 62 || ctx->current->type == 60 || ctx->current->type == 15933 || ctx->current->type == 15421))
        {
            int op;
            long long left_value;

            op = ctx->current->type;
            pre_match(ctx);
            left_value = ectx->value;
            pre_shift_expression(ctx, ectx);
            if (ctx->n_errors > 0)
            {
                goto __L0; /* throw */
            }
            if (op == 62)
            {
                ectx->value = left_value > ectx->value;
            }
            else
            {
                if (op == 60)
                {
                    ectx->value = left_value < ectx->value;
                }
                else
                {
                    if (op == 15933)
                    {
                        ectx->value = left_value >= ectx->value;
                    }
                    else
                    {
                        if (op == 15421)
                        {
                            ectx->value = left_value <= ectx->value;
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_equality_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_relational_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 15677 || ctx->current->type == 8509))
        {
            int op;
            long long left_value;

            op = ctx->current->type;
            pre_match(ctx);
            left_value = ectx->value;
            pre_multiplicative_expression(ctx, ectx);
            if (ctx->n_errors > 0)
            {
                goto __L0; /* throw */
            }
            if (op == 15677)
            {
                ectx->value = left_value == ectx->value;
            }
            else
            {
                if (op == 8509)
                {
                    ectx->value = left_value != ectx->value;
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_and_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_equality_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 38))
        {
            long long left_value;

            pre_match(ctx);
            left_value = ectx->value;
            pre_equality_expression(ctx, ectx);
            if (ctx->n_errors > 0)
            {
                goto __L0; /* throw */
            }
            ectx->value = left_value & ectx->value;
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_exclusive_or_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_and_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 94))
        {
            long long left_value;

            pre_match(ctx);
            left_value = ectx->value;
            pre_and_expression(ctx, ectx);
            if (ctx->n_errors > 0)
            {
                goto __L0; /* throw */
            }
            ectx->value = left_value ^ ectx->value;
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_inclusive_or_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_exclusive_or_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 124))
        {
            long long left_value;

            pre_match(ctx);
            left_value = ectx->value;
            pre_exclusive_or_expression(ctx, ectx);
            if (ctx->n_errors > 0)
            {
                goto __L0; /* throw */
            }
            ectx->value = left_value | ectx->value;
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_logical_and_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_inclusive_or_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 9766))
        {
            long long left_value;

            pre_match(ctx);
            left_value = ectx->value;
            pre_inclusive_or_expression(ctx, ectx);
            if (ctx->n_errors > 0)
            {
                goto __L0; /* throw */
            }
            ectx->value = left_value && ectx->value;
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_logical_or_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_logical_and_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (ctx->current->type == 31868))
        {
            long long left_value;

            pre_match(ctx);
            left_value = ectx->value;
            pre_logical_and_expression(ctx, ectx);
            if (ctx->n_errors > 0)
            {
                goto __L0; /* throw */
            }
            ectx->value = left_value || ectx->value;
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void pre_conditional_expression(struct preprocessor_ctx * ctx, struct pre_expression_ctx * ectx)
{
    if (1) /*try*/
    {
        pre_logical_or_expression(ctx, ectx);
        if (ctx->n_errors > 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current && ctx->current->type == 63)
        {
            pre_match(ctx);
            if (ectx->value)
            {
                struct pre_expression_ctx  temp;

                pre_expression(ctx, ectx);
                if (ctx->n_errors > 0)
                {
                    goto __L0; /* throw */
                }
                pre_match(ctx);
                _cake_zmem(&temp, 8);
                pre_conditional_expression(ctx, &temp);
                if (ctx->n_errors > 0)
                {
                    goto __L0; /* throw */
                }
            }
            else
            {
                struct pre_expression_ctx  temp;

                _cake_zmem(&temp, 8);
                pre_expression(ctx, &temp);
                if (ctx->n_errors > 0)
                {
                    goto __L0; /* throw */
                }
                pre_match(ctx);
                pre_conditional_expression(ctx, ectx);
                if (ctx->n_errors > 0)
                {
                    goto __L0; /* throw */
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}
void secondary_block_delete(struct secondary_block * p);

void defer_statement_delete(struct defer_statement * p)
{
    if (p)
    {
        secondary_block_delete(p->secondary_block);
        free(p);
    }
}


void scope_destroy(struct scope * p)
{
    hashmap_destroy(&p->tags);
    hashmap_destroy(&p->variables);
}


void scope_list_push(struct scope_list * list, struct scope * pnew)
{
    if (list->tail)
    {
        pnew->scope_level = list->tail->scope_level + 1;
    }
    if (list->head == 0)
    {
        list->head = pnew;
        list->tail = pnew;
    }
    else
    {
        ;
        pnew->previous = list->tail;
        list->tail->next = pnew;
        list->tail = pnew;
    }
}


void scope_list_pop(struct scope_list * list)
{
    struct scope * p;

    if (list->head == 0)
    {
        return;
    }
    ;
    p = list->tail;
    if (list->head == list->tail)
    {
        list->head = 0;
        list->tail = 0;
    }
    else
    {
        list->tail = list->tail->previous;
        if (list->tail == list->head)
        {
            ;
            list->tail->next = 0;
            list->tail->previous = 0;
        }
    }
    p->next = 0;
    p->previous = 0;
}


void label_list_clear(struct label_list * list);

void parser_ctx_destroy(struct parser_ctx * ctx)
{
    label_list_clear(&ctx->label_list);
    ;
    ;
    if (ctx->sarif_file)
    {
        fclose(ctx->sarif_file);
    }
}


static void stringfy(char * input, char * json_str_message, int output_size);
static int __cdecl fprintf(struct _iobuf * _Stream, char * _Format, ...);

unsigned char compiler_diagnostic(int w, struct parser_ctx * ctx, struct token * p_token_opt, struct marker * p_marker_temp, char * fmt, ...)
{
    unsigned char  color_enabled;
    unsigned char  included_file_location;
    struct marker  marker;
    unsigned char  is_error;
    unsigned char  is_warning;
    unsigned char  is_note;
    char * func_name;
    char buffer[200];
    char * args;

    color_enabled = !ctx->options.color_disabled;
    if (ctx->p_diagnostic_id_stack && ctx->p_diagnostic_id_stack->size > 0)
    {
        int d;

        d = ctx->p_diagnostic_id_stack->stack[ctx->p_diagnostic_id_stack->size - 1];
        if (d == w)
        {
            diagnostic_id_stack_pop(ctx->p_diagnostic_id_stack);
            return 0;
        }
        else
        {
        }
    }
    included_file_location = 0;
    _cake_zmem(&marker, 28);
    if (p_marker_temp == 0)
    {
        if (p_token_opt == 0)
        {
            return 0;
        }
        marker.file = p_token_opt->token_origin->lexeme;
        marker.line = p_token_opt->line;
        marker.start_col = p_token_opt->col;
        marker.end_col = p_token_opt->col;
        marker.p_token_caret = p_token_opt;
        included_file_location = p_token_opt->level > 0;
    }
    else
    {
        marker = *p_marker_temp;
        if (marker.p_token_caret)
        {
            p_token_opt = marker.p_token_caret;
        }
        else
        {
            if (marker.p_token_begin)
            {
                p_token_opt = marker.p_token_begin;
            }
        }
        if (p_token_opt == 0)
        {
            return 0;
        }
        marker.file = p_token_opt->token_origin->lexeme;
        included_file_location = p_token_opt->level > 0;
        marker.line = p_token_opt->line;
        marker.start_col = p_token_opt->col;
        marker.end_col = p_token_opt->col;
    }
    is_error = options_diagnostic_is_error(&ctx->options, w);
    is_warning = options_diagnostic_is_warning(&ctx->options, w);
    is_note = options_diagnostic_is_note(&ctx->options, w);
    if (is_error)
    {
        ctx->p_report->error_count++;
    }
    else
    {
        if (is_warning)
        {
            if (included_file_location)
            {
                return 0;
            }
            ctx->p_report->warnings_count++;
        }
        else
        {
            if (is_note)
            {
                if (included_file_location)
                {
                    return 0;
                }
                if (w != 0)
                {
                    ctx->p_report->info_count++;
                }
            }
            else
            {
                return 0;
            }
        }
    }
    func_name = "module";
    if (ctx->p_current_function_opt)
    {
        if (ctx->p_current_function_opt->name_opt)
        {
            func_name = ctx->p_current_function_opt->name_opt->lexeme;
        }
        else
        {
            func_name = "unnamed";
        }
    }
    _cake_zmem(&buffer, 200);
    print_position(marker.file, marker.line, marker.start_col, ctx->options.visual_studio_ouput_format, color_enabled);
    _cake_zmem(&args, 4);
    ((void)(args = (char *)(&(fmt)) + 4));
    vsnprintf(buffer, 200, fmt, args);
    ((void)(args = (char *)0));
    if (ctx->options.visual_studio_ouput_format)
    {
        if (is_error)
        {
            printf("error C%d: ", w);
        }
        else
        {
            if (is_warning)
            {
                printf("warning C%d: ", w);
            }
            else
            {
                if (is_note)
                {
                    printf("note: ");
                }
            }
        }
        printf("%s", buffer);
    }
    else
    {
        if (is_error)
        {
            if (color_enabled)
            {
                printf("\x1b[91merror \x1b[97mC%04d: %s\n\x1b[0m", w, buffer);
            }
            else
            {
                printf("error C%04d: %s\n", w, buffer);
            }
        }
        else
        {
            if (is_warning)
            {
                if (color_enabled)
                {
                    printf("\x1b[95mwarning \x1b[97mC%04d: %s\n\x1b[0m", w, buffer);
                }
                else
                {
                    printf("warning C%04d: %s\n", w, buffer);
                }
            }
            else
            {
                if (is_note)
                {
                    if (color_enabled)
                    {
                        printf("\x1b[36;1mnote: \x1b[97m%s\n\x1b[0m", buffer);
                    }
                    else
                    {
                        printf("note: %s\n", buffer);
                    }
                }
            }
        }
    }
    print_line_and_token(&marker, color_enabled);
    if (ctx->sarif_file)
    {
        char json_str_message[200];

        _cake_zmem(&json_str_message, 200);
        stringfy(buffer, json_str_message, 200);
        if (ctx->sarif_entries > 0)
        {
            fprintf(ctx->sarif_file, "   ,\n");
        }
        ((struct parser_ctx *)ctx)->sarif_entries++;
        fprintf(ctx->sarif_file, "   {\n");
        fprintf(ctx->sarif_file, "     \"ruleId\":\"C%d\",\n", w);
        if (is_error)
        {
            fprintf(ctx->sarif_file, "     \"level\":\"error\",\n");
        }
        else
        {
            if (is_warning)
            {
                fprintf(ctx->sarif_file, "     \"level\":\"warning\",\n");
            }
            else
            {
                if (is_note)
                {
                    fprintf(ctx->sarif_file, "     \"level\":\"note\",\n");
                }
            }
        }
        fprintf(ctx->sarif_file, "     \"message\": {\n");
        fprintf(ctx->sarif_file, "            \"text\": \"%s\"\n", json_str_message);
        fprintf(ctx->sarif_file, "      },\n");
        fprintf(ctx->sarif_file, "      \"locations\": [\n");
        fprintf(ctx->sarif_file, "       {\n");
        fprintf(ctx->sarif_file, "       \"physicalLocation\": {\n");
        fprintf(ctx->sarif_file, "             \"artifactLocation\": {\n");
        fprintf(ctx->sarif_file, "                 \"uri\": \"file:///%s\"\n", marker.file);
        fprintf(ctx->sarif_file, "              },\n");
        fprintf(ctx->sarif_file, "              \"region\": {\n");
        fprintf(ctx->sarif_file, "                  \"startLine\": %d,\n", marker.line);
        fprintf(ctx->sarif_file, "                  \"startColumn\": %d,\n", marker.start_col);
        fprintf(ctx->sarif_file, "                  \"endLine\": %d,\n", marker.line);
        fprintf(ctx->sarif_file, "                  \"endColumn\": %d\n", marker.end_col);
        fprintf(ctx->sarif_file, "               }\n");
        fprintf(ctx->sarif_file, "         },\n");
        fprintf(ctx->sarif_file, "         \"logicalLocations\": [\n");
        fprintf(ctx->sarif_file, "          {\n");
        fprintf(ctx->sarif_file, "              \"fullyQualifiedName\": \"%s\",\n", func_name);
        fprintf(ctx->sarif_file, "              \"decoratedName\": \"%s\",\n", func_name);
        fprintf(ctx->sarif_file, "              \"kind\": \"%s\"\n", "function");
        fprintf(ctx->sarif_file, "          }\n");
        fprintf(ctx->sarif_file, "         ]\n");
        fprintf(ctx->sarif_file, "       }\n");
        fprintf(ctx->sarif_file, "     ]\n");
        fprintf(ctx->sarif_file, "   }\n");
    }
    return 1;
}



static void stringfy(char * input, char * json_str_message, int output_size)
{
    int k;

    json_str_message[0] = 0;
    k = 0;
    while (*input != 0)
    {
        if (*input == 34)
        {
            if (k < output_size)
            {
                json_str_message[k] = 92;
            }
            k++;
            if (k < output_size)
            {
                json_str_message[k] = 34;
            }
            k++;
            input++;
        }
        else
        {
            if (*input == 10)
            {
                if (k < output_size)
                {
                    json_str_message[k] = 92;
                }
                k++;
                if (k < output_size)
                {
                    json_str_message[k] = 110;
                }
                k++;
                input++;
            }
            else
            {
                if (k < output_size)
                {
                    json_str_message[k] = *input;
                }
                k++;
                input++;
            }
        }
    }
    if (k < output_size)
    {
        json_str_message[k] = 0;
    }
    else
    {
        json_str_message[output_size - 1] = 0;
    }
}

static int __cdecl fprintf(struct _iobuf * _Stream, char * _Format, ...)
{
    int _Result;
    char * _ArgList;

    ((void)(_ArgList = (char *)(&(_Format)) + 4));
    _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (char *)0));
    return _Result;
}
void print_scope(struct scope_list * e)
{
    struct scope * p;
    int level;

    printf("--- begin of scope---\n");
    p = e->head;
    level = 0;
    while (p)
    {
        if (p->variables.table)
        {
            {
                int i;

                i = 0;
                for (; i < p->variables.capacity; i++)
                {
                    if (p->variables.table[i])
                    {
                        {
                            int k;

                            k = 0;
                            for (; k < level; k++)
                            printf(" ");
                        }
                        printf("%s\n", p->variables.table[i]->key);
                    }
                }
            }
            {
                int i;

                i = 0;
                for (; i < p->tags.capacity; i++)
                {
                    if (p->tags.table[i])
                    {
                        {
                            int k;

                            k = 0;
                            for (; k < level; k++)
                            printf(" ");
                        }
                        printf("tag %s\n", p->tags.table[i]->key);
                    }
                }
            }
        }
        level++;
        p = p->next;
    }
    printf("--- end of scope---\n");
}


unsigned char first_of_function_specifier(struct parser_ctx * ctx)
{
    struct token * token;

    token = ctx->current;
    if (token == 0)
    {
        return 0;
    }
    return token->type == 9018 || token->type == 9072;
}


unsigned char first_of_enum_specifier_token(struct token * token)
{
    return token->type == 9012;
}


unsigned char first_of_enum_specifier(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return first_of_enum_specifier_token(ctx->current);
}


unsigned char first_of_alignment_specifier(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 9043;
}


unsigned char first_of_atomic_type_specifier(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    if (ctx->current->type == 9045)
    {
        struct token * ahead;

        ahead = parser_look_ahead(ctx);
        if (ahead != 0)
        {
            return ahead->type == 40;
        }
    }
    return 0;
}


unsigned char first_of_storage_class_specifier(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 9035 || ctx->current->type == 9002 || ctx->current->type == 9013 || ctx->current->type == 9032 || ctx->current->type == 9075 || ctx->current->type == 8999 || ctx->current->type == 9025;
}


unsigned char first_of_struct_or_union_token(struct token * token)
{
    return token->type == 9033 || token->type == 9038;
}


unsigned char first_of_struct_or_union(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return first_of_struct_or_union_token(ctx->current);
}


unsigned char first_of_type_qualifier_token(struct token * p_token)
{
    return p_token->type == 9004 || p_token->type == 9026 || p_token->type == 9041 || p_token->type == 9045 || p_token->type == 9053 || p_token->type == 9054 || p_token->type == 9055 || p_token->type == 9083 || p_token->type == 9082 || p_token->type == 9084 || p_token->type == 9085 || p_token->type == 9086;
}


unsigned char first_of_type_qualifier(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    if (ctx->current->type == 9004)
    {
        struct token * ahead;

        ahead = parser_look_ahead(ctx);
        if (ahead && ahead->type == 40)
        {
            return 0;
        }
    }
    return first_of_type_qualifier_token(ctx->current);
}


struct map_entry *find_tag(struct parser_ctx * ctx, char * lexeme)
{
    struct scope * scope;

    scope = ctx->scopes.tail;
    while (scope)
    {
        struct map_entry * p_entry;

        p_entry = hashmap_find(&scope->tags, lexeme);
        if (p_entry)
        {
            return p_entry;
        }
        scope = scope->previous;
    }
    return 0;
}


struct map_entry *find_variables(struct parser_ctx * ctx, char * lexeme, struct scope ** ppscope_opt)
{
    struct scope * scope;

    if (ppscope_opt != 0)
    {
        *ppscope_opt = 0;
    }
    scope = ctx->scopes.tail;
    while (scope)
    {
        struct map_entry * p_entry;

        p_entry = hashmap_find(&scope->variables, lexeme);
        if (p_entry)
        {
            if (ppscope_opt)
            {
                *ppscope_opt = scope;
            }
            return p_entry;
        }
        scope = scope->previous;
    }
    return 0;
}


struct enum_specifier *find_enum_specifier(struct parser_ctx * ctx, char * lexeme)
{
    struct enum_specifier * best;
    struct scope * scope;

    best = 0;
    scope = ctx->scopes.tail;
    while (scope)
    {
        struct map_entry * p_entry;

        p_entry = hashmap_find(&scope->tags, lexeme);
        if (p_entry && p_entry->type == 1)
        {
            ;
            best = p_entry->data.p_enum_specifier;
            if (best->enumerator_list.head != 0)
            {
                return best;
            }
            else
            {
            }
        }
        scope = scope->previous;
    }
    return best;
}


struct struct_or_union_specifier *find_struct_or_union_specifier(struct parser_ctx * ctx, char * lexeme)
{
    struct struct_or_union_specifier * p;
    struct scope * scope;

    p = 0;
    scope = ctx->scopes.tail;
    while (scope)
    {
        struct map_entry * p_entry;

        p_entry = hashmap_find(&scope->tags, lexeme);
        if (p_entry && p_entry->type == 2)
        {
            ;
            p = p_entry->data.p_struct_or_union_specifier;
            break;
        }
        scope = scope->previous;
    }
    return p;
}


struct declarator *find_declarator(struct parser_ctx * ctx, char * lexeme, struct scope ** ppscope_opt)
{
    struct map_entry * p_entry;

    p_entry = find_variables(ctx, lexeme, ppscope_opt);
    if (p_entry)
    {
        if (p_entry->type == 5)
        {
            struct init_declarator * p_init_declarator;

            ;
            p_init_declarator = p_entry->data.p_init_declarator;
            return (struct declarator *)p_init_declarator->p_declarator;
        }
        else
        {
            if (p_entry->type == 4)
            {
                return p_entry->data.p_declarator;
            }
        }
    }
    return 0;
}


struct enumerator *find_enumerator(struct parser_ctx * ctx, char * lexeme, struct scope ** ppscope_opt)
{
    struct map_entry * p_entry;

    p_entry = find_variables(ctx, lexeme, ppscope_opt);
    if (p_entry && p_entry->type == 3)
    {
        return p_entry->data.p_enumerator;
    }
    return 0;
}


unsigned char first_of_typedef_name(struct parser_ctx * ctx, struct token * p_token)
{
    struct declarator * p_declarator;

    if (p_token->type != 8996)
    {
        return 0;
    }
    if (p_token->flags & 16)
    {
        return 1;
    }
    if (p_token->flags & 32)
    {
        return 0;
    }
    p_declarator = find_declarator(ctx, p_token->lexeme, 0);
    if (p_declarator && p_declarator->declaration_specifiers && (p_declarator->declaration_specifiers->storage_class_specifier_flags & 1))
    {
        p_declarator->num_uses++;
        p_token->flags |= 16;
        return 1;
    }
    else
    {
        p_token->flags |= 32;
    }
    return 0;
}


unsigned char first_of_type_specifier_token(struct parser_ctx * ctx, struct token * token);

unsigned char first_of_type_name_ahead(struct parser_ctx * ctx)
{
    struct token * token_ahead;

    if (ctx->current == 0)
    {
        return 0;
    }
    if (ctx->current->type != 40)
    {
        return 0;
    }
    token_ahead = parser_look_ahead(ctx);
    if (token_ahead == 0)
    {
        return 0;
    }
    return first_of_type_specifier_token(ctx, token_ahead) || first_of_type_qualifier_token(token_ahead);
}


unsigned char first_of_type_specifier(struct parser_ctx * ctx);

unsigned char first_of_type_name(struct parser_ctx * ctx)
{
    return first_of_type_specifier(ctx) || first_of_type_qualifier(ctx);
}


unsigned char first_of_type_specifier_token(struct parser_ctx * ctx, struct token * p_token)
{
    return p_token->type == 9040 || p_token->type == 9003 || p_token->type == 9028 || p_token->type == 9019 || p_token->type == 9020 || p_token->type == 9014 || p_token->type == 9010 || p_token->type == 9029 || p_token->type == 9039 || p_token->type == 9081 || p_token->type == 9065 || p_token->type == 9066 || p_token->type == 9068 || p_token->type == 9069 || p_token->type == 9067 || p_token->type == 9076 || p_token->type == 9080 || p_token->type == 9047 || p_token->type == 9021 || p_token->type == 9022 || p_token->type == 9023 || p_token->type == 9024 || first_of_atomic_type_specifier(ctx) || first_of_struct_or_union_token(p_token) || first_of_enum_specifier_token(p_token) || first_of_typedef_name(ctx, p_token);
}


unsigned char first_of_type_specifier(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return first_of_type_specifier_token(ctx, ctx->current);
}


unsigned char first_of_type_specifier_qualifier(struct parser_ctx * ctx)
{
    return first_of_type_specifier(ctx) || first_of_type_qualifier(ctx) || first_of_alignment_specifier(ctx);
}


unsigned char first_of_compound_statement(struct parser_ctx * ctx)
{
    return ctx->current != 0 && ctx->current->type == 123;
}


unsigned char first_of_jump_statement(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 9016 || ctx->current->type == 9005 || ctx->current->type == 9000 || ctx->current->type == 9027 || ctx->current->type == 9037;
}


unsigned char first_of_selection_statement(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 9017 || ctx->current->type == 9034;
}


unsigned char first_of_iteration_statement(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 9042 || ctx->current->type == 9008 || ctx->current->type == 9015;
}


unsigned char first_of_label(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    if (ctx->current->type == 8996)
    {
        struct token * next;

        next = parser_look_ahead(ctx);
        return next && next->type == 58;
    }
    else
    {
        if (ctx->current->type == 9001)
        {
            return 1;
        }
        else
        {
            if (ctx->current->type == 9007)
            {
                return 1;
            }
        }
    }
    return 0;
}


unsigned char first_of_declaration_specifier(struct parser_ctx * ctx)
{
    return first_of_storage_class_specifier(ctx) || first_of_function_specifier(ctx) || first_of_type_specifier_qualifier(ctx);
}


unsigned char first_of_pragma_declaration(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 128;
}


unsigned char first_of_static_assert_declaration(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 9073 || ctx->current->type == 9087 || ctx->current->type == 9088 || ctx->current->type == 9089 || ctx->current->type == 9090;
}


unsigned char first_of_attribute_specifier(struct parser_ctx * ctx)
{
    struct token * p_token;

    if (ctx->current == 0)
    {
        return 0;
    }
    if (ctx->options.target == 0 && ctx->current->type == 9064)
    {
        return 1;
    }
    if (ctx->current->type == 9059)
    {
        return 1;
    }
    if (ctx->current->type == 9046)
    {
        return 1;
    }
    if (ctx->current->type != 91)
    {
        return 0;
    }
    p_token = parser_look_ahead(ctx);
    return p_token != 0 && p_token->type == 91;
}


unsigned char first_of_labeled_statement(struct parser_ctx * ctx)
{
    return first_of_label(ctx);
}


unsigned char first_of_designator(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 91 || ctx->current->type == 46;
}


struct token *previous_parser_token(struct token * token)
{
    struct token * prev;

    if (token->prev == 0)
    {
        return 0;
    }
    prev = token->prev;
    while (prev && !(prev->flags & 1))
    {
        prev = prev->prev;
    }
    return prev;
}


char *__cdecl strstr(char * _Str, char * _SubStr);

int is_keyword(char * text, int target)
{
    /*switch*/
    {
        char __v0 = text[0];
        if (__v0 == 97) goto __L1; /*case 97*/
        if (__v0 == 98) goto __L8; /*case 98*/
        if (__v0 == 99) goto __L11; /*case 99*/
        if (__v0 == 100) goto __L18; /*case 100*/
        if (__v0 == 101) goto __L23; /*case 101*/
        if (__v0 == 102) goto __L27; /*case 102*/
        if (__v0 == 103) goto __L31; /*case 103*/
        if (__v0 == 105) goto __L33; /*case 105*/
        if (__v0 == 110) goto __L37; /*case 110*/
        if (__v0 == 111) goto __L39; /*case 111*/
        if (__v0 == 108) goto __L41; /*case 108*/
        if (__v0 == 114) goto __L43; /*case 114*/
        if (__v0 == 115) goto __L47; /*case 115*/
        if (__v0 == 116) goto __L59; /*case 116*/
        if (__v0 == 117) goto __L67; /*case 117*/
        if (__v0 == 118) goto __L70; /*case 118*/
        if (__v0 == 119) goto __L73; /*case 119*/
        if (__v0 == 95) goto __L75; /*case 95*/
        goto __L138; /* default */

        {
            __L1: /*case 97*/ 
            if (strcmp("alignof", text) == 0)
            {
                return 9044;
            }
            if (strcmp("auto", text) == 0)
            {
                return 8999;
            }
            if (strcmp("alignas", text) == 0)
            {
                return 9043;
            }
            if (strcmp("alignof", text) == 0)
            {
                return 9043;
            }
            if (strcmp("assert", text) == 0)
            {
                return 9074;
            }
            if (strcmp("asm", text) == 0)
            {
                return 9064;
            }
            goto __L0; /* break */

            __L8: /*case 98*/ 
            if (strcmp("break", text) == 0)
            {
                return 9000;
            }
            if (strcmp("bool", text) == 0)
            {
                return 9065;
            }
            goto __L0; /* break */

            __L11: /*case 99*/ 
            if (strcmp("case", text) == 0)
            {
                return 9001;
            }
            if (strcmp("char", text) == 0)
            {
                return 9003;
            }
            if (strcmp("const", text) == 0)
            {
                return 9004;
            }
            if (strcmp("constexpr", text) == 0)
            {
                return 9002;
            }
            if (strcmp("continue", text) == 0)
            {
                return 9005;
            }
            if (strcmp("catch", text) == 0)
            {
                return 9006;
            }
            goto __L0; /* break */

            __L18: /*case 100*/ 
            if (strcmp("default", text) == 0)
            {
                return 9007;
            }
            if (strcmp("do", text) == 0)
            {
                return 9008;
            }
            if (strcmp("defer", text) == 0)
            {
                return 9009;
            }
            if (strcmp("double", text) == 0)
            {
                return 9010;
            }
            goto __L0; /* break */

            __L23: /*case 101*/ 
            if (strcmp("else", text) == 0)
            {
                return 9011;
            }
            if (strcmp("enum", text) == 0)
            {
                return 9012;
            }
            if (strcmp("extern", text) == 0)
            {
                return 9013;
            }
            goto __L0; /* break */

            __L27: /*case 102*/ 
            if (strcmp("float", text) == 0)
            {
                return 9014;
            }
            if (strcmp("for", text) == 0)
            {
                return 9015;
            }
            if (strcmp("false", text) == 0)
            {
                return 9078;
            }
            goto __L0; /* break */

            __L31: /*case 103*/ 
            if (strcmp("goto", text) == 0)
            {
                return 9016;
            }
            goto __L0; /* break */

            __L33: /*case 105*/ 
            if (strcmp("if", text) == 0)
            {
                return 9017;
            }
            if (strcmp("inline", text) == 0)
            {
                return 9018;
            }
            if (strcmp("int", text) == 0)
            {
                return 9019;
            }
            goto __L0; /* break */

            __L37: /*case 110*/ 
            if (strcmp("nullptr", text) == 0)
            {
                return 9079;
            }
            goto __L0; /* break */

            __L39: /*case 111*/ 
            if (strcmp("offsetof", text) == 0)
            {
                return 9052;
            }
            goto __L0; /* break */

            __L41: /*case 108*/ 
            if (strcmp("long", text) == 0)
            {
                return 9020;
            }
            goto __L0; /* break */

            __L43: /*case 114*/ 
            if (strcmp("register", text) == 0)
            {
                return 9025;
            }
            if (strcmp("restrict", text) == 0)
            {
                return 9026;
            }
            if (strcmp("return", text) == 0)
            {
                return 9027;
            }
            goto __L0; /* break */

            __L47: /*case 115*/ 
            if (strcmp("short", text) == 0)
            {
                return 9028;
            }
            if (strcmp("signed", text) == 0)
            {
                return 9029;
            }
            if (strcmp("sizeof", text) == 0)
            {
                return 9030;
            }
            if (strcmp("static", text) == 0)
            {
                return 9032;
            }
            if (strcmp("struct", text) == 0)
            {
                return 9033;
            }
            if (strcmp("switch", text) == 0)
            {
                return 9034;
            }
            if (strcmp("static_assert", text) == 0)
            {
                return 9073;
            }
            if (strcmp("static_debug", text) == 0)
            {
                return 9087;
            }
            if (strcmp("static_debug_ex", text) == 0)
            {
                return 9088;
            }
            if (strcmp("static_state", text) == 0)
            {
                return 9089;
            }
            if (strcmp("static_set", text) == 0)
            {
                return 9090;
            }
            goto __L0; /* break */

            __L59: /*case 116*/ 
            if (strcmp("typedef", text) == 0)
            {
                return 9035;
            }
            if (strcmp("typeof", text) == 0)
            {
                return 9076;
            }
            if (strcmp("typeof_unqual", text) == 0)
            {
                return 9080;
            }
            if (strcmp("true", text) == 0)
            {
                return 9077;
            }
            if (strcmp("thread_local", text) == 0)
            {
                return 9075;
            }
            if (strcmp("try", text) == 0)
            {
                return 9036;
            }
            if (strcmp("throw", text) == 0)
            {
                return 9037;
            }
            goto __L0; /* break */

            __L67: /*case 117*/ 
            if (strcmp("union", text) == 0)
            {
                return 9038;
            }
            if (strcmp("unsigned", text) == 0)
            {
                return 9039;
            }
            goto __L0; /* break */

            __L70: /*case 118*/ 
            if (strcmp("void", text) == 0)
            {
                return 9040;
            }
            if (strcmp("volatile", text) == 0)
            {
                return 9041;
            }
            goto __L0; /* break */

            __L73: /*case 119*/ 
            if (strcmp("while", text) == 0)
            {
                return 9042;
            }
            goto __L0; /* break */

            __L75: /*case 95*/ 
            if (strcmp("_Ctor", text) == 0)
            {
                return 9083;
            }
            if (strcmp("_Owner", text) == 0)
            {
                return 9082;
            }
            if (strcmp("_Dtor", text) == 0)
            {
                return 9084;
            }
            if (strcmp("_Opt", text) == 0)
            {
                return 9086;
            }
            if (strcmp("_View", text) == 0)
            {
                return 9085;
            }
            if (strcmp("_Countof", text) == 0)
            {
                return 9031;
            }
            if (strcmp("_is_lvalue", text) == 0)
            {
                return 9092;
            }
            if (strcmp("_is_const", text) == 0)
            {
                return 9093;
            }
            if (strcmp("_is_owner", text) == 0)
            {
                return 9094;
            }
            if (strcmp("_is_pointer", text) == 0)
            {
                return 9091;
            }
            if (strcmp("_is_array", text) == 0)
            {
                return 9095;
            }
            if (strcmp("_is_function", text) == 0)
            {
                return 9096;
            }
            if (strcmp("_is_arithmetic", text) == 0)
            {
                return 9098;
            }
            if (strcmp("_is_floating_point", text) == 0)
            {
                return 9099;
            }
            if (strcmp("_is_integral", text) == 0)
            {
                return 9100;
            }
            if (strcmp("_is_scalar", text) == 0)
            {
                return 9097;
            }
            if (strcmp("_Alignof", text) == 0)
            {
                return 9044;
            }
            if (strcmp("_Alignas", text) == 0)
            {
                return 9043;
            }
            if (strcmp("_Atomic", text) == 0)
            {
                return 9045;
            }
            if (strcmp("__builtin_va_list", text) == 0)
            {
                return 9047;
            }
            if (strcmp("__attribute__", text) == 0)
            {
                return 9046;
            }
            if (strcmp("__builtin_offsetof", text) == 0)
            {
                return 9052;
            }
            if (strcmp("__builtin_va_end", text) == 0)
            {
                return 9048;
            }
            if (strcmp("__builtin_va_arg", text) == 0)
            {
                return 9049;
            }
            if (strcmp("__builtin_c23_va_start", text) == 0)
            {
                return 9050;
            }
            if (strcmp("__builtin_va_start", text) == 0)
            {
                return 9050;
            }
            if (strcmp("__builtin_va_copy", text) == 0)
            {
                return 9051;
            }
            if (strstr(text, "__volatile__") != 0)
            {
                return 9041;
            }
            if (strcmp("_Bool", text) == 0)
            {
                return 9065;
            }
            if (strcmp("_Complex", text) == 0)
            {
                return 9066;
            }
            if (strcmp("_Decimal32", text) == 0)
            {
                return 9068;
            }
            if (strcmp("_Decimal64", text) == 0)
            {
                return 9069;
            }
            if (strcmp("_Decimal128", text) == 0)
            {
                return 9067;
            }
            if (strcmp("_Generic", text) == 0)
            {
                return 9070;
            }
            if (strcmp("_Imaginary", text) == 0)
            {
                return 9071;
            }
            if (strcmp("_Noreturn", text) == 0)
            {
                return 9072;
            }
            if (strcmp("_Static_assert", text) == 0)
            {
                return 9073;
            }
            if (strcmp("_Thread_local", text) == 0)
            {
                return 9075;
            }
            if (strcmp("_BitInt", text) == 0)
            {
                return 9081;
            }
            if (strcmp("__typeof__", text) == 0)
            {
                return 9076;
            }
            if (strcmp("__asm__", text) == 0 || strcmp("_asm", text) == 0 || strcmp("__asm", text) == 0)
            {
                return 9064;
            }
            if (strcmp("__restrict", text) == 0)
            {
                return 9026;
            }
            if (strcmp("__inline", text) == 0 || strcmp("__inline__", text) == 0)
            {
                return 9018;
            }
            if (strcmp("__alignof__", text) == 0)
            {
                return 9044;
            }
            if (target == 1 || target == 2)
            {
                if (strcmp("__ptr32", text) == 0)
                {
                    return 9053;
                }
                if (strcmp("__ptr64", text) == 0)
                {
                    return 9054;
                }
                if (strcmp("__unaligned", text) == 0)
                {
                    return 9055;
                }
                if (strcmp("__try", text) == 0)
                {
                    return 9060;
                }
                if (strcmp("__except", text) == 0)
                {
                    return 9061;
                }
                if (strcmp("__finally", text) == 0)
                {
                    return 9062;
                }
                if (strcmp("__leave", text) == 0)
                {
                    return 9063;
                }
                if (strcmp("__int8", text) == 0)
                {
                    return 9021;
                }
                if (strcmp("__int16", text) == 0)
                {
                    return 9022;
                }
                if (strcmp("__int32", text) == 0)
                {
                    return 9023;
                }
                if (strcmp("__int64", text) == 0)
                {
                    return 9024;
                }
                if (strcmp("__forceinline", text) == 0)
                {
                    return 9018;
                }
                if (strcmp("__stdcall", text) == 0 || strcmp("_stdcall", text) == 0)
                {
                    return 9057;
                }
                if (strcmp("__cdecl", text) == 0)
                {
                    return 9058;
                }
                if (strcmp("__fastcall", text) == 0)
                {
                    return 9056;
                }
                if (strcmp("__alignof", text) == 0)
                {
                    return 9044;
                }
                if (strcmp("__declspec", text) == 0)
                {
                    return 9059;
                }
            }
            goto __L0; /* break */

            __L138: /* default */ 
            goto __L0; /* break */

        }
        __L0:;
    }
    return 0;
}


static void token_promote(struct parser_ctx * ctx, struct token * token);

struct token *parser_look_ahead(struct parser_ctx * ctx)
{
    struct token * p;

    if (ctx->current == 0)
    {
        return 0;
    }
    p = ctx->current->next;
    while (p && !(p->flags & 1))
    {
        p = p->next;
    }
    if (p)
    {
        token_promote(ctx, p);
    }
    return p;
}



static void token_promote(struct parser_ctx * ctx, struct token * token)
{
    if (token->type == 8997)
    {
        token->type = 8996;
    }
    if (token->type == 8996)
    {
        int t;

        t = is_keyword(token->lexeme, ctx->options.target);
        if (t != 0)
        {
            token->type = t;
        }
    }
    else
    {
        if (token->type == 134)
        {
            char errormsg[100];
            char suffix[4];

            _cake_zmem(&errormsg, 100);
            _cake_zmem(&suffix, 4);
            token->type = parse_number(token->lexeme, suffix, errormsg);
            if (token->type == 0)
            {
                compiler_diagnostic(1380, ctx, token, 0, errormsg);
            }
        }
    }
}
static void parser_skip_blanks(struct parser_ctx * ctx);

void parser_match(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return;
    }
    ctx->previous = ctx->current;
    ctx->current = ctx->current->next;
    parser_skip_blanks(ctx);
}



static void parser_skip_blanks(struct parser_ctx * ctx)
{
    while (ctx->current && !(ctx->current->flags & 1))
    {
        if (ctx->current)
        {
            ctx->current = ctx->current->next;
        }
    }
    if (ctx->current)
    {
        token_promote(ctx, ctx->current);
    }
}
void unexpected_end_of_file(struct parser_ctx * ctx)
{
    compiler_diagnostic(970, ctx, ctx->input_list.tail, 0, "unexpected end of file");
}


int parser_match_tk(struct parser_ctx * ctx, int type)
{
    int error;

    error = 0;
    if (ctx->current != 0)
    {
        if (ctx->current->type != type)
        {
            compiler_diagnostic(970, ctx, ctx->current, 0, "expected token '%s', got '%s' ", get_diagnostic_friendly_token_name(type), get_diagnostic_friendly_token_name(ctx->current->type));
            error = 1;
        }
        ctx->previous = ctx->current;
        ctx->current = ctx->current->next;
        parser_skip_blanks(ctx);
    }
    else
    {
        compiler_diagnostic(970, ctx, ctx->input_list.tail, 0, "unexpected end of file after");
        error = 1;
    }
    return error;
}


void print_type_qualifier_flags(struct osstream * ss, unsigned char * first, int e_type_qualifier_flags);
void print_item(struct osstream * ss, unsigned char * first, char * item);
unsigned char print_type_specifier_flags(struct osstream * ss, unsigned char * first, int e_type_specifier_flags);

void print_declaration_specifiers(struct osstream * ss, struct declaration_specifiers * p_declaration_specifiers)
{
    unsigned char  first;

    first = 1;
    print_type_qualifier_flags(ss, &first, p_declaration_specifiers->type_qualifier_flags);
    if (p_declaration_specifiers->enum_specifier)
    {
        if (p_declaration_specifiers->enum_specifier->tag_token)
        {
            ss_fprintf(ss, "enum %s", p_declaration_specifiers->enum_specifier->tag_token->lexeme);
        }
        else
        {
            ;
        }
    }
    else
    {
        if (p_declaration_specifiers->struct_or_union_specifier)
        {
            ss_fprintf(ss, "struct %s", p_declaration_specifiers->struct_or_union_specifier->tag_name);
        }
        else
        {
            if (p_declaration_specifiers->typedef_declarator)
            {
                if (p_declaration_specifiers->typedef_declarator->name_opt)
                {
                    print_item(ss, &first, p_declaration_specifiers->typedef_declarator->name_opt->lexeme);
                }
            }
            else
            {
                print_type_specifier_flags(ss, &first, p_declaration_specifiers->type_specifier_flags);
            }
        }
    }
}


unsigned char type_specifier_is_integer(int flags)
{
    if ((flags & 2) || (flags & 4) || (flags & 8) || (flags & 16) || (flags & 8) || (flags & 4194304))
    {
        return 1;
    }
    return 0;
}


int final_specifier(struct parser_ctx * ctx, int * flags)
{
    if (((*flags) & 256) || ((*flags) & 128))
    {
        if (!type_specifier_is_integer(*flags))
        {
            (*flags) |= 8;
        }
    }
    return 0;
}


int add_specifier(struct parser_ctx * ctx, int * flags, int new_flag)
{
    if (new_flag & 16)
    {
        if ((*flags) & 4194304)
        {
            compiler_diagnostic(980, ctx, ctx->current, 0, "cannot combine with previous 'long long' declaration specifier");
            return 1;
        }
        else
        {
            if ((*flags) & 16)
            {
                (*flags) = (*flags) & -17;
                (*flags) |= 4194304;
            }
            else
            {
                (*flags) = (*flags) & -9;
                (*flags) |= 16;
            }
        }
    }
    else
    {
        (*flags) |= new_flag;
    }
    /*switch*/
    {
        unsigned int __v0 = (unsigned int)*flags;
        if (__v0 == 0) goto __L4; /*case 0*/
        if (__v0 == 1) goto __L5; /*case 1*/
        if (__v0 == 33554432) goto __L6; /*case 33554432*/
        if (__v0 == 2) goto __L7; /*case 2*/
        if (__v0 == 130) goto __L8; /*case 130*/
        if (__v0 == 258) goto __L9; /*case 258*/
        if (__v0 == 4) goto __L10; /*case 4*/
        if (__v0 == 132) goto __L11; /*case 132*/
        if (__v0 == 12) goto __L12; /*case 12*/
        if (__v0 == 140) goto __L13; /*case 140*/
        if (__v0 == 260) goto __L14; /*case 260*/
        if (__v0 == 268) goto __L15; /*case 268*/
        if (__v0 == 8) goto __L16; /*case 8*/
        if (__v0 == 128) goto __L17; /*case 128*/
        if (__v0 == 136) goto __L18; /*case 136*/
        if (__v0 == 256) goto __L19; /*case 256*/
        if (__v0 == 264) goto __L20; /*case 264*/
        if (__v0 == 16) goto __L21; /*case 16*/
        if (__v0 == 144) goto __L22; /*case 144*/
        if (__v0 == 24) goto __L23; /*case 24*/
        if (__v0 == 152) goto __L24; /*case 152*/
        if (__v0 == 272) goto __L25; /*case 272*/
        if (__v0 == 280) goto __L26; /*case 280*/
        if (__v0 == 4194304) goto __L27; /*case 4194304*/
        if (__v0 == 4194432) goto __L28; /*case 4194432*/
        if (__v0 == 4194312) goto __L29; /*case 4194312*/
        if (__v0 == 4194440) goto __L30; /*case 4194440*/
        if (__v0 == 4194560) goto __L31; /*case 4194560*/
        if (__v0 == 4194568) goto __L32; /*case 4194568*/
        if (__v0 == 32) goto __L33; /*case 32*/
        if (__v0 == 64) goto __L34; /*case 64*/
        if (__v0 == 80) goto __L35; /*case 80*/
        if (__v0 == 2048) goto __L36; /*case 2048*/
        if (__v0 == 4096) goto __L37; /*case 4096*/
        if (__v0 == 8192) goto __L38; /*case 8192*/
        if (__v0 == 512) goto __L39; /*case 512*/
        if (__v0 == 1056) goto __L40; /*case 1056*/
        if (__v0 == 1088) goto __L41; /*case 1088*/
        if (__v0 == 1104) goto __L42; /*case 1104*/
        if (__v0 == 16384) goto __L43; /*case 16384*/
        if (__v0 == 32768) goto __L44; /*case 32768*/
        if (__v0 == 65536) goto __L45; /*case 65536*/
        if (__v0 == 8388608) goto __L46; /*case 8388608*/
        if (__v0 == 131072) goto __L47; /*case 131072*/
        goto __L48; /* default */

        {
            __L4: /*case 0*/ 
            __L5: /*case 1*/ 
            __L6: /*case 33554432*/ 
            __L7: /*case 2*/ 
            __L8: /*case 130*/ 
            __L9: /*case 258*/ 
            __L10: /*case 4*/ 
            __L11: /*case 132*/ 
            __L12: /*case 12*/ 
            __L13: /*case 140*/ 
            __L14: /*case 260*/ 
            __L15: /*case 268*/ 
            __L16: /*case 8*/ 
            __L17: /*case 128*/ 
            __L18: /*case 136*/ 
            __L19: /*case 256*/ 
            __L20: /*case 264*/ 
            __L21: /*case 16*/ 
            __L22: /*case 144*/ 
            __L23: /*case 24*/ 
            __L24: /*case 152*/ 
            __L25: /*case 272*/ 
            __L26: /*case 280*/ 
            __L27: /*case 4194304*/ 
            __L28: /*case 4194432*/ 
            __L29: /*case 4194312*/ 
            __L30: /*case 4194440*/ 
            __L31: /*case 4194560*/ 
            __L32: /*case 4194568*/ 
            __L33: /*case 32*/ 
            __L34: /*case 64*/ 
            __L35: /*case 80*/ 
            __L36: /*case 2048*/ 
            __L37: /*case 4096*/ 
            __L38: /*case 8192*/ 
            __L39: /*case 512*/ 
            __L40: /*case 1056*/ 
            __L41: /*case 1088*/ 
            __L42: /*case 1104*/ 
            __L43: /*case 16384*/ 
            __L44: /*case 32768*/ 
            __L45: /*case 65536*/ 
            __L46: /*case 8388608*/ 
            __L47: /*case 131072*/ 
            goto __L3; /* break */

            __L48: /* default */ 
            compiler_diagnostic(1300, ctx, ctx->current, 0, "incompatible specifiers");
            return 1;
        }
        __L3:;
    }
    return 0;
}


void attribute_specifier_sequence_delete(struct attribute_specifier_sequence * p);
void declaration_specifier_delete(struct declaration_specifier * p);

void declaration_specifiers_delete(struct declaration_specifiers * p)
{
    if (p)
    {
        struct declaration_specifier * item;

        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence);
        item = p->head;
        while (item)
        {
            struct declaration_specifier * next;

            next = item->next;
            item->next = 0;
            declaration_specifier_delete(item);
            item = next;
        }
        free(p);
    }
}


void declaration_specifiers_add(struct declaration_specifiers * list, struct declaration_specifier * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


struct declaration_specifier *declaration_specifier(struct parser_ctx * ctx);
struct attribute_specifier_sequence *attribute_specifier_sequence_opt(struct parser_ctx * ctx);

struct declaration_specifiers *declaration_specifiers(struct parser_ctx * ctx, int default_storage_flag)
{
    struct declaration_specifiers * p_declaration_specifiers;

    if (ctx->current == 0)
    {
        return 0;
    }
    p_declaration_specifiers = calloc(1, 64);
    if (1) /*try*/
    {
        struct token * prev;

        if (p_declaration_specifiers == 0)
        {
            goto __L1; /* throw */
        }
        p_declaration_specifiers->first_token = ctx->current;
        while (first_of_declaration_specifier(ctx))
        {
            struct declaration_specifier * p_declaration_specifier;

            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L1; /* throw */
            }
            if (ctx->current->flags & 16)
            {
                if (p_declaration_specifiers->type_specifier_flags != 0)
                {
                    break;
                }
            }
            p_declaration_specifier = declaration_specifier(ctx);
            if (p_declaration_specifier == 0)
            {
                goto __L1; /* throw */
            }
            if (p_declaration_specifier->type_specifier_qualifier)
            {
                if (p_declaration_specifier->type_specifier_qualifier->type_specifier)
                {
                    if (add_specifier(ctx, &p_declaration_specifiers->type_specifier_flags, p_declaration_specifier->type_specifier_qualifier->type_specifier->flags) != 0)
                    {
                    }
                    if (p_declaration_specifier->type_specifier_qualifier->type_specifier->struct_or_union_specifier)
                    {
                        p_declaration_specifiers->struct_or_union_specifier = p_declaration_specifier->type_specifier_qualifier->type_specifier->struct_or_union_specifier;
                    }
                    else
                    {
                        if (p_declaration_specifier->type_specifier_qualifier->type_specifier->enum_specifier)
                        {
                            p_declaration_specifiers->enum_specifier = p_declaration_specifier->type_specifier_qualifier->type_specifier->enum_specifier;
                        }
                        else
                        {
                            if (p_declaration_specifier->type_specifier_qualifier->type_specifier->typeof_specifier)
                            {
                                p_declaration_specifiers->typeof_specifier = p_declaration_specifier->type_specifier_qualifier->type_specifier->typeof_specifier;
                            }
                            else
                            {
                                if (p_declaration_specifier->type_specifier_qualifier->type_specifier->token->type == 8996)
                                {
                                    p_declaration_specifiers->typedef_declarator = find_declarator(ctx, p_declaration_specifier->type_specifier_qualifier->type_specifier->token->lexeme, 0);
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (p_declaration_specifier->type_specifier_qualifier->alignment_specifier)
                    {
                        p_declaration_specifiers->alignment_specifier_flags = p_declaration_specifier->type_specifier_qualifier->alignment_specifier->flags;
                    }
                    else
                    {
                        if (p_declaration_specifier->type_specifier_qualifier->type_qualifier)
                        {
                            p_declaration_specifiers->type_qualifier_flags |= p_declaration_specifier->type_specifier_qualifier->type_qualifier->flags;
                        }
                    }
                }
            }
            else
            {
                if (p_declaration_specifier->storage_class_specifier)
                {
                    p_declaration_specifiers->storage_class_specifier_flags |= p_declaration_specifier->storage_class_specifier->flags;
                }
                else
                {
                    if (p_declaration_specifier->function_specifier)
                    {
                        p_declaration_specifiers->function_specifier_flags |= p_declaration_specifier->function_specifier->flags;
                    }
                    else
                    {
                        if (p_declaration_specifier->alignment_specifier)
                        {
                            p_declaration_specifiers->alignment_specifier_flags |= p_declaration_specifier->alignment_specifier->flags;
                        }
                    }
                }
            }
            declaration_specifiers_add(p_declaration_specifiers, p_declaration_specifier);
            if (p_declaration_specifiers->p_attribute_specifier_sequence == 0)
            {
                attribute_specifier_sequence_delete(p_declaration_specifiers->p_attribute_specifier_sequence);
                p_declaration_specifiers->p_attribute_specifier_sequence = 0;
            }
            if (p_declaration_specifiers->p_attribute_specifier_sequence == 0)
            {
                free(p_declaration_specifiers->p_attribute_specifier_sequence);
                p_declaration_specifiers->p_attribute_specifier_sequence = 0;
            }
            p_declaration_specifiers->p_attribute_specifier_sequence = attribute_specifier_sequence_opt(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L1; /* throw */
            }
            if (ctx->current->type == 8996 && p_declaration_specifiers->type_specifier_flags != 0)
            {
                break;
            }
        }
        prev = previous_parser_token(ctx->current);
        if (prev == 0)
        {
            goto __L1; /* throw */
        }
        p_declaration_specifiers->last_token = prev;
        final_specifier(ctx, &p_declaration_specifiers->type_specifier_flags);
        p_declaration_specifiers->storage_class_specifier_flags |= default_storage_flag;
    }
    else __L1: /*catch*/ 
    {
        declaration_specifiers_delete(p_declaration_specifiers);
        p_declaration_specifiers = 0;
    }
    return p_declaration_specifiers;
}


struct static_assert_declaration *static_assert_declaration(struct parser_ctx * ctx);
struct pragma_declaration *pragma_declaration(struct parser_ctx * ctx);
struct init_declarator_list init_declarator_list(struct parser_ctx * ctx, struct declaration_specifiers * p_declaration_specifiers);
void declaration_delete(struct declaration * p);

struct declaration *declaration_core(struct parser_ctx * ctx, struct attribute_specifier_sequence * p_attribute_specifier_sequence, unsigned char  can_be_function_definition, unsigned char * is_function_definition, int default_storage_class_specifier_flags, unsigned char  without_semicolon)
{
    struct declaration * p_declaration;

    p_declaration = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_declaration = calloc(1, 52);
        if (p_declaration == 0)
        {
            goto __L0; /* throw */
        }
        p_declaration->p_attribute_specifier_sequence = p_attribute_specifier_sequence;
        p_attribute_specifier_sequence = 0;
        p_declaration->first_token = ctx->current;
        if (ctx->current->type == 59)
        {
            p_declaration->last_token = ctx->current;
            parser_match(ctx);
            return p_declaration;
        }
        if (first_of_static_assert_declaration(ctx))
        {
            p_declaration->static_assert_declaration = static_assert_declaration(ctx);
        }
        else
        {
            if (first_of_pragma_declaration(ctx))
            {
                p_declaration->pragma_declaration = pragma_declaration(ctx);
            }
            else
            {
                if (first_of_declaration_specifier(ctx))
                {
                    p_declaration->declaration_specifiers = declaration_specifiers(ctx, default_storage_class_specifier_flags);
                    if (p_declaration->declaration_specifiers == 0)
                    {
                        goto __L0; /* throw */
                    }
                    if (p_declaration->p_attribute_specifier_sequence)
                    {
                        p_declaration->declaration_specifiers->attributes_flags = p_declaration->p_attribute_specifier_sequence->attributes_flags;
                        p_declaration->declaration_specifiers->msvc_declspec_flags = p_declaration->p_attribute_specifier_sequence->msvc_declspec_flags;
                    }
                    if (ctx->current == 0)
                    {
                        unexpected_end_of_file(ctx);
                        goto __L0; /* throw */
                    }
                    if (ctx->current->type != 59)
                    {
                        p_declaration->init_declarator_list = init_declarator_list(ctx, p_declaration->declaration_specifiers);
                        if (p_declaration->init_declarator_list.head == 0)
                        {
                            goto __L0; /* throw */
                        }
                    }
                    if (ctx->current == 0)
                    {
                        unexpected_end_of_file(ctx);
                        goto __L0; /* throw */
                    }
                    p_declaration->last_token = ctx->current;
                    if (ctx->current->type == 123)
                    {
                        if (can_be_function_definition)
                        {
                            *is_function_definition = 1;
                        }
                    }
                    else
                    {
                        if (ctx->current->type == 9077 || ctx->current->type == 9078 || ctx->current->type == 8996)
                        {
                            if (can_be_function_definition)
                            {
                                *is_function_definition = 1;
                            }
                        }
                        else
                        {
                            if (!without_semicolon && parser_match_tk(ctx, 59) != 0)
                            {
                                goto __L0; /* throw */
                            }
                        }
                    }
                }
                else
                {
                    if (ctx->current->type == 8996)
                    {
                        compiler_diagnostic(860, ctx, ctx->current, 0, "invalid type '%s'", ctx->current->lexeme);
                    }
                    else
                    {
                        compiler_diagnostic(990, ctx, ctx->current, 0, "expected declaration not '%s'", get_diagnostic_friendly_token_name(ctx->current->type));
                    }
                    parser_match(ctx);
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        declaration_delete(p_declaration);
        p_declaration = 0;
    }
    attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
    return p_declaration;
}


struct declaration *declaration(struct parser_ctx * ctx, struct attribute_specifier_sequence * p_attribute_specifier_sequence, int storage_specifier_flags, unsigned char  extern_declaration);

struct declaration *function_definition_or_declaration(struct parser_ctx * ctx)
{
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;

    p_attribute_specifier_sequence = attribute_specifier_sequence_opt(ctx);
    return declaration(ctx, p_attribute_specifier_sequence, 0, 1);
}


void simple_declaration_delete(struct simple_declaration * p);

struct simple_declaration *simple_declaration(struct parser_ctx * ctx, unsigned char  ignore_semicolon, struct attribute_specifier_sequence * p_attribute_specifier_sequence)
{
    int storage_specifier_flags;
    struct simple_declaration * p_simple_declaration;

    if (ctx->current == 0)
    {
        unexpected_end_of_file(ctx);
        attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
        return 0;
    }
    storage_specifier_flags = 4096;
    p_simple_declaration = calloc(1, 24);
    if (1) /*try*/
    {
        struct declaration_specifiers * ptemp;
        struct token * prev;

        if (p_simple_declaration == 0)
        {
            goto __L1; /* throw */
        }
        p_simple_declaration->first_token = ctx->current;
        p_simple_declaration->p_attribute_specifier_sequence = p_attribute_specifier_sequence;
        p_attribute_specifier_sequence = 0;
        ptemp = declaration_specifiers(ctx, storage_specifier_flags);
        if (ptemp == 0)
        {
            goto __L1; /* throw */
        }
        p_simple_declaration->p_declaration_specifiers = ptemp;
        if (p_simple_declaration->p_attribute_specifier_sequence)
        {
            p_simple_declaration->p_declaration_specifiers->attributes_flags = p_simple_declaration->p_attribute_specifier_sequence->attributes_flags;
        }
        p_simple_declaration->init_declarator_list = init_declarator_list(ctx, p_simple_declaration->p_declaration_specifiers);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L1; /* throw */
        }
        prev = previous_parser_token(ctx->current);
        if (prev == 0)
        {
            goto __L1; /* throw */
        }
        p_simple_declaration->last_token = prev;
        if (!ignore_semicolon && parser_match_tk(ctx, 59) != 0)
        {
            goto __L1; /* throw */
        }
    }
    else __L1: /*catch*/ 
    {
        simple_declaration_delete(p_simple_declaration);
        p_simple_declaration = 0;
    }
    attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
    return p_simple_declaration;
}


struct diagnostic_id_stack *build_diagnostic_id_stack(struct parser_ctx * ctx, struct attribute_specifier_sequence * p_attribute_specifier_sequence, struct diagnostic_id_stack * stack, int diagnostic_phase);
static void check_func_open_brace_style(struct parser_ctx * ctx, struct token * token);
static void check_unused_parameters(struct parser_ctx * ctx, struct parameter_list * parameter_list);
unsigned char type_is_maybe_unused(struct type * p_type);
void defer_start_visit_declaration(struct defer_visit_ctx * ctx, struct declaration * p_declaration);
void defer_visit_ctx_destroy(struct defer_visit_ctx * p);
void flow_start_visit_declaration(struct flow_visit_ctx * ctx, struct declaration * p_declaration);
void flow_visit_ctx_destroy(struct flow_visit_ctx * p);
void warn_unrecognized_warnings(struct parser_ctx * ctx, struct diagnostic_id_stack * stack, struct attribute_specifier_sequence * p_attribute_specifier_sequence, struct diagnostic_id_stack * p_diagnostic_id_stack);

struct declaration *declaration(struct parser_ctx * ctx, struct attribute_specifier_sequence * p_attribute_specifier_sequence, int storage_specifier_flags, unsigned char  extern_declaration)
{
    struct declaration * p_declaration;

    p_declaration = 0;
    if (1) /*try*/
    {
        unsigned char  is_function_definition;
        struct diagnostic_id_stack  stack;
        struct diagnostic_id_stack * p_diagnostic_id_stack;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        is_function_definition = 0;
        _cake_zmem(&stack, 44);
        p_diagnostic_id_stack = build_diagnostic_id_stack(ctx, p_attribute_specifier_sequence, &stack, 0);
        p_declaration = declaration_core(ctx, p_attribute_specifier_sequence, 1, &is_function_definition, storage_specifier_flags, 0);
        p_attribute_specifier_sequence = 0;
        if (p_declaration == 0)
        {
            goto __L0; /* throw */
        }
        if (is_function_definition)
        {
            struct declarator * p_declarator;
            struct declarator * inner;
            struct diagnostic  before_function_diagnostics;
            struct declarator * p_current_function_opt;
            struct scope * parameters_scope;
            struct scope * p_current_function_scope_opt;
            struct compound_statement * p_function_body;

            if (p_declaration->init_declarator_list.head == 0 || p_declaration->init_declarator_list.head->p_declarator->direct_declarator == 0 || p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator == 0)
            {
                compiler_diagnostic(650, ctx, ctx->current, 0, "unexpected");
                goto __L0; /* throw */
            }
            p_declarator = p_declaration->init_declarator_list.head->p_declarator;
            ;
            inner = p_declaration->init_declarator_list.head->p_declarator;
            for (; ; )
            {
                if (inner->direct_declarator && inner->direct_declarator->function_declarator && inner->direct_declarator->function_declarator->direct_declarator && inner->direct_declarator->function_declarator->direct_declarator->declarator)
                {
                    inner = inner->direct_declarator->function_declarator->direct_declarator->declarator;
                }
                else
                {
                    break;
                }
            }
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            check_func_open_brace_style(ctx, ctx->current);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            before_function_diagnostics = ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index];
            if (ctx->current->type == 9077 || ctx->current->type == 9078 || ctx->current->type == 8996)
            {
                for (; ; )
                {
                    int type;

                    if (ctx->current == 0)
                    {
                        unexpected_end_of_file(ctx);
                        goto __L0; /* throw */
                    }
                    type = ctx->current->type;
                    if (type != 9077 && type != 9078 && type != 8996)
                    {
                        goto __L0; /* throw */
                    }
                    parser_match(ctx);
                    parser_match(ctx);
                    if (type != 9078)
                    {
                        ;
                        p_declarator->p_expression_true = expression(ctx, 2);
                    }
                    else
                    {
                        ;
                        p_declarator->p_expression_false = expression(ctx, 2);
                    }
                    parser_match(ctx);
                    if (ctx->current == 0)
                    {
                        unexpected_end_of_file(ctx);
                        goto __L0; /* throw */
                    }
                    if (ctx->current->type != 44)
                    {
                        break;
                    }
                    parser_match(ctx);
                }
            }
            p_current_function_opt = ctx->p_current_function_opt;
            ctx->p_current_function_opt = p_declarator;
            if (inner->direct_declarator->function_declarator == 0)
            {
                if (inner->first_token_opt)
                {
                    compiler_diagnostic(650, ctx, inner->first_token_opt, 0, "missing function declarator");
                }
                else
                {
                    compiler_diagnostic(650, ctx, ctx->current, 0, "missing function declarator");
                }
                goto __L0; /* throw */
            }
            parameters_scope = &inner->direct_declarator->function_declarator->parameters_scope;
            scope_list_push(&ctx->scopes, parameters_scope);
            p_current_function_scope_opt = ctx->p_current_function_scope_opt;
            ctx->p_current_function_scope_opt = ctx->scopes.tail;
            p_function_body = function_body(ctx);
            ctx->p_current_function_scope_opt = p_current_function_scope_opt;
            ctx->p_current_function_opt = p_current_function_opt;
            scope_list_pop(&ctx->scopes);
            if (p_function_body == 0)
            {
                goto __L0; /* throw */
            }
            ;
            p_declaration->function_body = p_function_body;
            p_declaration->init_declarator_list.head->p_declarator->function_body = p_declaration->function_body;
            if (p_declaration->init_declarator_list.head && p_declaration->init_declarator_list.head->p_declarator->direct_declarator && p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator && p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator->parameter_type_list_opt && p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator->parameter_type_list_opt->parameter_list)
            {
                check_unused_parameters(ctx, p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator->parameter_type_list_opt->parameter_list);
            }
            if (p_declaration->function_body)
            {
                char * func_name;
                struct scope * p_previous_scope;
                struct declarator * p_previous_declarator;

                func_name = p_declaration->init_declarator_list.head->p_declarator->name_opt->lexeme;
                p_previous_scope = 0;
                p_previous_declarator = find_declarator(ctx, func_name, &p_previous_scope);
                if (p_previous_declarator && p_previous_declarator != p_declaration->init_declarator_list.head->p_declarator)
                {
                    struct scope * p_current_scope;

                    p_previous_declarator->p_complete_declarator = p_declaration->init_declarator_list.head->p_declarator;
                    p_current_scope = ctx->scopes.tail;
                    if (p_current_scope == p_previous_scope)
                    {
                        if (p_previous_declarator->function_body)
                        {
                            compiler_diagnostic(1020, ctx, p_declaration->init_declarator_list.head->p_declarator->name_opt, 0, "function redefinition");
                            compiler_diagnostic(0, ctx, p_previous_declarator->name_opt, 0, "previous definition");
                        }
                        else
                        {
                        }
                    }
                }
            }
            if (extern_declaration && ctx->p_report->error_count == 0)
            {
                struct defer_visit_ctx  ctx2;

                ctx2.catch_secondary_block_opt = 0;
                ctx2.ctx = ctx;
                ctx2.ast.token_list.head = 0;
                ctx2.ast.token_list.tail = 0;
                ctx2.ast.declaration_list.head = 0;
                ctx2.ast.declaration_list.tail = 0;
                ctx2.tail_block = 0;
                ctx2.parameter_list = 0;
                defer_start_visit_declaration(&ctx2, p_declaration);
                defer_visit_ctx_destroy(&ctx2);
                if (ctx->options.flow_analysis)
                {
                    struct flow_visit_ctx  ctx3;

                    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] = before_function_diagnostics;
                    _cake_zmem(&ctx3, 868);
                    ctx3.ctx = ctx;
                    flow_start_visit_declaration(&ctx3, p_declaration);
                    flow_visit_ctx_destroy(&ctx3);
                }
            }
        }
        else
        {
            if (ctx->options.flow_analysis && extern_declaration)
            {
                struct flow_visit_ctx  ctx2;

                _cake_zmem(&ctx2, 868);
                ctx2.ctx = ctx;
                flow_start_visit_declaration(&ctx2, p_declaration);
                flow_visit_ctx_destroy(&ctx2);
            }
        }
        warn_unrecognized_warnings(ctx, &stack, p_declaration->p_attribute_specifier_sequence, p_diagnostic_id_stack);
    }
    else __L0: /*catch*/ 
    {
        declaration_delete(p_declaration);
        p_declaration = 0;
    }
    return p_declaration;
}



static void check_func_open_brace_style(struct parser_ctx * ctx, struct token * token)
{
    if (token->level == 0 && !(token->flags & 2) && token->type == 123 && token->prev && is_diagnostic_enabled(&ctx->options, 11))
    {
        if (ctx->options.style == 0)
        {
            if (token->prev->type == 10)
            {
            }
            else
            {
                compiler_diagnostic(11, ctx, token, 0, "not following correct brace style {");
            }
        }
    }
}

static void check_unused_parameters(struct parser_ctx * ctx, struct parameter_list * parameter_list)
{
    struct parameter_declaration * parameter;

    parameter = 0;
    parameter = parameter_list->head;
    while (parameter)
    {
        if (!type_is_maybe_unused(&parameter->declarator->type) && parameter->declarator && parameter->declarator->num_uses == 0)
        {
            if (parameter->declarator->name_opt && parameter->declarator->name_opt->level == 0)
            {
                compiler_diagnostic(6, ctx, parameter->declarator->name_opt, 0, "'%s': unreferenced formal parameter", parameter->declarator->name_opt->lexeme);
            }
        }
        parameter = parameter->next;
    }
}
void type_specifier_qualifier_delete(struct type_specifier_qualifier * p);

void declaration_specifier_delete(struct declaration_specifier * p)
{
    if (p)
    {
        free(p->function_specifier);
        type_specifier_qualifier_delete(p->type_specifier_qualifier);
        free(p->storage_class_specifier);
        ;
        free(p);
    }
}


struct storage_class_specifier *storage_class_specifier(struct parser_ctx * ctx);
struct type_specifier_qualifier *type_specifier_qualifier(struct parser_ctx * ctx);
struct function_specifier *function_specifier(struct parser_ctx * ctx);

struct declaration_specifier *declaration_specifier(struct parser_ctx * ctx)
{
    struct declaration_specifier * p_declaration_specifier;

    p_declaration_specifier = 0;
    if (1) /*try*/
    {
        p_declaration_specifier = calloc(1, 20);
        if (p_declaration_specifier == 0)
        {
            goto __L0; /* throw */
        }
        if (first_of_storage_class_specifier(ctx))
        {
            p_declaration_specifier->storage_class_specifier = storage_class_specifier(ctx);
            if (p_declaration_specifier->storage_class_specifier == 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            if (first_of_type_specifier_qualifier(ctx))
            {
                p_declaration_specifier->type_specifier_qualifier = type_specifier_qualifier(ctx);
                if (p_declaration_specifier->type_specifier_qualifier == 0)
                {
                    goto __L0; /* throw */
                }
            }
            else
            {
                if (first_of_function_specifier(ctx))
                {
                    p_declaration_specifier->function_specifier = function_specifier(ctx);
                    if (p_declaration_specifier->function_specifier == 0)
                    {
                        goto __L0; /* throw */
                    }
                }
                else
                {
                    compiler_diagnostic(650, ctx, ctx->current, 0, "unexpected");
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        declaration_specifier_delete(p_declaration_specifier);
        p_declaration_specifier = 0;
    }
    return p_declaration_specifier;
}


struct init_declarator *init_declarator_add_ref(struct init_declarator * p)
{
    p->has_shared_ownership = 1;
    return (struct init_declarator *)p;
}


void init_declarator_sink(struct init_declarator * p)
{
}


void initializer_delete(struct initializer * p);

void init_declarator_delete(struct init_declarator * p)
{
    if (p)
    {
        if (p->has_shared_ownership)
        {
            p->has_shared_ownership = 0;
            init_declarator_sink(p);
            return;
        }
        initializer_delete(p->initializer);
        declarator_delete(p->p_declarator);
        ;
        free(p);
    }
}


struct declarator *declarator(struct parser_ctx * ctx, struct specifier_qualifier_list * specifier_qualifier_list, struct declaration_specifiers * declaration_specifiers, unsigned char  abstract_acceptable, struct token ** pptokenname);
void naming_convention_global_var(struct parser_ctx * ctx, struct token * token, struct type * type, int storage);
void print_type_no_names(struct osstream * ss, struct type * p_type, int target);
struct initializer *initializer(struct parser_ctx * ctx, int eval_mode);
void type_remove_names(struct type * p_type);
void type_set_storage_specifiers_using_declarator(struct type * p_type, struct declarator * pdeclarator);
void type_set_qualifiers_using_declarator(struct type * p_type, struct declarator * pdeclarator);
void type_visit_to_mark_anonymous(struct type * p_type);

struct init_declarator *init_declarator(struct parser_ctx * ctx, struct declaration_specifiers * p_declaration_specifiers)
{
    struct init_declarator * p_init_declarator;

    p_init_declarator = 0;
    if (1) /*try*/
    {
        struct token * tkname;
        char * declarator_name;
        struct scope * out_scope;
        struct declarator * p_previous_declarator;

        p_init_declarator = calloc(1, 16);
        if (p_init_declarator == 0)
        {
            goto __L0; /* throw */
        }
        tkname = 0;
        {
            struct declarator * p_temp_declarator;

            p_temp_declarator = declarator(ctx, 0, p_declaration_specifiers, 0, &tkname);
            if (p_temp_declarator == 0)
            {
                goto __L0; /* throw */
            }
            p_init_declarator->p_declarator = p_temp_declarator;
        }
        if (tkname == 0)
        {
            compiler_diagnostic(650, ctx, ctx->current, 0, "init declarator must have a name");
            goto __L0; /* throw */
        }
        p_init_declarator->p_declarator->declaration_specifiers = p_declaration_specifiers;
        p_init_declarator->p_declarator->name_opt = tkname;
        if ((p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & 16) && (p_init_declarator->p_declarator->declaration_specifiers->type_specifier_flags == 0))
        {
        }
        else
        {
            ;
            p_init_declarator->p_declarator->type = make_type_using_declarator(ctx, p_init_declarator->p_declarator);
        }
        ;
        ;
        if (ctx->scopes.tail->scope_level == 0)
        {
            naming_convention_global_var(ctx, tkname, &p_init_declarator->p_declarator->type, p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags);
        }
        declarator_name = p_init_declarator->p_declarator->name_opt->lexeme;
        out_scope = 0;
        p_previous_declarator = find_declarator(ctx, declarator_name, &out_scope);
        if (p_previous_declarator)
        {
            p_init_declarator->p_declarator->p_complete_declarator = p_previous_declarator;
            ;
            ;
            if (out_scope->scope_level == ctx->scopes.tail->scope_level)
            {
                if (out_scope->scope_level == 0)
                {
                    if (strcmp(declarator_name, "__C_ASSERT__") != 0)
                    {
                        if (!type_is_same(&p_previous_declarator->type, &p_init_declarator->p_declarator->type, 0))
                        {
                            struct osstream  ss;

                            _cake_zmem(&ss, 12);
                            print_type_no_names(&ss, &p_previous_declarator->type, ctx->options.target);
                            compiler_diagnostic(1020, ctx, ctx->current, 0, "conflicting types for '%s' (%s)", declarator_name, ss.c_str);
                            ss_clear(&ss);
                            print_type_no_names(&ss, &p_init_declarator->p_declarator->type, ctx->options.target);
                            compiler_diagnostic(1020, ctx, p_previous_declarator->name_opt, 0, "previous declaration (%s)", ss.c_str);
                            ss_close(&ss);
                        }
                    }
                }
                else
                {
                    if (type_is_function(&p_init_declarator->p_declarator->type))
                    {
                    }
                    else
                    {
                        if (compiler_diagnostic(1020, ctx, ctx->current, 0, "redeclaration"))
                        {
                            compiler_diagnostic(0, ctx, p_previous_declarator->name_opt, 0, "previous declaration");
                        }
                    }
                }
            }
            else
            {
                struct hash_item_set  item;

                _cake_zmem(&item, 32);
                item.p_init_declarator = init_declarator_add_ref(p_init_declarator);
                hashmap_set(&ctx->scopes.tail->variables, declarator_name, &item);
                hash_item_set_destroy(&item);
                if (out_scope->scope_level != 0)
                {
                    if (compiler_diagnostic(7, ctx, p_init_declarator->p_declarator->first_token_opt, 0, "declaration of '%s' hides previous declaration", declarator_name))
                    {
                        compiler_diagnostic(0, ctx, p_previous_declarator->first_token_opt, 0, "previous declaration is here");
                    }
                }
            }
        }
        else
        {
            struct hash_item_set  item;

            _cake_zmem(&item, 32);
            item.p_init_declarator = init_declarator_add_ref(p_init_declarator);
            hashmap_set(&ctx->scopes.tail->variables, declarator_name, &item);
            hash_item_set_destroy(&item);
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 61)
        {
            unsigned char  requires_constant_initialization;

            requires_constant_initialization = (ctx->p_current_function_opt == 0) || (p_declaration_specifiers->storage_class_specifier_flags & 4);
            parser_match(ctx);
            ;
            p_init_declarator->initializer = initializer(ctx, 2);
            if (p_init_declarator->initializer == 0)
            {
                goto __L0; /* throw */
            }
            if (p_init_declarator->initializer->braced_initializer)
            {
                int er;
                unsigned char  is_constant;

                if (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & 16)
                {
                    compiler_diagnostic(1290, ctx, p_init_declarator->p_declarator->first_token_opt, 0, "'auto' requires a plain identifier");
                    goto __L0; /* throw */
                }
                er = make_object(&p_init_declarator->p_declarator->type, &p_init_declarator->p_declarator->object, ctx->options.target);
                if (er != 0)
                {
                    compiler_diagnostic(740, ctx, p_init_declarator->p_declarator->first_token_opt, 0, "incomplete struct/union type");
                    goto __L0; /* throw */
                }
                is_constant = type_is_const_or_constexpr(&p_init_declarator->p_declarator->type);
                if (initializer_init_new(ctx, &p_init_declarator->p_declarator->type, &p_init_declarator->p_declarator->object, p_init_declarator->initializer, is_constant, requires_constant_initialization) != 0)
                {
                    goto __L0; /* throw */
                }
                p_init_declarator->p_declarator->object.type.num_of_elements = p_init_declarator->p_declarator->type.num_of_elements;
            }
            else
            {
                if (p_init_declarator->initializer->assignment_expression)
                {
                    char * name2;
                    int er;
                    unsigned char  is_constant;

                    if (type_is_array(&p_init_declarator->p_declarator->type))
                    {
                        unsigned long long array_size_elements;

                        array_size_elements = p_init_declarator->p_declarator->type.num_of_elements;
                        if (array_size_elements == 0)
                        {
                            p_init_declarator->p_declarator->type.num_of_elements = p_init_declarator->initializer->assignment_expression->type.num_of_elements;
                        }
                        else
                        {
                            if (p_init_declarator->initializer->assignment_expression->type.num_of_elements > array_size_elements)
                            {
                                if (p_init_declarator->p_declarator->first_token_opt)
                                {
                                    compiler_diagnostic(52, ctx, p_init_declarator->p_declarator->first_token_opt, 0, "initializer for array is too long");
                                }
                            }
                        }
                    }
                    ;
                    if (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & 16)
                    {
                        struct type  t;

                        if (p_init_declarator->p_declarator->direct_declarator && (p_init_declarator->p_declarator->direct_declarator->array_declarator != 0 || p_init_declarator->p_declarator->direct_declarator->function_declarator != 0))
                        {
                            compiler_diagnostic(1290, ctx, p_init_declarator->p_declarator->first_token_opt, 0, "'auto' requires a plain identifier");
                            goto __L0; /* throw */
                        }
                        if (p_init_declarator->p_declarator->pointer != 0)
                        {
                            compiler_diagnostic(1290, ctx, p_init_declarator->p_declarator->first_token_opt, 0, "'auto' requires a plain identifier");
                        }
                        _cake_zmem(&t, 68);
                        if (p_init_declarator->initializer->assignment_expression->expression_type == 41)
                        {
                            t = type_dup(&p_init_declarator->initializer->assignment_expression->type);
                        }
                        else
                        {
                            struct type  t2;

                            t2 = type_lvalue_conversion(&p_init_declarator->initializer->assignment_expression->type, ctx->options.null_checks_enabled);
                            type_swap(&t2, &t);
                            type_destroy(&t2);
                        }
                        type_remove_names(&t);
                        ;
                        t.name_opt = strdup(p_init_declarator->p_declarator->name_opt->lexeme);
                        t.storage_class_specifier_flags = 0;
                        type_set_storage_specifiers_using_declarator(&t, p_init_declarator->p_declarator);
                        t.storage_class_specifier_flags &= -17;
                        type_set_qualifiers_using_declarator(&t, p_init_declarator->p_declarator);
                        type_visit_to_mark_anonymous(&t);
                        type_swap(&p_init_declarator->p_declarator->type, &t);
                        type_destroy(&t);
                    }
                    check_assigment(ctx, &p_init_declarator->p_declarator->type, p_init_declarator->initializer->assignment_expression, 3);
                    name2 = p_init_declarator->p_declarator->name_opt ? p_init_declarator->p_declarator->name_opt->lexeme : "";
                    er = make_object_with_member_designator(&p_init_declarator->p_declarator->type, &p_init_declarator->p_declarator->object, name2, ctx->options.target);
                    if (er != 0)
                    {
                        goto __L0; /* throw */
                    }
                    is_constant = type_is_const_or_constexpr(&p_init_declarator->p_declarator->type);
                    if (initializer_init_new(ctx, &p_init_declarator->p_declarator->type, &p_init_declarator->p_declarator->object, p_init_declarator->initializer, is_constant, requires_constant_initialization) != 0)
                    {
                        goto __L0; /* throw */
                    }
                }
            }
        }
        else
        {
            if (p_init_declarator->p_declarator->type.category != 1 && !(p_init_declarator->p_declarator->type.storage_class_specifier_flags & 1))
            {
                char * name2;
                int er;

                name2 = p_init_declarator->p_declarator->name_opt ? p_init_declarator->p_declarator->name_opt->lexeme : "";
                er = make_object_with_member_designator(&p_init_declarator->p_declarator->type, &p_init_declarator->p_declarator->object, name2, ctx->options.target);
                if (er != 0)
                {
                    if (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & 2)
                    {
                    }
                    else
                    {
                        compiler_diagnostic(740, ctx, p_init_declarator->p_declarator->first_token_opt, 0, "incomplete struct/union type");
                        goto __L0; /* throw */
                    }
                }
                if (type_is_const(&p_init_declarator->p_declarator->type))
                {
                    if (p_declaration_specifiers->storage_class_specifier_flags & 1)
                    {
                    }
                    else
                    {
                        compiler_diagnostic(48, ctx, p_init_declarator->p_declarator->first_token_opt, 0, "const object should be initialized");
                    }
                }
            }
        }
        if (p_init_declarator->p_declarator)
        {
            if (type_is_array(&p_init_declarator->p_declarator->type))
            {
                if (p_init_declarator->p_declarator->type.type_qualifier_flags != 0 || p_init_declarator->p_declarator->type.has_static_array_size)
                {
                    if (p_init_declarator->p_declarator->first_token_opt)
                    {
                        compiler_diagnostic(1000, ctx, p_init_declarator->p_declarator->first_token_opt, 0, "static or type qualifiers are not allowed in non-parameter array declarator");
                    }
                    else
                    {
                        if (p_init_declarator->initializer)
                        {
                            compiler_diagnostic(1000, ctx, p_init_declarator->initializer->first_token, 0, "static or type qualifiers are not allowed in non-parameter array declarator");
                        }
                    }
                }
            }
            if (!type_is_pointer(&p_init_declarator->p_declarator->type) && p_init_declarator->p_declarator->type.type_qualifier_flags & 128)
            {
                if (p_init_declarator->p_declarator->first_token_opt)
                {
                    compiler_diagnostic(1010, ctx, p_init_declarator->p_declarator->first_token_opt, 0, "_Dtor qualifier can only be used with pointers");
                }
                else
                {
                    if (p_init_declarator->initializer)
                    {
                        compiler_diagnostic(1010, ctx, p_init_declarator->initializer->first_token, 0, "_Dtor qualifier can only be used with pointers");
                    }
                }
            }
        }
        if (!(p_init_declarator->p_declarator->type.storage_class_specifier_flags & 1) && !type_is_function(&p_init_declarator->p_declarator->type))
        {
            if (type_is_vla(&p_init_declarator->p_declarator->type))
            {
            }
            else
            {
                if (type_is_function(&p_init_declarator->p_declarator->type))
                {
                    compiler_diagnostic(1270, ctx, p_init_declarator->p_declarator->name_opt, 0, "invalid application of 'sizeof' to a function type");
                }
                else
                {
                    unsigned int sz;
                    int size_result;

                    sz = 0;
                    size_result = type_get_sizeof(&p_init_declarator->p_declarator->type, &sz, ctx->options.target);
                    if (size_result == 0)
                    {
                    }
                    else
                    {
                        if (size_result == 3)
                        {
                            if (p_init_declarator->p_declarator->type.storage_class_specifier_flags & 2)
                            {
                            }
                            else
                            {
                                compiler_diagnostic(1270, ctx, p_init_declarator->p_declarator->name_opt, 0, "storage size of '%s' isn't known", p_init_declarator->p_declarator->name_opt->lexeme);
                            }
                        }
                        else
                        {
                            if (size_result == 1)
                            {
                                compiler_diagnostic(1270, ctx, p_init_declarator->p_declarator->name_opt, 0, "sizeof '%s' is too large", p_init_declarator->p_declarator->name_opt->lexeme);
                            }
                            else
                            {
                                compiler_diagnostic(1270, ctx, p_init_declarator->p_declarator->name_opt, 0, "storage size of '%s' isn't known", p_init_declarator->p_declarator->name_opt->lexeme);
                            }
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        init_declarator_delete(p_init_declarator);
        p_init_declarator = 0;
    }
    return p_init_declarator;
}


void init_declarator_list_add(struct init_declarator_list * list, struct init_declarator * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void init_declarator_list_destroy(struct init_declarator_list * p)
{
    struct init_declarator * item;

    item = p->head;
    while (item)
    {
        struct init_declarator * next;

        next = item->next;
        item->next = 0;
        init_declarator_delete(item);
        item = next;
    }
}


struct init_declarator_list init_declarator_list(struct parser_ctx * ctx, struct declaration_specifiers * p_declaration_specifiers)
{
    struct init_declarator_list  init_declarator_list;
    struct init_declarator * p_init_declarator;

    _cake_zmem(&init_declarator_list, 8);
    p_init_declarator = 0;
    if (1) /*try*/
    {
        p_init_declarator = init_declarator(ctx, p_declaration_specifiers);
        if (p_init_declarator == 0)
        {
            goto __L0; /* throw */
        }
        init_declarator_list_add(&init_declarator_list, p_init_declarator);
        p_init_declarator = 0;
        while (ctx->current != 0 && ctx->current->type == 44)
        {
            parser_match(ctx);
            p_init_declarator = init_declarator(ctx, p_declaration_specifiers);
            if (p_init_declarator == 0)
            {
                goto __L0; /* throw */
            }
            init_declarator_list_add(&init_declarator_list, p_init_declarator);
            p_init_declarator = 0;
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return init_declarator_list;
}


void storage_class_specifier_delete(struct storage_class_specifier * p)
{
    if (p)
    {
        free(p);
    }
}


struct storage_class_specifier *storage_class_specifier(struct parser_ctx * ctx)
{
    struct storage_class_specifier * p_storage_class_specifier;

    p_storage_class_specifier = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_storage_class_specifier = calloc(1, 8);
        if (p_storage_class_specifier == 0)
        {
            goto __L0; /* throw */
        }
        p_storage_class_specifier->token = ctx->current;
        /*switch*/
        {
            int __v0 = ctx->current->type;
            if (__v0 == 9035) goto __L4; /*case 9035*/
            if (__v0 == 9013) goto __L5; /*case 9013*/
            if (__v0 == 9002) goto __L6; /*case 9002*/
            if (__v0 == 9032) goto __L8; /*case 9032*/
            if (__v0 == 9075) goto __L9; /*case 9075*/
            if (__v0 == 8999) goto __L10; /*case 8999*/
            if (__v0 == 9025) goto __L11; /*case 9025*/
            goto __L12; /* default */

            {
                __L4: /*case 9035*/ 
                p_storage_class_specifier->flags = 1;
                goto __L3; /* break */

                __L5: /*case 9013*/ 
                p_storage_class_specifier->flags = 2;
                goto __L3; /* break */

                __L6: /*case 9002*/ 
                p_storage_class_specifier->flags = 64;
                if (ctx->scopes.tail && ctx->scopes.tail->scope_level == 0)
                {
                    p_storage_class_specifier->flags |= 128;
                }
                goto __L3; /* break */

                __L8: /*case 9032*/ 
                p_storage_class_specifier->flags = 4;
                goto __L3; /* break */

                __L9: /*case 9075*/ 
                p_storage_class_specifier->flags = 8;
                goto __L3; /* break */

                __L10: /*case 8999*/ 
                p_storage_class_specifier->flags = 16;
                goto __L3; /* break */

                __L11: /*case 9025*/ 
                p_storage_class_specifier->flags = 32;
                goto __L3; /* break */

                __L12: /* default */ 
                ;
            }
            __L3:;
        }
        parser_match(ctx);
    }
    else __L0: /*catch*/ 
    {
        storage_class_specifier_delete(p_storage_class_specifier);
        p_storage_class_specifier = 0;
    }
    return p_storage_class_specifier;
}


void typeof_specifier_argument_delete(struct typeof_specifier_argument * p);

struct typeof_specifier_argument *typeof_specifier_argument(struct parser_ctx * ctx)
{
    struct typeof_specifier_argument * new_typeof_specifier_argument;

    new_typeof_specifier_argument = 0;
    if (1) /*try*/
    {
        new_typeof_specifier_argument = calloc(1, 8);
        if (new_typeof_specifier_argument == 0)
        {
            goto __L0; /* throw */
        }
        if (first_of_type_name(ctx))
        {
            new_typeof_specifier_argument->type_name = type_name(ctx);
        }
        else
        {
            new_typeof_specifier_argument->expression = expression(ctx, 1);
            if (new_typeof_specifier_argument->expression == 0)
            {
                goto __L0; /* throw */
            }
        }
    }
    else __L0: /*catch*/ 
    {
        typeof_specifier_argument_delete(new_typeof_specifier_argument);
        new_typeof_specifier_argument = 0;
    }
    return new_typeof_specifier_argument;
}


unsigned char first_of_typeof_specifier(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    return ctx->current->type == 9076 || ctx->current->type == 9080;
}


struct type type_param_array_to_pointer(struct type * p_type, unsigned char  null_checks_enabled);
void type_remove_qualifiers(struct type * p_type);
void typeof_specifier_delete(struct typeof_specifier * p);

struct typeof_specifier *typeof_specifier(struct parser_ctx * ctx)
{
    struct typeof_specifier * p_typeof_specifier;

    p_typeof_specifier = 0;
    if (1) /*try*/
    {
        unsigned char  is_typeof_unqual;
        struct typeof_specifier_argument * p_typeof_specifier_argument;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_typeof_specifier = calloc(1, 80);
        if (p_typeof_specifier == 0)
        {
            goto __L0; /* throw */
        }
        p_typeof_specifier->first_token = ctx->current;
        is_typeof_unqual = ctx->current->type == 9080;
        parser_match(ctx);
        if (parser_match_tk(ctx, 40) != 0)
        {
            goto __L0; /* throw */
        }
        p_typeof_specifier_argument = typeof_specifier_argument(ctx);
        if (p_typeof_specifier_argument == 0)
        {
            goto __L0; /* throw */
        }
        p_typeof_specifier->typeof_specifier_argument = p_typeof_specifier_argument;
        if (p_typeof_specifier->typeof_specifier_argument->expression)
        {
            p_typeof_specifier->type = type_dup(&p_typeof_specifier->typeof_specifier_argument->expression->type);
        }
        else
        {
            if (p_typeof_specifier->typeof_specifier_argument->type_name)
            {
                p_typeof_specifier->type = type_dup(&p_typeof_specifier->typeof_specifier_argument->type_name->abstract_declarator->type);
            }
        }
        if (type_is_array(&p_typeof_specifier->type) && p_typeof_specifier->type.storage_class_specifier_flags & 2048)
        {
            compiler_diagnostic(8, ctx, ctx->current, 0, "typeof used in array arguments");
            if (type_is_array(&p_typeof_specifier->type))
            {
                struct type  t;

                t = type_param_array_to_pointer(&p_typeof_specifier->type, ctx->options.null_checks_enabled);
                type_swap(&t, &p_typeof_specifier->type);
                type_destroy(&t);
            }
        }
        if (is_typeof_unqual)
        {
            type_remove_qualifiers(&p_typeof_specifier->type);
        }
        type_visit_to_mark_anonymous(&p_typeof_specifier->type);
        free((void *)p_typeof_specifier->type.name_opt);
        p_typeof_specifier->type.name_opt = 0;
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_typeof_specifier->last_token = ctx->current;
        if (parser_match_tk(ctx, 41) != 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        typeof_specifier_delete(p_typeof_specifier);
        p_typeof_specifier = 0;
    }
    return p_typeof_specifier;
}


void typeof_specifier_argument_delete(struct typeof_specifier_argument * p)
{
    if (p)
    {
        expression_delete(p->expression);
        type_name_delete(p->type_name);
        free(p);
    }
}


void typeof_specifier_delete(struct typeof_specifier * p)
{
    if (p)
    {
        typeof_specifier_argument_delete(p->typeof_specifier_argument);
        type_destroy(&p->type);
        free(p);
    }
}


void atomic_type_specifier_delete(struct atomic_type_specifier * p);

void type_specifier_delete(struct type_specifier * p)
{
    if (p)
    {
        struct_or_union_specifier_delete(p->struct_or_union_specifier);
        typeof_specifier_delete(p->typeof_specifier);
        enum_specifier_delete(p->enum_specifier);
        atomic_type_specifier_delete(p->atomic_type_specifier);
        free(p);
    }
}


void attribute_delete(struct attribute * p);

struct attribute *extended_decl_modifier_seq(struct parser_ctx * ctx)
{
    struct attribute * p_type_specifier;

    p_type_specifier = 0;
    if (1) /*try*/
    {
        int count;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_type_specifier = calloc(1, 20);
        if (p_type_specifier == 0)
        {
            goto __L0; /* throw */
        }
        p_type_specifier->attribute_token = ctx->current;
        parser_match(ctx);
        if (strcmp(p_type_specifier->attribute_token->lexeme, "align") == 0)
        {
            int a;

            parser_match(ctx);
            a = atoi(ctx->current->lexeme);
            if (a == 8)
            {
                p_type_specifier->msvc_declspec_flags |= 2;
            }
            else
            {
                if (a == 16)
                {
                    p_type_specifier->msvc_declspec_flags |= 4;
                }
                else
                {
                    if (a == 32)
                    {
                        p_type_specifier->msvc_declspec_flags |= 8;
                    }
                    else
                    {
                        if (a == 64)
                        {
                            p_type_specifier->msvc_declspec_flags |= 16;
                        }
                    }
                }
            }
            parser_match(ctx);
            parser_match(ctx);
        }
        else
        {
            if (strcmp(p_type_specifier->attribute_token->lexeme, "allocate") == 0)
            {
                p_type_specifier->msvc_declspec_flags |= 32;
            }
            else
            {
                if (strcmp(p_type_specifier->attribute_token->lexeme, "allocator") == 0)
                {
                    p_type_specifier->msvc_declspec_flags |= 64;
                }
                else
                {
                    if (strcmp(p_type_specifier->attribute_token->lexeme, "appdomain") == 0)
                    {
                        p_type_specifier->msvc_declspec_flags |= 128;
                    }
                    else
                    {
                        if (strcmp(p_type_specifier->attribute_token->lexeme, "code_seg") == 0)
                        {
                            p_type_specifier->msvc_declspec_flags |= 256;
                        }
                        else
                        {
                            if (strcmp(p_type_specifier->attribute_token->lexeme, "deprecated") == 0)
                            {
                                p_type_specifier->msvc_declspec_flags |= 512;
                            }
                            else
                            {
                                if (strcmp(p_type_specifier->attribute_token->lexeme, "dllimport") == 0)
                                {
                                    p_type_specifier->msvc_declspec_flags |= 1024;
                                }
                                else
                                {
                                    if (strcmp(p_type_specifier->attribute_token->lexeme, "dllexport") == 0)
                                    {
                                        p_type_specifier->msvc_declspec_flags |= 2048;
                                    }
                                    else
                                    {
                                        if (strcmp(p_type_specifier->attribute_token->lexeme, "hybrid_patchable") == 0)
                                        {
                                        }
                                        else
                                        {
                                            if (strcmp(p_type_specifier->attribute_token->lexeme, "no_init_all") == 0)
                                            {
                                            }
                                            else
                                            {
                                                if (strcmp(p_type_specifier->attribute_token->lexeme, "jitintrinsic") == 0)
                                                {
                                                }
                                                else
                                                {
                                                    if (strcmp(p_type_specifier->attribute_token->lexeme, "intrin_type") == 0)
                                                    {
                                                    }
                                                    else
                                                    {
                                                        if (strcmp(p_type_specifier->attribute_token->lexeme, "naked") == 0)
                                                        {
                                                        }
                                                        else
                                                        {
                                                            if (strcmp(p_type_specifier->attribute_token->lexeme, "noalias") == 0)
                                                            {
                                                            }
                                                            else
                                                            {
                                                                if (strcmp(p_type_specifier->attribute_token->lexeme, "noinline") == 0)
                                                                {
                                                                }
                                                                else
                                                                {
                                                                    if (strcmp(p_type_specifier->attribute_token->lexeme, "noreturn") == 0)
                                                                    {
                                                                    }
                                                                    else
                                                                    {
                                                                        if (strcmp(p_type_specifier->attribute_token->lexeme, "nothrow") == 0)
                                                                        {
                                                                        }
                                                                        else
                                                                        {
                                                                            if (strcmp(p_type_specifier->attribute_token->lexeme, "novtable") == 0)
                                                                            {
                                                                            }
                                                                            else
                                                                            {
                                                                                if (strcmp(p_type_specifier->attribute_token->lexeme, "no_sanitize_address") == 0)
                                                                                {
                                                                                }
                                                                                else
                                                                                {
                                                                                    if (strcmp(p_type_specifier->attribute_token->lexeme, "process") == 0)
                                                                                    {
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        if (strcmp(p_type_specifier->attribute_token->lexeme, "property") == 0)
                                                                                        {
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                            if (strcmp(p_type_specifier->attribute_token->lexeme, "restrict") == 0)
                                                                                            {
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                                if (strcmp(p_type_specifier->attribute_token->lexeme, "safebuffers") == 0)
                                                                                                {
                                                                                                }
                                                                                                else
                                                                                                {
                                                                                                    if (strcmp(p_type_specifier->attribute_token->lexeme, "selectany") == 0)
                                                                                                    {
                                                                                                        p_type_specifier->msvc_declspec_flags |= 67108864;
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                        if (strcmp(p_type_specifier->attribute_token->lexeme, "thread") == 0)
                                                                                                        {
                                                                                                            p_type_specifier->msvc_declspec_flags |= 67108864;
                                                                                                        }
                                                                                                        else
                                                                                                        {
                                                                                                            if (strcmp(p_type_specifier->attribute_token->lexeme, "uuid") == 0)
                                                                                                            {
                                                                                                                p_type_specifier->msvc_declspec_flags |= 536870912;
                                                                                                            }
                                                                                                            else
                                                                                                            {
                                                                                                                compiler_diagnostic(9, ctx, p_type_specifier->attribute_token, 0, "unknown '%s'\n", p_type_specifier->attribute_token->lexeme);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        count = 1;
        while (ctx->current)
        {
            if (ctx->current->type == 40)
            {
                parser_match(ctx);
                count++;
            }
            else
            {
                if (ctx->current->type == 41)
                {
                    if (count == 1)
                    {
                        break;
                    }
                    count--;
                    parser_match(ctx);
                }
                else
                {
                    parser_match(ctx);
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        attribute_delete(p_type_specifier);
        p_type_specifier = 0;
    }
    return p_type_specifier;
}


struct attribute *msvc_declspec(struct parser_ctx * ctx)
{
    struct attribute * p_decl_specifier;

    p_decl_specifier = 0;
    if (1) /*try*/
    {
        if (ctx->current->type != 9059)
        {
            goto __L0; /* throw */
        }
        parser_match_tk(ctx, 9059);
        parser_match_tk(ctx, 40);
        p_decl_specifier = extended_decl_modifier_seq(ctx);
        parser_match_tk(ctx, 41);
    }
    else __L0: /*catch*/ 
    {
        attribute_delete(p_decl_specifier);
        p_decl_specifier = 0;
    }
    return p_decl_specifier;
}


int msvc_declspec_sequence_opt(struct parser_ctx * ctx)
{
    int msvc_declspec_flags;

    msvc_declspec_flags = 0;
    if (1) /*try*/
    {
        for (; ; )
        {
            struct attribute * p;

            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            if (ctx->current->type != 9059)
            {
                return msvc_declspec_flags;
            }
            p = msvc_declspec(ctx);
            if (p)
            {
                msvc_declspec_flags |= p->msvc_declspec_flags;
            }
            attribute_delete(p);
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return msvc_declspec_flags;
}


static void gcc_attribute_list(struct parser_ctx * ctx);
static void gcc_attribute(struct parser_ctx * ctx);

void gcc_attribute_specifier_opt(struct parser_ctx * ctx)
{
    if (ctx->current == 0 || ctx->current->type != 9046)
    {
        return;
    }
    parser_match(ctx);
    parser_match_tk(ctx, 40);
    parser_match_tk(ctx, 40);
    gcc_attribute_list(ctx);
    parser_match_tk(ctx, 41);
    parser_match_tk(ctx, 41);
}



static void gcc_attribute(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        unexpected_end_of_file(ctx);
        return;
    }
    if (!token_is_identifier_or_keyword(ctx->current->type))
    {
        compiler_diagnostic(650, ctx, ctx->current, 0, "expected identifier");
        return;
    }
    parser_match(ctx);
    if (ctx->current->type == 40)
    {
        int count;

        parser_match(ctx);
        count = 1;
        for (; ; )
        {
            if (ctx->current->type == 41)
            {
                count--;
                if (count == 0)
                {
                    break;
                }
                parser_match(ctx);
            }
            else
            {
                if (ctx->current->type == 40)
                {
                    count++;
                    parser_match(ctx);
                }
                else
                {
                    parser_match(ctx);
                }
            }
        }
        parser_match_tk(ctx, 41);
    }
}

static void gcc_attribute_list(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        unexpected_end_of_file(ctx);
        return;
    }
    if (ctx->current->type == 41)
    {
        return;
    }
    for (; ; )
    {
        gcc_attribute(ctx);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            return;
        }
        if (ctx->current->type != 44)
        {
            break;
        }
        parser_match(ctx);
    }
}
struct atomic_type_specifier *atomic_type_specifier(struct parser_ctx * ctx);
struct struct_or_union_specifier *struct_or_union_specifier(struct parser_ctx * ctx);
struct enum_specifier *enum_specifier(struct parser_ctx *);

struct type_specifier *type_specifier(struct parser_ctx * ctx)
{
    struct type_specifier * p_type_specifier;

    p_type_specifier = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_type_specifier = calloc(1, 28);
        if (p_type_specifier == 0)
        {
            goto __L0; /* throw */
        }
        /*switch*/
        {
            int __v0 = ctx->current->type;
            if (__v0 == 9040) goto __L4; /*case 9040*/
            if (__v0 == 9003) goto __L5; /*case 9003*/
            if (__v0 == 9028) goto __L6; /*case 9028*/
            if (__v0 == 9019) goto __L7; /*case 9019*/
            if (__v0 == 9047) goto __L8; /*case 9047*/
            if (__v0 == 9021) goto __L9; /*case 9021*/
            if (__v0 == 9022) goto __L10; /*case 9022*/
            if (__v0 == 9023) goto __L11; /*case 9023*/
            if (__v0 == 9024) goto __L12; /*case 9024*/
            if (__v0 == 9020) goto __L13; /*case 9020*/
            if (__v0 == 9014) goto __L14; /*case 9014*/
            if (__v0 == 9010) goto __L15; /*case 9010*/
            if (__v0 == 9029) goto __L16; /*case 9029*/
            if (__v0 == 9039) goto __L17; /*case 9039*/
            if (__v0 == 9065) goto __L18; /*case 9065*/
            if (__v0 == 9066) goto __L19; /*case 9066*/
            if (__v0 == 9068) goto __L20; /*case 9068*/
            if (__v0 == 9069) goto __L21; /*case 9069*/
            if (__v0 == 9067) goto __L22; /*case 9067*/
            goto __L23; /* default */

            {
                __L4: /*case 9040*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 1;
                parser_match(ctx);
                return p_type_specifier;
                __L5: /*case 9003*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 2;
                parser_match(ctx);
                return p_type_specifier;
                __L6: /*case 9028*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 4;
                parser_match(ctx);
                return p_type_specifier;
                __L7: /*case 9019*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 8;
                parser_match(ctx);
                return p_type_specifier;
                __L8: /*case 9047*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 33554432;
                parser_match(ctx);
                return p_type_specifier;
                __L9: /*case 9021*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = object_type_to_type_specifier(get_platform(ctx->options.target)->int8_type) & -129;
                parser_match(ctx);
                return p_type_specifier;
                __L10: /*case 9022*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = object_type_to_type_specifier(get_platform(ctx->options.target)->int16_type);
                parser_match(ctx);
                return p_type_specifier;
                __L11: /*case 9023*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = object_type_to_type_specifier(get_platform(ctx->options.target)->int32_type);
                parser_match(ctx);
                return p_type_specifier;
                __L12: /*case 9024*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = object_type_to_type_specifier(get_platform(ctx->options.target)->int64_type);
                parser_match(ctx);
                return p_type_specifier;
                __L13: /*case 9020*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 16;
                parser_match(ctx);
                return p_type_specifier;
                __L14: /*case 9014*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 32;
                parser_match(ctx);
                return p_type_specifier;
                __L15: /*case 9010*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 64;
                parser_match(ctx);
                return p_type_specifier;
                __L16: /*case 9029*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 128;
                parser_match(ctx);
                return p_type_specifier;
                __L17: /*case 9039*/ 
                p_type_specifier->flags = 256;
                p_type_specifier->token = ctx->current;
                parser_match(ctx);
                return p_type_specifier;
                __L18: /*case 9065*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 512;
                parser_match(ctx);
                return p_type_specifier;
                __L19: /*case 9066*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 1024;
                parser_match(ctx);
                return p_type_specifier;
                __L20: /*case 9068*/ 
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 2048;
                parser_match(ctx);
                return p_type_specifier;
                __L21: /*case 9069*/ 
                p_type_specifier->flags = 4096;
                p_type_specifier->token = ctx->current;
                parser_match(ctx);
                return p_type_specifier;
                __L22: /*case 9067*/ 
                p_type_specifier->flags = 8192;
                p_type_specifier->token = ctx->current;
                parser_match(ctx);
                return p_type_specifier;
                __L23: /* default */ 
                goto __L3; /* break */

            }
            __L3:;
        }
        if (first_of_typeof_specifier(ctx))
        {
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = 8388608;
            p_type_specifier->typeof_specifier = typeof_specifier(ctx);
            if (p_type_specifier->typeof_specifier == 0)
            {
                type_specifier_delete(p_type_specifier);
                return 0;
            }
        }
        else
        {
            if (first_of_atomic_type_specifier(ctx))
            {
                p_type_specifier->token = ctx->current;
                p_type_specifier->flags = 16384;
                p_type_specifier->atomic_type_specifier = atomic_type_specifier(ctx);
                if (p_type_specifier->atomic_type_specifier == 0)
                {
                    type_specifier_delete(p_type_specifier);
                    return 0;
                }
            }
            else
            {
                if (first_of_struct_or_union(ctx))
                {
                    p_type_specifier->token = ctx->current;
                    p_type_specifier->flags = 32768;
                    p_type_specifier->struct_or_union_specifier = struct_or_union_specifier(ctx);
                    if (p_type_specifier->struct_or_union_specifier == 0)
                    {
                        type_specifier_delete(p_type_specifier);
                        return 0;
                    }
                }
                else
                {
                    if (first_of_enum_specifier(ctx))
                    {
                        p_type_specifier->token = ctx->current;
                        p_type_specifier->flags = 65536;
                        p_type_specifier->enum_specifier = enum_specifier(ctx);
                        if (p_type_specifier->enum_specifier == 0)
                        {
                            type_specifier_delete(p_type_specifier);
                            return 0;
                        }
                    }
                    else
                    {
                        if (ctx->current->type == 9081)
                        {
                            type_specifier_delete(p_type_specifier);
                            return 0;
                        }
                        else
                        {
                            if (ctx->current->type == 8996)
                            {
                                p_type_specifier->token = ctx->current;
                                p_type_specifier->flags = 131072;
                                p_type_specifier->typedef_declarator = find_declarator(ctx, ctx->current->lexeme, 0);
                                ;
                                parser_match(ctx);
                            }
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        type_specifier_delete(p_type_specifier);
        p_type_specifier = 0;
    }
    return p_type_specifier;
}


int get_enum_type_specifier_flags(struct enum_specifier * p_enum_specifier)
{
    if (p_enum_specifier->specifier_qualifier_list)
    {
        return p_enum_specifier->specifier_qualifier_list->type_specifier_flags;
    }
    if (p_enum_specifier->p_complete_enum_specifier && p_enum_specifier->p_complete_enum_specifier->specifier_qualifier_list)
    {
        return p_enum_specifier->p_complete_enum_specifier->specifier_qualifier_list->type_specifier_flags;
    }
    else
    {
        if (p_enum_specifier->p_complete_enum_specifier && p_enum_specifier->p_complete_enum_specifier->p_complete_enum_specifier && p_enum_specifier->p_complete_enum_specifier->p_complete_enum_specifier->specifier_qualifier_list)
        {
            return p_enum_specifier->p_complete_enum_specifier->p_complete_enum_specifier->specifier_qualifier_list->type_specifier_flags;
        }
    }
    return 8;
}


struct enum_specifier *get_complete_enum_specifier(struct enum_specifier * p_enum_specifier)
{
    if (p_enum_specifier->enumerator_list.head)
    {
        return p_enum_specifier;
    }
    else
    {
        if (p_enum_specifier->p_complete_enum_specifier && p_enum_specifier->p_complete_enum_specifier->enumerator_list.head)
        {
            return p_enum_specifier->p_complete_enum_specifier;
        }
        else
        {
            if (p_enum_specifier->p_complete_enum_specifier && p_enum_specifier->p_complete_enum_specifier->p_complete_enum_specifier && p_enum_specifier->p_complete_enum_specifier->p_complete_enum_specifier->enumerator_list.head)
            {
                return p_enum_specifier->p_complete_enum_specifier->p_complete_enum_specifier;
            }
        }
    }
    return 0;
}


struct struct_or_union_specifier *get_complete_struct_or_union_specifier(struct struct_or_union_specifier * p_struct_or_union_specifier)
{
    if (p_struct_or_union_specifier->member_declaration_list.head)
    {
        return (struct struct_or_union_specifier *)p_struct_or_union_specifier;
    }
    else
    {
        if (p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection && p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection->member_declaration_list.head)
        {
            return p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection;
        }
        else
        {
            if (p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection && p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection->complete_struct_or_union_specifier_indirection && p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection->complete_struct_or_union_specifier_indirection->member_declaration_list.head)
            {
                return p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection->complete_struct_or_union_specifier_indirection;
            }
        }
    }
    return 0;
}


unsigned char struct_or_union_specifier_is_complete(struct struct_or_union_specifier * p_struct_or_union_specifier)
{
    return get_complete_struct_or_union_specifier(p_struct_or_union_specifier) != 0;
}


struct struct_or_union_specifier *struct_or_union_specifier_add_ref(struct struct_or_union_specifier * p)
{
    p->has_shared_ownership = 1;
    return (struct struct_or_union_specifier *)p;
}


void struct_or_union_specifier_sink(struct struct_or_union_specifier * p)
{
}


unsigned char struct_or_union_specifier_is_union(struct struct_or_union_specifier * p)
{
    return p->first_token->type == 9038;
}


void member_declaration_list_destroy(struct member_declaration_list * p);

void struct_or_union_specifier_delete(struct struct_or_union_specifier * p)
{
    if (p)
    {
        if (p->has_shared_ownership)
        {
            p->has_shared_ownership = 0;
            struct_or_union_specifier_sink(p);
            return;
        }
        member_declaration_list_destroy(&p->member_declaration_list);
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        free(p);
    }
}


void naming_convention_struct_tag(struct parser_ctx * ctx, struct token * token);
struct member_declaration_list member_declaration_list(struct parser_ctx * ctx, struct struct_or_union_specifier *);

struct struct_or_union_specifier *struct_or_union_specifier(struct parser_ctx * ctx)
{
    struct struct_or_union_specifier * p_struct_or_union_specifier;

    p_struct_or_union_specifier = 0;
    if (1) /*try*/
    {
        struct struct_or_union_specifier * p_first_tag_in_this_scope;
        struct struct_or_union_specifier * p_complete;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_struct_or_union_specifier = calloc(1, 260);
        if (p_struct_or_union_specifier == 0)
        {
            goto __L0; /* throw */
        }
        ctx->unique_tag_id++;
        p_struct_or_union_specifier->unique_id = ctx->unique_tag_id;
        if (ctx->current->type == 9033 || ctx->current->type == 9038)
        {
            p_struct_or_union_specifier->first_token = ctx->current;
            parser_match(ctx);
        }
        else
        {
            goto __L0; /* throw */
        }
        ;
        p_struct_or_union_specifier->attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);
        p_first_tag_in_this_scope = 0;
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 8996)
        {
            unsigned char  is_struct_definition;
            struct map_entry * p_entry;

            p_struct_or_union_specifier->tagtoken = ctx->current;
            snprintf(p_struct_or_union_specifier->tag_name, 200, "%s", p_struct_or_union_specifier->tagtoken->lexeme);
            parser_match(ctx);
            is_struct_definition = (ctx->current->type == 123);
            p_entry = hashmap_find(&ctx->scopes.tail->tags, p_struct_or_union_specifier->tagtoken->lexeme);
            if (p_entry)
            {
                if (p_entry->type == 2)
                {
                    if (p_struct_or_union_specifier->first_token->type == p_entry->data.p_struct_or_union_specifier->first_token->type)
                    {
                        ;
                        p_first_tag_in_this_scope = p_entry->data.p_struct_or_union_specifier;
                        p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection = p_first_tag_in_this_scope;
                    }
                    else
                    {
                        compiler_diagnostic(1030, ctx, p_struct_or_union_specifier->tagtoken, 0, "use of '%s' with tag type that does not match previous declaration.", p_struct_or_union_specifier->tagtoken->lexeme);
                    }
                }
                else
                {
                    compiler_diagnostic(1030, ctx, p_struct_or_union_specifier->tagtoken, 0, "use of '%s' with tag type that does not match previous declaration.", p_struct_or_union_specifier->tagtoken->lexeme);
                }
            }
            else
            {
                if (is_struct_definition)
                {
                    struct hash_item_set  item;

                    _cake_zmem(&item, 32);
                    item.p_struct_or_union_specifier = struct_or_union_specifier_add_ref(p_struct_or_union_specifier);
                    hashmap_set(&ctx->scopes.tail->tags, p_struct_or_union_specifier->tagtoken->lexeme, &item);
                    hash_item_set_destroy(&item);
                    p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection = p_struct_or_union_specifier;
                }
                else
                {
                    struct struct_or_union_specifier * p_first_tag_previous_scopes;

                    p_first_tag_previous_scopes = find_struct_or_union_specifier(ctx, p_struct_or_union_specifier->tagtoken->lexeme);
                    if (p_first_tag_previous_scopes == 0)
                    {
                        struct hash_item_set  item;

                        p_struct_or_union_specifier->scope_level = ctx->scopes.tail->scope_level;
                        _cake_zmem(&item, 32);
                        item.p_struct_or_union_specifier = struct_or_union_specifier_add_ref(p_struct_or_union_specifier);
                        hashmap_set(&ctx->scopes.tail->tags, p_struct_or_union_specifier->tagtoken->lexeme, &item);
                        hash_item_set_destroy(&item);
                    }
                    else
                    {
                        if (p_first_tag_previous_scopes->first_token->type == p_struct_or_union_specifier->first_token->type)
                        {
                            p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection = p_first_tag_previous_scopes;
                        }
                    }
                }
            }
        }
        else
        {
            struct hash_item_set  item;

            snprintf(p_struct_or_union_specifier->tag_name, 200, "__tag%d", ctx->anonymous_struct_count++);
            p_struct_or_union_specifier->has_anonymous_tag = 1;
            p_struct_or_union_specifier->scope_level = ctx->scopes.tail->scope_level;
            _cake_zmem(&item, 32);
            item.p_struct_or_union_specifier = struct_or_union_specifier_add_ref(p_struct_or_union_specifier);
            hashmap_set(&ctx->scopes.tail->tags, p_struct_or_union_specifier->tag_name, &item);
            hash_item_set_destroy(&item);
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 123)
        {
            struct struct_or_union_specifier * first;
            struct token * firsttoken;

            first = find_struct_or_union_specifier(ctx, p_struct_or_union_specifier->tag_name);
            if (first)
            {
                first->complete_struct_or_union_specifier_indirection = p_struct_or_union_specifier;
            }
            if (p_struct_or_union_specifier->tagtoken)
            {
                naming_convention_struct_tag(ctx, p_struct_or_union_specifier->tagtoken);
            }
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            firsttoken = ctx->current;
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            if (ctx->current->type != 125)
            {
                p_struct_or_union_specifier->member_declaration_list = member_declaration_list(ctx, p_struct_or_union_specifier);
                if (p_struct_or_union_specifier->member_declaration_list.head == 0)
                {
                    goto __L0; /* throw */
                }
            }
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            p_struct_or_union_specifier->member_declaration_list.first_token = firsttoken;
            p_struct_or_union_specifier->last_token = ctx->current;
            p_struct_or_union_specifier->member_declaration_list.last_token = ctx->current;
            if (parser_match_tk(ctx, 125) != 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            p_struct_or_union_specifier->last_token = ctx->current;
        }
        p_complete = get_complete_struct_or_union_specifier(p_struct_or_union_specifier);
        if (p_complete)
        {
            if (p_complete->attribute_specifier_sequence_opt && p_complete->attribute_specifier_sequence_opt->attributes_flags & 1)
            {
                if (p_struct_or_union_specifier->tagtoken)
                {
                    compiler_diagnostic(3, ctx, p_struct_or_union_specifier->first_token, 0, "'%s' is deprecated", p_struct_or_union_specifier->tagtoken->lexeme);
                }
                else
                {
                    compiler_diagnostic(3, ctx, p_struct_or_union_specifier->first_token, 0, "deprecated");
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        struct_or_union_specifier_delete(p_struct_or_union_specifier);
        p_struct_or_union_specifier = 0;
    }
    return p_struct_or_union_specifier;
}


void naming_convention_struct_member(struct parser_ctx * ctx, struct token * token, struct type * type);
void member_declarator_delete(struct member_declarator * p);

struct member_declarator *member_declarator(struct parser_ctx * ctx, struct struct_or_union_specifier * p_struct_or_union_specifier, struct specifier_qualifier_list * p_specifier_qualifier_list)
{
    struct member_declarator * p_member_declarator;

    p_member_declarator = 0;
    if (1) /*try*/
    {
        struct token * p_token_name;

        p_member_declarator = calloc(1, 12);
        if (p_member_declarator == 0)
        {
            goto __L0; /* throw */
        }
        p_token_name = 0;
        p_member_declarator->declarator = declarator(ctx, p_specifier_qualifier_list, 0, 0, &p_token_name);
        if (p_member_declarator->declarator == 0)
        {
            goto __L0; /* throw */
        }
        p_member_declarator->declarator->name_opt = p_token_name;
        p_member_declarator->declarator->specifier_qualifier_list = p_specifier_qualifier_list;
        p_member_declarator->declarator->type = make_type_using_declarator(ctx, p_member_declarator->declarator);
        if (type_is_function(&p_member_declarator->declarator->type))
        {
            struct token * p_token;

            p_token = p_member_declarator->declarator->first_token_opt;
            if (p_token == 0)
            {
                p_token = ctx->current;
            }
            compiler_diagnostic(1840, ctx, p_token, 0, "members having a function type are not allowed");
            goto __L0; /* throw */
        }
        if (type_is_owner(&p_member_declarator->declarator->type))
        {
            p_struct_or_union_specifier->is_owner = 1;
        }
        if (p_member_declarator->declarator->name_opt)
        {
            naming_convention_struct_member(ctx, p_member_declarator->declarator->name_opt, &p_member_declarator->declarator->type);
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 58)
        {
            parser_match(ctx);
            p_member_declarator->constant_expression = constant_expression(ctx, 1, 2);
        }
    }
    else __L0: /*catch*/ 
    {
        member_declarator_delete(p_member_declarator);
        p_member_declarator = 0;
    }
    return p_member_declarator;
}


void member_declarator_delete(struct member_declarator * p)
{
    if (p)
    {
        expression_delete(p->constant_expression);
        ;
        declarator_delete(p->declarator);
        free(p);
    }
}


void member_declarator_list_add(struct member_declarator_list * list, struct member_declarator * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void member_declarator_list_delete(struct member_declarator_list * p)
{
    if (p)
    {
        struct member_declarator * item;

        item = p->head;
        while (item)
        {
            struct member_declarator * next;

            next = item->next;
            item->next = 0;
            member_declarator_delete(item);
            item = next;
        }
        free(p);
    }
}


struct member_declarator_list *member_declarator_list(struct parser_ctx * ctx, struct struct_or_union_specifier * p_struct_or_union_specifier, struct specifier_qualifier_list * p_specifier_qualifier_list)
{
    struct member_declarator_list * p_member_declarator_list;

    p_member_declarator_list = calloc(1, 8);
    if (1) /*try*/
    {
        struct member_declarator * p_member_declarator;

        if (p_member_declarator_list == 0)
        {
            goto __L0; /* throw */
        }
        p_member_declarator = member_declarator(ctx, p_struct_or_union_specifier, p_specifier_qualifier_list);
        if (p_member_declarator == 0)
        {
            goto __L0; /* throw */
        }
        member_declarator_list_add(p_member_declarator_list, p_member_declarator);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        while (ctx->current->type == 44)
        {
            struct member_declarator * p_member_declarator2;

            parser_match(ctx);
            p_member_declarator2 = member_declarator(ctx, p_struct_or_union_specifier, p_specifier_qualifier_list);
            if (p_member_declarator2 == 0)
            {
                goto __L0; /* throw */
            }
            member_declarator_list_add(p_member_declarator_list, p_member_declarator2);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
        }
    }
    else __L0: /*catch*/ 
    {
        member_declarator_list_delete(p_member_declarator_list);
        p_member_declarator_list = 0;
    }
    return p_member_declarator_list;
}


void member_declaration_list_add(struct member_declaration_list * list, struct member_declaration * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void member_declaration_delete(struct member_declaration * p);

void member_declaration_list_destroy(struct member_declaration_list * p)
{
    struct member_declaration * item;

    item = p->head;
    while (item)
    {
        struct member_declaration * next;

        next = item->next;
        item->next = 0;
        member_declaration_delete(item);
        item = next;
    }
}


struct member_declaration *member_declaration(struct parser_ctx * ctx, struct struct_or_union_specifier *);

struct member_declaration_list member_declaration_list(struct parser_ctx * ctx, struct struct_or_union_specifier * p_struct_or_union_specifier)
{
    struct member_declaration_list  list;
    struct member_declaration * p_member_declaration;

    _cake_zmem(&list, 16);
    p_member_declaration = 0;
    if (1) /*try*/
    {
        p_member_declaration = member_declaration(ctx, p_struct_or_union_specifier);
        if (p_member_declaration == 0)
        {
            goto __L0; /* throw */
        }
        member_declaration_list_add(&list, p_member_declaration);
        p_member_declaration = 0;
        while (ctx->current && ctx->current->type != 125)
        {
            p_member_declaration = member_declaration(ctx, p_struct_or_union_specifier);
            if (p_member_declaration == 0)
            {
                goto __L0; /* throw */
            }
            member_declaration_list_add(&list, p_member_declaration);
            p_member_declaration = 0;
        }
    }
    else __L0: /*catch*/ 
    {
        struct member_declaration_list  __v0;

        member_declaration_list_destroy(&list);
        __v0.first_token = 0;
        __v0.last_token = 0;
        __v0.head = 0;
        __v0.tail = 0;
        list = __v0;
    }
    return list;
}


void specifier_qualifier_list_delete(struct specifier_qualifier_list * p);
void static_assert_declaration_delete(struct static_assert_declaration * p);
void pragma_declaration_delete(struct pragma_declaration * p);

void member_declaration_delete(struct member_declaration * p)
{
    if (p)
    {
        ;
        specifier_qualifier_list_delete(p->specifier_qualifier_list);
        member_declarator_list_delete(p->member_declarator_list_opt);
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence);
        static_assert_declaration_delete(p->static_assert_declaration);
        pragma_declaration_delete(p->pragma_declaration);
        free(p);
    }
}


struct specifier_qualifier_list *specifier_qualifier_list(struct parser_ctx * ctx);

struct member_declaration *member_declaration(struct parser_ctx * ctx, struct struct_or_union_specifier * p_struct_or_union_specifier)
{
    struct member_declaration * p_member_declaration;

    p_member_declaration = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_member_declaration = calloc(1, 24);
        if (p_member_declaration == 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current->type == 9073)
        {
            p_member_declaration->static_assert_declaration = static_assert_declaration(ctx);
        }
        else
        {
            if (ctx->current->type == 128)
            {
                p_member_declaration->pragma_declaration = pragma_declaration(ctx);
            }
            else
            {
                ;
                p_member_declaration->p_attribute_specifier_sequence = attribute_specifier_sequence_opt(ctx);
                p_member_declaration->specifier_qualifier_list = specifier_qualifier_list(ctx);
                if (p_member_declaration->specifier_qualifier_list == 0)
                {
                    goto __L0; /* throw */
                }
                if (ctx->current == 0)
                {
                    unexpected_end_of_file(ctx);
                    goto __L0; /* throw */
                }
                if (ctx->current->type != 59)
                {
                    p_member_declaration->member_declarator_list_opt = member_declarator_list(ctx, p_struct_or_union_specifier, p_member_declaration->specifier_qualifier_list);
                    if (p_member_declaration->member_declarator_list_opt == 0)
                    {
                        goto __L0; /* throw */
                    }
                }
                if (parser_match_tk(ctx, 59) != 0)
                {
                    goto __L0; /* throw */
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        member_declaration_delete(p_member_declaration);
        p_member_declaration = 0;
    }
    return p_member_declaration;
}


struct member_declarator *find_member_declarator(struct member_declaration_list * list, char * name, int * p_member_index)
{
    struct member_declaration * p_member_declaration;

    if (list->head == 0)
    {
        return 0;
    }
    p_member_declaration = list->head;
    while (p_member_declaration)
    {
        struct member_declarator * p_member_declarator;

        p_member_declarator = 0;
        if (p_member_declaration->member_declarator_list_opt)
        {
            p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
            while (p_member_declarator)
            {
                if (p_member_declarator->declarator)
                {
                    if (p_member_declarator->declarator->name_opt && strcmp(p_member_declarator->declarator->name_opt->lexeme, name) == 0)
                    {
                        return p_member_declarator;
                    }
                }
                (*p_member_index)++;
                p_member_declarator = p_member_declarator->next;
            }
        }
        else
        {
            if (p_member_declaration->specifier_qualifier_list && p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
            {
                struct struct_or_union_specifier * p_complete;

                p_complete = get_complete_struct_or_union_specifier(p_member_declaration->specifier_qualifier_list->struct_or_union_specifier);
                if (p_complete)
                {
                    p_member_declarator = find_member_declarator(&p_complete->member_declaration_list, name, p_member_index);
                    if (p_member_declarator)
                    {
                        return p_member_declarator;
                    }
                }
            }
        }
        p_member_declaration = p_member_declaration->next;
    }
    return 0;
}


static struct member_declarator *find_member_declarator_by_index_core(struct member_declaration_list * list, int member_index, int * p_count);

struct member_declarator *find_member_declarator_by_index(struct member_declaration_list * list, int member_index)
{
    int count;

    count = 0;
    return find_member_declarator_by_index_core(list, member_index, &count);
}



static struct member_declarator *find_member_declarator_by_index_core(struct member_declaration_list * list, int member_index, int * p_count)
{
    struct member_declaration * p_member_declaration;

    if (list->head == 0)
    {
        return 0;
    }
    p_member_declaration = list->head;
    while (p_member_declaration)
    {
        struct member_declarator * p_member_declarator;

        p_member_declarator = 0;
        if (p_member_declaration->member_declarator_list_opt)
        {
            p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
            while (p_member_declarator)
            {
                if (p_member_declarator->declarator)
                {
                    if (member_index == *p_count)
                    {
                        return p_member_declarator;
                    }
                }
                (*p_count)++;
                p_member_declarator = p_member_declarator->next;
            }
        }
        else
        {
            if (p_member_declaration->specifier_qualifier_list && p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
            {
                struct member_declaration_list * p_member_declaration_list;

                p_member_declaration_list = &p_member_declaration->specifier_qualifier_list->struct_or_union_specifier->member_declaration_list;
                p_member_declarator = find_member_declarator_by_index_core(p_member_declaration_list, member_index, p_count);
                if (p_member_declarator)
                {
                    return p_member_declarator;
                }
            }
        }
        p_member_declaration = p_member_declaration->next;
    }
    return 0;
}
static struct object *find_object_declarator_by_index_core(struct object * p_object0, struct member_declaration_list * list, int member_index, int * p_count);

struct object *find_object_declarator_by_index(struct object * p_object, struct member_declaration_list * list, int member_index)
{
    int count;

    count = 0;
    return find_object_declarator_by_index_core(p_object, list, member_index, &count);
}



static struct object *find_object_declarator_by_index_core(struct object * p_object0, struct member_declaration_list * list, int member_index, int * p_count)
{
    struct object * p_object;
    struct object * p_member_object;
    struct member_declaration * p_member_declaration;

    p_object = object_is_reference(p_object0) ? object_get_referenced(p_object0) : p_object0;
    if (list->head == 0)
    {
        return 0;
    }
    if (p_object->members.head == 0)
    {
        return 0;
    }
    p_member_object = p_object->members.head;
    p_member_declaration = list->head;
    while (p_member_declaration)
    {
        struct member_declarator * p_member_declarator;

        p_member_declarator = 0;
        if (p_member_declaration->member_declarator_list_opt)
        {
            p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
            while (p_member_declarator)
            {
                if (p_member_declarator->declarator)
                {
                    if (member_index == *p_count)
                    {
                        return p_member_object;
                    }
                }
                (*p_count)++;
                p_member_declarator = p_member_declarator->next;
                if (p_member_object == 0)
                {
                    return 0;
                }
                p_member_object = p_member_object->next;
            }
        }
        else
        {
            if (p_member_declaration->specifier_qualifier_list)
            {
                if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                {
                    struct member_declaration_list * p_member_declaration_list;
                    struct object * p_member_object2;

                    p_member_declaration_list = &p_member_declaration->specifier_qualifier_list->struct_or_union_specifier->member_declaration_list;
                    p_member_object2 = find_object_declarator_by_index_core(p_member_object, p_member_declaration_list, member_index, p_count);
                    if (p_member_object2)
                    {
                        return p_member_object2;
                    }
                }
                p_member_object = p_member_object->next;
            }
        }
        p_member_declaration = p_member_declaration->next;
    }
    return 0;
}
void print_specifier_qualifier_list(struct osstream * ss, unsigned char * first, struct specifier_qualifier_list * p_specifier_qualifier_list)
{
    print_type_qualifier_flags(ss, first, p_specifier_qualifier_list->type_qualifier_flags);
    if (p_specifier_qualifier_list->enum_specifier)
    {
        ;
    }
    else
    {
        if (p_specifier_qualifier_list->struct_or_union_specifier)
        {
            ss_fprintf(ss, "struct %s", p_specifier_qualifier_list->struct_or_union_specifier->tag_name);
        }
        else
        {
            if (p_specifier_qualifier_list->typedef_declarator)
            {
                if (p_specifier_qualifier_list->typedef_declarator->name_opt)
                {
                    print_item(ss, first, p_specifier_qualifier_list->typedef_declarator->name_opt->lexeme);
                }
            }
            else
            {
                print_type_specifier_flags(ss, first, p_specifier_qualifier_list->type_specifier_flags);
            }
        }
    }
}


void specifier_qualifier_list_add(struct specifier_qualifier_list * list, struct type_specifier_qualifier * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void specifier_qualifier_list_delete(struct specifier_qualifier_list * p)
{
    if (p)
    {
        struct type_specifier_qualifier * item;

        item = p->head;
        while (item)
        {
            struct type_specifier_qualifier * next;

            next = item->next;
            item->next = 0;
            type_specifier_qualifier_delete(item);
            item = next;
        }
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence);
        free(p);
    }
}


struct specifier_qualifier_list *specifier_qualifier_list(struct parser_ctx * ctx)
{
    struct specifier_qualifier_list * p_specifier_qualifier_list;

    p_specifier_qualifier_list = 0;
    if (1) /*try*/
    {
        struct token * p_previous_parser_token;

        if (!first_of_type_specifier_qualifier(ctx))
        {
            compiler_diagnostic(1040, ctx, ctx->current, 0, "type specifier or qualifier expected");
            goto __L0; /* throw */
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_specifier_qualifier_list = calloc(1, 48);
        if (p_specifier_qualifier_list == 0)
        {
            goto __L0; /* throw */
        }
        p_specifier_qualifier_list->first_token = ctx->current;
        while (ctx->current != 0 && (first_of_type_specifier_qualifier(ctx)))
        {
            struct type_specifier_qualifier * p_type_specifier_qualifier;

            if (ctx->current->flags & 16)
            {
                if (p_specifier_qualifier_list->type_specifier_flags != 0)
                {
                    break;
                }
            }
            p_type_specifier_qualifier = type_specifier_qualifier(ctx);
            if (p_type_specifier_qualifier == 0)
            {
                goto __L0; /* throw */
            }
            if (p_type_specifier_qualifier->type_specifier)
            {
                if (add_specifier(ctx, &p_specifier_qualifier_list->type_specifier_flags, p_type_specifier_qualifier->type_specifier->flags) != 0)
                {
                    type_specifier_qualifier_delete(p_type_specifier_qualifier);
                    goto __L0; /* throw */
                }
                if (p_type_specifier_qualifier->type_specifier->struct_or_union_specifier)
                {
                    p_specifier_qualifier_list->struct_or_union_specifier = p_type_specifier_qualifier->type_specifier->struct_or_union_specifier;
                }
                else
                {
                    if (p_type_specifier_qualifier->type_specifier->enum_specifier)
                    {
                        p_specifier_qualifier_list->enum_specifier = p_type_specifier_qualifier->type_specifier->enum_specifier;
                    }
                    else
                    {
                        if (p_type_specifier_qualifier->type_specifier->typeof_specifier)
                        {
                            p_specifier_qualifier_list->typeof_specifier = p_type_specifier_qualifier->type_specifier->typeof_specifier;
                        }
                        else
                        {
                            if (p_type_specifier_qualifier->type_specifier->token->type == 8996)
                            {
                                p_specifier_qualifier_list->typedef_declarator = find_declarator(ctx, p_type_specifier_qualifier->type_specifier->token->lexeme, 0);
                            }
                        }
                    }
                }
            }
            else
            {
                if (p_type_specifier_qualifier->alignment_specifier)
                {
                    p_specifier_qualifier_list->alignment_specifier_flags |= p_type_specifier_qualifier->alignment_specifier->flags;
                }
                else
                {
                    if (p_type_specifier_qualifier->type_qualifier)
                    {
                        p_specifier_qualifier_list->type_qualifier_flags |= p_type_specifier_qualifier->type_qualifier->flags;
                    }
                }
            }
            ;
            p_specifier_qualifier_list->p_attribute_specifier_sequence = attribute_specifier_sequence_opt(ctx);
            specifier_qualifier_list_add(p_specifier_qualifier_list, p_type_specifier_qualifier);
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        final_specifier(ctx, &p_specifier_qualifier_list->type_specifier_flags);
        p_previous_parser_token = previous_parser_token(ctx->current);
        if (p_previous_parser_token == 0)
        {
            goto __L0; /* throw */
        }
        p_specifier_qualifier_list->last_token = p_previous_parser_token;
    }
    else __L0: /*catch*/ 
    {
        specifier_qualifier_list_delete(p_specifier_qualifier_list);
        p_specifier_qualifier_list = 0;
    }
    return p_specifier_qualifier_list;
}


void type_qualifier_delete(struct type_qualifier * p)
{
    if (p)
    {
        ;
        free(p);
    }
}


void alignment_specifier_delete(struct alignment_specifier * p);

void type_specifier_qualifier_delete(struct type_specifier_qualifier * p)
{
    if (p)
    {
        ;
        if (p->type_qualifier)
        {
            ;
            free(p->type_qualifier);
        }
        alignment_specifier_delete(p->alignment_specifier);
        type_specifier_delete(p->type_specifier);
        free(p);
    }
}


struct type_qualifier *type_qualifier(struct parser_ctx * ctx);
struct alignment_specifier *alignment_specifier(struct parser_ctx * ctx);

struct type_specifier_qualifier *type_specifier_qualifier(struct parser_ctx * ctx)
{
    struct type_specifier_qualifier * type_specifier_qualifier;

    type_specifier_qualifier = 0;
    if (1) /*try*/
    {
        type_specifier_qualifier = calloc(1, 16);
        if (type_specifier_qualifier == 0)
        {
            goto __L0; /* throw */
        }
        if (first_of_type_specifier(ctx))
        {
            type_specifier_qualifier->type_specifier = type_specifier(ctx);
            if (type_specifier_qualifier->type_specifier == 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            if (first_of_type_qualifier(ctx))
            {
                type_specifier_qualifier->type_qualifier = type_qualifier(ctx);
                if (type_specifier_qualifier->type_qualifier == 0)
                {
                    goto __L0; /* throw */
                }
            }
            else
            {
                if (first_of_alignment_specifier(ctx))
                {
                    type_specifier_qualifier->alignment_specifier = alignment_specifier(ctx);
                    if (type_specifier_qualifier->alignment_specifier == 0)
                    {
                        goto __L0; /* throw */
                    }
                }
                else
                {
                    ;
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        type_specifier_qualifier_delete(type_specifier_qualifier);
        type_specifier_qualifier = 0;
    }
    return type_specifier_qualifier;
}


struct enumerator *find_enumerator_by_value(struct parser_ctx * ctx, struct enum_specifier * p_enum_specifier, struct object * object)
{
    struct enumerator * p;

    if (p_enum_specifier->enumerator_list.head == 0)
    {
        return 0;
    }
    p = p_enum_specifier->enumerator_list.head;
    while (p)
    {
        if (object_is_equal(ctx->options.target, &p->value, object))
        {
            return p;
        }
        p = p->next;
    }
    return 0;
}


struct enum_specifier *enum_specifier_add_ref(struct enum_specifier * p)
{
    p->has_shared_ownership = 1;
    return (struct enum_specifier *)p;
}


void enum_specifier_delete_sink(struct enum_specifier * p)
{
}


void enumerator_list_destroy(struct enumerator_list * p_enum_specifier);

void enum_specifier_delete(struct enum_specifier * p)
{
    if (p)
    {
        if (p->has_shared_ownership)
        {
            p->has_shared_ownership = 0;
            enum_specifier_delete_sink(p);
            return;
        }
        specifier_qualifier_list_delete(p->specifier_qualifier_list);
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        enumerator_list_destroy(&p->enumerator_list);
        free(p);
    }
}


unsigned char enum_specifier_has_fixed_underlying_type(struct enum_specifier * p_enum_specifier)
{
    return p_enum_specifier->specifier_qualifier_list != 0;
}


struct type make_with_type_specifier_flags(int f);
void naming_convention_enum_tag(struct parser_ctx * ctx, struct token * token);
struct enumerator_list enumerator_list(struct parser_ctx * ctx, struct enum_specifier * p_enum_specifier);

struct enum_specifier *enum_specifier(struct parser_ctx * ctx)
{
    struct enum_specifier * p_enum_specifier;

    p_enum_specifier = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_enum_specifier = calloc(1, 232);
        if (p_enum_specifier == 0)
        {
            goto __L0; /* throw */
        }
        p_enum_specifier->first_token = ctx->current;
        if (parser_match_tk(ctx, 9012) != 0)
        {
            goto __L0; /* throw */
        }
        p_enum_specifier->attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 8996)
        {
            snprintf(p_enum_specifier->tag_name, 200, "%s", ctx->current->lexeme);
            p_enum_specifier->tag_token = ctx->current;
            parser_match(ctx);
        }
        else
        {
            snprintf(p_enum_specifier->tag_name, 200, "__tag%d", ctx->anonymous_struct_count++);
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 58)
        {
            if (!ctx->inside_generic_association)
            {
                struct type  enum_underline_type;

                parser_match(ctx);
                p_enum_specifier->specifier_qualifier_list = specifier_qualifier_list(ctx);
                if (p_enum_specifier->specifier_qualifier_list == 0)
                {
                    goto __L0; /* throw */
                }
                enum_underline_type = make_with_type_specifier_flags(p_enum_specifier->specifier_qualifier_list->type_specifier_flags);
                if (!type_is_integer(&enum_underline_type))
                {
                    type_destroy(&enum_underline_type);
                    compiler_diagnostic(1850, ctx, p_enum_specifier->specifier_qualifier_list->first_token, 0, "expected an integer type");
                    goto __L0; /* throw */
                }
                type_destroy(&enum_underline_type);
            }
            else
            {
            }
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 123)
        {
            struct hash_item_set  item;

            if (p_enum_specifier->tag_token)
            {
                naming_convention_enum_tag(ctx, p_enum_specifier->tag_token);
            }
            p_enum_specifier->p_complete_enum_specifier = p_enum_specifier;
            if (parser_match_tk(ctx, 123) != 0)
            {
                goto __L0; /* throw */
            }
            p_enum_specifier->enumerator_list = enumerator_list(ctx, p_enum_specifier);
            if (p_enum_specifier->enumerator_list.head == 0)
            {
                goto __L0; /* throw */
            }
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            if (ctx->current->type == 44)
            {
                parser_match(ctx);
            }
            if (parser_match_tk(ctx, 125) != 0)
            {
                goto __L0; /* throw */
            }
            _cake_zmem(&item, 32);
            item.p_enum_specifier = enum_specifier_add_ref(p_enum_specifier);
            hashmap_set(&ctx->scopes.tail->tags, p_enum_specifier->tag_name, &item);
            p_enum_specifier->p_complete_enum_specifier = p_enum_specifier;
            hash_item_set_destroy(&item);
        }
        else
        {
            struct enum_specifier * p_existing_enum_specifier;

            p_existing_enum_specifier = 0;
            if (p_enum_specifier->tag_token)
            {
                p_existing_enum_specifier = find_enum_specifier(ctx, p_enum_specifier->tag_token->lexeme);
            }
            if (p_existing_enum_specifier)
            {
                p_enum_specifier->p_complete_enum_specifier = p_existing_enum_specifier;
            }
            else
            {
                struct hash_item_set  item;

                _cake_zmem(&item, 32);
                item.p_enum_specifier = enum_specifier_add_ref(p_enum_specifier);
                hashmap_set(&ctx->scopes.tail->tags, p_enum_specifier->tag_name, &item);
                p_enum_specifier->p_complete_enum_specifier = p_enum_specifier;
                hash_item_set_destroy(&item);
            }
        }
    }
    else __L0: /*catch*/ 
    {
        enum_specifier_delete(p_enum_specifier);
        p_enum_specifier = 0;
    }
    return p_enum_specifier;
}


void enumerator_list_add(struct enumerator_list * list, struct enumerator * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void enumerator_list_destroy(struct enumerator_list * p)
{
    struct enumerator * item;

    item = p->head;
    while (item)
    {
        struct enumerator * next;

        next = item->next;
        item->next = 0;
        enumerator_delete(item);
        item = next;
    }
}


struct enumerator *enumerator(struct parser_ctx * ctx, struct enum_specifier * p_enum_specifier, struct object * p_enumerator_value);

struct enumerator_list enumerator_list(struct parser_ctx * ctx, struct enum_specifier * p_enum_specifier)
{
    struct object  next_enumerator_value;
    struct enumerator_list  enumeratorlist;
    struct enumerator * p_enumerator;

    next_enumerator_value = object_make_signed_int(ctx->options.target, 0);
    if (p_enum_specifier->specifier_qualifier_list)
    {
        int vt;

        vt = type_specifier_to_object_type(p_enum_specifier->specifier_qualifier_list->type_specifier_flags, ctx->options.target);
        next_enumerator_value = object_cast(ctx->options.target, vt, &next_enumerator_value);
    }
    _cake_zmem(&enumeratorlist, 8);
    p_enumerator = 0;
    if (1) /*try*/
    {
        p_enumerator = enumerator(ctx, p_enum_specifier, &next_enumerator_value);
        if (p_enumerator == 0)
        {
            goto __L1; /* throw */
        }
        enumerator_list_add(&enumeratorlist, p_enumerator);
        while (ctx->current != 0 && ctx->current->type == 44)
        {
            parser_match(ctx);
            if (ctx->current && ctx->current->type != 125)
            {
                p_enumerator = enumerator(ctx, p_enum_specifier, &next_enumerator_value);
                if (p_enumerator == 0)
                {
                    goto __L1; /* throw */
                }
                enumerator_list_add(&enumeratorlist, p_enumerator);
            }
        }
    }
    else __L1: /*catch*/ 
    {
        enumerator_list_destroy(&enumeratorlist);
        enumeratorlist.head = 0;
        enumeratorlist.tail = 0;
    }
    return enumeratorlist;
}


struct enumerator *enumerator_add_ref(struct enumerator * p)
{
    p->has_shared_ownership = 1;
    return (struct enumerator *)p;
}


void enumerator_sink(struct enumerator * p)
{
}


void enumerator_delete(struct enumerator * p)
{
    if (p)
    {
        if (p->has_shared_ownership)
        {
            p->has_shared_ownership = 0;
            enumerator_sink(p);
            return;
        }
        ;
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        expression_delete(p->constant_expression_opt);
        free(p);
    }
}


void naming_convention_enumerator(struct parser_ctx * ctx, struct token * token);

struct enumerator *enumerator(struct parser_ctx * ctx, struct enum_specifier * p_enum_specifier, struct object * p_next_enumerator_value)
{
    struct enumerator * p_enumerator;

    p_enumerator = 0;
    if (1) /*try*/
    {
        struct token * name;
        struct hash_item_set  item;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_enumerator = calloc(1, 144);
        if (p_enumerator == 0)
        {
            goto __L0; /* throw */
        }
        p_enumerator->enum_specifier = p_enum_specifier;
        name = ctx->current;
        naming_convention_enumerator(ctx, name);
        if (parser_match_tk(ctx, 8996) != 0)
        {
            goto __L0; /* throw */
        }
        p_enumerator->attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);
        p_enumerator->token = name;
        _cake_zmem(&item, 32);
        item.p_enumerator = enumerator_add_ref(p_enumerator);
        hashmap_set(&ctx->scopes.tail->variables, p_enumerator->token->lexeme, &item);
        hash_item_set_destroy(&item);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 61)
        {
            parser_match(ctx);
            ;
            p_enumerator->constant_expression_opt = constant_expression(ctx, 1, 2);
            if (p_enumerator->constant_expression_opt == 0)
            {
                goto __L0; /* throw */
            }
            if (enum_specifier_has_fixed_underlying_type(p_enum_specifier))
            {
            }
            else
            {
            }
            p_enumerator->value = p_enumerator->constant_expression_opt->object;
            *p_next_enumerator_value = *object_get_referenced(&p_enumerator->value);
            object_increment_value(ctx->options.target, p_next_enumerator_value);
        }
        else
        {
            p_enumerator->value = *p_next_enumerator_value;
            object_increment_value(ctx->options.target, p_next_enumerator_value);
        }
    }
    else __L0: /*catch*/ 
    {
        enumerator_delete(p_enumerator);
        p_enumerator = 0;
    }
    return p_enumerator;
}


void alignment_specifier_delete(struct alignment_specifier * p)
{
    if (p)
    {
        expression_delete(p->constant_expression);
        type_name_delete(p->type_name);
        free(p);
    }
}


struct alignment_specifier *alignment_specifier(struct parser_ctx * ctx)
{
    struct alignment_specifier * alignment_specifier;

    alignment_specifier = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        alignment_specifier = calloc(1, 16);
        if (alignment_specifier == 0)
        {
            goto __L0; /* throw */
        }
        alignment_specifier->token = ctx->current;
        if (parser_match_tk(ctx, 9043) != 0)
        {
            goto __L0; /* throw */
        }
        if (parser_match_tk(ctx, 40) != 0)
        {
            goto __L0; /* throw */
        }
        if (first_of_type_name(ctx))
        {
            alignment_specifier->type_name = type_name(ctx);
            if (alignment_specifier->type_name == 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            alignment_specifier->constant_expression = constant_expression(ctx, 1, 2);
            if (alignment_specifier->constant_expression == 0)
            {
                goto __L0; /* throw */
            }
            if (object_has_constant_value(&alignment_specifier->constant_expression->object))
            {
                long long a;

                a = object_to_signed_long_long(&alignment_specifier->constant_expression->object);
                if (a == 8)
                {
                    alignment_specifier->flags |= 1;
                }
                else
                {
                    if (a == 16)
                    {
                        alignment_specifier->flags |= 2;
                    }
                    else
                    {
                        if (a == 32)
                        {
                            alignment_specifier->flags |= 4;
                        }
                        else
                        {
                            if (a == 64)
                            {
                                alignment_specifier->flags |= 8;
                            }
                            else
                            {
                                if (a == 128)
                                {
                                    alignment_specifier->flags |= 16;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (parser_match_tk(ctx, 41) != 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return alignment_specifier;
}


void atomic_type_specifier_delete(struct atomic_type_specifier * p)
{
    if (p)
    {
        type_name_delete(p->type_name);
        free(p);
    }
}


struct atomic_type_specifier *atomic_type_specifier(struct parser_ctx * ctx)
{
    struct atomic_type_specifier * p_atomic_type_specifier;

    p_atomic_type_specifier = 0;
    if (1) /*try*/
    {
        struct type_name * ptemp;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_atomic_type_specifier = calloc(1, 8);
        if (p_atomic_type_specifier == 0)
        {
            goto __L0; /* throw */
        }
        p_atomic_type_specifier->token = ctx->current;
        if (parser_match_tk(ctx, 9045) != 0)
        {
            goto __L0; /* throw */
        }
        if (parser_match_tk(ctx, 40) != 0)
        {
            goto __L0; /* throw */
        }
        ptemp = type_name(ctx);
        if (ptemp == 0)
        {
            goto __L0; /* throw */
        }
        p_atomic_type_specifier->type_name = ptemp;
        if (parser_match_tk(ctx, 41) != 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        atomic_type_specifier_delete(p_atomic_type_specifier);
        p_atomic_type_specifier = 0;
    }
    return p_atomic_type_specifier;
}


struct type_qualifier *type_qualifier(struct parser_ctx * ctx)
{
    struct type_qualifier * p_type_qualifier;

    if (ctx->current == 0)
    {
        unexpected_end_of_file(ctx);
        return 0;
    }
    p_type_qualifier = calloc(1, 12);
    if (p_type_qualifier == 0)
    {
        return 0;
    }
    /*switch*/
    {
        int __v0 = ctx->current->type;
        if (__v0 == 9004) goto __L3; /*case 9004*/
        if (__v0 == 9026) goto __L4; /*case 9026*/
        if (__v0 == 9041) goto __L5; /*case 9041*/
        if (__v0 == 9045) goto __L6; /*case 9045*/
        if (__v0 == 9053) goto __L7; /*case 9053*/
        if (__v0 == 9054) goto __L8; /*case 9054*/
        if (__v0 == 9055) goto __L9; /*case 9055*/
        goto __L10; /* default */

        {
            __L3: /*case 9004*/ 
            p_type_qualifier->flags = 1;
            goto __L2; /* break */

            __L4: /*case 9026*/ 
            p_type_qualifier->flags = 2;
            goto __L2; /* break */

            __L5: /*case 9041*/ 
            p_type_qualifier->flags = 4;
            goto __L2; /* break */

            __L6: /*case 9045*/ 
            p_type_qualifier->flags = 8;
            goto __L2; /* break */

            __L7: /*case 9053*/ 
            p_type_qualifier->flags = 512;
            goto __L2; /* break */

            __L8: /*case 9054*/ 
            p_type_qualifier->flags = 1024;
            goto __L2; /* break */

            __L9: /*case 9055*/ 
            p_type_qualifier->flags = 2048;
            goto __L2; /* break */

            __L10: /* default */ 
            goto __L2; /* break */

        }
        __L2:;
    }
    if (ctx->options.ownership_enabled)
    {
        /*switch*/
        {
            int __v1 = ctx->current->type;
            if (__v1 == 9083) goto __L13; /*case 9083*/
            if (__v1 == 9084) goto __L14; /*case 9084*/
            if (__v1 == 9082) goto __L15; /*case 9082*/
            if (__v1 == 9085) goto __L16; /*case 9085*/
            goto __L17; /* default */

            {
                __L13: /*case 9083*/ 
                p_type_qualifier->flags = 256;
                goto __L12; /* break */

                __L14: /*case 9084*/ 
                p_type_qualifier->flags = 128;
                goto __L12; /* break */

                __L15: /*case 9082*/ 
                p_type_qualifier->flags = 16;
                goto __L12; /* break */

                __L16: /*case 9085*/ 
                p_type_qualifier->flags = 32;
                goto __L12; /* break */

                __L17: /* default */ 
                goto __L12; /* break */

            }
            __L12:;
        }
    }
    if (ctx->options.null_checks_enabled)
    {
        /*switch*/
        {
            int __v2 = ctx->current->type;
            if (__v2 == 9086) goto __L20; /*case 9086*/
            goto __L21; /* default */

            {
                __L20: /*case 9086*/ 
                p_type_qualifier->flags = 64;
                goto __L19; /* break */

                __L21: /* default */ 
                goto __L19; /* break */

            }
            __L19:;
        }
    }
    p_type_qualifier->token = ctx->current;
    parser_match(ctx);
    return p_type_qualifier;
}


struct type_qualifier *type_qualifier_opt(struct parser_ctx * ctx)
{
    if (first_of_type_qualifier(ctx))
    {
        return type_qualifier(ctx);
    }
    return 0;
}


void function_specifier_delete(struct function_specifier * p)
{
    if (p)
    {
        free(p);
    }
}


struct function_specifier *function_specifier(struct parser_ctx * ctx)
{
    struct function_specifier * p_function_specifier;

    p_function_specifier = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_function_specifier = calloc(1, 8);
        if (p_function_specifier == 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current->type == 9072)
        {
            compiler_diagnostic(11, ctx, ctx->current, 0, "_Noreturn is deprecated use attributes");
        }
        if (ctx->current->type == 9018)
        {
            p_function_specifier->flags |= 1;
        }
        p_function_specifier->token = ctx->current;
        parser_match(ctx);
    }
    else __L0: /*catch*/ 
    {
        function_specifier_delete(p_function_specifier);
        p_function_specifier = 0;
    }
    return p_function_specifier;
}


struct declarator *declarator_add_ref(struct declarator * p)
{
    p->has_shared_ownership = 1;
    return (struct declarator *)p;
}


void declarator_sink(struct declarator * p)
{
}


void direct_declarator_delete(struct direct_declarator * p);
void pointer_delete(struct pointer * p);

void declarator_delete(struct declarator * p)
{
    if (p)
    {
        if (p->has_shared_ownership)
        {
            p->has_shared_ownership = 0;
            declarator_sink(p);
            return;
        }
        type_destroy(&p->type);
        direct_declarator_delete(p->direct_declarator);
        pointer_delete(p->pointer);
        free(p);
    }
}


struct pointer *pointer_opt(struct parser_ctx * ctx);
struct direct_declarator *direct_declarator(struct parser_ctx * ctx, struct specifier_qualifier_list * specifier_qualifier_list, struct declaration_specifiers * declaration_specifiers, unsigned char  abstract_acceptable, struct token ** pptoken_name);
static struct asm_statement *gcc_asm(struct parser_ctx * ctx, unsigned char  statement);
static void gcc_asm_qualifier_opt(struct parser_ctx * ctx);
void asm_statement_delete(struct asm_statement * p);

struct declarator *declarator(struct parser_ctx * ctx, struct specifier_qualifier_list * p_specifier_qualifier_list_opt, struct declaration_specifiers * p_declaration_specifiers_opt, unsigned char  abstract_acceptable, struct token ** pp_token_name_opt)
{
    struct declarator * p_declarator;
    struct attribute_specifier_sequence * p;

    p_declarator = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_declarator = calloc(1, 256);
        if (p_declarator == 0)
        {
            goto __L0; /* throw */
        }
        p_declarator->first_token_opt = ctx->current;
        p_declarator->pointer = pointer_opt(ctx);
        p_declarator->direct_declarator = direct_declarator(ctx, p_specifier_qualifier_list_opt, p_declaration_specifiers_opt, abstract_acceptable, pp_token_name_opt);
        if (p_declarator->direct_declarator == 0)
        {
            goto __L0; /* throw */
        }
        if (pp_token_name_opt && *pp_token_name_opt)
        {
            free((void *)p_declarator->object.member_designator);
            p_declarator->object.member_designator = strdup((*pp_token_name_opt)->lexeme);
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current != p_declarator->first_token_opt)
        {
            p_declarator->last_token_opt = previous_parser_token(ctx->current);
        }
        else
        {
            p_declarator->last_token_opt = p_declarator->first_token_opt;
            p_declarator->first_token_opt = 0;
        }
    }
    else __L0: /*catch*/ 
    {
        declarator_delete(p_declarator);
        p_declarator = 0;
    }
    p = attribute_specifier_sequence_opt(ctx);
    attribute_specifier_sequence_delete(p);
    if (ctx->current->type == 9064)
    {
        struct asm_statement * p3;

        p3 = gcc_asm(ctx, 0);
        asm_statement_delete(p3);
    }
    return p_declarator;
}



static void gcc_asm_qualifier_opt(struct parser_ctx * ctx)
{
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 9041)
        {
            parser_match(ctx);
            if (ctx->current->type == 9016)
            {
                parser_match(ctx);
            }
        }
        else
        {
            if (ctx->current->type == 9016)
            {
                parser_match(ctx);
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static struct asm_statement *gcc_asm(struct parser_ctx * ctx, unsigned char  statement)
{
    struct asm_statement * p_asm_statement;

    p_asm_statement = 0;
    if (1) /*try*/
    {
        int count;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_asm_statement = calloc(1, 8);
        if (p_asm_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_asm_statement->p_first_token = ctx->current;
        if (parser_match_tk(ctx, 9064) != 0)
        {
            goto __L0; /* throw */
        }
        gcc_asm_qualifier_opt(ctx);
        if (parser_match_tk(ctx, 40) != 0)
        {
            goto __L0; /* throw */
        }
        count = 1;
        for (; ; )
        {
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            if (ctx->current->type == 41)
            {
                count--;
                parser_match(ctx);
                if (count == 0)
                {
                    p_asm_statement->p_last_token = ctx->current;
                    break;
                }
            }
            else
            {
                if (ctx->current->type == 40)
                {
                    count++;
                    parser_match(ctx);
                }
                else
                {
                    parser_match(ctx);
                }
            }
        }
        if (statement)
        {
            if (parser_match_tk(ctx, 59) != 0)
            {
                goto __L0; /* throw */
            }
        }
    }
    else __L0: /*catch*/ 
    {
        asm_statement_delete(p_asm_statement);
        p_asm_statement = 0;
    }
    return p_asm_statement;
}
char *declarator_get_name(struct declarator * p_declarator)
{
    if (p_declarator->direct_declarator)
    {
        if (p_declarator->direct_declarator->name_opt)
        {
            return p_declarator->direct_declarator->name_opt->lexeme;
        }
    }
    return 0;
}


unsigned char declarator_is_function(struct declarator * p_declarator)
{
    return (p_declarator->direct_declarator && p_declarator->direct_declarator->function_declarator != 0);
}


void parameter_type_list_delete(struct parameter_type_list * p);

void function_declarator_delete(struct function_declarator * p)
{
    if (p)
    {
        direct_declarator_delete(p->direct_declarator);
        scope_destroy(&p->parameters_scope);
        parameter_type_list_delete(p->parameter_type_list_opt);
        free(p);
    }
}


void array_declarator_delete(struct array_declarator * p);

void direct_declarator_delete(struct direct_declarator * p)
{
    if (p)
    {
        declarator_delete(p->declarator);
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence);
        array_declarator_delete(p->array_declarator);
        function_declarator_delete(p->function_declarator);
        free(p);
    }
}


struct array_declarator *array_declarator(struct direct_declarator * p_direct_declarator, struct parser_ctx * ctx, int eval_mode);
struct function_declarator *function_declarator(struct direct_declarator * p_direct_declarator, struct parser_ctx * ctx);

struct direct_declarator *direct_declarator(struct parser_ctx * ctx, struct specifier_qualifier_list * p_specifier_qualifier_list, struct declaration_specifiers * p_declaration_specifiers, unsigned char  abstract_acceptable, struct token ** pp_token_name_opt)
{
    struct direct_declarator * p_direct_declarator;

    p_direct_declarator = 0;
    if (1) /*try*/
    {
        struct token * p_token_ahead;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_direct_declarator = calloc(1, 24);
        if (p_direct_declarator == 0)
        {
            goto __L0; /* throw */
        }
        p_token_ahead = parser_look_ahead(ctx);
        if (p_token_ahead == 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current->type == 9057 || ctx->current->type == 9058 || ctx->current->type == 9056)
        {
            p_direct_declarator->p_calling_convention = ctx->current;
            parser_match(ctx);
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 8996)
        {
            p_direct_declarator->name_opt = ctx->current;
            if (pp_token_name_opt != 0)
            {
                *pp_token_name_opt = ctx->current;
            }
            parser_match(ctx);
            p_direct_declarator->p_attribute_specifier_sequence = attribute_specifier_sequence_opt(ctx);
        }
        else
        {
            if (ctx->current->type == 40)
            {
                struct token * ahead;

                ahead = parser_look_ahead(ctx);
                if (ahead == 0)
                {
                    goto __L0; /* throw */
                }
                if (!first_of_type_specifier_token(ctx, p_token_ahead) && !first_of_type_qualifier_token(p_token_ahead) && ahead->type != 41 && ahead->type != 3026478)
                {
                    struct declarator * p_declarator_temp;

                    parser_match(ctx);
                    p_declarator_temp = declarator(ctx, p_specifier_qualifier_list, p_declaration_specifiers, abstract_acceptable, pp_token_name_opt);
                    if (p_declarator_temp == 0)
                    {
                        goto __L0; /* throw */
                    }
                    p_direct_declarator->declarator = p_declarator_temp;
                    parser_match(ctx);
                }
            }
        }
        while (ctx->current != 0 && (ctx->current->type == 91 || ctx->current->type == 40))
        {
            struct direct_declarator * p_direct_declarator2;

            p_direct_declarator2 = calloc(1, 24);
            if (p_direct_declarator2 == 0)
            {
                goto __L0; /* throw */
            }
            if (ctx->current->type == 91)
            {
                p_direct_declarator2->array_declarator = array_declarator(p_direct_declarator, ctx, 2);
                p_direct_declarator = 0;
                if (p_direct_declarator2->array_declarator == 0)
                {
                    direct_declarator_delete(p_direct_declarator2);
                    goto __L0; /* throw */
                }
            }
            else
            {
                p_direct_declarator2->function_declarator = function_declarator(p_direct_declarator, ctx);
                p_direct_declarator = 0;
                if (p_direct_declarator2->function_declarator == 0)
                {
                    direct_declarator_delete(p_direct_declarator2);
                    goto __L0; /* throw */
                }
            }
            p_direct_declarator = p_direct_declarator2;
            ;
            p_direct_declarator->p_attribute_specifier_sequence = attribute_specifier_sequence_opt(ctx);
        }
    }
    else __L0: /*catch*/ 
    {
        direct_declarator_delete(p_direct_declarator);
        p_direct_declarator = 0;
    }
    return p_direct_declarator;
}


void type_qualifier_list_delete(struct type_qualifier_list * p);

void array_declarator_delete(struct array_declarator * p)
{
    if (p)
    {
        expression_delete(p->assignment_expression);
        direct_declarator_delete(p->direct_declarator);
        expression_delete(p->expression);
        type_qualifier_list_delete(p->type_qualifier_list_opt);
        free(p);
    }
}


unsigned int array_declarator_is_vla(struct array_declarator * p_array_declarator)
{
    if (p_array_declarator->assignment_expression)
    {
        return !object_has_constant_value(&p_array_declarator->assignment_expression->object);
    }
    return 0;
}


unsigned int array_declarator_get_size(struct array_declarator * p_array_declarator)
{
    if (p_array_declarator->assignment_expression)
    {
        if (object_has_constant_value(&p_array_declarator->assignment_expression->object))
        {
            return (unsigned int)object_to_unsigned_long_long(&p_array_declarator->assignment_expression->object);
        }
    }
    return 0;
}


struct type_qualifier_list *type_qualifier_list(struct parser_ctx * ctx);

struct array_declarator *array_declarator(struct direct_declarator * p_direct_declarator, struct parser_ctx * ctx, int eval_mode)
{
    struct array_declarator * p_array_declarator;

    p_array_declarator = 0;
    if (1) /*try*/
    {
        unsigned char  has_static;

        p_array_declarator = calloc(1, 24);
        if (p_array_declarator == 0)
        {
            goto __L0; /* throw */
        }
        p_array_declarator->direct_declarator = p_direct_declarator;
        p_direct_declarator = 0;
        if (parser_match_tk(ctx, 91) != 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        has_static = 0;
        if (ctx->current->type == 9032)
        {
            p_array_declarator->static_token_opt = ctx->current;
            parser_match(ctx);
            has_static = 1;
        }
        if (first_of_type_qualifier(ctx))
        {
            p_array_declarator->type_qualifier_list_opt = type_qualifier_list(ctx);
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (!has_static)
        {
            if (ctx->current->type == 9032)
            {
                parser_match(ctx);
                has_static = 1;
            }
        }
        if (has_static)
        {
            p_array_declarator->assignment_expression = assignment_expression(ctx, 2);
            if (p_array_declarator->assignment_expression == 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            if (ctx->current->type == 42)
            {
                parser_match(ctx);
            }
            else
            {
                if (ctx->current->type != 93)
                {
                    p_array_declarator->assignment_expression = assignment_expression(ctx, 2);
                    if (p_array_declarator->assignment_expression == 0)
                    {
                        goto __L0; /* throw */
                    }
                }
                else
                {
                }
            }
        }
        if (parser_match_tk(ctx, 93) != 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        array_declarator_delete(p_array_declarator);
        p_array_declarator = 0;
    }
    direct_declarator_delete(p_direct_declarator);
    return p_array_declarator;
}


struct parameter_type_list *parameter_type_list(struct parser_ctx * ctx);

struct function_declarator *function_declarator(struct direct_declarator * p_direct_declarator_arg, struct parser_ctx * ctx)
{
    struct direct_declarator * p_direct_declarator;
    struct function_declarator * p_function_declarator;

    p_direct_declarator = p_direct_declarator_arg;
    p_function_declarator = calloc(1, 44);
    if (1) /*try*/
    {
        if (p_function_declarator == 0)
        {
            goto __L0; /* throw */
        }
        p_function_declarator->direct_declarator = p_direct_declarator;
        p_direct_declarator = 0;
        p_function_declarator->parameters_scope.scope_level = ctx->scopes.tail->scope_level + 1;
        p_function_declarator->parameters_scope.variables.capacity = 5;
        p_function_declarator->parameters_scope.tags.capacity = 1;
        if (parser_match_tk(ctx, 40) != 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type != 41)
        {
            scope_list_push(&ctx->scopes, &p_function_declarator->parameters_scope);
            p_function_declarator->parameter_type_list_opt = parameter_type_list(ctx);
            scope_list_pop(&ctx->scopes);
            if (p_function_declarator->parameter_type_list_opt == 0)
            {
                goto __L0; /* throw */
            }
        }
        if (parser_match_tk(ctx, 41) != 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        function_declarator_delete(p_function_declarator);
        p_function_declarator = 0;
    }
    direct_declarator_delete(p_direct_declarator);
    return p_function_declarator;
}


void pointer_delete(struct pointer * p)
{
    if (p)
    {
        struct pointer * item;

        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        type_qualifier_list_delete(p->type_qualifier_list_opt);
        item = p->pointer;
        while (item)
        {
            struct pointer * next;

            next = item->pointer;
            attribute_specifier_sequence_delete(item->attribute_specifier_sequence_opt);
            type_qualifier_list_delete(item->type_qualifier_list_opt);
            free(item);
            item = next;
        }
        free(p);
    }
}


struct pointer *pointer_opt(struct parser_ctx * ctx)
{
    struct pointer * p;
    struct pointer * p_pointer;

    p = 0;
    p_pointer = 0;
    if (1) /*try*/
    {
        struct token * calling_convention;
        struct token * ahead;

        calling_convention = 0;
        ahead = parser_look_ahead(ctx);
        if (ahead != 0 && ahead->type == 42)
        {
            if (ctx->current->type == 9057 || ctx->current->type == 9058 || ctx->current->type == 9056)
            {
                calling_convention = ctx->current;
                parser_match(ctx);
            }
        }
        while (ctx->current != 0 && ctx->current->type == 42)
        {
            p_pointer = calloc(1, 16);
            if (p_pointer == 0)
            {
                goto __L0; /* throw */
            }
            p_pointer->calling_convention = calling_convention;
            calling_convention = 0;
            p = p_pointer;
            parser_match(ctx);
            p_pointer->attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);
            if (first_of_type_qualifier(ctx))
            {
                ;
                if (ctx->current->type == 9085)
                {
                    compiler_diagnostic(640, ctx, ctx->current, 0, "invalid qualifier for pointer");
                }
                else
                {
                    p_pointer->type_qualifier_list_opt = type_qualifier_list(ctx);
                }
            }
            while (ctx->current != 0 && ctx->current->type == 42)
            {
                p_pointer->pointer = pointer_opt(ctx);
                if (p_pointer->pointer == 0)
                {
                    goto __L0; /* throw */
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return p;
}


void type_qualifier_list_add(struct type_qualifier_list * list, struct type_qualifier * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void type_qualifier_list_delete(struct type_qualifier_list * p)
{
    if (p)
    {
        struct type_qualifier * item;

        item = p->head;
        while (item)
        {
            struct type_qualifier * next;

            next = item->next;
            item->next = 0;
            free(item);
            item = next;
        }
        free(p);
    }
}


struct type_qualifier_list *type_qualifier_list(struct parser_ctx * ctx)
{
    struct type_qualifier_list * p_type_qualifier_list;
    struct type_qualifier * p_type_qualifier;

    p_type_qualifier_list = 0;
    p_type_qualifier = 0;
    if (1) /*try*/
    {
        p_type_qualifier_list = calloc(1, 12);
        if (p_type_qualifier_list == 0)
        {
            goto __L0; /* throw */
        }
        p_type_qualifier = type_qualifier(ctx);
        if (p_type_qualifier == 0)
        {
            goto __L0; /* throw */
        }
        p_type_qualifier_list->flags |= p_type_qualifier->flags;
        type_qualifier_list_add(p_type_qualifier_list, p_type_qualifier);
        p_type_qualifier = 0;
        while (ctx->current != 0 && first_of_type_qualifier(ctx))
        {
            p_type_qualifier = type_qualifier(ctx);
            if (p_type_qualifier == 0)
            {
                goto __L0; /* throw */
            }
            p_type_qualifier_list->flags |= p_type_qualifier->flags;
            type_qualifier_list_add(p_type_qualifier_list, p_type_qualifier);
            p_type_qualifier = 0;
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return p_type_qualifier_list;
}


void parameter_list_delete(struct parameter_list * p);

void parameter_type_list_delete(struct parameter_type_list * p)
{
    if (p)
    {
        parameter_list_delete(p->parameter_list);
        free(p);
    }
}


struct parameter_list *parameter_list(struct parser_ctx * ctx);

struct parameter_type_list *parameter_type_list(struct parser_ctx * ctx)
{
    struct parameter_type_list * p_parameter_type_list;

    if (ctx->current == 0)
    {
        return 0;
    }
    p_parameter_type_list = calloc(1, 8);
    if (1) /*try*/
    {
        if (p_parameter_type_list == 0)
        {
            goto __L1; /* throw */
        }
        if (ctx->current->type == 3026478)
        {
            parser_match(ctx);
            p_parameter_type_list->is_var_args = 1;
            return p_parameter_type_list;
        }
        p_parameter_type_list->parameter_list = parameter_list(ctx);
        if (p_parameter_type_list->parameter_list == 0)
        {
            goto __L1; /* throw */
        }
        if (p_parameter_type_list->parameter_list->head == p_parameter_type_list->parameter_list->tail)
        {
            if (type_is_void(&p_parameter_type_list->parameter_list->head->declarator->type))
            {
                p_parameter_type_list->is_void = 1;
            }
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L1; /* throw */
        }
        if (ctx->current->type == 3026478)
        {
            parser_match(ctx);
            p_parameter_type_list->is_var_args = 1;
        }
    }
    else __L1: /*catch*/ 
    {
        parameter_type_list_delete(p_parameter_type_list);
        p_parameter_type_list = 0;
    }
    return p_parameter_type_list;
}


void parameter_list_add(struct parameter_list * list, struct parameter_declaration * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void parameter_declaration_delete(struct parameter_declaration * p);

void parameter_list_delete(struct parameter_list * p)
{
    if (p)
    {
        struct parameter_declaration * item;

        item = p->head;
        while (item)
        {
            struct parameter_declaration * next;

            next = item->next;
            item->next = 0;
            parameter_declaration_delete(item);
            item = next;
        }
        free(p);
    }
}


struct parameter_declaration *parameter_declaration(struct parser_ctx * ctx);

struct parameter_list *parameter_list(struct parser_ctx * ctx)
{
    struct parameter_list * p_parameter_list;
    struct parameter_declaration * p_parameter_declaration;

    p_parameter_list = 0;
    p_parameter_declaration = 0;
    if (1) /*try*/
    {
        p_parameter_list = calloc(1, 8);
        if (p_parameter_list == 0)
        {
            goto __L0; /* throw */
        }
        p_parameter_declaration = parameter_declaration(ctx);
        if (p_parameter_declaration == 0)
        {
            goto __L0; /* throw */
        }
        parameter_list_add(p_parameter_list, p_parameter_declaration);
        p_parameter_declaration = 0;
        while (ctx->current != 0 && ctx->current->type == 44)
        {
            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            if (ctx->current->type == 3026478)
            {
                break;
            }
            p_parameter_declaration = parameter_declaration(ctx);
            if (p_parameter_declaration == 0)
            {
                goto __L0; /* throw */
            }
            parameter_list_add(p_parameter_list, p_parameter_declaration);
            p_parameter_declaration = 0;
        }
    }
    else __L0: /*catch*/ 
    {
        parameter_list_delete(p_parameter_list);
        p_parameter_list = 0;
    }
    return p_parameter_list;
}


void parameter_declaration_delete(struct parameter_declaration * p)
{
    if (p)
    {
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        declaration_specifiers_delete(p->declaration_specifiers);
        declarator_delete(p->declarator);
        ;
        free(p);
    }
}


void naming_convention_parameter(struct parser_ctx * ctx, struct token * token, struct type * type);

struct parameter_declaration *parameter_declaration(struct parser_ctx * ctx)
{
    struct parameter_declaration * p_parameter_declaration;

    p_parameter_declaration = calloc(1, 16);
    if (1) /*try*/
    {
        struct declaration_specifiers * p_declaration_specifiers;
        struct token * p_token_name;

        if (p_parameter_declaration == 0)
        {
            goto __L0; /* throw */
        }
        p_parameter_declaration->attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);
        p_declaration_specifiers = declaration_specifiers(ctx, 6144);
        if (p_declaration_specifiers == 0)
        {
            goto __L0; /* throw */
        }
        if (p_parameter_declaration->attribute_specifier_sequence_opt)
        {
            if (p_parameter_declaration->attribute_specifier_sequence_opt->attributes_flags & 128)
            {
                p_declaration_specifiers->type_qualifier_flags |= 256;
            }
            else
            {
                if (p_parameter_declaration->attribute_specifier_sequence_opt->attributes_flags & 256)
                {
                    p_declaration_specifiers->type_qualifier_flags |= 128;
                }
            }
        }
        p_parameter_declaration->declaration_specifiers = p_declaration_specifiers;
        p_token_name = 0;
        p_parameter_declaration->declarator = declarator(ctx, 0, p_parameter_declaration->declaration_specifiers, 1, &p_token_name);
        if (p_parameter_declaration->declarator == 0)
        {
            goto __L0; /* throw */
        }
        p_parameter_declaration->declarator->name_opt = p_token_name;
        p_parameter_declaration->declarator->declaration_specifiers = p_parameter_declaration->declaration_specifiers;
        p_parameter_declaration->declarator->type = make_type_using_declarator(ctx, p_parameter_declaration->declarator);
        if (p_parameter_declaration->declarator->type.storage_class_specifier_flags & 1)
        {
        }
        else
        {
            int er;

            er = make_object(&p_parameter_declaration->declarator->type, &p_parameter_declaration->declarator->object, ctx->options.target);
            if (er != 0)
            {
                goto __L0; /* throw */
            }
        }
        if (p_parameter_declaration->declarator->name_opt)
        {
            free((void *)p_parameter_declaration->declarator->object.member_designator);
            p_parameter_declaration->declarator->object.member_designator = strdup(p_parameter_declaration->declarator->name_opt->lexeme);
        }
        object_set_any(&p_parameter_declaration->declarator->object);
        if (p_parameter_declaration->attribute_specifier_sequence_opt)
        {
            p_parameter_declaration->declarator->type.attributes_flags |= p_parameter_declaration->attribute_specifier_sequence_opt->attributes_flags;
        }
        p_parameter_declaration->declarator->type.storage_class_specifier_flags |= 2048;
        if (p_parameter_declaration->declarator->name_opt)
        {
            naming_convention_parameter(ctx, p_parameter_declaration->declarator->name_opt, &p_parameter_declaration->declarator->type);
        }
        if (p_parameter_declaration->declarator->name_opt)
        {
            struct hash_item_set  item;

            _cake_zmem(&item, 32);
            item.p_declarator = declarator_add_ref(p_parameter_declaration->declarator);
            ;
            hashmap_set(&ctx->scopes.tail->variables, p_parameter_declaration->declarator->name_opt->lexeme, &item);
            hash_item_set_destroy(&item);
        }
    }
    else __L0: /*catch*/ 
    {
        parameter_declaration_delete(p_parameter_declaration);
        p_parameter_declaration = 0;
    }
    return p_parameter_declaration;
}


struct specifier_qualifier_list *copy(struct declaration_specifiers * p_declaration_specifiers)
{
    struct specifier_qualifier_list * p_specifier_qualifier_list;

    p_specifier_qualifier_list = calloc(1, 48);
    if (1) /*try*/
    {
        struct declaration_specifier * p_declaration_specifier;

        if (p_specifier_qualifier_list == 0)
        {
            goto __L0; /* throw */
        }
        p_specifier_qualifier_list->type_qualifier_flags = p_declaration_specifiers->type_qualifier_flags;
        p_specifier_qualifier_list->type_specifier_flags = p_declaration_specifiers->type_specifier_flags;
        p_declaration_specifier = p_declaration_specifiers->head;
        while (p_declaration_specifier)
        {
            if (p_declaration_specifier->type_specifier_qualifier)
            {
                struct type_specifier_qualifier * p_specifier_qualifier;

                p_specifier_qualifier = calloc(1, 16);
                if (p_specifier_qualifier == 0)
                {
                    goto __L0; /* throw */
                }
                if (p_declaration_specifier->type_specifier_qualifier->type_qualifier)
                {
                    struct type_qualifier * p_type_qualifier;

                    p_type_qualifier = calloc(1, 12);
                    if (p_type_qualifier == 0)
                    {
                        type_specifier_qualifier_delete(p_specifier_qualifier);
                        goto __L0; /* throw */
                    }
                    p_type_qualifier->flags = p_declaration_specifier->type_specifier_qualifier->type_qualifier->flags;
                    p_type_qualifier->token = p_declaration_specifier->type_specifier_qualifier->type_qualifier->token;
                    p_specifier_qualifier->type_qualifier = p_type_qualifier;
                }
                else
                {
                    if (p_declaration_specifier->type_specifier_qualifier->type_specifier)
                    {
                        struct type_specifier * p_type_specifier;

                        p_type_specifier = calloc(1, 28);
                        if (p_type_specifier == 0)
                        {
                            type_specifier_qualifier_delete(p_specifier_qualifier);
                            goto __L0; /* throw */
                        }
                        p_type_specifier->flags = p_declaration_specifier->type_specifier_qualifier->type_specifier->flags;
                        ;
                        p_type_specifier->token = p_declaration_specifier->type_specifier_qualifier->type_specifier->token;
                        p_specifier_qualifier->type_specifier = p_type_specifier;
                    }
                }
                specifier_qualifier_list_add(p_specifier_qualifier_list, p_specifier_qualifier);
            }
            p_declaration_specifier = p_declaration_specifier->next;
        }
    }
    else __L0: /*catch*/ 
    {
        specifier_qualifier_list_delete(p_specifier_qualifier_list);
        p_specifier_qualifier_list = 0;
    }
    return p_specifier_qualifier_list;
}


void print_declarator(struct osstream * ss, struct declarator * declarator, unsigned char  is_abstract);

void print_direct_declarator(struct osstream * ss, struct direct_declarator * p_direct_declarator, unsigned char  is_abstract)
{
    if (p_direct_declarator->declarator)
    {
        ss_fprintf(ss, "(");
        print_declarator(ss, p_direct_declarator->declarator, is_abstract);
        ss_fprintf(ss, ")");
    }
    if (p_direct_declarator->name_opt && !is_abstract)
    {
        ss_fprintf(ss, "%s", p_direct_declarator->name_opt->lexeme);
    }
    if (p_direct_declarator->function_declarator)
    {
        struct parameter_declaration * p_parameter_declaration;

        ;
        print_direct_declarator(ss, p_direct_declarator->function_declarator->direct_declarator, is_abstract);
        ss_fprintf(ss, "(");
        p_parameter_declaration = p_direct_declarator->function_declarator->parameter_type_list_opt ? p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head : 0;
        while (p_parameter_declaration)
        {
            if (p_parameter_declaration != p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head)
            {
                ss_fprintf(ss, ",");
            }
            print_declaration_specifiers(ss, p_parameter_declaration->declaration_specifiers);
            ss_fprintf(ss, " ");
            if (p_parameter_declaration->declarator)
            {
                print_declarator(ss, p_parameter_declaration->declarator, is_abstract);
            }
            p_parameter_declaration = p_parameter_declaration->next;
        }
        ss_fprintf(ss, ")");
    }
    if (p_direct_declarator->array_declarator)
    {
        ss_fprintf(ss, "[]");
    }
}


struct declarator *declarator_get_innert_function_declarator(struct declarator * p)
{
    struct declarator * inner;

    inner = p;
    for (; ; )
    {
        if (inner->direct_declarator && inner->direct_declarator->function_declarator && inner->direct_declarator->function_declarator->direct_declarator && inner->direct_declarator->function_declarator->direct_declarator->declarator)
        {
            inner = inner->direct_declarator->function_declarator->direct_declarator->declarator;
        }
        else
        {
            break;
        }
    }
    return inner;
}


struct declarator *declarator_get_function_definition(struct declarator * declarator)
{
    struct declarator * p_function_defined;

    p_function_defined = 0;
    if (declarator->function_body)
    {
        p_function_defined = declarator;
    }
    if (!p_function_defined && declarator->p_complete_declarator && declarator->p_complete_declarator->function_body)
    {
        p_function_defined = declarator->p_complete_declarator;
    }
    if (!p_function_defined && declarator->p_complete_declarator && declarator->p_complete_declarator->p_complete_declarator && declarator->p_complete_declarator->p_complete_declarator->function_body)
    {
        p_function_defined = declarator->p_complete_declarator->p_complete_declarator;
    }
    ;
    return p_function_defined;
}


int declarator_get_type_specifier_flags(struct declarator * p)
{
    if (p->declaration_specifiers)
    {
        return p->declaration_specifiers->type_specifier_flags;
    }
    if (p->specifier_qualifier_list)
    {
        return p->specifier_qualifier_list->type_specifier_flags;
    }
    return 0;
}


void print_declarator(struct osstream * ss, struct declarator * p_declarator, unsigned char  is_abstract)
{
    unsigned char  first;

    first = 1;
    if (p_declarator->pointer)
    {
        struct pointer * p;

        p = p_declarator->pointer;
        while (p)
        {
            if (p->type_qualifier_list_opt)
            {
                print_type_qualifier_flags(ss, &first, p->type_qualifier_list_opt->flags);
            }
            ss_fprintf(ss, "*");
            p = p->pointer;
        }
    }
    if (p_declarator->direct_declarator)
    {
        print_direct_declarator(ss, p_declarator->direct_declarator, is_abstract);
    }
}


void print_type_name(struct osstream * ss, struct type_name * p)
{
    unsigned char  first;

    first = 1;
    print_specifier_qualifier_list(ss, &first, p->specifier_qualifier_list);
    print_declarator(ss, p->abstract_declarator, 1);
}


void type_name_delete(struct type_name * p)
{
    if (p)
    {
        specifier_qualifier_list_delete(p->specifier_qualifier_list);
        type_destroy(&p->type);
        declarator_delete(p->abstract_declarator);
        free(p);
    }
}


struct type_name *type_name(struct parser_ctx * ctx)
{
    struct type_name * p_type_name;

    if (ctx->current == 0)
    {
        return 0;
    }
    p_type_name = calloc(1, 84);
    if (1) /*try*/
    {
        struct specifier_qualifier_list * p_specifier_qualifier_list;
        struct declarator * p_declarator;

        if (p_type_name == 0)
        {
            goto __L1; /* throw */
        }
        p_type_name->first_token = ctx->current;
        p_specifier_qualifier_list = specifier_qualifier_list(ctx);
        if (p_specifier_qualifier_list == 0)
        {
            goto __L1; /* throw */
        }
        p_type_name->specifier_qualifier_list = p_specifier_qualifier_list;
        p_declarator = declarator(ctx, p_type_name->specifier_qualifier_list, 0, 1, 0);
        if (p_declarator == 0)
        {
            goto __L1; /* throw */
        }
        p_type_name->abstract_declarator = p_declarator;
        p_type_name->abstract_declarator->specifier_qualifier_list = p_type_name->specifier_qualifier_list;
        p_type_name->abstract_declarator->type = make_type_using_declarator(ctx, p_type_name->abstract_declarator);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L1; /* throw */
        }
        if (ctx->current->prev == 0)
        {
            goto __L1; /* throw */
        }
        p_type_name->last_token = ctx->current->prev;
        p_type_name->type = type_dup(&p_type_name->abstract_declarator->type);
    }
    else __L1: /*catch*/ 
    {
        type_name_delete(p_type_name);
        p_type_name = 0;
    }
    return p_type_name;
}


void initializer_list_delete(struct initializer_list * p);

void braced_initializer_delete(struct braced_initializer * p)
{
    if (p)
    {
        initializer_list_delete(p->initializer_list);
        free(p);
    }
}


struct initializer_list *initializer_list(struct parser_ctx * ctx, int eval_mode);

struct braced_initializer *braced_initializer(struct parser_ctx * ctx)
{
    struct braced_initializer * p_bracket_initializer_list;

    p_bracket_initializer_list = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_bracket_initializer_list = calloc(1, 12);
        if (p_bracket_initializer_list == 0)
        {
            goto __L0; /* throw */
        }
        p_bracket_initializer_list->first_token = ctx->current;
        if (parser_match_tk(ctx, 123) != 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type != 125)
        {
            p_bracket_initializer_list->initializer_list = initializer_list(ctx, 2);
        }
        if (parser_match_tk(ctx, 125) != 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        braced_initializer_delete(p_bracket_initializer_list);
        p_bracket_initializer_list = 0;
    }
    return p_bracket_initializer_list;
}


void initializer_destroy(struct initializer * p)
{
    expression_delete(p->assignment_expression);
    braced_initializer_delete(p->braced_initializer);
}


void initializer_delete(struct initializer * p)
{
    if (p)
    {
        expression_delete(p->assignment_expression);
        braced_initializer_delete(p->braced_initializer);
        free(p);
    }
}


struct initializer *initializer(struct parser_ctx * ctx, int eval_mode)
{
    struct initializer * p_initializer;

    p_initializer = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_initializer = calloc(1, 12);
        if (p_initializer == 0)
        {
            goto __L0; /* throw */
        }
        p_initializer->first_token = ctx->current;
        if (ctx->current->type == 123)
        {
            p_initializer->braced_initializer = braced_initializer(ctx);
            if (p_initializer->braced_initializer == 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            p_initializer->assignment_expression = assignment_expression(ctx, eval_mode);
            if (p_initializer->assignment_expression == 0)
            {
                goto __L0; /* throw */
            }
        }
    }
    else __L0: /*catch*/ 
    {
        initializer_delete(p_initializer);
        p_initializer = 0;
    }
    return p_initializer;
}


void defer_list_add(struct defer_list * list, struct defer_list_item * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void defer_list_destroy(struct defer_list * p)
{
    struct defer_list_item * item;

    item = p->head;
    while (item)
    {
        struct defer_list_item * next;

        next = item->next;
        item->next = 0;
        free(item);
        item = next;
    }
    free(p);
}


void initializer_list_add(struct initializer_list * list, struct initializer_list_item * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void designation_delete(struct designation * p);

void initializer_list_item_delete(struct initializer_list_item * p)
{
    if (p)
    {
        designation_delete(p->designation);
        initializer_delete(p->initializer);
        free(p);
    }
}


void initializer_list_delete(struct initializer_list * p)
{
    if (p)
    {
        struct initializer_list_item * item;

        item = p->head;
        while (item)
        {
            struct initializer_list_item * next;

            next = item->next;
            item->next = 0;
            initializer_list_item_delete(item);
            item = next;
        }
        free(p);
    }
}


struct designation *designation(struct parser_ctx * ctx);

struct initializer_list *initializer_list(struct parser_ctx * ctx, int eval_mode)
{
    struct initializer_list * p_initializer_list;

    p_initializer_list = 0;
    if (1) /*try*/
    {
        struct initializer_list_item * p_initializer_list_item;
        struct designation * p_designation;
        struct initializer * p_initializer;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            return 0;
        }
        p_initializer_list = calloc(1, 16);
        if (p_initializer_list == 0)
        {
            goto __L0; /* throw */
        }
        p_initializer_list->first_token = ctx->current;
        p_initializer_list_item = calloc(1, 12);
        if (p_initializer_list_item == 0)
        {
            goto __L0; /* throw */
        }
        p_designation = 0;
        if (first_of_designator(ctx))
        {
            p_designation = designation(ctx);
            if (p_designation == 0)
            {
                goto __L0; /* throw */
            }
            p_initializer_list_item->designation = p_designation;
        }
        p_initializer = initializer(ctx, eval_mode);
        if (p_initializer == 0)
        {
            designation_delete(p_designation);
            goto __L0; /* throw */
        }
        p_initializer_list_item->initializer = p_initializer;
        initializer_list_add(p_initializer_list, p_initializer_list_item);
        p_initializer_list_item = 0;
        while (ctx->current != 0 && ctx->current->type == 44)
        {
            struct designation * p_designation2;
            struct initializer * p_initializer2;

            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            if (ctx->current->type == 125)
            {
                break;
            }
            p_initializer_list_item = calloc(1, 12);
            if (p_initializer_list_item == 0)
            {
                goto __L0; /* throw */
            }
            p_designation2 = 0;
            if (first_of_designator(ctx))
            {
                p_designation2 = designation(ctx);
                if (p_designation2 == 0)
                {
                    goto __L0; /* throw */
                }
            }
            p_initializer_list_item->designation = p_designation2;
            p_initializer2 = initializer(ctx, eval_mode);
            if (p_initializer2 == 0)
            {
                designation_delete(p_designation2);
                goto __L0; /* throw */
            }
            p_initializer_list_item->initializer = p_initializer2;
            initializer_list_add(p_initializer_list, p_initializer_list_item);
            p_initializer_list_item = 0;
            p_initializer_list->size++;
        }
    }
    else __L0: /*catch*/ 
    {
        initializer_list_delete(p_initializer_list);
        p_initializer_list = 0;
    }
    return p_initializer_list;
}


void designator_list_delete(struct designator_list * p);

void designation_delete(struct designation * p)
{
    if (p)
    {
        designator_list_delete(p->designator_list);
        free(p);
    }
}


struct designator_list *designator_list(struct parser_ctx * ctx);

struct designation *designation(struct parser_ctx * ctx)
{
    struct designation * p_designation;

    p_designation = 0;
    if (1) /*try*/
    {
        struct designator_list * p_designator_list;

        p_designation = calloc(1, 8);
        if (p_designation == 0)
        {
            goto __L0; /* throw */
        }
        p_designator_list = designator_list(ctx);
        if (p_designator_list == 0)
        {
            goto __L0; /* throw */
        }
        p_designation->designator_list = p_designator_list;
        if (parser_match_tk(ctx, 61) != 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        designation_delete(p_designation);
        p_designation = 0;
    }
    return p_designation;
}


void designator_list_add(struct designator_list * list, struct designator * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void designator_delete(struct designator * p);

void designator_list_delete(struct designator_list * p)
{
    if (p)
    {
        struct designator * item;

        item = p->head;
        while (item)
        {
            struct designator * next;

            next = item->next;
            item->next = 0;
            designator_delete(item);
            item = next;
        }
        free(p);
    }
}


struct designator *designator(struct parser_ctx * ctx);

struct designator_list *designator_list(struct parser_ctx * ctx)
{
    struct designator_list * p_designator_list;
    struct designator * p_designator;

    p_designator_list = 0;
    p_designator = 0;
    if (1) /*try*/
    {
        p_designator_list = calloc(1, 8);
        if (p_designator_list == 0)
        {
            goto __L0; /* throw */
        }
        p_designator = designator(ctx);
        if (p_designator == 0)
        {
            goto __L0; /* throw */
        }
        designator_list_add(p_designator_list, p_designator);
        p_designator = 0;
        while (ctx->current != 0 && first_of_designator(ctx))
        {
            p_designator = designator(ctx);
            if (p_designator == 0)
            {
                goto __L0; /* throw */
            }
            designator_list_add(p_designator_list, p_designator);
            p_designator = 0;
        }
    }
    else __L0: /*catch*/ 
    {
        designator_list_delete(p_designator_list);
        p_designator_list = 0;
    }
    return p_designator_list;
}


void designator_delete(struct designator * p)
{
    if (p)
    {
        ;
        expression_delete(p->constant_expression_opt);
        free(p);
    }
}


struct designator *designator(struct parser_ctx * ctx)
{
    struct designator * p_designator;

    p_designator = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_designator = calloc(1, 12);
        if (p_designator == 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current->type == 91)
        {
            if (parser_match_tk(ctx, 91) != 0)
            {
                goto __L0; /* throw */
            }
            p_designator->constant_expression_opt = constant_expression(ctx, 1, 2);
            if (parser_match_tk(ctx, 93) != 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            if (ctx->current->type == 46)
            {
                parser_match(ctx);
                p_designator->token = ctx->current;
                if (parser_match_tk(ctx, 8996) != 0)
                {
                    goto __L0; /* throw */
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        designator_delete(p_designator);
        p_designator = 0;
    }
    return p_designator;
}


void static_assert_declaration_delete(struct static_assert_declaration * p)
{
    if (p)
    {
        expression_delete(p->constant_expression);
        free(p);
    }
}


void pragma_declaration_delete(struct pragma_declaration * p)
{
    if (p)
    {
        free(p);
    }
}


static struct token *pragma_declaration_match(struct token * p_current);

void execute_pragma_declaration(struct parser_ctx * ctx, struct pragma_declaration * p_pragma, unsigned char  on_flow_analysis)
{
    struct token * p_pragma_token;

    p_pragma_token = p_pragma->first_token;
    if (1) /*try*/
    {
        unsigned char  is_standard_pragma;

        if (p_pragma_token->type != 128)
        {
            goto __L0; /* throw */
        }
        p_pragma_token = pragma_declaration_match(p_pragma_token);
        if (p_pragma_token == 0)
        {
            goto __L0; /* throw */
        }
        if ((strcmp(p_pragma_token->lexeme, "CAKE") == 0 || strcmp(p_pragma_token->lexeme, "cake") == 0))
        {
            p_pragma_token = pragma_declaration_match(p_pragma_token);
            if (p_pragma_token == 0)
            {
                goto __L0; /* throw */
            }
        }
        is_standard_pragma = 0;
        if ((strcmp(p_pragma_token->lexeme, "STDC") == 0))
        {
            p_pragma_token = pragma_declaration_match(p_pragma_token);
            if (p_pragma_token == 0)
            {
                goto __L0; /* throw */
            }
            is_standard_pragma = 1;
        }
        if (strcmp(p_pragma_token->lexeme, "diagnostic") == 0)
        {
            p_pragma_token = pragma_declaration_match(p_pragma_token);
            if (p_pragma_token == 0)
            {
                goto __L0; /* throw */
            }
            if (strcmp(p_pragma_token->lexeme, "push") == 0)
            {
                if (ctx->options.diagnostic_stack.top_index < 10)
                {
                    ctx->options.diagnostic_stack.top_index++;
                    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] = ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index - 1];
                }
                p_pragma_token = pragma_declaration_match(p_pragma_token);
            }
            else
            {
                if (strcmp(p_pragma_token->lexeme, "pop") == 0)
                {
                    if (ctx->options.diagnostic_stack.top_index > 0)
                    {
                        ctx->options.diagnostic_stack.top_index--;
                    }
                    p_pragma_token = pragma_declaration_match(p_pragma_token);
                }
                else
                {
                    if (strcmp(p_pragma_token->lexeme, "error") == 0 || strcmp(p_pragma_token->lexeme, "warning") == 0 || strcmp(p_pragma_token->lexeme, "note") == 0 || strcmp(p_pragma_token->lexeme, "ignored") == 0)
                    {
                        unsigned char  is_error;
                        unsigned char  is_warning;
                        unsigned char  is_note;
                        unsigned long long w;

                        is_error = strcmp(p_pragma_token->lexeme, "error") == 0;
                        is_warning = strcmp(p_pragma_token->lexeme, "warning") == 0;
                        is_note = strcmp(p_pragma_token->lexeme, "note") == 0;
                        p_pragma_token = pragma_declaration_match(p_pragma_token);
                        if (p_pragma_token == 0)
                        {
                            goto __L0; /* throw */
                        }
                        if (p_pragma_token->type != 130)
                        {
                            goto __L0; /* throw */
                        }
                        w = atoi(p_pragma_token->lexeme + 2);
                        if (is_error)
                        {
                            options_set_error(&ctx->options, w, 1);
                        }
                        else
                        {
                            if (is_warning)
                            {
                                options_set_warning(&ctx->options, w, 1);
                            }
                            else
                            {
                                if (is_note)
                                {
                                    options_set_note(&ctx->options, w, 1);
                                }
                            }
                        }
                    }
                    else
                    {
                        compiler_diagnostic(9, ctx, p_pragma_token, 0, "unknown diagnostic command");
                        goto __L0; /* throw */
                    }
                }
            }
        }
        else
        {
            if (strcmp(p_pragma_token->lexeme, "nullable") == 0)
            {
                unsigned char  nullable_enable;

                p_pragma_token = pragma_declaration_match(p_pragma_token);
                if (p_pragma_token == 0)
                {
                    goto __L0; /* throw */
                }
                if (strcmp(p_pragma_token->lexeme, "enable") != 0 && strcmp(p_pragma_token->lexeme, "disable") != 0)
                {
                    compiler_diagnostic(9, ctx, p_pragma_token, 0, "expected enable/disable");
                    goto __L0; /* throw */
                }
                nullable_enable = strcmp(p_pragma_token->lexeme, "enable") == 0;
                options_set_warning(&ctx->options, 60, nullable_enable);
                options_set_warning(&ctx->options, 33, nullable_enable);
                options_set_warning(&ctx->options, 35, nullable_enable);
                if (nullable_enable)
                {
                    ctx->options.null_checks_enabled = 1;
                    ctx->options.flow_analysis = 1;
                }
                else
                {
                    ctx->options.null_checks_enabled = 0;
                }
            }
            else
            {
                if (strcmp(p_pragma_token->lexeme, "ownership") == 0)
                {
                    unsigned char  ownership_enable;

                    p_pragma_token = pragma_declaration_match(p_pragma_token);
                    if (p_pragma_token == 0)
                    {
                        goto __L0; /* throw */
                    }
                    if (strcmp(p_pragma_token->lexeme, "enable") != 0 && strcmp(p_pragma_token->lexeme, "disable") != 0)
                    {
                        compiler_diagnostic(9, ctx, p_pragma_token, 0, "expected enable/disable");
                        goto __L0; /* throw */
                    }
                    ownership_enable = strcmp(p_pragma_token->lexeme, "enable") == 0;
                    options_set_warning(&ctx->options, 30, ownership_enable);
                    if (ownership_enable)
                    {
                        ctx->options.ownership_enabled = 1;
                        ctx->options.flow_analysis = 1;
                    }
                    else
                    {
                        ctx->options.ownership_enabled = 0;
                    }
                }
                else
                {
                    if (p_pragma_token && strcmp(p_pragma_token->lexeme, "flow") == 0)
                    {
                        unsigned char  flow_enable;

                        p_pragma_token = pragma_declaration_match(p_pragma_token);
                        if (p_pragma_token == 0)
                        {
                            goto __L0; /* throw */
                        }
                        if (strcmp(p_pragma_token->lexeme, "enable") != 0 && strcmp(p_pragma_token->lexeme, "disable") != 0)
                        {
                            compiler_diagnostic(9, ctx, p_pragma_token, 0, "expected enable/disable");
                            goto __L0; /* throw */
                        }
                        flow_enable = strcmp(p_pragma_token->lexeme, "enable") == 0;
                        p_pragma_token = pragma_declaration_match(p_pragma_token);
                        ctx->options.flow_analysis = flow_enable;
                    }
                    else
                    {
                        if (strcmp(p_pragma_token->lexeme, "safety") == 0)
                        {
                            unsigned char  safety_enable;

                            p_pragma_token = pragma_declaration_match(p_pragma_token);
                            if (p_pragma_token == 0)
                            {
                                goto __L0; /* throw */
                            }
                            if (strcmp(p_pragma_token->lexeme, "enable") != 0 && strcmp(p_pragma_token->lexeme, "disable") != 0)
                            {
                                compiler_diagnostic(9, ctx, p_pragma_token, 0, "expected enable/disable");
                                goto __L0; /* throw */
                            }
                            safety_enable = strcmp(p_pragma_token->lexeme, "enable") == 0;
                            p_pragma_token = pragma_declaration_match(p_pragma_token);
                            options_set_warning(&ctx->options, 33, safety_enable);
                            options_set_warning(&ctx->options, 35, safety_enable);
                            if (safety_enable)
                            {
                                ctx->options.null_checks_enabled = 1;
                                ctx->options.flow_analysis = 1;
                                ctx->options.ownership_enabled = 1;
                            }
                            else
                            {
                                ctx->options.null_checks_enabled = 0;
                                ctx->options.ownership_enabled = 0;
                                ctx->options.flow_analysis = 0;
                            }
                        }
                        else
                        {
                            if (is_standard_pragma && (strcmp(p_pragma_token->lexeme, "FP_CONTRACT") == 0 || strcmp(p_pragma_token->lexeme, "FENV_ACCESS") == 0 || strcmp(p_pragma_token->lexeme, "CX_LIMITED_RANGE") == 0))
                            {
                                p_pragma_token = pragma_declaration_match(p_pragma_token);
                                if (p_pragma_token == 0)
                                {
                                    goto __L0; /* throw */
                                }
                                if (strcmp(p_pragma_token->lexeme, "ON") != 0 && strcmp(p_pragma_token->lexeme, "OFF") != 0 && strcmp(p_pragma_token->lexeme, "DEFAULT") != 0)
                                {
                                    compiler_diagnostic(9, ctx, p_pragma_token, 0, "expected ON OFF DEFAULT");
                                    goto __L0; /* throw */
                                }
                            }
                            else
                            {
                                if (is_standard_pragma && strcmp(p_pragma_token->lexeme, "FENV_DEC_ROUND") == 0)
                                {
                                    p_pragma_token = pragma_declaration_match(p_pragma_token);
                                    if (p_pragma_token == 0)
                                    {
                                        goto __L0; /* throw */
                                    }
                                    if (strcmp(p_pragma_token->lexeme, "FE_DEC_DOWNWARD") != 0 && strcmp(p_pragma_token->lexeme, "FE_DEC_TONEAREST") != 0 && strcmp(p_pragma_token->lexeme, "FE_DEC_TONEARESTFROMZERO") != 0 && strcmp(p_pragma_token->lexeme, "FE_DEC_TOWARDZERO") != 0 && strcmp(p_pragma_token->lexeme, "FE_DEC_UPWARD") != 0 && strcmp(p_pragma_token->lexeme, "FE_DEC_DYNAMIC") != 0)
                                    {
                                        compiler_diagnostic(9, ctx, p_pragma_token, 0, "expected FE_DEC_DOWNWARD FE_DEC_TONEAREST FE_DEC_TONEARESTFROMZERO FE_DEC_TOWARDZERO FE_DEC_UPWARD FE_DEC_DYNAMIC");
                                        goto __L0; /* throw */
                                    }
                                }
                                else
                                {
                                    if (is_standard_pragma && strcmp(p_pragma_token->lexeme, "FENV_ROUND") == 0)
                                    {
                                        p_pragma_token = pragma_declaration_match(p_pragma_token);
                                        if (p_pragma_token == 0)
                                        {
                                            goto __L0; /* throw */
                                        }
                                        if (strcmp(p_pragma_token->lexeme, "FE_DOWNWARD") != 0 && strcmp(p_pragma_token->lexeme, "FE_TONEAREST") != 0 && strcmp(p_pragma_token->lexeme, "FE_TONEARESTFROMZERO") != 0 && strcmp(p_pragma_token->lexeme, "FE_TOWARDZERO") != 0 && strcmp(p_pragma_token->lexeme, "FE_UPWARD") != 0 && strcmp(p_pragma_token->lexeme, "FE_DYNAMIC") != 0)
                                        {
                                            compiler_diagnostic(9, ctx, p_pragma_token, 0, "expected enable/disable");
                                            goto __L0; /* throw */
                                        }
                                    }
                                    else
                                    {
                                        compiler_diagnostic(9, ctx, p_pragma_token, 0, "unknown pragma");
                                        goto __L0; /* throw */
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}



static struct token *pragma_declaration_match(struct token * p_current)
{
    struct token * p_token;

    p_token = p_current->next;
    while (p_token && p_token->type == 143)
    {
        p_token = p_token->next;
    }
    return p_token;
}
struct pragma_declaration *pragma_declaration(struct parser_ctx * ctx)
{
    struct pragma_declaration * p_pragma_declaration;

    p_pragma_declaration = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0 || ctx->current->type != 128)
        {
            ;
            goto __L0; /* throw */
        }
        p_pragma_declaration = calloc(1, 8);
        if (p_pragma_declaration == 0)
        {
            goto __L0; /* throw */
        }
        p_pragma_declaration->first_token = ctx->current;
        parser_match(ctx);
        while (ctx->current && ctx->current->type != 129)
        {
            ctx->current = ctx->current->next;
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_pragma_declaration->last_token = ctx->current;
        parser_match(ctx);
        execute_pragma_declaration(ctx, p_pragma_declaration, 0);
    }
    else __L0: /*catch*/ 
    {
    }
    return p_pragma_declaration;
}


struct static_assert_declaration *static_assert_declaration(struct parser_ctx * ctx)
{
    struct static_assert_declaration * p_static_assert_declaration;

    p_static_assert_declaration = 0;
    if (1) /*try*/
    {
        struct token * position;
        unsigned char  show_error_if_not_constant;
        struct expression * p_constant_expression;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_static_assert_declaration = calloc(1, 16);
        if (p_static_assert_declaration == 0)
        {
            goto __L0; /* throw */
        }
        p_static_assert_declaration->first_token = ctx->current;
        position = ctx->current;
        parser_match(ctx);
        if (parser_match_tk(ctx, 40) != 0)
        {
            goto __L0; /* throw */
        }
        show_error_if_not_constant = 0;
        if (p_static_assert_declaration->first_token->type == 9073)
        {
            show_error_if_not_constant = 1;
        }
        if (ctx->options.flow_analysis)
        {
            show_error_if_not_constant = 0;
        }
        p_constant_expression = constant_expression(ctx, show_error_if_not_constant, 2);
        if (p_constant_expression == 0)
        {
            goto __L0; /* throw */
        }
        p_static_assert_declaration->constant_expression = p_constant_expression;
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 44)
        {
            parser_match(ctx);
            p_static_assert_declaration->string_literal_opt = ctx->current;
            if (parser_match_tk(ctx, 130) != 0)
            {
                goto __L0; /* throw */
            }
        }
        if (parser_match_tk(ctx, 41) != 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_static_assert_declaration->last_token = ctx->current;
        if (parser_match_tk(ctx, 59) != 0)
        {
            goto __L0; /* throw */
        }
        if (position->type == 9073)
        {
            if (object_has_constant_value(&p_static_assert_declaration->constant_expression->object) && !object_is_true(&p_static_assert_declaration->constant_expression->object))
            {
                if (p_static_assert_declaration->string_literal_opt)
                {
                    compiler_diagnostic(1060, ctx, position, 0, "static_assert failed %s\n", p_static_assert_declaration->string_literal_opt->lexeme);
                }
                else
                {
                    compiler_diagnostic(1060, ctx, position, 0, "static_assert failed");
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return p_static_assert_declaration;
}


void attribute_specifier_sequence_add(struct attribute_specifier_sequence * list, struct attribute_specifier * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void attribute_specifier_delete(struct attribute_specifier * p);

void attribute_specifier_sequence_delete(struct attribute_specifier_sequence * p)
{
    if (p)
    {
        struct attribute_specifier * item;

        item = p->head;
        while (item)
        {
            struct attribute_specifier * next;

            next = item->next;
            item->next = 0;
            attribute_specifier_delete(item);
            item = next;
        }
        free(p);
    }
}


struct attribute_specifier *attribute_specifier(struct parser_ctx * ctx);

struct attribute_specifier_sequence *attribute_specifier_sequence_opt(struct parser_ctx * ctx)
{
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;

    p_attribute_specifier_sequence = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (first_of_attribute_specifier(ctx))
        {
            p_attribute_specifier_sequence = calloc(1, 24);
            if (p_attribute_specifier_sequence == 0)
            {
                goto __L0; /* throw */
            }
            p_attribute_specifier_sequence->first_token = ctx->current;
            while (ctx->current != 0 && first_of_attribute_specifier(ctx))
            {
                if (ctx->current->type == 9046)
                {
                    gcc_attribute_specifier_opt(ctx);
                }
                else
                {
                    if (ctx->current->type == 9059)
                    {
                        p_attribute_specifier_sequence->msvc_declspec_flags |= msvc_declspec_sequence_opt(ctx);
                    }
                    else
                    {
                        if (ctx->current->type == 9064)
                        {
                            if (ctx->options.target == 0)
                            {
                                struct asm_statement * p3;

                                p3 = gcc_asm(ctx, 0);
                                asm_statement_delete(p3);
                            }
                        }
                        else
                        {
                            struct attribute_specifier * p_attribute_specifier;

                            p_attribute_specifier = attribute_specifier(ctx);
                            if (p_attribute_specifier == 0)
                            {
                                goto __L0; /* throw */
                            }
                            p_attribute_specifier_sequence->attributes_flags |= p_attribute_specifier->attribute_list->attributes_flags;
                            attribute_specifier_sequence_add(p_attribute_specifier_sequence, p_attribute_specifier);
                        }
                    }
                }
            }
            if (ctx->previous == 0)
            {
                goto __L0; /* throw */
            }
            p_attribute_specifier_sequence->last_token = ctx->previous;
        }
    }
    else __L0: /*catch*/ 
    {
        attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
        p_attribute_specifier_sequence = 0;
    }
    return p_attribute_specifier_sequence;
}


void attribute_list_delete(struct attribute_list * p);

void attribute_specifier_delete(struct attribute_specifier * p)
{
    if (p)
    {
        attribute_list_delete(p->attribute_list);
        ;
        free(p);
    }
}


struct attribute_list *attribute_list(struct parser_ctx * ctx, struct attribute_specifier * p_attribute_specifier);

struct attribute_specifier *attribute_specifier(struct parser_ctx * ctx)
{
    struct attribute_specifier * p_attribute_specifier;

    p_attribute_specifier = 0;
    if (1) /*try*/
    {
        struct attribute_list * p_attribute_list;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_attribute_specifier = calloc(1, 20);
        if (p_attribute_specifier == 0)
        {
            goto __L0; /* throw */
        }
        p_attribute_specifier->first_token = ctx->current;
        if (parser_match_tk(ctx, 91) != 0)
        {
            goto __L0; /* throw */
        }
        if (parser_match_tk(ctx, 91) != 0)
        {
            goto __L0; /* throw */
        }
        p_attribute_list = attribute_list(ctx, p_attribute_specifier);
        if (p_attribute_list == 0)
        {
            goto __L0; /* throw */
        }
        p_attribute_specifier->attribute_list = p_attribute_list;
        if (parser_match_tk(ctx, 93) != 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_attribute_specifier->last_token = ctx->current;
        if (parser_match_tk(ctx, 93) != 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        attribute_specifier_delete(p_attribute_specifier);
        p_attribute_specifier = 0;
    }
    return p_attribute_specifier;
}


void attribute_argument_clause_delete(struct attribute_argument_clause * p);

void attribute_delete(struct attribute * p)
{
    if (p)
    {
        attribute_argument_clause_delete(p->attribute_argument_clause);
        ;
        free(p);
    }
}


void attribute_list_add(struct attribute_list * list, struct attribute * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void attribute_list_destroy(struct attribute_list * p)
{
    struct attribute * item;

    item = p->head;
    while (item)
    {
        struct attribute * next;

        next = item->next;
        item->next = 0;
        attribute_delete(item);
        item = next;
    }
}


void attribute_list_delete(struct attribute_list * p)
{
    if (p)
    {
        attribute_list_destroy(p);
        free(p);
    }
}


unsigned char first_of_attribute(struct parser_ctx * ctx);
struct attribute *attribute(struct parser_ctx * ctx, struct attribute_specifier * p_attribute_specifier);

struct attribute_list *attribute_list(struct parser_ctx * ctx, struct attribute_specifier * p_attribute_specifier)
{
    struct attribute_list * p_attribute_list;

    p_attribute_list = 0;
    if (1) /*try*/
    {
        p_attribute_list = calloc(1, 12);
        if (p_attribute_list == 0)
        {
            goto __L0; /* throw */
        }
        while (ctx->current != 0 && (first_of_attribute(ctx) || ctx->current->type == 44))
        {
            if (first_of_attribute(ctx))
            {
                struct attribute * p_attribute;

                p_attribute = attribute(ctx, p_attribute_specifier);
                if (p_attribute == 0)
                {
                    goto __L0; /* throw */
                }
                p_attribute_list->attributes_flags |= p_attribute->attributes_flags;
                attribute_list_add(p_attribute_list, p_attribute);
            }
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            if (ctx->current->type == 44)
            {
                parser_match(ctx);
            }
        }
    }
    else __L0: /*catch*/ 
    {
        attribute_list_delete(p_attribute_list);
        p_attribute_list = 0;
    }
    return p_attribute_list;
}


unsigned char first_of_attribute(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    if (ctx->current->type == 8996)
    {
        return 1;
    }
    if (is_keyword(ctx->current->lexeme, ctx->options.target) != 0)
    {
        return 1;
    }
    return 0;
}


int attribute_token(struct parser_ctx * ctx, struct attribute_specifier * p_attribute_specifier)
{
    int attribute_flags;

    attribute_flags = 0;
    if (1) /*try*/
    {
        struct token * attr_token;
        unsigned char  is_standard_attribute;
        unsigned char  is_cake_attr;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        attr_token = ctx->current;
        is_standard_attribute = 0;
        if (strcmp(attr_token->lexeme, "deprecated") == 0)
        {
            is_standard_attribute = 1;
            attribute_flags = 1;
        }
        else
        {
            if (strcmp(attr_token->lexeme, "fallthrough") == 0)
            {
                is_standard_attribute = 1;
            }
            else
            {
                if (strcmp(attr_token->lexeme, "maybe_unused") == 0)
                {
                    is_standard_attribute = 1;
                    attribute_flags = 4;
                }
                else
                {
                    if (strcmp(attr_token->lexeme, "noreturn") == 0)
                    {
                        is_standard_attribute = 1;
                        attribute_flags = 16;
                    }
                    else
                    {
                        if (strcmp(attr_token->lexeme, "reproducible") == 0)
                        {
                            is_standard_attribute = 1;
                            attribute_flags = 64;
                        }
                        else
                        {
                            if (strcmp(attr_token->lexeme, "unsequenced") == 0)
                            {
                                is_standard_attribute = 1;
                                attribute_flags = 32;
                            }
                            else
                            {
                                if (strcmp(attr_token->lexeme, "nodiscard") == 0)
                                {
                                    is_standard_attribute = 1;
                                    attribute_flags = 8;
                                }
                                else
                                {
                                    if (strcmp(attr_token->lexeme, "dtor") == 0)
                                    {
                                        is_standard_attribute = 1;
                                        attribute_flags = 256;
                                    }
                                    else
                                    {
                                        if (strcmp(attr_token->lexeme, "ctor") == 0)
                                        {
                                            is_standard_attribute = 1;
                                            attribute_flags = 128;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        is_cake_attr = strcmp(attr_token->lexeme, "cake") == 0;
        if (token_is_identifier_or_keyword(ctx->current->type))
        {
            parser_match(ctx);
        }
        else
        {
            compiler_diagnostic(970, ctx, attr_token, 0, "expected identifier");
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 14906)
        {
            parser_match(ctx);
            if (is_cake_attr)
            {
                if (ctx->current->lexeme[0] == 69 || ctx->current->lexeme[0] == 101 || ctx->current->lexeme[0] == 87 || ctx->current->lexeme[0] == 119)
                {
                    p_attribute_specifier->ack = atoi(ctx->current->lexeme + 1);
                }
                else
                {
                    if (strcmp(ctx->current->lexeme, "leak") == 0)
                    {
                        attribute_flags = 1073741824;
                    }
                    else
                    {
                        compiler_diagnostic(9, ctx, attr_token, 0, "warning '%s' is not an cake attribute", ctx->current->lexeme);
                    }
                }
            }
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            if (token_is_identifier_or_keyword(ctx->current->type))
            {
                parser_match(ctx);
            }
            else
            {
                compiler_diagnostic(970, ctx, attr_token, 0, "expected identifier");
            }
        }
        else
        {
            if (!is_standard_attribute)
            {
                compiler_diagnostic(9, ctx, attr_token, 0, "warning '%s' is not an standard attribute", attr_token->lexeme);
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return attribute_flags;
}


struct attribute_argument_clause *attribute_argument_clause(struct parser_ctx * ctx);

struct attribute *attribute(struct parser_ctx * ctx, struct attribute_specifier * p_attribute_specifier)
{
    struct attribute * p_attribute;

    p_attribute = 0;
    if (1) /*try*/
    {
        int attribute_flags;

        p_attribute = calloc(1, 20);
        if (p_attribute == 0)
        {
            goto __L0; /* throw */
        }
        attribute_flags = attribute_token(ctx, p_attribute_specifier);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_attribute->attributes_flags |= attribute_flags;
        if (ctx->current->type == 40)
        {
            struct attribute_argument_clause * p_attribute_argument_clause;

            p_attribute_argument_clause = attribute_argument_clause(ctx);
            if (p_attribute_argument_clause == 0)
            {
                goto __L0; /* throw */
            }
            p_attribute->attribute_argument_clause = p_attribute_argument_clause;
        }
    }
    else __L0: /*catch*/ 
    {
        attribute_delete(p_attribute);
        p_attribute = 0;
    }
    return p_attribute;
}


void balanced_token_sequence_delete(struct balanced_token_sequence * p);

void attribute_argument_clause_delete(struct attribute_argument_clause * p)
{
    if (p)
    {
        balanced_token_sequence_delete(p->p_balanced_token_sequence);
        free(p);
    }
}


struct balanced_token_sequence *balanced_token_sequence_opt(struct parser_ctx * ctx);

struct attribute_argument_clause *attribute_argument_clause(struct parser_ctx * ctx)
{
    struct attribute_argument_clause * p_attribute_argument_clause;

    p_attribute_argument_clause = calloc(1, 8);
    if (1) /*try*/
    {
        if (p_attribute_argument_clause == 0)
        {
            goto __L0; /* throw */
        }
        if (parser_match_tk(ctx, 40) != 0)
        {
            goto __L0; /* throw */
        }
        p_attribute_argument_clause->p_balanced_token_sequence = balanced_token_sequence_opt(ctx);
        if (parser_match_tk(ctx, 41) != 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        attribute_argument_clause_delete(p_attribute_argument_clause);
        p_attribute_argument_clause = 0;
    }
    return p_attribute_argument_clause;
}


void balanced_token_sequence_delete(struct balanced_token_sequence * p)
{
    if (p)
    {
        struct balanced_token * item;

        item = p->head;
        while (item)
        {
            struct balanced_token * next;

            next = item->next;
            free(item);
            item = next;
        }
        free(p);
    }
}


struct balanced_token_sequence *balanced_token_sequence_opt(struct parser_ctx * ctx)
{
    struct balanced_token_sequence * p_balanced_token_sequence;

    p_balanced_token_sequence = calloc(1, 8);
    if (1) /*try*/
    {
        int count1;
        int count2;
        int count3;

        if (p_balanced_token_sequence == 0)
        {
            goto __L0; /* throw */
        }
        count1 = 0;
        count2 = 0;
        count3 = 0;
        for (; ctx->current; )
        {
            if (ctx->current->type == 40)
            {
                count1++;
            }
            else
            {
                if (ctx->current->type == 91)
                {
                    count2++;
                }
                else
                {
                    if (ctx->current->type == 123)
                    {
                        count3++;
                    }
                    else
                    {
                        if (ctx->current->type == 41)
                        {
                            if (count1 == 0)
                            {
                                break;
                            }
                            count1--;
                        }
                        else
                        {
                            if (ctx->current->type == 91)
                            {
                                count2--;
                            }
                            else
                            {
                                if (ctx->current->type == 123)
                                {
                                    count3--;
                                }
                            }
                        }
                    }
                }
            }
            parser_match(ctx);
        }
        if (count2 != 0)
        {
            compiler_diagnostic(1090, ctx, ctx->current, 0, "expected ']' before ')'");
        }
        if (count3 != 0)
        {
            compiler_diagnostic(1090, ctx, ctx->current, 0, "expected '}' before ')'");
        }
    }
    else __L0: /*catch*/ 
    {
        balanced_token_sequence_delete(p_balanced_token_sequence);
        p_balanced_token_sequence = 0;
    }
    return p_balanced_token_sequence;
}


void labeled_statement_delete(struct labeled_statement * p);
void unlabeled_statement_delete(struct unlabeled_statement * p);

void statement_delete(struct statement * p)
{
    if (p)
    {
        labeled_statement_delete(p->labeled_statement);
        unlabeled_statement_delete(p->unlabeled_statement);
        free(p);
    }
}


struct labeled_statement *labeled_statement(struct parser_ctx * ctx, struct attribute_specifier_sequence * p_attribute_specifier_sequence);
struct unlabeled_statement *unlabeled_statement(struct parser_ctx * ctx, struct attribute_specifier_sequence * p_attribute_specifier_sequence);

struct statement *statement(struct parser_ctx * ctx, struct attribute_specifier_sequence * p_attribute_specifier_sequence)
{
    struct statement * p_statement;

    p_statement = calloc(1, 8);
    if (1) /*try*/
    {
        if (p_statement == 0)
        {
            goto __L0; /* throw */
        }
        if (first_of_labeled_statement(ctx))
        {
            p_statement->labeled_statement = labeled_statement(ctx, p_attribute_specifier_sequence);
            p_attribute_specifier_sequence = 0;
            if (p_statement->labeled_statement == 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            p_statement->unlabeled_statement = unlabeled_statement(ctx, p_attribute_specifier_sequence);
            p_attribute_specifier_sequence = 0;
            if (p_statement->unlabeled_statement == 0)
            {
                goto __L0; /* throw */
            }
        }
    }
    else __L0: /*catch*/ 
    {
        statement_delete(p_statement);
        p_statement = 0;
    }
    attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
    return p_statement;
}


struct selection_statement *selection_statement(struct parser_ctx * ctx);
struct iteration_statement *iteration_statement(struct parser_ctx * ctx);
struct defer_statement *defer_statement(struct parser_ctx * ctx);
struct try_statement *try_statement(struct parser_ctx * ctx);
struct asm_statement *asm_statement(struct parser_ctx * ctx);
void primary_block_delete(struct primary_block * p);

struct primary_block *primary_block(struct parser_ctx * ctx)
{
    struct primary_block * p_primary_block;

    ;
    p_primary_block = calloc(1, 24);
    if (1) /*try*/
    {
        if (p_primary_block == 0)
        {
            goto __L0; /* throw */
        }
        if (first_of_compound_statement(ctx))
        {
            p_primary_block->compound_statement = compound_statement(ctx);
            if (p_primary_block->compound_statement == 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            if (first_of_selection_statement(ctx))
            {
                p_primary_block->selection_statement = selection_statement(ctx);
                if (p_primary_block->selection_statement == 0)
                {
                    goto __L0; /* throw */
                }
            }
            else
            {
                if (first_of_iteration_statement(ctx))
                {
                    p_primary_block->iteration_statement = iteration_statement(ctx);
                    if (p_primary_block->iteration_statement == 0)
                    {
                        goto __L0; /* throw */
                    }
                }
                else
                {
                    if (ctx->current->type == 9009)
                    {
                        p_primary_block->defer_statement = defer_statement(ctx);
                        if (p_primary_block->defer_statement == 0)
                        {
                            goto __L0; /* throw */
                        }
                    }
                    else
                    {
                        if (ctx->current->type == 9036 || ctx->current->type == 9060)
                        {
                            p_primary_block->try_statement = try_statement(ctx);
                            if (p_primary_block->try_statement == 0)
                            {
                                goto __L0; /* throw */
                            }
                        }
                        else
                        {
                            if (ctx->current->type == 9064)
                            {
                                p_primary_block->asm_statement = asm_statement(ctx);
                                if (p_primary_block->asm_statement == 0)
                                {
                                    goto __L0; /* throw */
                                }
                            }
                            else
                            {
                                compiler_diagnostic(970, ctx, ctx->current, 0, "unexpected token");
                            }
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        primary_block_delete(p_primary_block);
        p_primary_block = 0;
    }
    return p_primary_block;
}


static void check_open_brace_style(struct parser_ctx * ctx, struct token * token);
static void check_close_brace_style(struct parser_ctx * ctx, struct token * token);

struct secondary_block *secondary_block(struct parser_ctx * ctx)
{
    struct secondary_block * p_secondary_block;

    p_secondary_block = 0;
    if (1) /*try*/
    {
        struct attribute_specifier_sequence * p_attribute_specifier_sequence;
        struct statement * p_statement;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        check_open_brace_style(ctx, ctx->current);
        p_secondary_block = calloc(1, 12);
        if (p_secondary_block == 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_secondary_block->first_token = ctx->current;
        p_attribute_specifier_sequence = attribute_specifier_sequence_opt(ctx);
        p_statement = statement(ctx, p_attribute_specifier_sequence);
        p_attribute_specifier_sequence = 0;
        if (p_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_secondary_block->statement = p_statement;
        if (ctx->previous == 0)
        {
            goto __L0; /* throw */
        }
        p_secondary_block->last_token = ctx->previous;
        check_close_brace_style(ctx, p_secondary_block->last_token);
    }
    else __L0: /*catch*/ 
    {
        secondary_block_delete(p_secondary_block);
        p_secondary_block = 0;
    }
    return p_secondary_block;
}



static void check_open_brace_style(struct parser_ctx * ctx, struct token * token)
{
    if (token->level == 0 && !(token->flags & 2) && token->type == 123 && token->prev && is_diagnostic_enabled(&ctx->options, 11))
    {
        if (ctx->options.style == 0)
        {
            if (token->prev->type == 143 && token->prev->prev && token->prev->prev->type == 10)
            {
            }
            else
            {
                compiler_diagnostic(11, ctx, token, 0, "not following correct brace style {");
            }
        }
    }
}

static void check_close_brace_style(struct parser_ctx * ctx, struct token * token)
{
    if (token->level == 0 && !(token->flags & 2) && token->type == 125 && token->prev && token->prev->prev && is_diagnostic_enabled(&ctx->options, 11))
    {
        if (ctx->options.style == 0)
        {
            if (token->prev->type == 143 && token->prev->prev->type == 10)
            {
            }
            else
            {
                compiler_diagnostic(11, ctx, token, 0, "not following correct close brace style }");
            }
        }
    }
}
unsigned char unlabeled_statement_ends_with_jump(struct unlabeled_statement * p_unlabeled_statement)
{
    struct expression * p_expression;

    p_expression = 0;
    if (p_unlabeled_statement->expression_statement)
    {
        p_expression = p_unlabeled_statement->expression_statement->expression_opt;
    }
    else
    {
        if (p_unlabeled_statement->jump_statement)
        {
            return 1;
        }
        else
        {
            if (p_unlabeled_statement->primary_block && p_unlabeled_statement->primary_block->compound_statement && p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail && p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement && p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement->expression_statement)
            {
                p_expression = p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement->expression_statement->expression_opt;
            }
        }
    }
    if (p_expression)
    {
        return ((p_expression->type.attributes_flags & 16) != 0);
    }
    if (p_unlabeled_statement->primary_block && p_unlabeled_statement->primary_block->compound_statement && p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail && p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement)
    {
        return p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement->jump_statement != 0;
    }
    return 0;
}


unsigned char secondary_block_ends_with_jump(struct secondary_block * p_secondary_block)
{
    if (p_secondary_block && p_secondary_block->statement->unlabeled_statement)
    {
        return unlabeled_statement_ends_with_jump(p_secondary_block->statement->unlabeled_statement);
    }
    return 0;
}


void secondary_block_delete(struct secondary_block * p)
{
    if (p)
    {
        statement_delete(p->statement);
        free(p);
    }
}


void iteration_statement_delete(struct iteration_statement * p);
void selection_statement_delete(struct selection_statement * p);
void try_statement_delete(struct try_statement * p);

void primary_block_delete(struct primary_block * p)
{
    if (p)
    {
        compound_statement_delete(p->compound_statement);
        defer_statement_delete(p->defer_statement);
        iteration_statement_delete(p->iteration_statement);
        selection_statement_delete(p->selection_statement);
        try_statement_delete(p->try_statement);
        free(p);
    }
}


void expression_statement_delete(struct expression_statement * p);
void jump_statement_delete(struct jump_statement * p);

void unlabeled_statement_delete(struct unlabeled_statement * p)
{
    if (p)
    {
        expression_statement_delete(p->expression_statement);
        jump_statement_delete(p->jump_statement);
        primary_block_delete(p->primary_block);
        free(p);
    }
}


struct diagnostic_id_stack *build_diagnostic_id_stack(struct parser_ctx * ctx, struct attribute_specifier_sequence * p_attribute_specifier_sequence, struct diagnostic_id_stack * stack, int diagnostic_phase)
{
    struct diagnostic_id_stack * previous;
    struct attribute_specifier * p_attribute_specifier;

    previous = ctx->p_diagnostic_id_stack;
    ctx->p_diagnostic_id_stack = stack;
    if (p_attribute_specifier_sequence == 0)
    {
        return previous;
    }
    p_attribute_specifier = p_attribute_specifier_sequence->head;
    while (p_attribute_specifier)
    {
        int d;

        d = p_attribute_specifier->ack;
        if (d != 0)
        {
            if (get_diagnostic_phase(d) == diagnostic_phase)
            {
                diagnostic_id_stack_push(stack, p_attribute_specifier->ack);
            }
        }
        p_attribute_specifier = p_attribute_specifier->next;
    }
    return previous;
}


void warn_unrecognized_warnings(struct parser_ctx * ctx, struct diagnostic_id_stack * stack, struct attribute_specifier_sequence * p_attribute_specifier_sequence, struct diagnostic_id_stack * p_diagnostic_id_stack)
{
    struct token * token;

    ctx->p_diagnostic_id_stack = p_diagnostic_id_stack;
    if (p_attribute_specifier_sequence == 0)
    {
        return;
    }
    token = p_attribute_specifier_sequence->first_token;
    {
        int i;

        i = stack->size - 1;
        for (; i >= 0; i--)
        {
            compiler_diagnostic(59, ctx, token, 0, "warning 'C%04d' was not recognized", stack->stack[i]);
        }
    }
}


static unsigned char first_of_primary_block(struct parser_ctx * ctx);
struct jump_statement *jump_statement(struct parser_ctx * ctx);
struct expression_statement *expression_statement(struct parser_ctx * ctx, unsigned char  ignore_semicolon, struct attribute_specifier_sequence * p_attribute_specifier_sequence);
unsigned char type_is_nodiscard(struct type * p_type);

struct unlabeled_statement *unlabeled_statement(struct parser_ctx * ctx, struct attribute_specifier_sequence * p_attribute_specifier_sequence)
{
    struct unlabeled_statement * p_unlabeled_statement;

    p_unlabeled_statement = calloc(1, 16);
    if (1) /*try*/
    {
        if (p_unlabeled_statement == 0)
        {
            goto __L0; /* throw */
        }
        if (first_of_primary_block(ctx))
        {
            struct diagnostic_id_stack  stack;
            struct diagnostic_id_stack * p_diagnostic_id_stack;

            p_unlabeled_statement->p_attribute_specifier_sequence = p_attribute_specifier_sequence;
            p_attribute_specifier_sequence = 0;
            _cake_zmem(&stack, 44);
            p_diagnostic_id_stack = build_diagnostic_id_stack(ctx, p_unlabeled_statement->p_attribute_specifier_sequence, &stack, 0);
            p_unlabeled_statement->primary_block = primary_block(ctx);
            warn_unrecognized_warnings(ctx, &stack, p_unlabeled_statement->p_attribute_specifier_sequence, p_diagnostic_id_stack);
            if (p_unlabeled_statement->primary_block == 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            if (first_of_jump_statement(ctx))
            {
                struct diagnostic_id_stack  stack;
                struct diagnostic_id_stack * p_diagnostic_id_stack;

                p_unlabeled_statement->p_attribute_specifier_sequence = p_attribute_specifier_sequence;
                p_attribute_specifier_sequence = 0;
                _cake_zmem(&stack, 44);
                p_diagnostic_id_stack = build_diagnostic_id_stack(ctx, p_unlabeled_statement->p_attribute_specifier_sequence, &stack, 0);
                p_unlabeled_statement->jump_statement = jump_statement(ctx);
                warn_unrecognized_warnings(ctx, &stack, p_unlabeled_statement->p_attribute_specifier_sequence, p_diagnostic_id_stack);
                if (p_unlabeled_statement->jump_statement == 0)
                {
                    goto __L0; /* throw */
                }
            }
            else
            {
                p_unlabeled_statement->expression_statement = expression_statement(ctx, 0, p_attribute_specifier_sequence);
                p_attribute_specifier_sequence = 0;
                if (p_unlabeled_statement->expression_statement == 0)
                {
                    goto __L0; /* throw */
                }
                if (p_unlabeled_statement->expression_statement->expression_opt)
                {
                    if (!type_is_void(&p_unlabeled_statement->expression_statement->expression_opt->type) && type_is_nodiscard(&p_unlabeled_statement->expression_statement->expression_opt->type) && p_unlabeled_statement->expression_statement->expression_opt->type.storage_class_specifier_flags & 8192)
                    {
                        if (p_unlabeled_statement->expression_statement->expression_opt->first_token->level == 0)
                        {
                            compiler_diagnostic(9, ctx, p_unlabeled_statement->expression_statement->expression_opt->first_token, 0, "ignoring return value of function declared with 'nodiscard' attribute");
                        }
                    }
                    if (type_is_owner(&p_unlabeled_statement->expression_statement->expression_opt->type) && p_unlabeled_statement->expression_statement->expression_opt->type.storage_class_specifier_flags & 8192)
                    {
                        if (p_unlabeled_statement->expression_statement->expression_opt->first_token->level == 0)
                        {
                            compiler_diagnostic(9, ctx, p_unlabeled_statement->expression_statement->expression_opt->first_token, 0, "ignoring the result of _Owner type ");
                        }
                    }
                }
                if (p_unlabeled_statement->expression_statement->expression_opt && p_unlabeled_statement->expression_statement->expression_opt->expression_type == 12)
                {
                }
                else
                {
                    if (p_unlabeled_statement != 0 && p_unlabeled_statement->jump_statement == 0 && p_unlabeled_statement->expression_statement != 0 && p_unlabeled_statement->expression_statement->expression_opt)
                    {
                        if (p_unlabeled_statement->expression_statement->expression_opt->expression_type == 2 || p_unlabeled_statement->expression_statement->expression_opt->expression_type == 8)
                        {
                            if (ctx->current && ctx->current->level == 0)
                            {
                                compiler_diagnostic(10, ctx, p_unlabeled_statement->expression_statement->expression_opt->first_token, 0, "expression result not used");
                            }
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        unlabeled_statement_delete(p_unlabeled_statement);
        p_unlabeled_statement = 0;
    }
    attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
    return p_unlabeled_statement;
}



static unsigned char first_of_primary_block(struct parser_ctx * ctx)
{
    if (ctx->current == 0)
    {
        return 0;
    }
    if (first_of_compound_statement(ctx) || first_of_selection_statement(ctx) || first_of_iteration_statement(ctx) || ctx->current->type == 9009 || ctx->current->type == 9036 || ctx->current->type == 9060 || ctx->current->type == 9064)
    {
        return 1;
    }
    return 0;
}
void label_delete(struct label * p)
{
    if (p)
    {
        expression_delete(p->constant_expression);
        free(p);
    }
}


struct label_list_item *label_list_find(struct label_list * list, char * label_name);
void label_list_push(struct label_list * list, struct label_list_item * pitem);
struct label *case_label_list_find_range(struct parser_ctx * ctx, struct case_label_list * list, struct object * begin, struct object * end);
struct label *case_label_list_find(struct parser_ctx * ctx, struct case_label_list * list, struct object * object);
void case_label_list_push(struct case_label_list * list, struct label * pnew);
struct label *case_label_list_find_default(struct parser_ctx * ctx, struct case_label_list * list);

struct label *label(struct parser_ctx * ctx, struct attribute_specifier_sequence * p_attribute_specifier_sequence)
{
    struct label * p_label;

    if (ctx->current == 0)
    {
        return 0;
    }
    p_label = calloc(1, 28);
    if (1) /*try*/
    {
        struct diagnostic_id_stack  stack;
        struct diagnostic_id_stack * p_diagnostic_id_stack;

        if (p_label == 0)
        {
            goto __L1; /* throw */
        }
        p_label->p_attribute_specifier_sequence = p_attribute_specifier_sequence;
        p_attribute_specifier_sequence = 0;
        _cake_zmem(&stack, 44);
        p_diagnostic_id_stack = build_diagnostic_id_stack(ctx, p_label->p_attribute_specifier_sequence, &stack, 0);
        p_label->label_id = ctx->label_id++;
        p_label->p_first_token = ctx->current;
        if (ctx->current->type == 8996)
        {
            struct label_list_item * p_label_list_item;

            p_label_list_item = label_list_find(&ctx->label_list, ctx->current->lexeme);
            if (p_label_list_item == 0)
            {
                struct label_list_item * p_label_list_item_new;

                p_label_list_item_new = calloc(1, 12);
                if (p_label_list_item_new)
                {
                    p_label_list_item_new->p_defined = ctx->current;
                    label_list_push(&ctx->label_list, p_label_list_item_new);
                }
            }
            else
            {
                if (p_label_list_item->p_defined)
                {
                    compiler_diagnostic(1440, ctx, ctx->current, 0, "duplicated label '%s'", ctx->current->lexeme);
                    compiler_diagnostic(0, ctx, p_label_list_item->p_defined, 0, "previous definition of '%s'", ctx->current->lexeme);
                }
                else
                {
                    p_label_list_item->p_defined = ctx->current;
                }
            }
            p_label->p_identifier_opt = ctx->current;
            parser_match(ctx);
            if (parser_match_tk(ctx, 58) != 0)
            {
                goto __L1; /* throw */
            }
        }
        else
        {
            if (ctx->current->type == 9001)
            {
                if (ctx->p_current_selection_statement == 0 || ctx->p_current_selection_statement->condition == 0)
                {
                    goto __L1; /* throw */
                }
                parser_match(ctx);
                p_label->constant_expression = constant_expression(ctx, 1, 2);
                if (p_label->constant_expression == 0)
                {
                    goto __L1; /* throw */
                }
                if (ctx->current == 0)
                {
                    unexpected_end_of_file(ctx);
                    goto __L1; /* throw */
                }
                if (ctx->current->type == 3026478)
                {
                    struct label * p_existing_label;

                    parser_match(ctx);
                    p_label->constant_expression_end = constant_expression(ctx, 1, 2);
                    if (p_label->constant_expression_end == 0)
                    {
                        goto __L1; /* throw */
                    }
                    p_existing_label = case_label_list_find_range(ctx, &ctx->p_current_selection_statement->label_list, &p_label->constant_expression->object, &p_label->constant_expression_end->object);
                    if (p_existing_label)
                    {
                        char str1[50];
                        char str2[50];

                        object_to_str(&p_label->constant_expression->object, 50, str1);
                        object_to_str(&p_label->constant_expression_end->object, 50, str2);
                        compiler_diagnostic(1450, ctx, p_label->constant_expression->first_token, 0, "case '%s' ... '%s' is duplicating values", str1, str2);
                        ;
                        compiler_diagnostic(0, ctx, p_existing_label->constant_expression->first_token, 0, "previous case");
                    }
                }
                else
                {
                    struct label * p_existing_label;

                    p_existing_label = case_label_list_find(ctx, &ctx->p_current_selection_statement->label_list, &p_label->constant_expression->object);
                    if (p_existing_label)
                    {
                        char str[50];

                        object_to_str(&p_label->constant_expression->object, 50, str);
                        compiler_diagnostic(1450, ctx, p_label->constant_expression->first_token, 0, "duplicate case '%s'", str);
                        ;
                        compiler_diagnostic(0, ctx, p_existing_label->constant_expression->first_token, 0, "previous declaration");
                    }
                }
                if (parser_match_tk(ctx, 58) != 0)
                {
                    goto __L1; /* throw */
                }
                case_label_list_push(&ctx->p_current_selection_statement->label_list, p_label);
                if (ctx->p_current_selection_statement && ctx->p_current_selection_statement->condition && ctx->p_current_selection_statement->condition->expression)
                {
                    struct enum_specifier * p_enum_specifier;

                    if (type_is_enum(&ctx->p_current_selection_statement->condition->expression->type))
                    {
                        if (type_is_enum(&p_label->constant_expression->type))
                        {
                            check_diferent_enuns(ctx, p_label->constant_expression->first_token, p_label->constant_expression, ctx->p_current_selection_statement->condition->expression, "mismatch in enumeration types");
                        }
                        else
                        {
                        }
                    }
                    if (ctx->p_current_selection_statement == 0)
                    {
                        goto __L1; /* throw */
                    }
                    p_enum_specifier = 0;
                    if (ctx->p_current_selection_statement->condition && ctx->p_current_selection_statement->condition->expression && ctx->p_current_selection_statement->condition->expression->type.enum_specifier)
                    {
                        p_enum_specifier = get_complete_enum_specifier(ctx->p_current_selection_statement->condition->expression->type.enum_specifier);
                    }
                    if (p_enum_specifier)
                    {
                        struct enumerator * p_enumerator;

                        p_enumerator = find_enumerator_by_value(ctx, p_enum_specifier, &p_label->constant_expression->object);
                        if (p_enumerator == 0)
                        {
                            char str[50];

                            object_to_str(&p_label->constant_expression->object, 50, str);
                            compiler_diagnostic(4, ctx, p_label->constant_expression->first_token, 0, "case value '%s' not in enumerated type 'enum %s'", str, p_enum_specifier->tag_name);
                        }
                        else
                        {
                        }
                    }
                }
            }
            else
            {
                if (ctx->current->type == 9007)
                {
                    struct label * p_existing_default_label;

                    p_existing_default_label = case_label_list_find_default(ctx, &ctx->p_current_selection_statement->label_list);
                    if (p_existing_default_label)
                    {
                        if (compiler_diagnostic(1780, ctx, p_label->p_first_token, 0, "multiple default labels in one switch"))
                        {
                            compiler_diagnostic(0, ctx, p_existing_default_label->p_first_token, 0, "previous default");
                        }
                        goto __L1; /* throw */
                    }
                    parser_match(ctx);
                    if (parser_match_tk(ctx, 58) != 0)
                    {
                        goto __L1; /* throw */
                    }
                    case_label_list_push(&ctx->p_current_selection_statement->label_list, p_label);
                }
            }
        }
        warn_unrecognized_warnings(ctx, &stack, p_label->p_attribute_specifier_sequence, p_diagnostic_id_stack);
    }
    else __L1: /*catch*/ 
    {
        label_delete(p_label);
        p_label = 0;
    }
    attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
    return p_label;
}


struct label *case_label_list_find_default(struct parser_ctx * ctx, struct case_label_list * list)
{
    struct label * p;

    p = list->head;
    while (p)
    {
        if (p->p_first_token->type == 9007)
        {
            return p;
        }
        p = p->next;
    }
    return 0;
}


struct label *case_label_list_find_range(struct parser_ctx * ctx, struct case_label_list * list, struct object * begin, struct object * end)
{
    struct label * p;

    p = list->head;
    while (p)
    {
        if (p->constant_expression_end == 0)
        {
            if (object_is_greater_than_or_equal(ctx->options.target, &p->constant_expression->object, begin) && object_is_smaller_than_or_equal(ctx->options.target, &p->constant_expression_end->object, end))
            {
                return p;
            }
        }
        else
        {
            if (object_is_smaller_than_or_equal(ctx->options.target, &p->constant_expression->object, end) && object_is_smaller_than_or_equal(ctx->options.target, begin, &p->constant_expression_end->object))
            {
                return p;
            }
        }
        p = p->next;
    }
    return 0;
}


struct label *case_label_list_find(struct parser_ctx * ctx, struct case_label_list * list, struct object * object)
{
    struct label * p;

    p = list->head;
    while (p)
    {
        if (p->constant_expression_end == 0)
        {
            if (p->constant_expression && object_is_equal(ctx->options.target, &p->constant_expression->object, object))
            {
                return p;
            }
        }
        else
        {
            if (p->constant_expression && object_is_greater_than_or_equal(ctx->options.target, object, &p->constant_expression->object) && object_is_smaller_than_or_equal(ctx->options.target, object, &p->constant_expression_end->object))
            {
                return p;
            }
        }
        p = p->next;
    }
    return 0;
}


void case_label_list_push(struct case_label_list * list, struct label * pnew)
{
    if (list->head == 0)
    {
        list->head = pnew;
        list->tail = pnew;
    }
    else
    {
        ;
        list->tail->next = pnew;
        list->tail = pnew;
    }
}


void labeled_statement_delete(struct labeled_statement * p)
{
    if (p)
    {
        label_delete(p->label);
        statement_delete(p->statement);
        free(p);
    }
}


struct labeled_statement *labeled_statement(struct parser_ctx * ctx, struct attribute_specifier_sequence * p_attribute_specifier_sequence)
{
    struct labeled_statement * p_labeled_statement;

    p_labeled_statement = calloc(1, 8);
    if (1) /*try*/
    {
        struct label * p_label;
        struct statement * p_statement;

        if (p_labeled_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_label = label(ctx, p_attribute_specifier_sequence);
        p_attribute_specifier_sequence = 0;
        if (p_label == 0)
        {
            goto __L0; /* throw */
        }
        p_labeled_statement->label = p_label;
        p_statement = statement(ctx, p_attribute_specifier_sequence);
        p_attribute_specifier_sequence = 0;
        if (p_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_labeled_statement->statement = p_statement;
    }
    else __L0: /*catch*/ 
    {
        labeled_statement_delete(p_labeled_statement);
        p_labeled_statement = 0;
    }
    attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
    return p_labeled_statement;
}


void block_item_list_destroy(struct block_item_list * p);

void compound_statement_delete(struct compound_statement * p)
{
    if (p)
    {
        block_item_list_destroy(&p->block_item_list);
        free(p);
    }
}


struct block_item_list block_item_list(struct parser_ctx * ctx, unsigned char * error);

struct compound_statement *compound_statement(struct parser_ctx * ctx)
{
    struct scope  block_scope;
    struct compound_statement * p_compound_statement;

    block_scope.scope_level = 0;
    block_scope.tags.table = 0;
    block_scope.tags.capacity = 0;
    block_scope.tags.size = 0;
    block_scope.variables.table = 0;
    block_scope.variables.capacity = 10;
    block_scope.variables.size = 0;
    block_scope.next = 0;
    block_scope.previous = 0;
    p_compound_statement = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_compound_statement = calloc(1, 72);
        if (p_compound_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_compound_statement->diagnostic_flags = ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index];
        scope_list_push(&ctx->scopes, &block_scope);
        p_compound_statement->first_token = ctx->current;
        if (parser_match_tk(ctx, 123) != 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current == 0)
        {
            compiler_diagnostic(970, ctx, ctx->input_list.tail, 0, "unexpected end of file");
            goto __L0; /* throw */
        }
        if (ctx->current->type != 125)
        {
            unsigned char  berror;

            berror = 0;
            p_compound_statement->block_item_list = block_item_list(ctx, &berror);
            if (berror)
            {
                goto __L0; /* throw */
            }
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_compound_statement->last_token = ctx->current;
        if (parser_match_tk(ctx, 125) != 0)
        {
            goto __L0; /* throw */
        }
        {
            int i;

            i = 0;
            for (; i < block_scope.variables.capacity; i++)
            {
                struct map_entry * entry;

                if (block_scope.variables.table == 0)
                {
                    continue;
                }
                entry = block_scope.variables.table[i];
                while (entry)
                {
                    struct declarator * p_declarator;
                    struct init_declarator * p_init_declarator;

                    if (entry->type != 4 && entry->type != 5)
                    {
                        entry = entry->next;
                        continue;
                    }
                    p_declarator = 0;
                    p_init_declarator = 0;
                    if (entry->type == 5)
                    {
                        ;
                        p_init_declarator = entry->data.p_init_declarator;
                        p_declarator = p_init_declarator->p_declarator;
                    }
                    else
                    {
                        p_declarator = entry->data.p_declarator;
                    }
                    if (p_declarator)
                    {
                        if (!type_is_maybe_unused(&p_declarator->type) && p_declarator->num_uses == 0)
                        {
                            if (p_declarator->name_opt && p_declarator->name_opt->token_origin->level == 0)
                            {
                                compiler_diagnostic(2, ctx, p_declarator->name_opt, 0, "'%s': unreferenced declarator", p_declarator->name_opt->lexeme);
                            }
                        }
                    }
                    entry = entry->next;
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        compound_statement_delete(p_compound_statement);
        p_compound_statement = 0;
    }
    scope_list_pop(&ctx->scopes);
    scope_destroy(&block_scope);
    return p_compound_statement;
}


void block_item_list_add(struct block_item_list * list, struct block_item * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void block_item_delete(struct block_item * p);

void block_item_list_destroy(struct block_item_list * list)
{
    struct block_item * item;

    item = list->head;
    while (item)
    {
        struct block_item * next;

        next = item->next;
        item->next = 0;
        block_item_delete(item);
        item = next;
    }
}


struct block_item *block_item(struct parser_ctx * ctx);

struct block_item_list block_item_list(struct parser_ctx * ctx, unsigned char * error)
{
    struct block_item_list  block_item_list;
    struct block_item * p_block_item;

    *error = 0;
    _cake_zmem(&block_item_list, 8);
    p_block_item = 0;
    if (1) /*try*/
    {
        p_block_item = block_item(ctx);
        if (p_block_item == 0)
        {
            goto __L0; /* throw */
        }
        block_item_list_add(&block_item_list, p_block_item);
        p_block_item = 0;
        while (ctx->current != 0 && ctx->current->type != 125)
        {
            p_block_item = block_item(ctx);
            if (p_block_item == 0)
            {
                goto __L0; /* throw */
            }
            block_item_list_add(&block_item_list, p_block_item);
            p_block_item = 0;
        }
    }
    else __L0: /*catch*/ 
    {
        *error = 1;
    }
    return block_item_list;
}


void block_item_delete(struct block_item * p)
{
    if (p)
    {
        declaration_delete(p->declaration);
        label_delete(p->label);
        unlabeled_statement_delete(p->unlabeled_statement);
        ;
        free(p);
    }
}


void naming_convention_local_var(struct parser_ctx * ctx, struct token * token, struct type * type);

struct block_item *block_item(struct parser_ctx * ctx)
{
    struct block_item * p_block_item;
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;

    p_block_item = 0;
    p_attribute_specifier_sequence = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_block_item = calloc(1, 20);
        if (p_block_item == 0)
        {
            goto __L0; /* throw */
        }
        p_attribute_specifier_sequence = attribute_specifier_sequence_opt(ctx);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_block_item->first_token = ctx->current;
        if (first_of_declaration_specifier(ctx) || first_of_static_assert_declaration(ctx) || first_of_pragma_declaration(ctx))
        {
            struct init_declarator * p;

            p_block_item->declaration = declaration(ctx, p_attribute_specifier_sequence, 4096, 0);
            p_attribute_specifier_sequence = 0;
            if (p_block_item->declaration == 0)
            {
                goto __L0; /* throw */
            }
            p = p_block_item->declaration->init_declarator_list.head;
            while (p)
            {
                if (p->p_declarator->name_opt)
                {
                    naming_convention_local_var(ctx, p->p_declarator->name_opt, &p->p_declarator->type);
                }
                p = p->next;
            }
        }
        else
        {
            if (first_of_label(ctx))
            {
                p_block_item->label = label(ctx, p_attribute_specifier_sequence);
                p_attribute_specifier_sequence = 0;
                if (p_block_item->label == 0)
                {
                    goto __L0; /* throw */
                }
            }
            else
            {
                p_block_item->unlabeled_statement = unlabeled_statement(ctx, p_attribute_specifier_sequence);
                p_attribute_specifier_sequence = 0;
                if (p_block_item->unlabeled_statement == 0)
                {
                    goto __L0; /* throw */
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        block_item_delete(p_block_item);
        p_block_item = 0;
    }
    attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
    return p_block_item;
}


void try_statement_delete(struct try_statement * p)
{
    if (p)
    {
        secondary_block_delete(p->catch_secondary_block_opt);
        secondary_block_delete(p->secondary_block);
        free(p);
    }
}


void asm_statement_delete(struct asm_statement * p)
{
    if (p == 0)
    {
        return;
    }
    free(p);
}


static struct asm_statement *msvc_asm_statement(struct parser_ctx * ctx);

struct asm_statement *asm_statement(struct parser_ctx * ctx)
{
    /*switch*/
    {
        int __v0 = ctx->options.target;
        if (__v0 == 1) goto __L1; /*case 1*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 0) goto __L3; /*case 0*/
        if (__v0 == 3) goto __L4; /*case 3*/
        if (__v0 == 4) goto __L5; /*case 4*/
        if (__v0 == 5) goto __L6; /*case 5*/
        goto __L0;

        {
            __L1: /*case 1*/ 
            __L2: /*case 2*/ 
            return msvc_asm_statement(ctx);
            __L3: /*case 0*/ 
            __L4: /*case 3*/ 
            __L5: /*case 4*/ 
            __L6: /*case 5*/ 
            goto __L0; /* break */

        }
        __L0:;
    }
    return gcc_asm(ctx, 1);
}



static struct asm_statement *msvc_asm_statement(struct parser_ctx * ctx)
{
    struct asm_statement * p_asm_statement;

    p_asm_statement = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_asm_statement = calloc(1, 8);
        if (p_asm_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_asm_statement->p_first_token = ctx->current;
        if (parser_match_tk(ctx, 9064) != 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 123)
        {
            parser_match(ctx);
            while (ctx->current && ctx->current->type != 125)
            {
                parser_match(ctx);
            }
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            p_asm_statement->p_last_token = ctx->current;
            if (parser_match_tk(ctx, 125))
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            while (ctx->current && ctx->current->type != 10)
            {
                ctx->current = ctx->current->next;
            }
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            p_asm_statement->p_last_token = ctx->current;
            parser_match(ctx);
        }
        if (ctx->current && ctx->current->type == 59)
        {
            p_asm_statement->p_last_token = ctx->current;
            parser_match(ctx);
        }
    }
    else __L0: /*catch*/ 
    {
        asm_statement_delete(p_asm_statement);
        p_asm_statement = 0;
    }
    return p_asm_statement;
}
struct try_statement *try_statement(struct parser_ctx * ctx)
{
    struct try_statement * p_try_statement;

    p_try_statement = 0;
    if (1) /*try*/
    {
        struct try_statement * try_statement_copy_opt;
        struct secondary_block * p_secondary_block;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_try_statement = calloc(1, 28);
        if (p_try_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_try_statement->first_token = ctx->current;
        if (ctx->current->type != 9036 && ctx->current->type != 9060)
        {
            goto __L0; /* throw */
        }
        try_statement_copy_opt = ctx->p_current_try_statement_opt;
        ctx->p_current_try_statement_opt = p_try_statement;
        p_try_statement->catch_label_id = ctx->label_id++;
        parser_match(ctx);
        p_secondary_block = secondary_block(ctx);
        if (p_secondary_block == 0)
        {
            goto __L0; /* throw */
        }
        p_try_statement->secondary_block = p_secondary_block;
        ctx->p_current_try_statement_opt = try_statement_copy_opt;
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 9006)
        {
            p_try_statement->catch_token_opt = ctx->current;
            parser_match(ctx);
            ;
            p_try_statement->catch_secondary_block_opt = secondary_block(ctx);
            if (p_try_statement->catch_secondary_block_opt == 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            if (ctx->current->type == 9062)
            {
                p_try_statement->catch_token_opt = ctx->current;
                parser_match(ctx);
                ;
                p_try_statement->catch_secondary_block_opt = secondary_block(ctx);
                if (p_try_statement->catch_secondary_block_opt == 0)
                {
                    goto __L0; /* throw */
                }
            }
            else
            {
                if (ctx->current->type == 9061)
                {
                    p_try_statement->catch_token_opt = ctx->current;
                    parser_match(ctx);
                    parser_match_tk(ctx, 40);
                    p_try_statement->msvc_except_expression = expression(ctx, 2);
                    parser_match_tk(ctx, 41);
                    ;
                    p_try_statement->catch_secondary_block_opt = secondary_block(ctx);
                    if (p_try_statement->catch_secondary_block_opt == 0)
                    {
                        goto __L0; /* throw */
                    }
                }
            }
        }
        if (ctx->previous == 0)
        {
            goto __L0; /* throw */
        }
        p_try_statement->last_token = ctx->previous;
    }
    else __L0: /*catch*/ 
    {
        try_statement_delete(p_try_statement);
        p_try_statement = 0;
    }
    return p_try_statement;
}


void condition_delete(struct condition * p);
void init_statement_delete(struct init_statement * p);

void selection_statement_delete(struct selection_statement * p)
{
    if (p)
    {
        secondary_block_delete(p->secondary_block);
        secondary_block_delete(p->else_secondary_block_opt);
        condition_delete(p->condition);
        init_statement_delete(p->p_init_statement);
        free(p);
    }
}


struct init_statement *init_statement(struct parser_ctx * ctx, unsigned char  ignore_semicolon);
struct condition *condition(struct parser_ctx * ctx);

struct selection_statement *selection_statement(struct parser_ctx * ctx)
{
    struct scope  if_scope;
    struct selection_statement * p_selection_statement;

    _cake_zmem(&if_scope, 36);
    scope_list_push(&ctx->scopes, &if_scope);
    p_selection_statement = 0;
    if (1) /*try*/
    {
        unsigned char  is_if;
        struct selection_statement * previous;
        struct secondary_block * p_secondary_block;
        struct token * p_tk;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_selection_statement = calloc(1, 56);
        if (p_selection_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_selection_statement->label_id = ctx->label_id++;
        p_selection_statement->first_token = ctx->current;
        is_if = (ctx->current->type == 9017);
        if (ctx->current->type == 9017 || ctx->current->type == 9034)
        {
            parser_match(ctx);
        }
        else
        {
            goto __L0; /* throw */
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (!(ctx->current->flags & 2) && !style_has_one_space(ctx->current))
        {
            compiler_diagnostic(11, ctx, ctx->current, 0, "one space");
        }
        p_selection_statement->open_parentesis_token = ctx->current;
        if (parser_match_tk(ctx, 40) != 0)
        {
            goto __L0; /* throw */
        }
        p_selection_statement->p_init_statement = init_statement(ctx, 1);
        if (p_selection_statement->p_init_statement == 0)
        {
            goto __L0; /* throw */
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type == 59)
        {
            if (p_selection_statement->p_init_statement->p_simple_declaration)
            {
                p_selection_statement->p_init_statement->p_simple_declaration->last_token = ctx->current;
            }
            else
            {
                if (p_selection_statement->p_init_statement->p_expression_statement)
                {
                    p_selection_statement->p_init_statement->p_simple_declaration->last_token = ctx->current;
                }
            }
            parser_match(ctx);
            p_selection_statement->condition = condition(ctx);
        }
        else
        {
            if (ctx->current->type == 41)
            {
                p_selection_statement->condition = calloc(1, 24);
                if (p_selection_statement->condition == 0)
                {
                    goto __L0; /* throw */
                }
                if (p_selection_statement->p_init_statement->p_expression_statement && p_selection_statement->p_init_statement->p_expression_statement->expression_opt)
                {
                    p_selection_statement->condition->first_token = p_selection_statement->p_init_statement->p_expression_statement->expression_opt->first_token;
                    p_selection_statement->condition->last_token = p_selection_statement->p_init_statement->p_expression_statement->expression_opt->last_token;
                    p_selection_statement->condition->expression = p_selection_statement->p_init_statement->p_expression_statement->expression_opt;
                    p_selection_statement->p_init_statement->p_expression_statement->expression_opt = 0;
                }
                if (p_selection_statement->p_init_statement->p_simple_declaration)
                {
                    p_selection_statement->condition->first_token = p_selection_statement->p_init_statement->p_simple_declaration->first_token;
                    p_selection_statement->condition->last_token = p_selection_statement->p_init_statement->p_simple_declaration->last_token;
                    if (p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.head != p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.tail)
                    {
                        ;
                        goto __L0; /* throw */
                    }
                    p_selection_statement->condition->p_init_declarator = p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.head;
                    p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.head = 0;
                    p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.tail = 0;
                    p_selection_statement->condition->p_declaration_specifiers = p_selection_statement->p_init_statement->p_simple_declaration->p_declaration_specifiers;
                    p_selection_statement->p_init_statement->p_simple_declaration->p_declaration_specifiers = 0;
                }
                init_statement_delete(p_selection_statement->p_init_statement);
                p_selection_statement->p_init_statement = 0;
            }
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_selection_statement->close_parentesis_token = ctx->current;
        if (parser_match_tk(ctx, 41) != 0)
        {
            goto __L0; /* throw */
        }
        if (!is_if && p_selection_statement && p_selection_statement->condition)
        {
            if (type_is_bool(&p_selection_statement->condition->expression->type) || type_is_essential_bool(&p_selection_statement->condition->expression->type))
            {
                compiler_diagnostic(45, ctx, p_selection_statement->condition->first_token, 0, "switch condition has boolean value");
            }
        }
        previous = ctx->p_current_selection_statement;
        ctx->p_current_selection_statement = p_selection_statement;
        p_secondary_block = secondary_block(ctx);
        if (p_secondary_block == 0)
        {
            goto __L0; /* throw */
        }
        if (p_secondary_block->statement->unlabeled_statement && p_secondary_block->statement->unlabeled_statement->expression_statement && p_secondary_block->statement->unlabeled_statement->expression_statement->expression_opt == 0)
        {
            compiler_diagnostic(45, ctx, p_secondary_block->first_token, 0, "empty controlled statement found; is this the intent?");
        }
        ;
        p_selection_statement->secondary_block = p_secondary_block;
        if (p_selection_statement->first_token->type == 9034)
        {
            if (case_label_list_find_default(ctx, &p_selection_statement->label_list) == 0)
            {
                struct enum_specifier * p_enum_specifier;

                p_enum_specifier = 0;
                if (ctx->p_current_selection_statement && ctx->p_current_selection_statement->condition && ctx->p_current_selection_statement->condition->expression && ctx->p_current_selection_statement->condition->expression->type.enum_specifier)
                {
                    p_enum_specifier = get_complete_enum_specifier(ctx->p_current_selection_statement->condition->expression->type.enum_specifier);
                }
                if (p_enum_specifier)
                {
                    struct enumerator * p;

                    p = p_enum_specifier->enumerator_list.head;
                    while (p)
                    {
                        struct label * p_used;

                        p_used = case_label_list_find(ctx, &p_selection_statement->label_list, &p->value);
                        if (p_used == 0)
                        {
                            compiler_diagnostic(45, ctx, ctx->current, 0, "enumeration '%s' not handled in switch", p->token->lexeme);
                        }
                        p = p->next;
                    }
                }
            }
        }
        ctx->p_current_selection_statement = previous;
        if (is_if && ctx->current && ctx->current->type == 9011)
        {
            struct secondary_block * p_secondary_block2;

            p_selection_statement->else_token_opt = ctx->current;
            parser_match(ctx);
            ;
            p_secondary_block2 = secondary_block(ctx);
            if (p_secondary_block2 == 0)
            {
                goto __L0; /* throw */
            }
            p_selection_statement->else_secondary_block_opt = p_secondary_block2;
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_tk = previous_parser_token(ctx->current);
        if (p_tk == 0)
        {
            goto __L0; /* throw */
        }
        p_selection_statement->last_token = p_tk;
    }
    else __L0: /*catch*/ 
    {
        selection_statement_delete(p_selection_statement);
        p_selection_statement = 0;
    }
    scope_list_pop(&ctx->scopes);
    scope_destroy(&if_scope);
    return p_selection_statement;
}


struct defer_statement *defer_statement(struct parser_ctx * ctx)
{
    struct defer_statement * p_defer_statement;

    p_defer_statement = 0;
    if (1) /*try*/
    {
        struct defer_statement * p_previous_defer_statement_opt;
        struct secondary_block * p_secondary_block;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type != 9009)
        {
            goto __L0; /* throw */
        }
        p_defer_statement = calloc(1, 12);
        if (p_defer_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_defer_statement->first_token = ctx->current;
        parser_match(ctx);
        p_previous_defer_statement_opt = ctx->p_current_defer_statement_opt;
        ctx->p_current_defer_statement_opt = p_defer_statement;
        p_secondary_block = secondary_block(ctx);
        if (p_secondary_block == 0)
        {
            goto __L0; /* throw */
        }
        p_defer_statement->secondary_block = p_secondary_block;
        if (ctx->previous == 0)
        {
            goto __L0; /* throw */
        }
        p_defer_statement->last_token = ctx->previous;
        ctx->p_current_defer_statement_opt = p_previous_defer_statement_opt;
    }
    else __L0: /*catch*/ 
    {
        defer_statement_delete(p_defer_statement);
        p_defer_statement = 0;
    }
    return p_defer_statement;
}


void iteration_statement_delete(struct iteration_statement * p)
{
    if (p)
    {
        expression_delete(p->expression0);
        expression_delete(p->expression1);
        expression_delete(p->expression2);
        declaration_delete(p->declaration);
        secondary_block_delete(p->secondary_block);
        free(p);
    }
}


struct iteration_statement *iteration_statement(struct parser_ctx * ctx)
{
    struct iteration_statement * p_iteration_statement;

    p_iteration_statement = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_iteration_statement = calloc(1, 36);
        if (p_iteration_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_iteration_statement->first_token = ctx->current;
        if (ctx->current->type == 9008)
        {
            struct secondary_block * p_secondary_block;

            parser_match(ctx);
            p_secondary_block = secondary_block(ctx);
            if (p_secondary_block == 0)
            {
                goto __L0; /* throw */
            }
            p_iteration_statement->secondary_block = p_secondary_block;
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            p_iteration_statement->second_token = ctx->current;
            if (parser_match_tk(ctx, 9042) != 0)
            {
                goto __L0; /* throw */
            }
            if (parser_match_tk(ctx, 40) != 0)
            {
                goto __L0; /* throw */
            }
            p_iteration_statement->expression1 = expression(ctx, 2);
            if (parser_match_tk(ctx, 41) != 0)
            {
                goto __L0; /* throw */
            }
            if (parser_match_tk(ctx, 59) != 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            if (ctx->current->type == 9042)
            {
                struct secondary_block * p_secondary_block;

                parser_match(ctx);
                if (parser_match_tk(ctx, 40) != 0)
                {
                    goto __L0; /* throw */
                }
                p_iteration_statement->expression1 = expression(ctx, 2);
                if (parser_match_tk(ctx, 41) != 0)
                {
                    goto __L0; /* throw */
                }
                p_secondary_block = secondary_block(ctx);
                if (p_secondary_block == 0)
                {
                    goto __L0; /* throw */
                }
                p_iteration_statement->secondary_block = p_secondary_block;
            }
            else
            {
                if (ctx->current->type == 9015)
                {
                    parser_match(ctx);
                    if (parser_match_tk(ctx, 40) != 0)
                    {
                        goto __L0; /* throw */
                    }
                    if (first_of_declaration_specifier(ctx))
                    {
                        struct scope  for_scope;
                        struct secondary_block * p_secondary_block;

                        _cake_zmem(&for_scope, 36);
                        scope_list_push(&ctx->scopes, &for_scope);
                        p_iteration_statement->declaration = declaration(ctx, 0, 4096, 0);
                        if (ctx->current == 0)
                        {
                            unexpected_end_of_file(ctx);
                            scope_list_pop(&ctx->scopes);
                            scope_destroy(&for_scope);
                            goto __L0; /* throw */
                        }
                        if (ctx->current->type != 59)
                        {
                            p_iteration_statement->expression1 = expression(ctx, 2);
                            if (p_iteration_statement->expression1 == 0)
                            {
                                scope_list_pop(&ctx->scopes);
                                scope_destroy(&for_scope);
                                goto __L0; /* throw */
                            }
                        }
                        if (parser_match_tk(ctx, 59) != 0)
                        {
                            scope_list_pop(&ctx->scopes);
                            scope_destroy(&for_scope);
                            goto __L0; /* throw */
                        }
                        if (ctx->current == 0)
                        {
                            unexpected_end_of_file(ctx);
                            scope_list_pop(&ctx->scopes);
                            scope_destroy(&for_scope);
                            goto __L0; /* throw */
                        }
                        if (ctx->current->type != 41)
                        {
                            p_iteration_statement->expression2 = expression(ctx, 2);
                        }
                        if (parser_match_tk(ctx, 41) != 0)
                        {
                            scope_list_pop(&ctx->scopes);
                            scope_destroy(&for_scope);
                            goto __L0; /* throw */
                        }
                        p_secondary_block = secondary_block(ctx);
                        if (p_secondary_block == 0)
                        {
                            scope_list_pop(&ctx->scopes);
                            scope_destroy(&for_scope);
                            goto __L0; /* throw */
                        }
                        p_iteration_statement->secondary_block = p_secondary_block;
                        scope_list_pop(&ctx->scopes);
                        scope_destroy(&for_scope);
                    }
                    else
                    {
                        struct secondary_block * p_secondary_block;

                        if (ctx->current == 0)
                        {
                            unexpected_end_of_file(ctx);
                            goto __L0; /* throw */
                        }
                        if (ctx->current->type != 59)
                        {
                            p_iteration_statement->expression0 = expression(ctx, 2);
                        }
                        if (parser_match_tk(ctx, 59) != 0)
                        {
                            goto __L0; /* throw */
                        }
                        if (ctx->current == 0)
                        {
                            unexpected_end_of_file(ctx);
                            goto __L0; /* throw */
                        }
                        if (ctx->current->type != 59)
                        {
                            p_iteration_statement->expression1 = expression(ctx, 2);
                        }
                        if (parser_match_tk(ctx, 59) != 0)
                        {
                            goto __L0; /* throw */
                        }
                        if (ctx->current == 0)
                        {
                            unexpected_end_of_file(ctx);
                            goto __L0; /* throw */
                        }
                        if (ctx->current->type != 41)
                        {
                            p_iteration_statement->expression2 = expression(ctx, 2);
                        }
                        if (parser_match_tk(ctx, 41) != 0)
                        {
                            goto __L0; /* throw */
                        }
                        if (ctx->current == 0)
                        {
                            unexpected_end_of_file(ctx);
                            goto __L0; /* throw */
                        }
                        p_secondary_block = secondary_block(ctx);
                        if (p_secondary_block == 0)
                        {
                            goto __L0; /* throw */
                        }
                        p_iteration_statement->secondary_block = p_secondary_block;
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        iteration_statement_delete(p_iteration_statement);
        p_iteration_statement = 0;
    }
    return p_iteration_statement;
}


void jump_statement_delete(struct jump_statement * p)
{
    if (p)
    {
        expression_delete(p->expression_opt);
        free(p);
    }
}


struct jump_statement *jump_statement(struct parser_ctx * ctx)
{
    struct jump_statement * p_jump_statement;

    p_jump_statement = 0;
    if (1) /*try*/
    {
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_jump_statement = calloc(1, 28);
        if (p_jump_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_jump_statement->first_token = ctx->current;
        if (ctx->current->type == 9016)
        {
            struct label_list_item * p_label_list_item;

            parser_match(ctx);
            if (ctx->current == 0)
            {
                unexpected_end_of_file(ctx);
                goto __L0; /* throw */
            }
            p_label_list_item = label_list_find(&ctx->label_list, ctx->current->lexeme);
            if (p_label_list_item == 0)
            {
                struct label_list_item * p_label_list_item_new;

                p_label_list_item_new = calloc(1, 12);
                if (p_label_list_item_new)
                {
                    p_label_list_item_new->p_last_usage = ctx->current;
                    label_list_push(&ctx->label_list, p_label_list_item_new);
                }
            }
            else
            {
                p_label_list_item->p_last_usage = ctx->current;
            }
            p_jump_statement->label = ctx->current;
            if (parser_match_tk(ctx, 8996) != 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            if (ctx->current->type == 9005)
            {
                parser_match(ctx);
            }
            else
            {
                if (ctx->current->type == 9000)
                {
                    parser_match(ctx);
                }
                else
                {
                    if (ctx->current->type == 9037)
                    {
                        if (ctx->p_current_try_statement_opt == 0)
                        {
                            compiler_diagnostic(1110, ctx, ctx->current, 0, "throw statement not within try block");
                        }
                        else
                        {
                            p_jump_statement->label_id = ctx->p_current_try_statement_opt->catch_label_id;
                        }
                        parser_match(ctx);
                    }
                    else
                    {
                        if (ctx->current->type == 9027)
                        {
                            struct token * p_return_token;
                            struct type  return_type;

                            if (ctx->p_current_defer_statement_opt != 0)
                            {
                                compiler_diagnostic(1400, ctx, ctx->current, 0, "%s", "return cannot be used inside defer statement");
                                goto __L0; /* throw */
                            }
                            p_return_token = ctx->current;
                            parser_match(ctx);
                            if (ctx->current == 0)
                            {
                                unexpected_end_of_file(ctx);
                                goto __L0; /* throw */
                            }
                            return_type = get_function_return_type(&ctx->p_current_function_opt->type);
                            if (ctx->current->type != 59)
                            {
                                p_jump_statement->expression_opt = expression(ctx, 2);
                                if (p_jump_statement->expression_opt)
                                {
                                    if (type_is_void(&return_type))
                                    {
                                        char * func_name;

                                        func_name = ctx->p_current_function_opt->name_opt ? ctx->p_current_function_opt->name_opt->lexeme : "unnamed";
                                        compiler_diagnostic(1120, ctx, p_return_token, 0, "void function '%s' should not return a value", func_name);
                                    }
                                    else
                                    {
                                        check_assigment(ctx, &return_type, p_jump_statement->expression_opt, 0);
                                    }
                                }
                            }
                            else
                            {
                                if (!type_is_void(&return_type))
                                {
                                    char * func_name;

                                    func_name = ctx->p_current_function_opt->name_opt ? ctx->p_current_function_opt->name_opt->lexeme : "unnamed";
                                    compiler_diagnostic(1121, ctx, p_return_token, 0, "non void function '%s' should return a value", func_name);
                                }
                            }
                            type_destroy(&return_type);
                        }
                        else
                        {
                            ;
                        }
                    }
                }
            }
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_jump_statement->last_token = ctx->current;
        if (parser_match_tk(ctx, 59) != 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        jump_statement_delete(p_jump_statement);
        p_jump_statement = 0;
    }
    return p_jump_statement;
}


void expression_statement_delete(struct expression_statement * p)
{
    if (p)
    {
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence);
        expression_delete(p->expression_opt);
        free(p);
    }
}


struct expression_statement *expression_statement(struct parser_ctx * ctx, unsigned char  ignore_semicolon, struct attribute_specifier_sequence * p_attribute_specifier_sequence)
{
    struct expression_statement * p_expression_statement;

    p_expression_statement = calloc(1, 8);
    if (1) /*try*/
    {
        struct diagnostic_id_stack  stack;
        struct diagnostic_id_stack * p_diagnostic_id_stack;

        if (p_expression_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_expression_statement->p_attribute_specifier_sequence = p_attribute_specifier_sequence;
        p_attribute_specifier_sequence = 0;
        _cake_zmem(&stack, 44);
        p_diagnostic_id_stack = build_diagnostic_id_stack(ctx, p_expression_statement->p_attribute_specifier_sequence, &stack, 0);
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        if (ctx->current->type != 59)
        {
            p_expression_statement->expression_opt = expression(ctx, 2);
            warn_unrecognized_warnings(ctx, &stack, p_expression_statement->p_attribute_specifier_sequence, p_diagnostic_id_stack);
            if (p_expression_statement->expression_opt == 0)
            {
                goto __L0; /* throw */
            }
        }
        ctx->p_diagnostic_id_stack = p_diagnostic_id_stack;
        if (!ignore_semicolon && parser_match_tk(ctx, 59) != 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        expression_statement_delete(p_expression_statement);
        p_expression_statement = 0;
    }
    return p_expression_statement;
}


void declaration_list_add(struct declaration_list * list, struct declaration * p_declaration)
{
    if (list->head == 0)
    {
        list->head = p_declaration;
    }
    else
    {
        ;
        ;
        list->tail->next = p_declaration;
    }
    list->tail = p_declaration;
}


void simple_declaration_delete(struct simple_declaration * p_simple_declaration)
{
    if (p_simple_declaration)
    {
        declaration_specifiers_delete(p_simple_declaration->p_declaration_specifiers);
        init_declarator_list_destroy(&p_simple_declaration->init_declarator_list);
        attribute_specifier_sequence_delete(p_simple_declaration->p_attribute_specifier_sequence);
        free(p_simple_declaration);
    }
}


void condition_delete(struct condition * p_condition)
{
    if (p_condition)
    {
        init_declarator_delete(p_condition->p_init_declarator);
        expression_delete(p_condition->expression);
        attribute_specifier_sequence_delete(p_condition->p_attribute_specifier_sequence);
        declaration_specifiers_delete(p_condition->p_declaration_specifiers);
        free(p_condition);
    }
}


static struct attribute_specifier_sequence *attribute_specifier_sequence(struct parser_ctx * ctx);

struct condition *condition(struct parser_ctx * ctx)
{
    struct condition * p_condition;

    p_condition = 0;
    if (1) /*try*/
    {
        struct token * previous;

        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        p_condition = calloc(1, 24);
        if (p_condition == 0)
        {
            goto __L0; /* throw */
        }
        p_condition->first_token = ctx->current;
        if (first_of_declaration_specifier(ctx))
        {
            struct init_declarator * p_init_declarator;

            p_condition->p_attribute_specifier_sequence = attribute_specifier_sequence(ctx);
            p_condition->p_declaration_specifiers = declaration_specifiers(ctx, 4096);
            if (p_condition->p_declaration_specifiers == 0)
            {
                goto __L0; /* throw */
            }
            p_init_declarator = init_declarator(ctx, p_condition->p_declaration_specifiers);
            if (p_init_declarator == 0)
            {
                goto __L0; /* throw */
            }
            p_condition->p_init_declarator = p_init_declarator;
        }
        else
        {
            p_condition->expression = expression(ctx, 2);
            if (p_condition->expression == 0)
            {
                goto __L0; /* throw */
            }
        }
        if (ctx->current == 0)
        {
            unexpected_end_of_file(ctx);
            goto __L0; /* throw */
        }
        previous = previous_parser_token(ctx->current);
        if (previous)
        {
            p_condition->last_token = previous;
        }
    }
    else __L0: /*catch*/ 
    {
        condition_delete(p_condition);
        p_condition = 0;
    }
    return p_condition;
}



static struct attribute_specifier_sequence *attribute_specifier_sequence(struct parser_ctx * ctx)
{
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;

    p_attribute_specifier_sequence = 0;
    if (1) /*try*/
    {
        p_attribute_specifier_sequence = calloc(1, 24);
        if (p_attribute_specifier_sequence == 0)
        {
            goto __L0; /* throw */
        }
        while (first_of_attribute_specifier(ctx))
        {
            struct attribute_specifier * p_attribute_specifier;

            p_attribute_specifier = attribute_specifier(ctx);
            if (p_attribute_specifier == 0)
            {
                goto __L0; /* throw */
            }
            attribute_specifier_sequence_add(p_attribute_specifier_sequence, p_attribute_specifier);
        }
    }
    else __L0: /*catch*/ 
    {
        attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
        p_attribute_specifier_sequence = 0;
    }
    return p_attribute_specifier_sequence;
}
void init_statement_delete(struct init_statement * p_init_statement)
{
    if (p_init_statement)
    {
        expression_statement_delete(p_init_statement->p_expression_statement);
        simple_declaration_delete(p_init_statement->p_simple_declaration);
        free(p_init_statement);
    }
}


struct init_statement *init_statement(struct parser_ctx * ctx, unsigned char  ignore_semicolon)
{
    struct init_statement * p_init_statement;

    p_init_statement = 0;
    if (1) /*try*/
    {
        struct attribute_specifier_sequence * p_attribute_specifier_sequence;

        p_init_statement = calloc(1, 8);
        if (p_init_statement == 0)
        {
            goto __L0; /* throw */
        }
        p_attribute_specifier_sequence = attribute_specifier_sequence_opt(ctx);
        if (first_of_declaration_specifier(ctx))
        {
            p_init_statement->p_simple_declaration = simple_declaration(ctx, ignore_semicolon, p_attribute_specifier_sequence);
            p_attribute_specifier_sequence = 0;
        }
        else
        {
            p_init_statement->p_expression_statement = expression_statement(ctx, ignore_semicolon, p_attribute_specifier_sequence);
            p_attribute_specifier_sequence = 0;
        }
    }
    else __L0: /*catch*/ 
    {
        init_statement_delete(p_init_statement);
        p_init_statement = 0;
    }
    return p_init_statement;
}


void declaration_delete(struct declaration * p)
{
    if (p)
    {
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence);
        static_assert_declaration_delete(p->static_assert_declaration);
        declaration_specifiers_delete(p->declaration_specifiers);
        compound_statement_delete(p->function_body);
        pragma_declaration_delete(p->pragma_declaration);
        init_declarator_list_destroy(&p->init_declarator_list);
        ;
        free(p);
    }
}


void declaration_list_destroy(struct declaration_list * list)
{
    struct declaration * p;

    p = list->head;
    while (p)
    {
        struct declaration * next;

        next = p->next;
        p->next = 0;
        declaration_delete(p);
        p = next;
    }
}


struct declaration *external_declaration(struct parser_ctx * ctx)
{
    return function_definition_or_declaration(ctx);
}


static void check_unused_static_declarators(struct parser_ctx * ctx, struct declaration_list * declaration_list);

struct declaration_list translation_unit(struct parser_ctx * ctx, unsigned char * berror)
{
    struct declaration_list  declaration_list;

    *berror = 0;
    _cake_zmem(&declaration_list, 8);
    if (1) /*try*/
    {
        while (ctx->current != 0)
        {
            struct declaration * p;

            if (ctx->current->type == 9064)
            {
                struct asm_statement * p3;

                p3 = gcc_asm(ctx, 1);
                asm_statement_delete(p3);
            }
            p = external_declaration(ctx);
            if (p == 0)
            {
                goto __L0; /* throw */
            }
            declaration_list_add(&declaration_list, p);
        }
        check_unused_static_declarators(ctx, &declaration_list);
    }
    else __L0: /*catch*/ 
    {
        *berror = 1;
    }
    return declaration_list;
}



static void check_unused_static_declarators(struct parser_ctx * ctx, struct declaration_list * declaration_list)
{
    struct declaration * p;

    p = declaration_list->head;
    while (p)
    {
        if (p->declaration_specifiers && p->declaration_specifiers->storage_class_specifier_flags & 4)
        {
            if (p->init_declarator_list.head && p->init_declarator_list.head->p_declarator)
            {
                struct map_entry * p_entry;

                p_entry = find_variables(ctx, p->init_declarator_list.head->p_declarator->name_opt->lexeme, 0);
                if (p_entry && (p_entry->type == 4 || p_entry->type == 5))
                {
                    struct declarator * p_declarator_local;
                    int num_uses;

                    p_declarator_local = 0;
                    if (p_entry->type == 5)
                    {
                        p_declarator_local = p_entry->data.p_init_declarator->p_declarator;
                    }
                    else
                    {
                        p_declarator_local = p_entry->data.p_declarator;
                    }
                    num_uses = p_declarator_local->num_uses;
                    if (num_uses == 0)
                    {
                        if (type_is_function(&p->init_declarator_list.head->p_declarator->type))
                        {
                            compiler_diagnostic(57, ctx, p->init_declarator_list.head->p_declarator->name_opt, 0, "warning: static function '%s' not used.", p->init_declarator_list.head->p_declarator->name_opt->lexeme);
                        }
                        else
                        {
                            compiler_diagnostic(2, ctx, p->init_declarator_list.head->p_declarator->name_opt, 0, "warning: '%s' not used.", p->init_declarator_list.head->p_declarator->name_opt->lexeme);
                        }
                    }
                }
            }
        }
        p = p->next;
    }
}
struct label_list_item *label_list_find(struct label_list * list, char * label_name)
{
    struct label_list_item * item;

    item = list->head;
    while (item)
    {
        if (item->p_defined && strcmp(item->p_defined->lexeme, label_name) == 0)
        {
            return item;
        }
        else
        {
            if (item->p_last_usage && strcmp(item->p_last_usage->lexeme, label_name) == 0)
            {
                return item;
            }
        }
        item = item->next;
    }
    return 0;
}


void label_list_swap(struct label_list * a, struct label_list * b)
{
    struct label_list  temp;

    temp = *a;
    *a = *b;
    *b = temp;
}


void label_list_clear(struct label_list * list)
{
    struct label_list_item * item;

    item = list->head;
    while (item)
    {
        struct label_list_item * next;

        next = item->next;
        item->next = 0;
        free(item);
        item = next;
    }
    list->head = 0;
    list->tail = 0;
}


void label_list_push(struct label_list * list, struct label_list_item * pitem)
{
    if (list->head == 0)
    {
        list->head = pitem;
    }
    else
    {
        ;
        ;
        list->tail->next = pitem;
    }
    list->tail = pitem;
}


void check_labels(struct parser_ctx * ctx)
{
    struct label_list_item * item;

    item = ctx->label_list.head;
    while (item)
    {
        if (item->p_defined == 0 && item->p_last_usage != 0)
        {
            compiler_diagnostic(1430, ctx, item->p_last_usage, 0, "label '%s' used but not defined", item->p_last_usage->lexeme);
        }
        else
        {
            if (item->p_defined != 0 && item->p_last_usage == 0)
            {
                compiler_diagnostic(55, ctx, item->p_defined, 0, "label '%s' defined but not used", item->p_defined->lexeme);
            }
        }
        item = item->next;
    }
}


struct compound_statement *function_body(struct parser_ctx * ctx)
{
    struct try_statement * p_current_try_statement_opt;
    int label_id;
    struct defer_statement * p_current_defer_statement_opt;
    struct selection_statement * p_current_selection_statement;
    struct label_list  label_list;
    struct compound_statement * p_compound_statement;

    p_current_try_statement_opt = ctx->p_current_try_statement_opt;
    ctx->p_current_try_statement_opt = 0;
    label_id = ctx->label_id;
    ctx->label_id = 0;
    p_current_defer_statement_opt = ctx->p_current_defer_statement_opt;
    ctx->p_current_defer_statement_opt = 0;
    p_current_selection_statement = ctx->p_current_selection_statement;
    ctx->p_current_selection_statement = 0;
    _cake_zmem(&label_list, 8);
    label_list_swap(&label_list, &ctx->label_list);
    p_compound_statement = compound_statement(ctx);
    if (p_compound_statement)
    {
        check_labels(ctx);
    }
    label_list_swap(&label_list, &ctx->label_list);
    ctx->label_id = label_id;
    ctx->p_current_try_statement_opt = p_current_try_statement_opt;
    ctx->p_current_defer_statement_opt = p_current_defer_statement_opt;
    ctx->p_current_selection_statement = p_current_selection_statement;
    label_list_clear(&label_list);
    return p_compound_statement;
}


char *target_get_builtins(int e);

struct declaration_list parse(struct parser_ctx * ctx, struct token_list * list, unsigned char * berror)
{
    struct declaration_list  l;
    struct scope  file_scope;
    struct preprocessor_ctx  prectx;
    struct tokenizer_ctx  tctx;
    struct token_list  builtin_tokens;
    struct token_list  built;

    *berror = 0;
    _cake_zmem(&l, 8);
    _cake_zmem(&file_scope, 36);
    _cake_zmem(&prectx, 984);
    prectx.options = ctx->options;
    prectx.macros.capacity = 1000;
    _cake_zmem(&tctx, 928);
    _cake_zmem(&builtin_tokens, 8);
    _cake_zmem(&built, 8);
    if (1) /*try*/
    {
        char * builtin;
        unsigned char  local_error;

        scope_list_push(&ctx->scopes, &file_scope);
        builtin = target_get_builtins(ctx->options.target);
        if (builtin == 0)
        {
            goto __L0; /* throw */
        }
        builtin_tokens = tokenizer(&tctx, builtin, "builtins", 0, 0);
        built = preprocessor(&prectx, &builtin_tokens, 0);
        ctx->input_list = built;
        ctx->current = ctx->input_list.head;
        parser_skip_blanks(ctx);
        local_error = 0;
        l = translation_unit(ctx, &local_error);
        if (local_error)
        {
            goto __L0; /* throw */
        }
        ctx->input_list = *list;
        ctx->current = ctx->input_list.head;
        parser_skip_blanks(ctx);
        l = translation_unit(ctx, &local_error);
        if (local_error)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        *berror = 1;
    }
    scope_destroy(&file_scope);
    return l;
}


struct ast get_ast(struct options * options, char * filename, char * source, struct report * report)
{
    struct ast  ast;
    struct tokenizer_ctx  tctx;
    struct token_list  list;
    struct preprocessor_ctx  prectx;
    struct parser_ctx  ctx;

    _cake_zmem(&ast, 16);
    _cake_zmem(&tctx, 928);
    list = tokenizer(&tctx, source, filename, 0, 0);
    _cake_zmem(&prectx, 984);
    _cake_zmem(&ctx, 1004);
    ctx.p_report = report;
    if (1) /*try*/
    {
        unsigned char  berror;

        prectx.options = *options;
        prectx.macros.capacity = 5000;
        add_standard_macros(&prectx, options->target);
        ast.token_list = preprocessor(&prectx, &list, 0);
        if (prectx.n_errors != 0)
        {
            goto __L0; /* throw */
        }
        ctx.options = *options;
        berror = 0;
        ast.declaration_list = parse(&ctx, &ast.token_list, &berror);
        if (berror)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
    }
    parser_ctx_destroy(&ctx);
    token_list_destroy(&list);
    preprocessor_ctx_destroy(&prectx);
    return ast;
}


void ast_destroy(struct ast * ast)
{
    token_list_destroy(&ast->token_list);
    declaration_list_destroy(&ast->declaration_list);
}


static unsigned char is_snake_case(char * text);
static unsigned char is_pascal_case(char * text);

void naming_convention_struct_tag(struct parser_ctx * ctx, struct token * token)
{
    if (!is_diagnostic_enabled(&ctx->options, 11) || token->level != 0)
    {
        return;
    }
    if (ctx->options.style == 0)
    {
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic(11, ctx, token, 0, "use snake_case for struct/union tags");
        }
    }
    else
    {
        if (ctx->options.style == 6)
        {
            if (!is_pascal_case(token->lexeme))
            {
                compiler_diagnostic(11, ctx, token, 0, "use camelCase for struct/union tags");
            }
        }
    }
}



static unsigned char is_snake_case(char * text)
{
    if (!(*text >= 97 && *text <= 122))
    {
        return 0;
    }
    while (*text)
    {
        if ((*text >= 97 && *text <= 122) || *text == 95 || (*text >= 48 && *text <= 57))
        {
        }
        else
        {
            return 0;
        }
        text++;
    }
    return 1;
}

static unsigned char is_pascal_case(char * text)
{
    if (!(text[0] >= 65 && text[0] <= 90))
    {
        return 0;
    }
    while (*text)
    {
        if ((*text >= 97 && *text <= 122) || (*text >= 65 && *text <= 90) || (*text >= 48 && *text <= 57))
        {
        }
        else
        {
            return 0;
        }
        text++;
    }
    return 1;
}
void naming_convention_enum_tag(struct parser_ctx * ctx, struct token * token)
{
    if (!is_diagnostic_enabled(&ctx->options, 11) || token->level != 0)
    {
        return;
    }
    if (ctx->options.style == 0)
    {
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic(11, ctx, token, 0, "use snake_case for enum tags");
        }
    }
    else
    {
        if (ctx->options.style == 6)
        {
            if (!is_pascal_case(token->lexeme))
            {
                compiler_diagnostic(11, ctx, token, 0, "use PascalCase for enum tags");
            }
        }
    }
}


void naming_convention_function(struct parser_ctx * ctx, struct token * token)
{
    if (!is_diagnostic_enabled(&ctx->options, 11) || token->level != 0)
    {
        return;
    }
    if (ctx->options.style == 0)
    {
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic(11, ctx, token, 0, "use snake_case for functions");
        }
    }
    else
    {
        if (ctx->options.style == 6)
        {
            if (!is_pascal_case(token->lexeme))
            {
                compiler_diagnostic(11, ctx, token, 0, "use PascalCase for functions");
            }
        }
    }
}


void naming_convention_global_var(struct parser_ctx * ctx, struct token * token, struct type * type, int storage)
{
    if (!is_diagnostic_enabled(&ctx->options, 11) || token->level != 0)
    {
        return;
    }
    if (!type_is_function_or_function_pointer(type))
    {
        if (storage & 4)
        {
            if (type_is_const(type))
            {
            }
            else
            {
                if (token->lexeme[0] != 115 || token->lexeme[1] != 95)
                {
                    compiler_diagnostic(11, ctx, token, 0, "use prefix s_ for static global variables");
                }
            }
        }
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic(11, ctx, token, 0, "use snake_case global variables");
        }
    }
}


static unsigned char is_camel_case(char * text);

void naming_convention_local_var(struct parser_ctx * ctx, struct token * token, struct type * type)
{
    if (!is_diagnostic_enabled(&ctx->options, 11) || token->level != 0)
    {
        return;
    }
    if (ctx->options.style == 0)
    {
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic(11, ctx, token, 0, "use snake_case for local variables");
        }
    }
    else
    {
        if (ctx->options.style == 6)
        {
            if (!is_camel_case(token->lexeme))
            {
                compiler_diagnostic(11, ctx, token, 0, "use camelCase for local variables");
            }
        }
    }
}



static unsigned char is_camel_case(char * text)
{
    if (!(*text >= 97 && *text <= 122))
    {
        return 0;
    }
    while (*text)
    {
        if ((*text >= 97 && *text <= 122) || (*text >= 65 && *text <= 90) || (*text >= 48 && *text <= 57))
        {
        }
        else
        {
            return 0;
        }
        text++;
    }
    return 1;
}
static unsigned char is_all_upper(char * text);
int __cdecl toupper(int _C);

void naming_convention_enumerator(struct parser_ctx * ctx, struct token * token)
{
    if (!is_diagnostic_enabled(&ctx->options, 11) || token->level != 0)
    {
        return;
    }
    if (!is_all_upper(token->lexeme))
    {
        compiler_diagnostic(11, ctx, token, 0, "use UPPERCASE for enumerators");
    }
}



static unsigned char is_all_upper(char * text)
{
    char * p;

    p = text;
    while (*p)
    {
        if (*p != toupper(*p))
        {
            return 0;
        }
        p++;
    }
    return 1;
}
void naming_convention_struct_member(struct parser_ctx * ctx, struct token * token, struct type * type)
{
    if (!is_diagnostic_enabled(&ctx->options, 11) || token->level != 0)
    {
        return;
    }
    if (!is_snake_case(token->lexeme))
    {
        compiler_diagnostic(11, ctx, token, 0, "use snake_case for struct members");
    }
}


void naming_convention_parameter(struct parser_ctx * ctx, struct token * token, struct type * type)
{
    if (!is_diagnostic_enabled(&ctx->options, 11) || token->level != 0)
    {
        return;
    }
    if (!is_snake_case(token->lexeme))
    {
        compiler_diagnostic(11, ctx, token, 0, "use snake_case for arguments");
    }
}


static int braced_initializer_new(struct parser_ctx * ctx, struct type * p_current_object_type, struct object * current_object, struct braced_initializer * braced_initializer, unsigned char  is_constant, unsigned char  requires_constant_initialization);
static struct initializer_list_item *find_innner_initializer_list_item(struct braced_initializer * braced_initializer);
unsigned char type_is_char(struct type * p_type);
static struct object *find_designated_subobject(struct parser_ctx * ctx, struct type * p_current_object_type, struct object * current_object, struct designator * p_designator, unsigned char  is_constant, struct type * p_type_out2, unsigned char  not_error, int target);
static struct object *find_next_subobject(struct type * p_top_object_not_used, struct object * current_object, struct object * it, struct type * p_type_out, unsigned char * sub_object_of_union);
static struct object *find_next_subobject_old(struct type * p_top_object_not_used, struct object * current_object, struct object * it, struct type * p_type_out, unsigned char * sub_object_of_union);
void type_clear(struct type * a);
static struct object *find_first_subobject(struct type * p_type_not_used, struct object * p_object, struct type * p_type_out, unsigned char * sub_object_of_union);
static struct object *find_first_subobject_old(struct type * p_type_not_used, struct object * p_object, struct type * p_type_out, unsigned char * sub_object_of_union);
static struct object *find_last_suboject_of_suboject(struct type * p_type_not_used, struct object * p_object, struct type * p_type_out);
static struct object *find_last_suboject_of_suboject_old(struct type * p_type_not_used, struct object * p_object, struct type * p_type_out);
unsigned char type_is_array_of_char(struct type * p_type);

int initializer_init_new(struct parser_ctx * ctx, struct type * p_type, struct object * object, struct initializer * initializer, unsigned char  is_constant, unsigned char  requires_constant_initialization)
{
    if (1) /*try*/
    {
        if (initializer->assignment_expression != 0)
        {
            if (object_set(ctx, object, initializer->assignment_expression, &initializer->assignment_expression->object, is_constant, requires_constant_initialization) != 0)
            {
                goto __L0; /* throw */
            }
        }
        else
        {
            if (initializer->braced_initializer)
            {
                if (braced_initializer_new(ctx, p_type, object, initializer->braced_initializer, is_constant, requires_constant_initialization) != 0)
                {
                    goto __L0; /* throw */
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
        return 1;
    }
    return 0;
}



static struct initializer_list_item *find_innner_initializer_list_item(struct braced_initializer * braced_initializer)
{
    struct initializer_list_item * p_initializer_list_item;

    ;
    p_initializer_list_item = braced_initializer->initializer_list->head;
    while (p_initializer_list_item->initializer->braced_initializer)
    {
        p_initializer_list_item = p_initializer_list_item->initializer->braced_initializer->initializer_list->head;
        if (p_initializer_list_item == 0)
        {
            ;
            return 0;
        }
        if (p_initializer_list_item->next == 0)
        {
            return p_initializer_list_item;
        }
        p_initializer_list_item = p_initializer_list_item->next;
    }
    return p_initializer_list_item;
}

static struct object *find_designated_subobject(struct parser_ctx * ctx, struct type * p_current_object_type, struct object * current_object, struct designator * p_designator, unsigned char  is_constant, struct type * p_type_out2, unsigned char  not_error, int target)
{
    if (1) /*try*/
    {
        if (type_is_struct_or_union(p_current_object_type))
        {
            struct struct_or_union_specifier * p_struct_or_union_specifier;
            struct member_declaration * p_member_declaration;
            struct member_declarator * p_member_declarator;
            char * name;
            struct object * p_member_object;

            ;
            p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_current_object_type->struct_or_union_specifier);
            if (p_struct_or_union_specifier == 0)
            {
                goto __L0; /* throw */
            }
            p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
            p_member_declarator = 0;
            name = p_designator->token->lexeme;
            p_member_object = current_object->members.head;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_member_declarator->declarator->name_opt && strcmp(p_member_declarator->declarator->name_opt->lexeme, name) == 0)
                            {
                                if (p_designator->next != 0)
                                {
                                    return find_designated_subobject(ctx, &p_member_declarator->declarator->type, p_member_object, p_designator->next, is_constant, p_type_out2, 0, ctx->options.target);
                                }
                                else
                                {
                                    struct type  t;

                                    t = type_dup(&p_member_declarator->declarator->type);
                                    type_swap(&t, p_type_out2);
                                    type_destroy(&t);
                                    return p_member_object;
                                }
                            }
                        }
                        p_member_object = p_member_object->next;
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list)
                    {
                        if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                        {
                            struct struct_or_union_specifier * p_complete;

                            p_complete = get_complete_struct_or_union_specifier(p_member_declaration->specifier_qualifier_list->struct_or_union_specifier);
                            if (p_complete)
                            {
                                struct type  t;
                                struct object * p;

                                _cake_zmem(&t, 68);
                                t.category = 0;
                                t.struct_or_union_specifier = p_complete;
                                t.type_specifier_flags = 32768;
                                p = find_designated_subobject(ctx, &t, p_member_object, p_designator, is_constant, p_type_out2, 1, ctx->options.target);
                                if (p)
                                {
                                    type_destroy(&t);
                                    return p;
                                }
                                p_member_object = p_member_object->next;
                                type_destroy(&t);
                            }
                        }
                    }
                    else
                    {
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            if (!not_error)
            {
                compiler_diagnostic(720, ctx, p_designator->token, 0, "member '%s' not found in '%s'", name, p_struct_or_union_specifier->tag_name);
            }
            return 0;
        }
        else
        {
            if (type_is_array(p_current_object_type))
            {
                unsigned char  compute_array_size;
                long long index;
                long long max_index;
                struct type  array_item_type;
                struct object * member_obj;

                compute_array_size = p_current_object_type->array_num_elements_expression == 0;
                index = -1;
                max_index = -1;
                array_item_type = get_array_item_type(p_current_object_type);
                member_obj = current_object->members.head;
                if (p_designator->constant_expression_opt)
                {
                    index = object_to_signed_long_long(&p_designator->constant_expression_opt->object);
                    if (index > max_index)
                    {
                        max_index = index;
                        if (compute_array_size)
                        {
                            member_obj = object_extend_array_to_index(&array_item_type, current_object, (unsigned int)max_index, is_constant, target);
                        }
                    }
                    member_obj = object_get_member(current_object, (unsigned int)index);
                    if (member_obj == 0)
                    {
                        if (index < 0)
                        {
                            compiler_diagnostic(720, ctx, p_designator->constant_expression_opt->first_token, 0, "array designator value '%d' is negative", index);
                        }
                        else
                        {
                            if (index > (int)p_current_object_type->num_of_elements)
                            {
                                compiler_diagnostic(720, ctx, p_designator->constant_expression_opt->first_token, 0, "array index '%d' in initializer exceeds array bounds", index);
                            }
                        }
                        type_destroy(&array_item_type);
                        return 0;
                    }
                    if (p_designator->next != 0)
                    {
                        struct object * p;

                        p = find_designated_subobject(ctx, &array_item_type, member_obj, p_designator->next, is_constant, p_type_out2, 0, ctx->options.target);
                        type_destroy(&array_item_type);
                        return p;
                    }
                    else
                    {
                        type_swap(p_type_out2, &array_item_type);
                        type_destroy(&array_item_type);
                    }
                    return member_obj;
                }
                else
                {
                }
                type_destroy(&array_item_type);
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return 0;
}

static struct object *find_next_subobject_old(struct type * p_top_object_not_used, struct object * current_object, struct object * it, struct type * p_type_out, unsigned char * sub_object_of_union)
{
    type_clear(p_type_out);
    if (it == 0)
    {
        return 0;
    }
    if (it->members.head)
    {
        struct type  t;

        *sub_object_of_union = type_is_union(&it->type);
        it = it->members.head;
        t = type_dup(&it->type);
        type_swap(&t, p_type_out);
        type_destroy(&t);
        return it;
    }
    for (; ; )
    {
        struct object * next;

        if (it == 0)
        {
            break;
        }
        next = it->next;
        if (next != 0)
        {
            if (it->parent)
            {
                *sub_object_of_union = type_is_union(&it->parent->type);
            }
            it = next;
            break;
        }
        it = it->parent;
    }
    if (it != 0)
    {
        struct type  t;

        t = type_dup(&it->type);
        type_swap(&t, p_type_out);
        type_destroy(&t);
    }
    return it;
}

static struct object *find_next_subobject(struct type * p_top_object_not_used, struct object * current_object, struct object * it, struct type * p_type_out, unsigned char * sub_object_of_union)
{
    return find_next_subobject_old(p_top_object_not_used, current_object, it, p_type_out, sub_object_of_union);
}

static struct object *find_first_subobject_old(struct type * p_type_not_used, struct object * p_object, struct type * p_type_out, unsigned char * sub_object_of_union)
{
    struct type  t;

    p_object = (struct object *)object_get_referenced(p_object);
    if (p_object->members.head == 0)
    {
        struct type  t;

        *sub_object_of_union = 0;
        t = type_dup(&p_object->type);
        type_swap(&t, p_type_out);
        type_destroy(&t);
        return p_object;
    }
    *sub_object_of_union = type_is_union(&p_object->type);
    t = type_dup(&p_object->members.head->type);
    type_swap(&t, p_type_out);
    type_destroy(&t);
    return p_object->members.head;
}

static struct object *find_first_subobject(struct type * p_type_not_used, struct object * p_object, struct type * p_type_out, unsigned char * sub_object_of_union)
{
    return find_first_subobject_old(p_type_not_used, p_object, p_type_out, sub_object_of_union);
}

static struct object *find_last_suboject_of_suboject_old(struct type * p_type_not_used, struct object * p_object, struct type * p_type_out)
{
    struct object * it;
    struct type  t;

    p_object = (struct object *)object_get_referenced(p_object);
    if (p_object->members.head == 0)
    {
        struct type  t;

        t = type_dup(&p_object->type);
        type_swap(&t, p_type_out);
        type_destroy(&t);
        return p_object;
    }
    it = p_object->members.head;
    while (it)
    {
        if (it->next == 0)
        {
            return find_last_suboject_of_suboject_old(p_type_not_used, it, p_type_out);
        }
        it = it->next;
    }
    t = type_dup(&p_object->type);
    type_swap(&t, p_type_out);
    type_destroy(&t);
    return p_object;
}

static struct object *find_last_suboject_of_suboject(struct type * p_type_not_used, struct object * p_object, struct type * p_type_out)
{
    return find_last_suboject_of_suboject_old(p_type_not_used, p_object, p_type_out);
}

static int braced_initializer_new(struct parser_ctx * ctx, struct type * p_current_object_type, struct object * current_object, struct braced_initializer * braced_initializer, unsigned char  is_constant, unsigned char  requires_constant_initialization)
{
    if (1) /*try*/
    {
        struct object * parent_copy;
        struct initializer_list_item * p_initializer_list_item;
        int array_to_expand_index;
        int array_to_expand_max_index;
        unsigned char  compute_array_size;
        struct type  array_item_type;
        struct object * p_subobject;

        if (braced_initializer->initializer_list == 0)
        {
            object_default_initialization(current_object, is_constant);
            return 0;
        }
        if (!type_is_union(p_current_object_type))
        {
            object_default_initialization(current_object, is_constant);
        }
        if (type_is_scalar(p_current_object_type))
        {
            struct initializer_list_item * p_initializer_list_item;

            p_initializer_list_item = find_innner_initializer_list_item(braced_initializer);
            if (p_initializer_list_item == 0)
            {
                return 0;
            }
            if (p_initializer_list_item->initializer->assignment_expression != 0)
            {
                if (object_set(ctx, current_object, p_initializer_list_item->initializer->assignment_expression, &p_initializer_list_item->initializer->assignment_expression->object, is_constant, requires_constant_initialization) != 0)
                {
                    goto __L0; /* throw */
                }
            }
            p_initializer_list_item = p_initializer_list_item->next;
            if (p_initializer_list_item != 0)
            {
                compiler_diagnostic(62, ctx, p_initializer_list_item->initializer->first_token, 0, "warning: excess elements in initializer");
            }
            return 0;
        }
        parent_copy = current_object->parent;
        current_object->parent = 0;
        p_initializer_list_item = braced_initializer->initializer_list->head;
        array_to_expand_index = -1;
        array_to_expand_max_index = -1;
        compute_array_size = 0;
        _cake_zmem(&array_item_type, 68);
        if (type_is_array(p_current_object_type))
        {
            array_item_type = get_array_item_type(p_current_object_type);
            compute_array_size = p_current_object_type->array_num_elements_expression == 0;
            if (type_is_char(&array_item_type))
            {
                struct initializer_list_item * p_initializer_list_item2;

                p_initializer_list_item2 = find_innner_initializer_list_item(braced_initializer);
                if (p_initializer_list_item2 == 0)
                {
                    type_destroy(&array_item_type);
                    return 0;
                }
                if (p_initializer_list_item2->initializer->assignment_expression != 0)
                {
                    if (p_initializer_list_item2->initializer->assignment_expression->expression_type == 3)
                    {
                        unsigned int num_of_elements;

                        num_of_elements = p_initializer_list_item2->initializer->assignment_expression->type.num_of_elements;
                        if (compute_array_size)
                        {
                            object_extend_array_to_index(&array_item_type, current_object, num_of_elements - 1, is_constant, ctx->options.target);
                        }
                        if (object_set(ctx, current_object, p_initializer_list_item2->initializer->assignment_expression, &p_initializer_list_item2->initializer->assignment_expression->object, is_constant, requires_constant_initialization) != 0)
                        {
                            type_destroy(&array_item_type);
                            goto __L0; /* throw */
                        }
                        p_current_object_type->num_of_elements = num_of_elements;
                        type_destroy(&array_item_type);
                        return 0;
                    }
                }
            }
        }
        p_subobject = 0;
        for (; ; )
        {
            unsigned char  is_subobject_of_union;
            struct type  subobject_type;

            is_subobject_of_union = 0;
            _cake_zmem(&subobject_type, 68);
            if (p_initializer_list_item == 0)
            {
                break;
            }
            if (p_initializer_list_item->designation)
            {
                if (compute_array_size)
                {
                    array_to_expand_index = (int)object_to_signed_long_long(&p_initializer_list_item->designation->designator_list->head->constant_expression_opt->object);
                    if (array_to_expand_index > array_to_expand_max_index)
                    {
                        array_to_expand_max_index = array_to_expand_index;
                    }
                    object_extend_array_to_index(&array_item_type, current_object, array_to_expand_max_index, is_constant, ctx->options.target);
                }
                is_subobject_of_union = type_is_union(&subobject_type);
                p_subobject = find_designated_subobject(ctx, p_current_object_type, current_object, p_initializer_list_item->designation->designator_list->head, is_constant, &subobject_type, 0, ctx->options.target);
                if (p_subobject == 0)
                {
                    p_initializer_list_item = p_initializer_list_item->next;
                    type_destroy(&subobject_type);
                    break;
                }
            }
            else
            {
                if (compute_array_size)
                {
                    struct object * po;

                    po = find_next_subobject(p_current_object_type, current_object, p_subobject, &subobject_type, &is_subobject_of_union);
                    if (po == 0)
                    {
                        array_to_expand_index++;
                        if (array_to_expand_index > array_to_expand_max_index)
                        {
                            array_to_expand_max_index = array_to_expand_index;
                        }
                        object_extend_array_to_index(&array_item_type, current_object, array_to_expand_max_index, is_constant, ctx->options.target);
                    }
                }
                if (p_subobject == 0)
                {
                    p_subobject = find_first_subobject(p_current_object_type, current_object, &subobject_type, &is_subobject_of_union);
                }
                else
                {
                    p_subobject = find_next_subobject(p_current_object_type, current_object, p_subobject, &subobject_type, &is_subobject_of_union);
                }
            }
            if (p_subobject == 0)
            {
                type_destroy(&subobject_type);
                break;
            }
            if (p_initializer_list_item->initializer->braced_initializer)
            {
                struct type  t;

                if (braced_initializer_new(ctx, &subobject_type, p_subobject, p_initializer_list_item->initializer->braced_initializer, is_constant, requires_constant_initialization) != 0)
                {
                    type_destroy(&array_item_type);
                    type_destroy(&subobject_type);
                    goto __L0; /* throw */
                }
                _cake_zmem(&t, 68);
                is_subobject_of_union = type_is_union(&subobject_type);
                p_subobject = find_last_suboject_of_suboject(&subobject_type, p_subobject, &t);
                type_swap(&t, &subobject_type);
                type_destroy(&t);
            }
            else
            {
                if (p_initializer_list_item->initializer->assignment_expression)
                {
                    unsigned char  entire_object_initialized;

                    entire_object_initialized = 0;
                    if (type_is_array_of_char(&subobject_type) && p_initializer_list_item->initializer->assignment_expression->expression_type == 3)
                    {
                        entire_object_initialized = 1;
                    }
                    else
                    {
                        if (type_is_array(&subobject_type))
                        {
                            while (type_is_array(&subobject_type))
                            {
                                p_subobject = find_next_subobject(p_current_object_type, current_object, p_subobject, &subobject_type, &is_subobject_of_union);
                            }
                        }
                        else
                        {
                            if (type_is_struct_or_union(&subobject_type))
                            {
                                if (type_is_struct_or_union(&p_initializer_list_item->initializer->assignment_expression->type))
                                {
                                    entire_object_initialized = 1;
                                }
                                else
                                {
                                    p_subobject = find_next_subobject(p_current_object_type, current_object, p_subobject, &subobject_type, &is_subobject_of_union);
                                }
                            }
                        }
                    }
                    if (object_set(ctx, p_subobject, p_initializer_list_item->initializer->assignment_expression, &p_initializer_list_item->initializer->assignment_expression->object, is_constant, requires_constant_initialization) != 0)
                    {
                        type_destroy(&array_item_type);
                        type_destroy(&subobject_type);
                        goto __L0; /* throw */
                    }
                    if (is_subobject_of_union)
                    {
                        struct type  t;

                        ;
                        ;
                        _cake_zmem(&t, 68);
                        is_subobject_of_union = 1;
                        p_subobject = find_last_suboject_of_suboject(&p_subobject->parent->type, p_subobject->parent, &t);
                        type_swap(&t, &subobject_type);
                        type_destroy(&t);
                        if (p_subobject)
                        {
                            type_destroy(&subobject_type);
                            subobject_type = type_dup(&p_subobject->type);
                        }
                    }
                    else
                    {
                        if (entire_object_initialized)
                        {
                            struct type  t;

                            ;
                            _cake_zmem(&t, 68);
                            is_subobject_of_union = type_is_union(p_current_object_type);
                            p_subobject = find_last_suboject_of_suboject(&subobject_type, p_subobject, &t);
                            type_swap(&t, &subobject_type);
                            type_destroy(&t);
                            if (p_subobject)
                            {
                                type_destroy(&subobject_type);
                                subobject_type = type_dup(&p_subobject->type);
                            }
                        }
                    }
                }
            }
            p_initializer_list_item = p_initializer_list_item->next;
            type_destroy(&subobject_type);
        }
        if (p_initializer_list_item != 0)
        {
            compiler_diagnostic(62, ctx, p_initializer_list_item->initializer->first_token, 0, "warning: excess elements in initializer");
        }
        if (compute_array_size)
        {
            current_object->type.num_of_elements = array_to_expand_max_index + 1;
            p_current_object_type->num_of_elements = array_to_expand_max_index + 1;
        }
        current_object->parent = parent_copy;
        type_destroy(&array_item_type);
    }
    else __L0: /*catch*/ 
    {
        return 1;
    }
    return 0;
}
int fill_preprocessor_options(int argc, char ** argv, struct preprocessor_ctx * prectx)
{
    {
        int i;

        i = 1;
        for (; i < argc; i++)
        {
            if (argv[i][0] != 45)
            {
                continue;
            }
            if (argv[i][1] == 73)
            {
                include_dir_add(&prectx->include_dir, argv[i] + 2);
                continue;
            }
            if (argv[i][1] == 68)
            {
                char buffer[200];
                char * p;
                struct tokenizer_ctx  tctx;
                struct token_list  l1;
                struct token_list  r;

                _cake_zmem(&buffer, 200);
                snprintf(buffer, 200, "#define %s \n", argv[i] + 2);
                p = &buffer[7];
                while (*p)
                {
                    if (*p == 61)
                    {
                        *p = 32;
                        break;
                    }
                    p++;
                }
                _cake_zmem(&tctx, 928);
                l1 = tokenizer(&tctx, buffer, "", 0, 0);
                r = preprocessor(prectx, &l1, 0);
                token_list_destroy(&l1);
                token_list_destroy(&r);
                continue;
            }
        }
    }
    return 0;
}


char *get_posix_error_message(int error);
unsigned long __stdcall GetEnvironmentVariableA(char * lpName, char * lpBuffer, unsigned long nSize);

int generate_config_file(char * configpath)
{
    struct _iobuf * outfile;
    int error;

    outfile = 0;
    error = 0;
    if (1) /*try*/
    {
        char env[2000];
        int n;
        char * p;

        outfile = fopen(configpath, "w");
        if (outfile == 0)
        {
            error = (*_errno());
            printf("Cannot open the file '%s' for writing '%s'.\n", configpath, get_posix_error_message(error));
            goto __L0; /* throw */
        }
        fprintf(outfile, "//This was generated by running cake -autoconfig \n");
        _cake_zmem(&env, 2000);
        n = GetEnvironmentVariableA("INCLUDE", env, 2000);
        if (n <= 0)
        {
            printf("INCLUDE not found.\nPlease, run cake -autoconfig inside visual studio command prompt.\n");
            error = 1;
            goto __L0; /* throw */
        }
        fprintf(outfile, "//This file was generated reading the variable INCLUDE inside Visual Studio Command Prompt.\n");
        fprintf(outfile, "//echo %%INCLUDE%% \n");
        p = env;
        for (; ; )
        {
            char filename_local[500];
            int count;

            if (*p == 0)
            {
                break;
            }
            _cake_zmem(&filename_local, 500);
            count = 0;
            while (*p != 0 && (*p != 59 && *p != 10))
            {
                filename_local[count] = *p;
                p++;
                count++;
            }
            filename_local[count] = 0;
            if (count > 0)
            {
                char * pch;

                strcat(filename_local, "/");
                pch = filename_local;
                while (*pch)
                {
                    if (*pch == 92)
                    {
                        *pch = 47;
                    }
                    pch++;
                }
                fprintf(outfile, "#pragma dir \"%s\"\n", filename_local);
            }
            if (*p == 0)
            {
                break;
            }
            p++;
        }
    }
    else __L0: /*catch*/ 
    {
    }
    if (outfile)
    {
        fclose(outfile);
    }
    if (error == 0)
    {
        printf("file '%s'\n", configpath);
        printf("successfully generated\n");
    }
    return error;
}


void d_visit(struct d_visit_ctx * ctx, struct osstream * oss);
void d_visit_ctx_destroy(struct d_visit_ctx * ctx);
static int get_first_line_len(char * s);

int compile_one_file(char * file_name, struct options * options, char * out_file_name, int argc, char ** argv, struct report * report)
{
    unsigned char  color_enabled;
    struct preprocessor_ctx  prectx;
    struct ast  ast;
    char * p_output_string;
    struct parser_ctx  ctx;
    struct tokenizer_ctx  tctx;
    struct token_list  tokens;
    char * content;

    color_enabled = !options->color_disabled;
    printf("%s\n", file_name);
    _cake_zmem(&prectx, 984);
    prectx.options = *options;
    prectx.macros.capacity = 5000;
    add_standard_macros(&prectx, options->target);
    if (include_config_header(&prectx, file_name) != 0)
    {
    }
    _cake_zmem(&ast, 16);
    p_output_string = 0;
    _cake_zmem(&ctx, 1004);
    _cake_zmem(&tctx, 928);
    _cake_zmem(&tokens, 8);
    tctx.options = *options;
    ctx.options = *options;
    ctx.p_report = report;
    content = 0;
    if (1) /*try*/
    {
        if (fill_preprocessor_options(argc, argv, &prectx) != 0)
        {
            goto __L1; /* throw */
        }
        prectx.options = *options;
        content = read_file(file_name, 1);
        if (content == 0)
        {
            report->error_count++;
            printf("file not found '%s'\n", file_name);
            goto __L1; /* throw */
        }
        if (options->sarif_output)
        {
            char sarif_file_name[260];

            _cake_zmem(&sarif_file_name, 260);
            if (options->sarifpath[0] != 0)
            {
                _mkdir(options->sarifpath);
                snprintf(sarif_file_name, 260, "%s/%s.cake.sarif", options->sarifpath, basename(file_name));
            }
            else
            {
                snprintf(sarif_file_name, 260, "%s.cake.sarif", file_name);
            }
            ctx.sarif_file = (struct _iobuf *)fopen(sarif_file_name, "w");
            if (ctx.sarif_file)
            {
                char * begin_sarif;

                begin_sarif = "{\n  \"version\": \"2.1.0\",\n  \"$schema\": \"https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.5.json\",\n  \"runs\": [\n    {\n      \"results\": [\n\n";
                fprintf(ctx.sarif_file, "%s", begin_sarif);
            }
            else
            {
                report->error_count++;
                printf("cannot open Sarif output file '%s'\n", sarif_file_name);
                goto __L1; /* throw */
            }
        }
        tokens = tokenizer(&tctx, content, file_name, 0, 0);
        if (tctx.n_errors > 0)
        {
            goto __L1; /* throw */
        }
        if (options->dump_tokens)
        {
            print_tokens(color_enabled, tokens.head);
        }
        ast.token_list = preprocessor(&prectx, &tokens, 0);
        report->warnings_count += prectx.n_warnings;
        report->error_count += prectx.n_errors;
        if (prectx.n_errors > 0)
        {
            goto __L1; /* throw */
        }
        if (options->dump_pptokens)
        {
            if (ast.token_list.head != 0)
            {
                print_tokens(color_enabled, ast.token_list.head);
            }
        }
        if (options->preprocess_only)
        {
            struct _iobuf * outfile;

            p_output_string = print_preprocessed_to_string2(ast.token_list.head);
            printf("%s", p_output_string);
            outfile = fopen(out_file_name, "w");
            if (outfile)
            {
                if (p_output_string)
                {
                    fprintf(outfile, "%s", p_output_string);
                }
                fclose(outfile);
            }
            else
            {
                report->error_count++;
                printf("cannot open output file '%s' - %s\n", out_file_name, get_posix_error_message((*_errno())));
                goto __L1; /* throw */
            }
        }
        else
        {
            unsigned char  berror;

            berror = 0;
            ast.declaration_list = parse(&ctx, &ast.token_list, &berror);
            if (berror || report->error_count > 0)
            {
                goto __L1; /* throw */
            }
            if (!options->no_output)
            {
                struct osstream  ss;
                struct d_visit_ctx  ctx2;
                struct _iobuf * outfile;

                _cake_zmem(&ss, 12);
                _cake_zmem(&ctx2, 1072);
                ctx2.ast = ast;
                ctx2.options = ctx.options;
                d_visit(&ctx2, &ss);
                p_output_string = ss.c_str;
                d_visit_ctx_destroy(&ctx2);
                outfile = fopen(out_file_name, "w");
                if (outfile)
                {
                    if (p_output_string)
                    {
                        fprintf(outfile, "%s", p_output_string);
                    }
                    fclose(outfile);
                }
                else
                {
                    report->error_count++;
                    printf("cannot open output file '%s' - %s\n", out_file_name, get_posix_error_message((*_errno())));
                    goto __L1; /* throw */
                }
            }
        }
        if (ctx.sarif_file)
        {
            fprintf(ctx.sarif_file, "%s", "      ],\n      \"tool\": {\n        \"driver\": {\n          \"name\": \"cake\",\n          \"fullName\": \"cake code analysis\",\n          \"version\": \"0.12.56\",\n          \"informationUri\": \"https://https://github.com/thradams/cake\"\n        }\n      }\n    }\n  ]\n}\n\n");
            fclose(ctx.sarif_file);
            ctx.sarif_file = 0;
        }
    }
    else __L1: /*catch*/ 
    {
    }
    if (ctx.options.test_mode_inout)
    {
        char file_name_no_ext[260];
        char buf[260];
        char * content_expected;

        _cake_zmem(&file_name_no_ext, 260);
        remove_file_extension(file_name, 260, file_name_no_ext);
        _cake_zmem(&buf, 260);
        snprintf(buf, 260, "%s_%s.out", file_name_no_ext, get_platform(ctx.options.target)->name);
        content_expected = read_file(buf, 0);
        if (content_expected)
        {
            int s_first_line_len;
            int content_expected_first_line_len;

            s_first_line_len = 0;
            content_expected_first_line_len = 0;
            if (ctx.options.preprocess_only)
            {
            }
            else
            {
                s_first_line_len = get_first_line_len(p_output_string);
                content_expected_first_line_len = get_first_line_len(content_expected);
            }
            if (p_output_string && strcmp(content_expected + content_expected_first_line_len, p_output_string + s_first_line_len) != 0)
            {
                printf("Output file '%s' is different from expected file '%s'\n", out_file_name, buf);
                report->error_count++;
            }
            free(content_expected);
        }
        else
        {
            printf("Missing comparison file '%s' (-test-mode-in-out)\n", buf);
            report->test_failed++;
        }
        if (report->error_count > 0 || report->warnings_count > 0)
        {
            printf("-------------------------------------------\n");
            printf("%s", content);
            printf("\n-------------------------------------------\n");
            if (color_enabled)
            {
                printf("\x1b[91mTEST FAILED\x1b[0m : error=%d, warnings=%d\n", report->error_count, report->warnings_count);
            }
            else
            {
                printf("TEST FAILED : error=%d, warnings=%d\n", report->error_count, report->warnings_count);
            }
            printf("\n\n");
            report->test_failed++;
        }
        else
        {
            report->test_succeeded++;
        }
    }
    token_list_destroy(&tokens);
    parser_ctx_destroy(&ctx);
    free((void *)p_output_string);
    free(content);
    ast_destroy(&ast);
    preprocessor_ctx_destroy(&prectx);
    return report->error_count > 0;
}



static int get_first_line_len(char * s)
{
    int n;

    n = 0;
    while (*s && (*s != 13 && *s != 10))
    {
        s++;
        n++;
    }
    return n;
}
void print_report(struct report * report)
{
    if (report->ignore_this_report)
    {
        return;
    }
    if (report->test_mode || report->error_count != 0 || report->warnings_count != 0 || report->info_count != 0)
    {
        printf("\n");
        printf("%d errors ", report->error_count);
        printf("%d warnings ", report->warnings_count);
        printf("%d notes ", report->info_count);
        printf("\n");
        printf("%d files in %.2f seconds", report->no_files, report->cpu_time_used_sec);
        if (report->test_mode)
        {
            if (report->error_count > 0 || report->warnings_count > 0)
            {
                printf("\x1b[31;1m - TEST FAILED\x1b[0m");
            }
            else
            {
                printf("\x1b[32m - TEST SUCCEEDED\x1b[0m");
            }
        }
        printf("\n");
    }
    printf("\n");
}


long __cdecl clock(void);
static void longest_common_path(int argc, char ** argv, char root_dir[260]);
static int create_multiple_paths(char * root, char * outdir);
static int compile_many_files(char * file_name, struct options * options, char * out_file_name, int argc, char ** argv, struct report * report);
static char *strrchr2(char * s, int c);

int compile(int argc, char ** argv, struct report * report)
{
    struct options  options;
    char executable_path[246];
    char cakeconfig_path[260];
    long begin_clock;
    int no_files;
    char root_dir[260];
    unsigned int root_dir_len;
    long end_clock;
    double cpu_time_used;

    _cake_zmem(&options, 920);
    if (fill_options(&options, argc, argv) != 0)
    {
        return 1;
    }
    if (options.target != 1)
    {
        printf("emulating %s\n", get_platform(options.target)->name);
    }
    _cake_zmem(&executable_path, 246);
    get_self_path(executable_path, 246);
    dirname(executable_path);
    _cake_zmem(&cakeconfig_path, 260);
    snprintf(cakeconfig_path, 260, "%s/cakeconfig.h", executable_path);
    if (options.auto_config)
    {
        report->ignore_this_report = 1;
        return generate_config_file(cakeconfig_path);
    }
    report->test_mode = options.test_mode;
    begin_clock = clock();
    no_files = 0;
    _cake_zmem(&root_dir, 260);
    if (!options.no_output)
    {
        longest_common_path(argc, argv, root_dir);
    }
    root_dir_len = strlen(root_dir);
    {
        int i;

        i = 1;
        for (; i < argc; i++)
        {
            char output_file[260];
            char fullpath[260];
            char * file_extension;

            if (strcmp(argv[i], "-o") == 0 || strcmp(argv[i], "-sarif-path") == 0)
            {
                i++;
                continue;
            }
            if (argv[i][0] == 45)
            {
                continue;
            }
            no_files++;
            _cake_zmem(&output_file, 260);
            if (!options.no_output)
            {
                if (no_files == 1 && options.output[0] != 0)
                {
                    strcat(output_file, options.output);
                }
                else
                {
                    char fullpath[260];
                    char outdir[260];

                    _cake_zmem(&fullpath, 260);
                    realpath(argv[i], fullpath);
                    strcpy(output_file, root_dir);
                    strcat(output_file, "/");
                    strcat(output_file, get_platform(options.target)->name);
                    strcat(output_file, fullpath + root_dir_len);
                    _cake_zmem(&outdir, 260);
                    strcpy(outdir, output_file);
                    dirname(outdir);
                    if (create_multiple_paths(root_dir, outdir) != 0)
                    {
                        return 1;
                    }
                }
            }
            _cake_zmem(&fullpath, 260);
            realpath(argv[i], fullpath);
            file_extension = basename(fullpath);
            if (file_extension[0] == 42)
            {
                no_files--;
                no_files += compile_many_files(fullpath, &options, output_file, argc, argv, report);
            }
            else
            {
                struct report  report_local;

                _cake_zmem(&report_local, 48);
                compile_one_file(fullpath, &options, output_file, argc, argv, &report_local);
                report->error_count += report_local.error_count;
                report->warnings_count += report_local.warnings_count;
                report->info_count += report_local.info_count;
                report->test_succeeded += report_local.test_succeeded;
                report->test_failed += report_local.test_failed;
            }
        }
    }
    end_clock = clock();
    cpu_time_used = ((double)(end_clock - begin_clock)) / 1000L;
    report->no_files = no_files;
    report->cpu_time_used_sec = cpu_time_used;
    print_report(report);
    if (report->test_mode)
    {
        if (report->error_count > 0 || report->warnings_count > 0)
        {
            return 1;
        }
        return 0;
    }
    return 0;
}



static void longest_common_path(int argc, char ** argv, char root_dir[260])
{
    {
        int i;

        i = 1;
        for (; i < argc; i++)
        {
            char fullpath_i[260];

            if (argv[i][0] == 45)
            {
                continue;
            }
            _cake_zmem(&fullpath_i, 260);
            realpath(argv[i], fullpath_i);
            strcpy(root_dir, fullpath_i);
            dirname(root_dir);
            {
                int k;

                k = 0;
                for (; k < 260; k++)
                {
                    char ch;

                    ch = fullpath_i[k];
                    {
                        int j;

                        j = 2;
                        for (; j < argc; j++)
                        {
                            char fullpath_j[260];

                            if (argv[j][0] == 45)
                            {
                                continue;
                            }
                            _cake_zmem(&fullpath_j, 260);
                            realpath(argv[j], fullpath_j);
                            if (fullpath_j[k] != ch)
                            {
                                strncpy(root_dir, fullpath_j, k);
                                root_dir[k] = 0;
                                dirname(root_dir);
                                goto exit;
                            }
                        }
                    }
                    if (ch == 0)
                    {
                        break;
                    }
                }
            }
        }
    }
    exit:
    ;
}

static int create_multiple_paths(char * root, char * outdir)
{
    char * p;

    p = outdir + strlen(root) + 1;
    for (; ; )
    {
        char temp[260];
        int er;

        if (*p != 0 && *p != 47 && *p != 92)
        {
            p++;
            continue;
        }
        _cake_zmem(&temp, 260);
        strncpy(temp, outdir, p - outdir);
        er = _mkdir(temp);
        if (er != 0)
        {
            er = (*_errno());
            if (er != 17)
            {
                printf("error creating output folder '%s' - %s\n", temp, get_posix_error_message(er));
                return er;
            }
        }
        if (*p == 0)
        {
            break;
        }
        p++;
    }
    return 0;
}

static char *strrchr2(char * s, int c)
{
    char * last;
    unsigned char ch;

    last = 0;
    ch = (unsigned char)c;
    while (*s)
    {
        if ((unsigned char)*s == ch)
        {
            last = s;
        }
        s++;
    }
    if (ch == 0)
    {
        return (char *)s;
    }
    return (char *)last;
}

static int compile_many_files(char * file_name, struct options * options, char * out_file_name, int argc, char ** argv, struct report * report)
{
    char * file_name_name;
    char * file_name_extension;
    int num_files;
    char path[260];
    struct TAGDIR * dir;
    struct dirent * dp;

    file_name_name = basename(file_name);
    file_name_extension = strrchr2((char *)file_name_name, 46);
    if (file_name_extension == 0)
    {
        ;
    }
    num_files = 0;
    _cake_zmem(&path, 260);
    snprintf(path, 260, "%s", file_name);
    dirname(path);
    dir = opendir(path);
    if (dir == 0)
    {
        return (*_errno());
    }
    while ((dp = readdir(dir)) != 0)
    {
        char fromlocal[257];

        if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
        {
            continue;
        }
        _cake_zmem(&fromlocal, 257);
        snprintf(fromlocal, 257, "%s/%s", "", dp->d_name);
        if (dp->d_type & 4)
        {
        }
        else
        {
            char * file_name_iter;
            char * file_extension;

            file_name_iter = basename(dp->d_name);
            file_extension = strrchr2((char *)file_name_iter, 46);
            if (file_name_extension && file_extension && strcmp(file_name_extension, file_extension) == 0)
            {
                char out_file_name_final[260];
                char in_file_name_final[260];
                struct report  report_local;

                _cake_zmem(&out_file_name_final, 260);
                strcpy(out_file_name_final, out_file_name);
                dirname(out_file_name_final);
                strcat(out_file_name_final, "/");
                strcat(out_file_name_final, file_name_iter);
                _cake_zmem(&in_file_name_final, 260);
                strcpy(in_file_name_final, file_name);
                dirname(in_file_name_final);
                strcat(in_file_name_final, "/");
                strcat(in_file_name_final, file_name_iter);
                _cake_zmem(&report_local, 48);
                report_local.test_mode = report->test_mode;
                compile_one_file(in_file_name_final, options, out_file_name_final, argc, argv, &report_local);
                report->error_count += report_local.error_count;
                report->warnings_count += report_local.warnings_count;
                report->info_count += report_local.info_count;
                report->test_succeeded += report_local.test_succeeded;
                report->test_failed += report_local.test_failed;
                num_files++;
            }
        }
    }
    closedir(dir);
    return num_files;
}
static int strtoargv(char * s, int n, char *argv[]);

char *compile_source(char * pszoptions, char * content, struct report * report)
{
    char *argv[100];
    char string[200];
    int argc;
    char * s;
    struct preprocessor_ctx  prectx;
    struct ast  ast;
    struct options  options;

    _cake_zmem(&argv, 400);
    _cake_zmem(&string, 200);
    snprintf(string, 200, "exepath %s", pszoptions);
    argc = strtoargv(string, 10, argv);
    s = 0;
    _cake_zmem(&prectx, 984);
    _cake_zmem(&ast, 16);
    options.input = 2;
    options.target = 0;
    options.diagnostic_stack.top_index = 0;
    options.diagnostic_stack.stack[0].errors.bits[0] = 0;
    options.diagnostic_stack.stack[0].errors.bits[1] = 0;
    options.diagnostic_stack.stack[0].errors.bits[2] = 0;
    options.diagnostic_stack.stack[0].errors.bits[3] = 0;
    options.diagnostic_stack.stack[0].warnings.bits[0] = 0;
    options.diagnostic_stack.stack[0].warnings.bits[1] = 0;
    options.diagnostic_stack.stack[0].warnings.bits[2] = 0;
    options.diagnostic_stack.stack[0].warnings.bits[3] = 0;
    options.diagnostic_stack.stack[0].notes.bits[0] = 0;
    options.diagnostic_stack.stack[0].notes.bits[1] = 0;
    options.diagnostic_stack.stack[0].notes.bits[2] = 0;
    options.diagnostic_stack.stack[0].notes.bits[3] = 0;
    options.diagnostic_stack.stack[1].errors.bits[0] = 0;
    options.diagnostic_stack.stack[1].errors.bits[1] = 0;
    options.diagnostic_stack.stack[1].errors.bits[2] = 0;
    options.diagnostic_stack.stack[1].errors.bits[3] = 0;
    options.diagnostic_stack.stack[1].warnings.bits[0] = 0;
    options.diagnostic_stack.stack[1].warnings.bits[1] = 0;
    options.diagnostic_stack.stack[1].warnings.bits[2] = 0;
    options.diagnostic_stack.stack[1].warnings.bits[3] = 0;
    options.diagnostic_stack.stack[1].notes.bits[0] = 0;
    options.diagnostic_stack.stack[1].notes.bits[1] = 0;
    options.diagnostic_stack.stack[1].notes.bits[2] = 0;
    options.diagnostic_stack.stack[1].notes.bits[3] = 0;
    options.diagnostic_stack.stack[2].errors.bits[0] = 0;
    options.diagnostic_stack.stack[2].errors.bits[1] = 0;
    options.diagnostic_stack.stack[2].errors.bits[2] = 0;
    options.diagnostic_stack.stack[2].errors.bits[3] = 0;
    options.diagnostic_stack.stack[2].warnings.bits[0] = 0;
    options.diagnostic_stack.stack[2].warnings.bits[1] = 0;
    options.diagnostic_stack.stack[2].warnings.bits[2] = 0;
    options.diagnostic_stack.stack[2].warnings.bits[3] = 0;
    options.diagnostic_stack.stack[2].notes.bits[0] = 0;
    options.diagnostic_stack.stack[2].notes.bits[1] = 0;
    options.diagnostic_stack.stack[2].notes.bits[2] = 0;
    options.diagnostic_stack.stack[2].notes.bits[3] = 0;
    options.diagnostic_stack.stack[3].errors.bits[0] = 0;
    options.diagnostic_stack.stack[3].errors.bits[1] = 0;
    options.diagnostic_stack.stack[3].errors.bits[2] = 0;
    options.diagnostic_stack.stack[3].errors.bits[3] = 0;
    options.diagnostic_stack.stack[3].warnings.bits[0] = 0;
    options.diagnostic_stack.stack[3].warnings.bits[1] = 0;
    options.diagnostic_stack.stack[3].warnings.bits[2] = 0;
    options.diagnostic_stack.stack[3].warnings.bits[3] = 0;
    options.diagnostic_stack.stack[3].notes.bits[0] = 0;
    options.diagnostic_stack.stack[3].notes.bits[1] = 0;
    options.diagnostic_stack.stack[3].notes.bits[2] = 0;
    options.diagnostic_stack.stack[3].notes.bits[3] = 0;
    options.diagnostic_stack.stack[4].errors.bits[0] = 0;
    options.diagnostic_stack.stack[4].errors.bits[1] = 0;
    options.diagnostic_stack.stack[4].errors.bits[2] = 0;
    options.diagnostic_stack.stack[4].errors.bits[3] = 0;
    options.diagnostic_stack.stack[4].warnings.bits[0] = 0;
    options.diagnostic_stack.stack[4].warnings.bits[1] = 0;
    options.diagnostic_stack.stack[4].warnings.bits[2] = 0;
    options.diagnostic_stack.stack[4].warnings.bits[3] = 0;
    options.diagnostic_stack.stack[4].notes.bits[0] = 0;
    options.diagnostic_stack.stack[4].notes.bits[1] = 0;
    options.diagnostic_stack.stack[4].notes.bits[2] = 0;
    options.diagnostic_stack.stack[4].notes.bits[3] = 0;
    options.diagnostic_stack.stack[5].errors.bits[0] = 0;
    options.diagnostic_stack.stack[5].errors.bits[1] = 0;
    options.diagnostic_stack.stack[5].errors.bits[2] = 0;
    options.diagnostic_stack.stack[5].errors.bits[3] = 0;
    options.diagnostic_stack.stack[5].warnings.bits[0] = 0;
    options.diagnostic_stack.stack[5].warnings.bits[1] = 0;
    options.diagnostic_stack.stack[5].warnings.bits[2] = 0;
    options.diagnostic_stack.stack[5].warnings.bits[3] = 0;
    options.diagnostic_stack.stack[5].notes.bits[0] = 0;
    options.diagnostic_stack.stack[5].notes.bits[1] = 0;
    options.diagnostic_stack.stack[5].notes.bits[2] = 0;
    options.diagnostic_stack.stack[5].notes.bits[3] = 0;
    options.diagnostic_stack.stack[6].errors.bits[0] = 0;
    options.diagnostic_stack.stack[6].errors.bits[1] = 0;
    options.diagnostic_stack.stack[6].errors.bits[2] = 0;
    options.diagnostic_stack.stack[6].errors.bits[3] = 0;
    options.diagnostic_stack.stack[6].warnings.bits[0] = 0;
    options.diagnostic_stack.stack[6].warnings.bits[1] = 0;
    options.diagnostic_stack.stack[6].warnings.bits[2] = 0;
    options.diagnostic_stack.stack[6].warnings.bits[3] = 0;
    options.diagnostic_stack.stack[6].notes.bits[0] = 0;
    options.diagnostic_stack.stack[6].notes.bits[1] = 0;
    options.diagnostic_stack.stack[6].notes.bits[2] = 0;
    options.diagnostic_stack.stack[6].notes.bits[3] = 0;
    options.diagnostic_stack.stack[7].errors.bits[0] = 0;
    options.diagnostic_stack.stack[7].errors.bits[1] = 0;
    options.diagnostic_stack.stack[7].errors.bits[2] = 0;
    options.diagnostic_stack.stack[7].errors.bits[3] = 0;
    options.diagnostic_stack.stack[7].warnings.bits[0] = 0;
    options.diagnostic_stack.stack[7].warnings.bits[1] = 0;
    options.diagnostic_stack.stack[7].warnings.bits[2] = 0;
    options.diagnostic_stack.stack[7].warnings.bits[3] = 0;
    options.diagnostic_stack.stack[7].notes.bits[0] = 0;
    options.diagnostic_stack.stack[7].notes.bits[1] = 0;
    options.diagnostic_stack.stack[7].notes.bits[2] = 0;
    options.diagnostic_stack.stack[7].notes.bits[3] = 0;
    options.diagnostic_stack.stack[8].errors.bits[0] = 0;
    options.diagnostic_stack.stack[8].errors.bits[1] = 0;
    options.diagnostic_stack.stack[8].errors.bits[2] = 0;
    options.diagnostic_stack.stack[8].errors.bits[3] = 0;
    options.diagnostic_stack.stack[8].warnings.bits[0] = 0;
    options.diagnostic_stack.stack[8].warnings.bits[1] = 0;
    options.diagnostic_stack.stack[8].warnings.bits[2] = 0;
    options.diagnostic_stack.stack[8].warnings.bits[3] = 0;
    options.diagnostic_stack.stack[8].notes.bits[0] = 0;
    options.diagnostic_stack.stack[8].notes.bits[1] = 0;
    options.diagnostic_stack.stack[8].notes.bits[2] = 0;
    options.diagnostic_stack.stack[8].notes.bits[3] = 0;
    options.diagnostic_stack.stack[9].errors.bits[0] = 0;
    options.diagnostic_stack.stack[9].errors.bits[1] = 0;
    options.diagnostic_stack.stack[9].errors.bits[2] = 0;
    options.diagnostic_stack.stack[9].errors.bits[3] = 0;
    options.diagnostic_stack.stack[9].warnings.bits[0] = 0;
    options.diagnostic_stack.stack[9].warnings.bits[1] = 0;
    options.diagnostic_stack.stack[9].warnings.bits[2] = 0;
    options.diagnostic_stack.stack[9].warnings.bits[3] = 0;
    options.diagnostic_stack.stack[9].notes.bits[0] = 0;
    options.diagnostic_stack.stack[9].notes.bits[1] = 0;
    options.diagnostic_stack.stack[9].notes.bits[2] = 0;
    options.diagnostic_stack.stack[9].notes.bits[3] = 0;
    options.style = 0;
    options.show_includes = 0;
    options.disable_assert = 0;
    options.flow_analysis = 0;
    options.test_mode = 0;
    options.test_mode_inout = 0;
    options.null_checks_enabled = 0;
    options.ownership_enabled = 0;
    options.preprocess_only = 0;
    options.preprocess_def_macro = 0;
    options.clear_error_at_end = 0;
    options.sarif_output = 0;
    options.no_output = 0;
    options.const_literal = 0;
    options.visual_studio_ouput_format = 0;
    options.color_disabled = 0;
    options.dump_tokens = 0;
    options.dump_pptokens = 0;
    options.auto_config = 0;
    options.comment_to_attribute = 0;
    options.do_static_debug = 0;
    options.static_debug_lines = 0;
    options.output[0] = 0;
    options.output[1] = 0;
    options.output[2] = 0;
    options.output[3] = 0;
    options.output[4] = 0;
    options.output[5] = 0;
    options.output[6] = 0;
    options.output[7] = 0;
    options.output[8] = 0;
    options.output[9] = 0;
    options.output[10] = 0;
    options.output[11] = 0;
    options.output[12] = 0;
    options.output[13] = 0;
    options.output[14] = 0;
    options.output[15] = 0;
    options.output[16] = 0;
    options.output[17] = 0;
    options.output[18] = 0;
    options.output[19] = 0;
    options.output[20] = 0;
    options.output[21] = 0;
    options.output[22] = 0;
    options.output[23] = 0;
    options.output[24] = 0;
    options.output[25] = 0;
    options.output[26] = 0;
    options.output[27] = 0;
    options.output[28] = 0;
    options.output[29] = 0;
    options.output[30] = 0;
    options.output[31] = 0;
    options.output[32] = 0;
    options.output[33] = 0;
    options.output[34] = 0;
    options.output[35] = 0;
    options.output[36] = 0;
    options.output[37] = 0;
    options.output[38] = 0;
    options.output[39] = 0;
    options.output[40] = 0;
    options.output[41] = 0;
    options.output[42] = 0;
    options.output[43] = 0;
    options.output[44] = 0;
    options.output[45] = 0;
    options.output[46] = 0;
    options.output[47] = 0;
    options.output[48] = 0;
    options.output[49] = 0;
    options.output[50] = 0;
    options.output[51] = 0;
    options.output[52] = 0;
    options.output[53] = 0;
    options.output[54] = 0;
    options.output[55] = 0;
    options.output[56] = 0;
    options.output[57] = 0;
    options.output[58] = 0;
    options.output[59] = 0;
    options.output[60] = 0;
    options.output[61] = 0;
    options.output[62] = 0;
    options.output[63] = 0;
    options.output[64] = 0;
    options.output[65] = 0;
    options.output[66] = 0;
    options.output[67] = 0;
    options.output[68] = 0;
    options.output[69] = 0;
    options.output[70] = 0;
    options.output[71] = 0;
    options.output[72] = 0;
    options.output[73] = 0;
    options.output[74] = 0;
    options.output[75] = 0;
    options.output[76] = 0;
    options.output[77] = 0;
    options.output[78] = 0;
    options.output[79] = 0;
    options.output[80] = 0;
    options.output[81] = 0;
    options.output[82] = 0;
    options.output[83] = 0;
    options.output[84] = 0;
    options.output[85] = 0;
    options.output[86] = 0;
    options.output[87] = 0;
    options.output[88] = 0;
    options.output[89] = 0;
    options.output[90] = 0;
    options.output[91] = 0;
    options.output[92] = 0;
    options.output[93] = 0;
    options.output[94] = 0;
    options.output[95] = 0;
    options.output[96] = 0;
    options.output[97] = 0;
    options.output[98] = 0;
    options.output[99] = 0;
    options.output[100] = 0;
    options.output[101] = 0;
    options.output[102] = 0;
    options.output[103] = 0;
    options.output[104] = 0;
    options.output[105] = 0;
    options.output[106] = 0;
    options.output[107] = 0;
    options.output[108] = 0;
    options.output[109] = 0;
    options.output[110] = 0;
    options.output[111] = 0;
    options.output[112] = 0;
    options.output[113] = 0;
    options.output[114] = 0;
    options.output[115] = 0;
    options.output[116] = 0;
    options.output[117] = 0;
    options.output[118] = 0;
    options.output[119] = 0;
    options.output[120] = 0;
    options.output[121] = 0;
    options.output[122] = 0;
    options.output[123] = 0;
    options.output[124] = 0;
    options.output[125] = 0;
    options.output[126] = 0;
    options.output[127] = 0;
    options.output[128] = 0;
    options.output[129] = 0;
    options.output[130] = 0;
    options.output[131] = 0;
    options.output[132] = 0;
    options.output[133] = 0;
    options.output[134] = 0;
    options.output[135] = 0;
    options.output[136] = 0;
    options.output[137] = 0;
    options.output[138] = 0;
    options.output[139] = 0;
    options.output[140] = 0;
    options.output[141] = 0;
    options.output[142] = 0;
    options.output[143] = 0;
    options.output[144] = 0;
    options.output[145] = 0;
    options.output[146] = 0;
    options.output[147] = 0;
    options.output[148] = 0;
    options.output[149] = 0;
    options.output[150] = 0;
    options.output[151] = 0;
    options.output[152] = 0;
    options.output[153] = 0;
    options.output[154] = 0;
    options.output[155] = 0;
    options.output[156] = 0;
    options.output[157] = 0;
    options.output[158] = 0;
    options.output[159] = 0;
    options.output[160] = 0;
    options.output[161] = 0;
    options.output[162] = 0;
    options.output[163] = 0;
    options.output[164] = 0;
    options.output[165] = 0;
    options.output[166] = 0;
    options.output[167] = 0;
    options.output[168] = 0;
    options.output[169] = 0;
    options.output[170] = 0;
    options.output[171] = 0;
    options.output[172] = 0;
    options.output[173] = 0;
    options.output[174] = 0;
    options.output[175] = 0;
    options.output[176] = 0;
    options.output[177] = 0;
    options.output[178] = 0;
    options.output[179] = 0;
    options.output[180] = 0;
    options.output[181] = 0;
    options.output[182] = 0;
    options.output[183] = 0;
    options.output[184] = 0;
    options.output[185] = 0;
    options.output[186] = 0;
    options.output[187] = 0;
    options.output[188] = 0;
    options.output[189] = 0;
    options.output[190] = 0;
    options.output[191] = 0;
    options.output[192] = 0;
    options.output[193] = 0;
    options.output[194] = 0;
    options.output[195] = 0;
    options.output[196] = 0;
    options.output[197] = 0;
    options.output[198] = 0;
    options.output[199] = 0;
    options.sarifpath[0] = 0;
    options.sarifpath[1] = 0;
    options.sarifpath[2] = 0;
    options.sarifpath[3] = 0;
    options.sarifpath[4] = 0;
    options.sarifpath[5] = 0;
    options.sarifpath[6] = 0;
    options.sarifpath[7] = 0;
    options.sarifpath[8] = 0;
    options.sarifpath[9] = 0;
    options.sarifpath[10] = 0;
    options.sarifpath[11] = 0;
    options.sarifpath[12] = 0;
    options.sarifpath[13] = 0;
    options.sarifpath[14] = 0;
    options.sarifpath[15] = 0;
    options.sarifpath[16] = 0;
    options.sarifpath[17] = 0;
    options.sarifpath[18] = 0;
    options.sarifpath[19] = 0;
    options.sarifpath[20] = 0;
    options.sarifpath[21] = 0;
    options.sarifpath[22] = 0;
    options.sarifpath[23] = 0;
    options.sarifpath[24] = 0;
    options.sarifpath[25] = 0;
    options.sarifpath[26] = 0;
    options.sarifpath[27] = 0;
    options.sarifpath[28] = 0;
    options.sarifpath[29] = 0;
    options.sarifpath[30] = 0;
    options.sarifpath[31] = 0;
    options.sarifpath[32] = 0;
    options.sarifpath[33] = 0;
    options.sarifpath[34] = 0;
    options.sarifpath[35] = 0;
    options.sarifpath[36] = 0;
    options.sarifpath[37] = 0;
    options.sarifpath[38] = 0;
    options.sarifpath[39] = 0;
    options.sarifpath[40] = 0;
    options.sarifpath[41] = 0;
    options.sarifpath[42] = 0;
    options.sarifpath[43] = 0;
    options.sarifpath[44] = 0;
    options.sarifpath[45] = 0;
    options.sarifpath[46] = 0;
    options.sarifpath[47] = 0;
    options.sarifpath[48] = 0;
    options.sarifpath[49] = 0;
    options.sarifpath[50] = 0;
    options.sarifpath[51] = 0;
    options.sarifpath[52] = 0;
    options.sarifpath[53] = 0;
    options.sarifpath[54] = 0;
    options.sarifpath[55] = 0;
    options.sarifpath[56] = 0;
    options.sarifpath[57] = 0;
    options.sarifpath[58] = 0;
    options.sarifpath[59] = 0;
    options.sarifpath[60] = 0;
    options.sarifpath[61] = 0;
    options.sarifpath[62] = 0;
    options.sarifpath[63] = 0;
    options.sarifpath[64] = 0;
    options.sarifpath[65] = 0;
    options.sarifpath[66] = 0;
    options.sarifpath[67] = 0;
    options.sarifpath[68] = 0;
    options.sarifpath[69] = 0;
    options.sarifpath[70] = 0;
    options.sarifpath[71] = 0;
    options.sarifpath[72] = 0;
    options.sarifpath[73] = 0;
    options.sarifpath[74] = 0;
    options.sarifpath[75] = 0;
    options.sarifpath[76] = 0;
    options.sarifpath[77] = 0;
    options.sarifpath[78] = 0;
    options.sarifpath[79] = 0;
    options.sarifpath[80] = 0;
    options.sarifpath[81] = 0;
    options.sarifpath[82] = 0;
    options.sarifpath[83] = 0;
    options.sarifpath[84] = 0;
    options.sarifpath[85] = 0;
    options.sarifpath[86] = 0;
    options.sarifpath[87] = 0;
    options.sarifpath[88] = 0;
    options.sarifpath[89] = 0;
    options.sarifpath[90] = 0;
    options.sarifpath[91] = 0;
    options.sarifpath[92] = 0;
    options.sarifpath[93] = 0;
    options.sarifpath[94] = 0;
    options.sarifpath[95] = 0;
    options.sarifpath[96] = 0;
    options.sarifpath[97] = 0;
    options.sarifpath[98] = 0;
    options.sarifpath[99] = 0;
    options.sarifpath[100] = 0;
    options.sarifpath[101] = 0;
    options.sarifpath[102] = 0;
    options.sarifpath[103] = 0;
    options.sarifpath[104] = 0;
    options.sarifpath[105] = 0;
    options.sarifpath[106] = 0;
    options.sarifpath[107] = 0;
    options.sarifpath[108] = 0;
    options.sarifpath[109] = 0;
    options.sarifpath[110] = 0;
    options.sarifpath[111] = 0;
    options.sarifpath[112] = 0;
    options.sarifpath[113] = 0;
    options.sarifpath[114] = 0;
    options.sarifpath[115] = 0;
    options.sarifpath[116] = 0;
    options.sarifpath[117] = 0;
    options.sarifpath[118] = 0;
    options.sarifpath[119] = 0;
    options.sarifpath[120] = 0;
    options.sarifpath[121] = 0;
    options.sarifpath[122] = 0;
    options.sarifpath[123] = 0;
    options.sarifpath[124] = 0;
    options.sarifpath[125] = 0;
    options.sarifpath[126] = 0;
    options.sarifpath[127] = 0;
    options.sarifpath[128] = 0;
    options.sarifpath[129] = 0;
    options.sarifpath[130] = 0;
    options.sarifpath[131] = 0;
    options.sarifpath[132] = 0;
    options.sarifpath[133] = 0;
    options.sarifpath[134] = 0;
    options.sarifpath[135] = 0;
    options.sarifpath[136] = 0;
    options.sarifpath[137] = 0;
    options.sarifpath[138] = 0;
    options.sarifpath[139] = 0;
    options.sarifpath[140] = 0;
    options.sarifpath[141] = 0;
    options.sarifpath[142] = 0;
    options.sarifpath[143] = 0;
    options.sarifpath[144] = 0;
    options.sarifpath[145] = 0;
    options.sarifpath[146] = 0;
    options.sarifpath[147] = 0;
    options.sarifpath[148] = 0;
    options.sarifpath[149] = 0;
    options.sarifpath[150] = 0;
    options.sarifpath[151] = 0;
    options.sarifpath[152] = 0;
    options.sarifpath[153] = 0;
    options.sarifpath[154] = 0;
    options.sarifpath[155] = 0;
    options.sarifpath[156] = 0;
    options.sarifpath[157] = 0;
    options.sarifpath[158] = 0;
    options.sarifpath[159] = 0;
    options.sarifpath[160] = 0;
    options.sarifpath[161] = 0;
    options.sarifpath[162] = 0;
    options.sarifpath[163] = 0;
    options.sarifpath[164] = 0;
    options.sarifpath[165] = 0;
    options.sarifpath[166] = 0;
    options.sarifpath[167] = 0;
    options.sarifpath[168] = 0;
    options.sarifpath[169] = 0;
    options.sarifpath[170] = 0;
    options.sarifpath[171] = 0;
    options.sarifpath[172] = 0;
    options.sarifpath[173] = 0;
    options.sarifpath[174] = 0;
    options.sarifpath[175] = 0;
    options.sarifpath[176] = 0;
    options.sarifpath[177] = 0;
    options.sarifpath[178] = 0;
    options.sarifpath[179] = 0;
    options.sarifpath[180] = 0;
    options.sarifpath[181] = 0;
    options.sarifpath[182] = 0;
    options.sarifpath[183] = 0;
    options.sarifpath[184] = 0;
    options.sarifpath[185] = 0;
    options.sarifpath[186] = 0;
    options.sarifpath[187] = 0;
    options.sarifpath[188] = 0;
    options.sarifpath[189] = 0;
    options.sarifpath[190] = 0;
    options.sarifpath[191] = 0;
    options.sarifpath[192] = 0;
    options.sarifpath[193] = 0;
    options.sarifpath[194] = 0;
    options.sarifpath[195] = 0;
    options.sarifpath[196] = 0;
    options.sarifpath[197] = 0;
    options.sarifpath[198] = 0;
    options.sarifpath[199] = 0;
    if (1) /*try*/
    {
        if (fill_options(&options, argc, argv) != 0)
        {
            goto __L0; /* throw */
        }
        prectx.options = options;
        add_standard_macros(&prectx, options.target);
        if (options.preprocess_only)
        {
            struct tokenizer_ctx  tctx;
            struct token_list  tokens;
            struct token_list  token_list;

            _cake_zmem(&tctx, 928);
            tokens = tokenizer(&tctx, content, "c:/main.c", 0, 0);
            token_list = preprocessor(&prectx, &tokens, 0);
            if (prectx.n_errors == 0)
            {
                s = print_preprocessed_to_string2(token_list.head);
            }
            token_list_destroy(&tokens);
            token_list_destroy(&token_list);
        }
        else
        {
            struct osstream  ss;
            struct d_visit_ctx  ctx2;

            ast = get_ast(&options, "c:/main.c", content, report);
            if (report->error_count > 0)
            {
                goto __L0; /* throw */
            }
            _cake_zmem(&ss, 12);
            _cake_zmem(&ctx2, 1072);
            ctx2.ast = ast;
            ctx2.options = options;
            d_visit(&ctx2, &ss);
            s = ss.c_str;
            d_visit_ctx_destroy(&ctx2);
        }
    }
    else __L0: /*catch*/ 
    {
    }
    preprocessor_ctx_destroy(&prectx);
    ast_destroy(&ast);
    return s;
}



static int strtoargv(char * s, int n, char *argv[])
{
    int argvc;
    char * p;

    argvc = 0;
    p = s;
    while (*p)
    {
        while (*p == 32)
        p++;
        if (*p == 0)
        {
            break;
        }
        argv[argvc] = p;
        argvc++;
        while (*p != 32 && *p != 0)
        p++;
        if (*p == 0)
        {
            break;
        }
        *p = 0;
        p++;
        if (argvc >= n)
        {
            break;
        }
    }
    return argvc;
}
char *CompileText(char * pszoptions, char * content)
{
    struct report  report;
    char * s;

    printf("\x1b[97mcake %s main.c\n", pszoptions);
    printf("\x1b[97mCake 0.12.56\x1b[0m\n");
    _cake_zmem(&report, 48);
    s = (char *)compile_source(pszoptions, content, &report);
    return s;
}


static void defer_visit_init_declarator_list(struct defer_visit_ctx * ctx, struct init_declarator_list * p_init_declarator_list);
static void defer_visit_init_declarator(struct defer_visit_ctx * ctx, struct init_declarator * p_init_declarator);
static void defer_visit_declarator(struct defer_visit_ctx * ctx, struct declarator * p_declarator);
static struct defer_defer_scope *defer_visit_ctx_push_child(struct defer_visit_ctx * ctx);
static void defer_visit_direct_declarator(struct defer_visit_ctx * ctx, struct direct_declarator * p_direct_declarator);
static void defer_visit_compound_statement(struct defer_visit_ctx * ctx, struct compound_statement * p_compound_statement);
static struct defer_defer_scope *defer_visit_ctx_push_tail_block(struct defer_visit_ctx * ctx);
static void defer_visit_block_item_list(struct defer_visit_ctx * ctx, struct block_item_list * p_block_item_list);
static void defer_visit_block_item(struct defer_visit_ctx * ctx, struct block_item * p_block_item);
static void defer_visit_unlabeled_statement(struct defer_visit_ctx * ctx, struct unlabeled_statement * p_unlabeled_statement);
static void defer_visit_primary_block(struct defer_visit_ctx * ctx, struct primary_block * p_primary_block);
static void defer_visit_defer_statement(struct defer_visit_ctx * ctx, struct defer_statement * p_defer_statement);
static void defer_visit_iteration_statement(struct defer_visit_ctx * ctx, struct iteration_statement * p_iteration_statement);
static void defer_visit_while_statement(struct defer_visit_ctx * ctx, struct iteration_statement * p_iteration_statement);
static void defer_visit_secondary_block(struct defer_visit_ctx * ctx, struct secondary_block * p_secondary_block);
static void defer_visit_statement(struct defer_visit_ctx * ctx, struct statement * p_statement);
static void defer_visit_labeled_statement(struct defer_visit_ctx * ctx, struct labeled_statement * p_labeled_statement);
static void defer_exit_block_visit(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, struct token * position_token, struct defer_list * p_defer_list);
static void defer_visit_ctx_pop_tail_block(struct defer_visit_ctx * ctx);
static void defer_defer_scope_delete_one(struct defer_defer_scope * p);
static void defer_visit_do_while_statement(struct defer_visit_ctx * ctx, struct iteration_statement * p_iteration_statement);
static void defer_visit_for_statement(struct defer_visit_ctx * ctx, struct iteration_statement * p_iteration_statement);
static void defer_visit_selection_statement(struct defer_visit_ctx * ctx, struct selection_statement * p_selection_statement);
static void defer_visit_if_statement(struct defer_visit_ctx * ctx, struct selection_statement * p_selection_statement);
static void defer_visit_simple_declaration(struct defer_visit_ctx * ctx, struct simple_declaration * p_simple_declaration);
static void defer_visit_switch_statement(struct defer_visit_ctx * ctx, struct selection_statement * p_selection_statement);
static void defer_visit_try_statement(struct defer_visit_ctx * ctx, struct try_statement * p_try_statement);
static void defer_visit_expression_statement(struct defer_visit_ctx * ctx, struct expression_statement * p_expression_statement);
static void defer_visit_expression(struct defer_visit_ctx * ctx, struct expression * p_expression);
static void defer_visit_jump_statement(struct defer_visit_ctx * ctx, struct jump_statement * p_jump_statement);
static void defer_check_all_defer_until_try(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, struct token * position_token, struct defer_list * p_defer_list);
static void defer_exit_function_visit(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, struct token * position_token, struct defer_list * p_defer_list);
static void defer_check_all_defer_until_iter(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, struct token * position_token, struct defer_list * p_defer_list);
static void defer_exit_iteration_or_switch_statement_visit(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, struct token * position_token, struct defer_list * p_defer_list);
static void defer_check_all_defer_until_label(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, char * label, struct token * position_token, struct defer_list * p_defer_list);
static unsigned char defer_find_label_scope(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, char * label);
static unsigned char defer_find_label_statement(struct defer_visit_ctx * ctx, struct statement * statement, char * label);
static unsigned char defer_find_label_unlabeled_statement(struct defer_visit_ctx * ctx, struct unlabeled_statement * p_unlabeled_statement, char * label);
static unsigned char defer_find_label_block_item_list(struct defer_visit_ctx * ctx, struct block_item_list * p_block_item, char * label);

void defer_visit_declaration(struct defer_visit_ctx * ctx, struct declaration * p_declaration)
{
    if (p_declaration->init_declarator_list.head)
    {
        defer_visit_init_declarator_list(ctx, &p_declaration->init_declarator_list);
    }
    if (p_declaration->function_body)
    {
        defer_visit_compound_statement(ctx, p_declaration->function_body);
    }
}



static struct defer_defer_scope *defer_visit_ctx_push_child(struct defer_visit_ctx * ctx)
{
    struct defer_defer_scope * child;

    if (ctx->tail_block == 0)
    {
        return 0;
    }
    child = calloc(1, 48);
    if (child)
    {
        child->previous = ctx->tail_block->last_child;
        ctx->tail_block->last_child = child;
    }
    else
    {
    }
    return ctx->tail_block->last_child;
}

static void defer_visit_direct_declarator(struct defer_visit_ctx * ctx, struct direct_declarator * p_direct_declarator)
{
    if (p_direct_declarator->function_declarator)
    {
        struct parameter_declaration * parameter;

        parameter = 0;
        if (p_direct_declarator->function_declarator->parameter_type_list_opt && p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list)
        {
            parameter = p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head;
        }
        ctx->parameter_list++;
        while (parameter)
        {
            if (parameter->declarator)
            {
                defer_visit_declarator(ctx, parameter->declarator);
            }
            parameter = parameter->next;
        }
        ctx->parameter_list--;
    }
    else
    {
        if (p_direct_declarator->array_declarator)
        {
        }
    }
}

static void defer_visit_declarator(struct defer_visit_ctx * ctx, struct declarator * p_declarator)
{
    if (1) /*try*/
    {
        if (ctx->tail_block && p_declarator->type.category != 1)
        {
            struct defer_defer_scope * p_defer;

            if (ctx->parameter_list > 1)
            {
                return;
            }
            p_defer = defer_visit_ctx_push_child(ctx);
            if (p_defer == 0)
            {
                goto __L0; /* throw */
            }
            p_defer->declarator = p_declarator;
        }
        if (p_declarator->direct_declarator)
        {
            defer_visit_direct_declarator(ctx, p_declarator->direct_declarator);
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void defer_visit_init_declarator(struct defer_visit_ctx * ctx, struct init_declarator * p_init_declarator)
{
    defer_visit_declarator(ctx, p_init_declarator->p_declarator);
}

static void defer_visit_init_declarator_list(struct defer_visit_ctx * ctx, struct init_declarator_list * p_init_declarator_list)
{
    struct init_declarator * p_init_declarator;

    p_init_declarator = p_init_declarator_list->head;
    while (p_init_declarator)
    {
        defer_visit_init_declarator(ctx, p_init_declarator);
        p_init_declarator = p_init_declarator->next;
    }
}

static struct defer_defer_scope *defer_visit_ctx_push_tail_block(struct defer_visit_ctx * ctx)
{
    struct defer_defer_scope * p_block;

    p_block = calloc(1, 48);
    if (p_block)
    {
        p_block->previous = ctx->tail_block;
        ctx->tail_block = p_block;
    }
    else
    {
    }
    return ctx->tail_block;
}

static void defer_visit_defer_statement(struct defer_visit_ctx * ctx, struct defer_statement * p_defer_statement)
{
    struct defer_defer_scope * p_defer;

    p_defer = defer_visit_ctx_push_child(ctx);
    if (p_defer)
    {
        p_defer->defer_statement = p_defer_statement;
    }
}

static void defer_visit_labeled_statement(struct defer_visit_ctx * ctx, struct labeled_statement * p_labeled_statement)
{
    defer_visit_statement(ctx, p_labeled_statement->statement);
}

static void defer_visit_statement(struct defer_visit_ctx * ctx, struct statement * p_statement)
{
    if (p_statement->labeled_statement)
    {
        defer_visit_labeled_statement(ctx, p_statement->labeled_statement);
    }
    else
    {
        if (p_statement->unlabeled_statement)
        {
            defer_visit_unlabeled_statement(ctx, p_statement->unlabeled_statement);
        }
    }
}

static void defer_visit_secondary_block(struct defer_visit_ctx * ctx, struct secondary_block * p_secondary_block)
{
    defer_visit_statement(ctx, p_secondary_block->statement);
}

static void defer_exit_block_visit(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, struct token * position_token, struct defer_list * p_defer_list)
{
    if (1) /*try*/
    {
        struct defer_defer_scope * deferchild;

        deferchild = deferblock->last_child;
        while (deferchild != 0)
        {
            if (deferchild->defer_statement)
            {
                struct defer_list_item * p_item;

                p_item = calloc(1, 12);
                if (p_item == 0)
                {
                    goto __L0; /* throw */
                }
                p_item->defer_statement = deferchild->defer_statement;
                defer_list_add(p_defer_list, p_item);
                defer_visit_secondary_block(ctx, deferchild->defer_statement->secondary_block);
            }
            else
            {
                if (deferchild->declarator)
                {
                    struct defer_list_item * p_item;

                    p_item = calloc(1, 12);
                    if (p_item == 0)
                    {
                        goto __L0; /* throw */
                    }
                    p_item->declarator = deferchild->declarator;
                    defer_list_add(p_defer_list, p_item);
                }
            }
            deferchild = deferchild->previous;
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void defer_defer_scope_delete_one(struct defer_defer_scope * p)
{
    struct defer_defer_scope * p_block;
    struct defer_defer_scope * child;

    p_block = p;
    child = p_block->last_child;
    while (child != 0)
    {
        struct defer_defer_scope * previous;

        previous = child->previous;
        child->previous = 0;
        defer_defer_scope_delete_one(child);
        child = previous;
    }
    ;
    free(p_block);
}

static void defer_visit_ctx_pop_tail_block(struct defer_visit_ctx * ctx)
{
    if (ctx->tail_block)
    {
        struct defer_defer_scope * previous;

        previous = ctx->tail_block->previous;
        ctx->tail_block->previous = 0;
        defer_defer_scope_delete_one(ctx->tail_block);
        ctx->tail_block = previous;
    }
}

static void defer_visit_while_statement(struct defer_visit_ctx * ctx, struct iteration_statement * p_iteration_statement)
{
    struct defer_defer_scope * p_defer;

    ;
    if (p_iteration_statement->expression1 == 0)
    {
        return;
    }
    p_defer = defer_visit_ctx_push_tail_block(ctx);
    if (p_defer == 0)
    {
        return;
    }
    p_defer->p_iteration_statement = p_iteration_statement;
    defer_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
    defer_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
    defer_exit_block_visit(ctx, p_defer, p_iteration_statement->secondary_block->last_token, &p_iteration_statement->defer_list);
    defer_visit_ctx_pop_tail_block(ctx);
}

static void defer_visit_do_while_statement(struct defer_visit_ctx * ctx, struct iteration_statement * p_iteration_statement)
{
    ;
    if (1) /*try*/
    {
        struct defer_defer_scope * p_defer;

        p_defer = defer_visit_ctx_push_tail_block(ctx);
        if (p_defer == 0)
        {
            goto __L0; /* throw */
        }
        p_defer->p_iteration_statement = p_iteration_statement;
        defer_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
        defer_exit_block_visit(ctx, p_defer, p_iteration_statement->secondary_block->last_token, &p_iteration_statement->defer_list);
        defer_visit_ctx_pop_tail_block(ctx);
    }
    else __L0: /*catch*/ 
    {
    }
}

static void defer_visit_for_statement(struct defer_visit_ctx * ctx, struct iteration_statement * p_iteration_statement)
{
    ;
    if (1) /*try*/
    {
        struct defer_defer_scope * p_defer;
        unsigned char  b_secondary_block_ends_with_jump;

        if (p_iteration_statement->declaration && p_iteration_statement->declaration->init_declarator_list.head)
        {
            defer_visit_init_declarator_list(ctx, &p_iteration_statement->declaration->init_declarator_list);
        }
        p_defer = defer_visit_ctx_push_tail_block(ctx);
        if (p_defer == 0)
        {
            goto __L0; /* throw */
        }
        p_defer->p_iteration_statement = p_iteration_statement;
        defer_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
        defer_visit_ctx_pop_tail_block(ctx);
        b_secondary_block_ends_with_jump = secondary_block_ends_with_jump(p_iteration_statement->secondary_block);
        if (!b_secondary_block_ends_with_jump)
        {
            struct defer_defer_scope * p_defer2;

            p_defer2 = defer_visit_ctx_push_tail_block(ctx);
            if (p_defer2 == 0)
            {
                goto __L0; /* throw */
            }
            p_defer2->p_iteration_statement = p_iteration_statement;
            defer_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
            defer_exit_block_visit(ctx, p_defer2, p_iteration_statement->secondary_block->last_token, &p_iteration_statement->defer_list);
            defer_visit_ctx_pop_tail_block(ctx);
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void defer_visit_iteration_statement(struct defer_visit_ctx * ctx, struct iteration_statement * p_iteration_statement)
{
    /*switch*/
    {
        int __v0 = p_iteration_statement->first_token->type;
        if (__v0 == 9042) goto __L1; /*case 9042*/
        if (__v0 == 9008) goto __L2; /*case 9008*/
        if (__v0 == 9015) goto __L3; /*case 9015*/
        goto __L4; /* default */

        {
            __L1: /*case 9042*/ 
            defer_visit_while_statement(ctx, p_iteration_statement);
            goto __L0; /* break */

            __L2: /*case 9008*/ 
            defer_visit_do_while_statement(ctx, p_iteration_statement);
            goto __L0; /* break */

            __L3: /*case 9015*/ 
            defer_visit_for_statement(ctx, p_iteration_statement);
            goto __L0; /* break */

            __L4: /* default */ 
            ;
            goto __L0; /* break */

        }
        __L0:;
    }
}

static void defer_visit_simple_declaration(struct defer_visit_ctx * ctx, struct simple_declaration * p_simple_declaration)
{
    defer_visit_init_declarator_list(ctx, &p_simple_declaration->init_declarator_list);
}

static void defer_visit_if_statement(struct defer_visit_ctx * ctx, struct selection_statement * p_selection_statement)
{
    struct defer_defer_scope * p_defer;

    p_defer = defer_visit_ctx_push_tail_block(ctx);
    if (p_defer == 0)
    {
        return;
    }
    p_defer->p_selection_statement = p_selection_statement;
    if (p_selection_statement->p_init_statement && p_selection_statement->p_init_statement->p_simple_declaration)
    {
        defer_visit_simple_declaration(ctx, p_selection_statement->p_init_statement->p_simple_declaration);
    }
    if (p_selection_statement->condition && p_selection_statement->condition->p_init_declarator)
    {
        defer_visit_init_declarator(ctx, p_selection_statement->condition->p_init_declarator);
    }
    ;
    defer_visit_secondary_block(ctx, p_selection_statement->secondary_block);
    if (p_selection_statement->else_secondary_block_opt)
    {
        defer_visit_secondary_block(ctx, p_selection_statement->else_secondary_block_opt);
    }
    defer_exit_block_visit(ctx, p_defer, p_selection_statement->last_token, &p_selection_statement->defer_list);
    defer_visit_ctx_pop_tail_block(ctx);
}

static void defer_visit_switch_statement(struct defer_visit_ctx * ctx, struct selection_statement * p_selection_statement)
{
    struct defer_defer_scope * p_defer;

    p_defer = defer_visit_ctx_push_tail_block(ctx);
    if (p_defer == 0)
    {
        return;
    }
    p_defer->p_selection_statement = p_selection_statement;
    defer_visit_secondary_block(ctx, p_selection_statement->secondary_block);
    defer_exit_block_visit(ctx, p_defer, p_selection_statement->secondary_block->last_token, &p_selection_statement->defer_list);
    defer_visit_ctx_pop_tail_block(ctx);
}

static void defer_visit_selection_statement(struct defer_visit_ctx * ctx, struct selection_statement * p_selection_statement)
{
    if (p_selection_statement->first_token->type == 9017)
    {
        defer_visit_if_statement(ctx, p_selection_statement);
    }
    else
    {
        if (p_selection_statement->first_token->type == 9034)
        {
            defer_visit_switch_statement(ctx, p_selection_statement);
        }
        else
        {
            ;
        }
    }
}

static void defer_visit_try_statement(struct defer_visit_ctx * ctx, struct try_statement * p_try_statement)
{
    if (1) /*try*/
    {
        struct secondary_block * catch_secondary_block_old;
        struct defer_defer_scope * p_defer;

        catch_secondary_block_old = ctx->catch_secondary_block_opt;
        ctx->catch_secondary_block_opt = p_try_statement->catch_secondary_block_opt;
        p_defer = defer_visit_ctx_push_tail_block(ctx);
        if (p_defer == 0)
        {
            goto __L0; /* throw */
        }
        p_defer->p_try_statement = p_try_statement;
        defer_visit_secondary_block(ctx, p_try_statement->secondary_block);
        if (p_try_statement->catch_secondary_block_opt)
        {
            defer_visit_secondary_block(ctx, p_try_statement->catch_secondary_block_opt);
        }
        defer_visit_ctx_pop_tail_block(ctx);
        ctx->catch_secondary_block_opt = catch_secondary_block_old;
    }
    else __L0: /*catch*/ 
    {
    }
}

static void defer_visit_primary_block(struct defer_visit_ctx * ctx, struct primary_block * p_primary_block)
{
    if (p_primary_block->defer_statement)
    {
        defer_visit_defer_statement(ctx, p_primary_block->defer_statement);
    }
    else
    {
        if (p_primary_block->compound_statement)
        {
            defer_visit_compound_statement(ctx, p_primary_block->compound_statement);
        }
        else
        {
            if (p_primary_block->iteration_statement)
            {
                defer_visit_iteration_statement(ctx, p_primary_block->iteration_statement);
            }
            else
            {
                if (p_primary_block->selection_statement)
                {
                    defer_visit_selection_statement(ctx, p_primary_block->selection_statement);
                }
                else
                {
                    if (p_primary_block->try_statement)
                    {
                        defer_visit_try_statement(ctx, p_primary_block->try_statement);
                    }
                }
            }
        }
    }
}

static void defer_visit_expression(struct defer_visit_ctx * ctx, struct expression * p_expression)
{
    if (p_expression->condition_expr)
    {
        defer_visit_expression(ctx, p_expression->condition_expr);
    }
    if (p_expression->left)
    {
        defer_visit_expression(ctx, p_expression->left);
    }
    if (p_expression->right)
    {
        defer_visit_expression(ctx, p_expression->right);
    }
    /*switch*/
    {
        int __v0 = p_expression->expression_type;
        if (__v0 == 10) goto __L4; /*case 10*/
        goto __L5; /* default */

        {
            __L4: /*case 10*/ 
            {
                ;
                defer_visit_compound_statement(ctx, p_expression->compound_statement);
            }
            goto __L3; /* break */

            __L5: /* default */ 
            goto __L3; /* break */

        }
        __L3:;
    }
}

static void defer_visit_expression_statement(struct defer_visit_ctx * ctx, struct expression_statement * p_expression_statement)
{
    if (p_expression_statement->expression_opt)
    {
        defer_visit_expression(ctx, p_expression_statement->expression_opt);
    }
}

static void defer_check_all_defer_until_try(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, struct token * position_token, struct defer_list * p_defer_list)
{
    struct defer_defer_scope * p_defer;

    p_defer = deferblock;
    while (p_defer != 0)
    {
        defer_exit_block_visit(ctx, p_defer, position_token, p_defer_list);
        if (p_defer->p_try_statement)
        {
            break;
        }
        p_defer = p_defer->previous;
    }
}

static void defer_exit_function_visit(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, struct token * position_token, struct defer_list * p_defer_list)
{
    struct defer_defer_scope * p_defer;

    p_defer = deferblock;
    while (p_defer != 0)
    {
        defer_exit_block_visit(ctx, p_defer, position_token, p_defer_list);
        p_defer = p_defer->previous;
    }
}

static void defer_check_all_defer_until_iter(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, struct token * position_token, struct defer_list * p_defer_list)
{
    struct defer_defer_scope * p_defer;

    p_defer = deferblock;
    while (p_defer != 0)
    {
        defer_exit_block_visit(ctx, p_defer, position_token, p_defer_list);
        if (p_defer->p_iteration_statement)
        {
            break;
        }
        p_defer = p_defer->previous;
    }
}

static void defer_exit_iteration_or_switch_statement_visit(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, struct token * position_token, struct defer_list * p_defer_list)
{
    struct defer_defer_scope * p_defer;

    p_defer = deferblock;
    while (p_defer != 0)
    {
        defer_exit_block_visit(ctx, p_defer, position_token, p_defer_list);
        if (p_defer->p_iteration_statement)
        {
            break;
        }
        if (p_defer->p_selection_statement && p_defer->p_selection_statement->first_token->type == 9034)
        {
            break;
        }
        p_defer = p_defer->previous;
    }
}

static unsigned char defer_find_label_block_item_list(struct defer_visit_ctx * ctx, struct block_item_list * p_block_item, char * label)
{
    struct block_item * block_item;

    block_item = p_block_item->head;
    while (block_item)
    {
        if (block_item->label && block_item->label->p_identifier_opt && strcmp(block_item->label->p_identifier_opt->lexeme, label) == 0)
        {
            return 1;
        }
        else
        {
            if (block_item->unlabeled_statement)
            {
                if (defer_find_label_unlabeled_statement(ctx, block_item->unlabeled_statement, label))
                {
                    return 1;
                }
            }
        }
        block_item = block_item->next;
    }
    return 0;
}

static unsigned char defer_find_label_unlabeled_statement(struct defer_visit_ctx * ctx, struct unlabeled_statement * p_unlabeled_statement, char * label)
{
    if (p_unlabeled_statement->primary_block)
    {
        if (p_unlabeled_statement->primary_block->compound_statement)
        {
            if (defer_find_label_block_item_list(ctx, &p_unlabeled_statement->primary_block->compound_statement->block_item_list, label))
            {
                return 1;
            }
        }
        else
        {
            if (p_unlabeled_statement->primary_block->selection_statement)
            {
                if (defer_find_label_statement(ctx, p_unlabeled_statement->primary_block->selection_statement->secondary_block->statement, label))
                {
                    return 1;
                }
                if (p_unlabeled_statement->primary_block->selection_statement->else_secondary_block_opt)
                {
                    if (defer_find_label_statement(ctx, p_unlabeled_statement->primary_block->selection_statement->else_secondary_block_opt->statement, label))
                    {
                        return 1;
                    }
                }
            }
            else
            {
                if (p_unlabeled_statement->primary_block->try_statement)
                {
                    if (defer_find_label_statement(ctx, p_unlabeled_statement->primary_block->try_statement->secondary_block->statement, label))
                    {
                        return 1;
                    }
                    if (p_unlabeled_statement->primary_block->try_statement->catch_secondary_block_opt)
                    {
                        if (defer_find_label_statement(ctx, p_unlabeled_statement->primary_block->try_statement->catch_secondary_block_opt->statement, label))
                        {
                            return 1;
                        }
                    }
                }
                else
                {
                    if (p_unlabeled_statement->primary_block->iteration_statement)
                    {
                        if (defer_find_label_statement(ctx, p_unlabeled_statement->primary_block->iteration_statement->secondary_block->statement, label))
                        {
                            return 1;
                        }
                    }
                }
            }
        }
    }
    return 0;
}

static unsigned char defer_find_label_statement(struct defer_visit_ctx * ctx, struct statement * statement, char * label)
{
    if (statement->labeled_statement && statement->labeled_statement->label->p_identifier_opt)
    {
        if (strcmp(statement->labeled_statement->label->p_identifier_opt->lexeme, label) == 0)
        {
            return 1;
        }
    }
    else
    {
        if (statement->unlabeled_statement)
        {
            if (defer_find_label_unlabeled_statement(ctx, statement->unlabeled_statement, label))
            {
                return 1;
            }
        }
    }
    return 0;
}

static unsigned char defer_find_label_scope(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, char * label)
{
    if (deferblock->p_iteration_statement)
    {
        if (defer_find_label_statement(ctx, deferblock->p_iteration_statement->secondary_block->statement, label))
        {
            return 1;
        }
    }
    else
    {
        if (deferblock->p_selection_statement)
        {
            if (defer_find_label_statement(ctx, deferblock->p_selection_statement->secondary_block->statement, label))
            {
                return 1;
            }
            if (deferblock->p_selection_statement->else_secondary_block_opt)
            {
                if (defer_find_label_statement(ctx, deferblock->p_selection_statement->else_secondary_block_opt->statement, label))
                {
                    return 1;
                }
            }
        }
        else
        {
            if (deferblock->p_try_statement)
            {
                if (defer_find_label_statement(ctx, deferblock->p_try_statement->secondary_block->statement, label))
                {
                    return 1;
                }
                if (deferblock->p_try_statement->catch_secondary_block_opt)
                {
                    if (defer_find_label_statement(ctx, deferblock->p_try_statement->catch_secondary_block_opt->statement, label))
                    {
                        return 1;
                    }
                }
            }
            else
            {
                if (deferblock->p_statement)
                {
                    if (defer_find_label_statement(ctx, deferblock->p_statement, label))
                    {
                        return 1;
                    }
                }
                else
                {
                    if (deferblock->p_function_body)
                    {
                        if (defer_find_label_block_item_list(ctx, &deferblock->p_function_body->block_item_list, label))
                        {
                            return 1;
                        }
                    }
                    else
                    {
                        if (deferblock->p_compound_statement)
                        {
                            if (defer_find_label_block_item_list(ctx, &deferblock->p_compound_statement->block_item_list, label))
                            {
                                return 1;
                            }
                        }
                    }
                }
            }
        }
    }
    return 0;
}

static void defer_check_all_defer_until_label(struct defer_visit_ctx * ctx, struct defer_defer_scope * deferblock, char * label, struct token * position_token, struct defer_list * p_defer_list)
{
    struct defer_defer_scope * p_defer;

    p_defer = deferblock;
    while (p_defer != 0)
    {
        if (!defer_find_label_scope(ctx, p_defer, label))
        {
            defer_exit_block_visit(ctx, p_defer, position_token, p_defer_list);
        }
        else
        {
            break;
        }
        p_defer = p_defer->previous;
    }
}

static void defer_visit_jump_statement(struct defer_visit_ctx * ctx, struct jump_statement * p_jump_statement)
{
    ;
    if (1) /*try*/
    {
        if (p_jump_statement->first_token->type == 9037)
        {
            defer_check_all_defer_until_try(ctx, ctx->tail_block, p_jump_statement->first_token, &p_jump_statement->defer_list);
        }
        else
        {
            if (p_jump_statement->first_token->type == 9027)
            {
                defer_exit_function_visit(ctx, ctx->tail_block, p_jump_statement->first_token, &p_jump_statement->defer_list);
            }
            else
            {
                if (p_jump_statement->first_token->type == 9005)
                {
                    defer_check_all_defer_until_iter(ctx, ctx->tail_block, p_jump_statement->first_token, &p_jump_statement->defer_list);
                }
                else
                {
                    if (p_jump_statement->first_token->type == 9000)
                    {
                        defer_exit_iteration_or_switch_statement_visit(ctx, ctx->tail_block, p_jump_statement->first_token, &p_jump_statement->defer_list);
                    }
                    else
                    {
                        if (p_jump_statement->first_token->type == 9016)
                        {
                            ;
                            defer_check_all_defer_until_label(ctx, ctx->tail_block, p_jump_statement->label->lexeme, p_jump_statement->first_token, &p_jump_statement->defer_list);
                        }
                        else
                        {
                            ;
                            goto __L0; /* throw */
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void defer_visit_unlabeled_statement(struct defer_visit_ctx * ctx, struct unlabeled_statement * p_unlabeled_statement)
{
    if (p_unlabeled_statement->primary_block)
    {
        defer_visit_primary_block(ctx, p_unlabeled_statement->primary_block);
    }
    else
    {
        if (p_unlabeled_statement->expression_statement)
        {
            defer_visit_expression_statement(ctx, p_unlabeled_statement->expression_statement);
        }
        else
        {
            if (p_unlabeled_statement->jump_statement)
            {
                defer_visit_jump_statement(ctx, p_unlabeled_statement->jump_statement);
            }
            else
            {
                ;
            }
        }
    }
}

static void defer_visit_block_item(struct defer_visit_ctx * ctx, struct block_item * p_block_item)
{
    if (p_block_item->declaration)
    {
        defer_visit_declaration(ctx, p_block_item->declaration);
    }
    else
    {
        if (p_block_item->unlabeled_statement)
        {
            defer_visit_unlabeled_statement(ctx, p_block_item->unlabeled_statement);
        }
        else
        {
            if (p_block_item->label)
            {
            }
        }
    }
}

static void defer_visit_block_item_list(struct defer_visit_ctx * ctx, struct block_item_list * p_block_item_list)
{
    struct block_item * p_block_item;

    p_block_item = p_block_item_list->head;
    while (p_block_item)
    {
        defer_visit_block_item(ctx, p_block_item);
        p_block_item = p_block_item->next;
    }
}

static void defer_visit_compound_statement(struct defer_visit_ctx * ctx, struct compound_statement * p_compound_statement)
{
    struct defer_defer_scope * p_defer;

    p_defer = defer_visit_ctx_push_tail_block(ctx);
    if (p_defer == 0)
    {
        return;
    }
    p_defer->p_compound_statement = p_compound_statement;
    defer_visit_block_item_list(ctx, &p_compound_statement->block_item_list);
    defer_exit_block_visit(ctx, p_defer, p_compound_statement->last_token, &p_compound_statement->defer_list);
    defer_visit_ctx_pop_tail_block(ctx);
}
void defer_start_visit_declaration(struct defer_visit_ctx * ctx, struct declaration * p_declaration)
{
    if (p_declaration->function_body)
    {
        struct defer_defer_scope * p_defer;

        ;
        p_defer = defer_visit_ctx_push_tail_block(ctx);
        if (p_defer == 0)
        {
            return;
        }
        p_defer->p_function_body = p_declaration->function_body;
        defer_visit_declaration(ctx, p_declaration);
        ;
        if (ctx->tail_block)
        {
            defer_exit_block_visit(ctx, ctx->tail_block, p_declaration->function_body->last_token, &p_declaration->defer_list);
        }
        defer_visit_ctx_pop_tail_block(ctx);
    }
    else
    {
        struct defer_defer_scope * p_defer;

        p_defer = defer_visit_ctx_push_tail_block(ctx);
        if (p_defer == 0)
        {
            return;
        }
        defer_visit_declaration(ctx, p_declaration);
        defer_visit_ctx_pop_tail_block(ctx);
    }
}


void defer_visit_ctx_destroy(struct defer_visit_ctx * p)
{
    ;
}


void d_visit_ctx_destroy(struct d_visit_ctx * ctx)
{
    hashmap_destroy(&ctx->tag_names);
    hashmap_destroy(&ctx->structs_map);
    hashmap_destroy(&ctx->file_scope_declarator_map);
    hashmap_destroy(&ctx->instantiated_function_literals);
    ss_close(&ctx->block_scope_declarators);
    ss_close(&ctx->add_this_before);
    ss_close(&ctx->add_this_before_external_decl);
    ss_close(&ctx->add_this_after_external_decl);
}


void struct_entry_delete(struct struct_entry * p)
{
    if (p)
    {
        free(p->hard_dependencies.data);
        free(p->soft_dependencies.data);
        free(p);
    }
}


int struct_entry_list_reserve(struct struct_entry_list * p, int n)
{
    if (n > p->capacity)
    {
        void * pnew;

        if ((unsigned int)n > 1073741823)
        {
            return 132;
        }
        pnew = realloc(p->data, n * 4);
        if (pnew == 0)
        {
            return 12;
        }
        p->data = pnew;
        p->capacity = n;
    }
    return 0;
}


int struct_entry_list_push_back(struct struct_entry_list * p, struct struct_entry * book)
{
    if (p->size == 2147483647)
    {
        return 132;
    }
    if (p->size + 1 > p->capacity)
    {
        int new_capacity;
        int error;

        new_capacity = 0;
        if (p->capacity > (2147483647 - p->capacity / 2))
        {
            new_capacity = 2147483647;
        }
        else
        {
            new_capacity = p->capacity + p->capacity / 2;
            if (new_capacity < p->size + 1)
            {
                new_capacity = p->size + 1;
            }
        }
        error = struct_entry_list_reserve(p, new_capacity);
        if (error != 0)
        {
            return error;
        }
    }
    p->data[p->size] = book;
    p->size++;
    return 0;
}


static void d_print_struct(struct d_visit_ctx * ctx, struct osstream * ss, struct struct_or_union_specifier * p_struct_or_union_specifier);
static struct struct_or_union_specifier *get_complete_struct_or_union_specifier2(struct struct_or_union_specifier * p_struct_or_union_specifier);
static void d_print_type(struct d_visit_ctx * ctx, struct osstream * ss, struct type * p_type, char * name_opt, unsigned char  print_storage_qualifier);
static void register_struct_types_and_functions(struct d_visit_ctx * ctx, struct type * p_type0, struct struct_entry * p_struct_entry0);
static void d_print_type_core(struct d_visit_ctx * ctx, struct osstream * ss, struct type * p_type0, char * name_opt);
static void d_print_type_qualifier_flags(struct osstream * ss, unsigned char * first, int e_type_qualifier_flags);
unsigned char print_type_alignment_flags(struct osstream * ss, unsigned char * first, int flags, int target);
void print_msvc_declspec(struct osstream * ss, unsigned char * first, int msvc_declspec_flags);

void d_print_structs(struct d_visit_ctx * ctx, struct osstream * ss, struct struct_entry * p_struct_entry)
{
    unsigned char  some_declartions_printed;

    if (p_struct_entry->definition_was_printed)
    {
        return;
    }
    {
        int i;

        i = 0;
        for (; i < p_struct_entry->hard_dependencies.size; i++)
        {
            struct struct_entry * p_struct_entry_item;

            p_struct_entry_item = p_struct_entry->hard_dependencies.data[i];
            d_print_structs(ctx, ss, p_struct_entry_item);
        }
    }
    some_declartions_printed = 0;
    {
        int i;

        i = 0;
        for (; i < p_struct_entry->soft_dependencies.size; i++)
        {
            struct struct_entry * p_struct_entry_item;

            p_struct_entry_item = p_struct_entry->soft_dependencies.data[i];
            if (!p_struct_entry_item->definition_was_printed && !p_struct_entry_item->declaration_was_printed)
            {
                some_declartions_printed = 1;
                p_struct_entry_item->declaration_was_printed = 1;
                if (struct_or_union_specifier_is_union(p_struct_entry_item->p_struct_or_union_specifier))
                {
                    ss_fprintf(ss, "union %s;\n", p_struct_entry_item->p_struct_or_union_specifier->tag_name);
                }
                else
                {
                    ss_fprintf(ss, "struct %s;\n", p_struct_entry_item->p_struct_or_union_specifier->tag_name);
                }
            }
        }
    }
    if (some_declartions_printed)
    {
        ss_fprintf(ss, "\n");
    }
    if (!p_struct_entry->definition_was_printed)
    {
        struct osstream  local;

        p_struct_entry->definition_was_printed = 1;
        _cake_zmem(&local, 12);
        d_print_struct(ctx, &local, p_struct_entry->p_struct_or_union_specifier);
        if (local.c_str)
        {
            ss_fprintf(ss, local.c_str);
        }
        ss_close(&local);
    }
}



static struct struct_or_union_specifier *get_complete_struct_or_union_specifier2(struct struct_or_union_specifier * p_struct_or_union_specifier)
{
    struct struct_or_union_specifier * p_complete;

    p_complete = get_complete_struct_or_union_specifier(p_struct_or_union_specifier);
    if (p_complete == 0)
    {
        p_complete = p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection;
    }
    return p_complete;
}

static void register_struct_types_and_functions(struct d_visit_ctx * ctx, struct type * p_type0, struct struct_entry * p_struct_entry0)
{
    if (1) /*try*/
    {
        struct type * p_type;

        p_type = p_type0;
        while (p_type)
        {
            /*switch*/
            {
                int __v0 = p_type->category;
                if (__v0 == 0) goto __L2; /*case 0*/
                if (__v0 == 1) goto __L27; /*case 1*/
                if (__v0 == 2) goto __L28; /*case 2*/
                if (__v0 == 3) goto __L29; /*case 3*/
                goto __L1;

                {
                    __L2: /*case 0*/ 
                    {
                        if (p_type->struct_or_union_specifier)
                        {
                            struct struct_or_union_specifier * p_complete;

                            p_complete = get_complete_struct_or_union_specifier2(p_type->struct_or_union_specifier);
                            if (p_complete == 0)
                            {
                                p_complete = p_type->struct_or_union_specifier;
                            }
                            if (p_complete)
                            {
                                char unique_id[100];
                                struct map_entry * p;

                                _cake_zmem(&unique_id, 100);
                                snprintf(unique_id, 100, "%d", p_complete->unique_id);
                                p = hashmap_find(&ctx->structs_map, unique_id);
                                if (p == 0)
                                {
                                    struct map_entry * p_name;
                                    struct struct_entry * p_struct_entry;
                                    struct member_declaration * member_declaration;

                                    p_name = hashmap_find(&ctx->tag_names, p_complete->tag_name);
                                    if (p_name != 0)
                                    {
                                        char new_name[100];
                                        struct hash_item_set  i;

                                        _cake_zmem(&new_name, 100);
                                        snprintf(new_name, 100, "__c%s%d", p_complete->tag_name, p_complete->unique_id);
                                        snprintf(p_complete->tag_name, 200, "%s", new_name);
                                        _cake_zmem(&i, 32);
                                        i.number = 1;
                                        hashmap_set(&ctx->tag_names, new_name, &i);
                                        hash_item_set_destroy(&i);
                                    }
                                    else
                                    {
                                        struct hash_item_set  i;

                                        _cake_zmem(&i, 32);
                                        i.number = 1;
                                        hashmap_set(&ctx->tag_names, p_complete->tag_name, &i);
                                        hash_item_set_destroy(&i);
                                    }
                                    p_struct_entry = calloc(1, 36);
                                    if (p_struct_entry == 0)
                                    {
                                        goto __L0; /* throw */
                                    }
                                    p_struct_entry->p_struct_or_union_specifier = p_complete;
                                    {
                                        struct hash_item_set  i;

                                        _cake_zmem(&i, 32);
                                        i.p_struct_entry = p_struct_entry;
                                        hashmap_set(&ctx->structs_map, unique_id, &i);
                                        hash_item_set_destroy(&i);
                                    }
                                    if (p_struct_entry0 && p_struct_entry0 != p_struct_entry)
                                    {
                                        struct_entry_list_push_back(&p_struct_entry0->soft_dependencies, p_struct_entry);
                                    }
                                    member_declaration = p_complete->member_declaration_list.head;
                                    while (member_declaration)
                                    {
                                        struct member_declarator * member_declarator;

                                        member_declarator = 0;
                                        if (member_declaration->member_declarator_list_opt)
                                        {
                                            member_declarator = member_declaration->member_declarator_list_opt->head;
                                            while (member_declarator)
                                            {
                                                if (member_declarator->declarator)
                                                {
                                                    if (type_is_struct_or_union(&member_declarator->declarator->type))
                                                    {
                                                        struct struct_or_union_specifier * p_complete_member;
                                                        char name2[100];
                                                        struct map_entry * p2;

                                                        ;
                                                        p_complete_member = get_complete_struct_or_union_specifier(member_declarator->declarator->type.struct_or_union_specifier);
                                                        if (p_complete_member == 0)
                                                        {
                                                            goto __L0; /* throw */
                                                        }
                                                        _cake_zmem(&name2, 100);
                                                        snprintf(name2, 100, "%d", p_complete_member->unique_id);
                                                        register_struct_types_and_functions(ctx, &member_declarator->declarator->type, 0);
                                                        p2 = hashmap_find(&ctx->structs_map, name2);
                                                        if (p2 != 0)
                                                        {
                                                            ;
                                                            struct_entry_list_push_back(&p_struct_entry->hard_dependencies, p2->data.p_struct_entry);
                                                        }
                                                    }
                                                    if (type_is_array(&member_declarator->declarator->type))
                                                    {
                                                        struct type  t;

                                                        t = get_array_item_type(&member_declarator->declarator->type);
                                                        if (type_is_struct_or_union(&t))
                                                        {
                                                            struct struct_or_union_specifier * p_complete_member;
                                                            char name2[100];
                                                            struct map_entry * p2;

                                                            ;
                                                            p_complete_member = p_complete_member = get_complete_struct_or_union_specifier(t.struct_or_union_specifier);
                                                            _cake_zmem(&name2, 100);
                                                            snprintf(name2, 100, "%d", p_complete_member->unique_id);
                                                            register_struct_types_and_functions(ctx, &t, 0);
                                                            p2 = hashmap_find(&ctx->structs_map, name2);
                                                            if (p2 != 0)
                                                            {
                                                                ;
                                                                struct_entry_list_push_back(&p_struct_entry->hard_dependencies, p2->data.p_struct_entry);
                                                            }
                                                        }
                                                        else
                                                        {
                                                            register_struct_types_and_functions(ctx, &member_declarator->declarator->type, p_struct_entry);
                                                        }
                                                        type_destroy(&t);
                                                    }
                                                    else
                                                    {
                                                        register_struct_types_and_functions(ctx, &member_declarator->declarator->type, p_struct_entry);
                                                    }
                                                }
                                                member_declarator = member_declarator->next;
                                            }
                                        }
                                        else
                                        {
                                            if (member_declaration->specifier_qualifier_list != 0)
                                            {
                                                if (member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                                                {
                                                    struct type  t;

                                                    _cake_zmem(&t, 68);
                                                    t.category = 0;
                                                    t.struct_or_union_specifier = member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                                                    t.type_specifier_flags = 32768;
                                                    if (type_is_struct_or_union(&t))
                                                    {
                                                        struct struct_or_union_specifier * p_complete_member;
                                                        char name2[100];
                                                        struct map_entry * p2;

                                                        p_complete_member = p_complete_member = get_complete_struct_or_union_specifier(t.struct_or_union_specifier);
                                                        _cake_zmem(&name2, 100);
                                                        snprintf(name2, 100, "%d", p_complete_member->unique_id);
                                                        register_struct_types_and_functions(ctx, &t, p_struct_entry);
                                                        p2 = hashmap_find(&ctx->structs_map, name2);
                                                        if (p2 != 0)
                                                        {
                                                            ;
                                                            struct_entry_list_push_back(&p_struct_entry->hard_dependencies, p2->data.p_struct_entry);
                                                        }
                                                    }
                                                    if (type_is_array(&t))
                                                    {
                                                        struct type  t2;

                                                        t2 = get_array_item_type(&t);
                                                        if (type_is_struct_or_union(&t2))
                                                        {
                                                            struct struct_or_union_specifier * p_complete_member;
                                                            char name2[100];
                                                            struct map_entry * p2;

                                                            p_complete_member = p_complete_member = get_complete_struct_or_union_specifier(t.struct_or_union_specifier);
                                                            if (p_complete_member == 0)
                                                            {
                                                                type_destroy(&t2);
                                                                goto __L0; /* throw */
                                                            }
                                                            _cake_zmem(&name2, 100);
                                                            snprintf(name2, 100, "%d", p_complete_member->unique_id);
                                                            register_struct_types_and_functions(ctx, &t, p_struct_entry);
                                                            p2 = hashmap_find(&ctx->structs_map, name2);
                                                            if (p2 != 0)
                                                            {
                                                                ;
                                                                struct_entry_list_push_back(&p_struct_entry->hard_dependencies, p2->data.p_struct_entry);
                                                            }
                                                        }
                                                        else
                                                        {
                                                            register_struct_types_and_functions(ctx, &t, p_struct_entry);
                                                        }
                                                        type_destroy(&t2);
                                                    }
                                                    else
                                                    {
                                                        register_struct_types_and_functions(ctx, &t, p_struct_entry);
                                                    }
                                                    type_destroy(&t);
                                                }
                                            }
                                        }
                                        member_declaration = member_declaration->next;
                                    }
                                }
                                else
                                {
                                    if (p_struct_entry0 && p_struct_entry0 != p->data.p_struct_entry)
                                    {
                                        struct_entry_list_push_back(&p_struct_entry0->soft_dependencies, p->data.p_struct_entry);
                                    }
                                }
                            }
                        }
                        else
                        {
                        }
                    }
                    goto __L1; /* break */

                    __L27: /*case 1*/ 
                    {
                        struct param * pa;

                        pa = p_type->params.head;
                        while (pa)
                        {
                            register_struct_types_and_functions(ctx, &pa->type, p_struct_entry0);
                            pa = pa->next;
                        }
                    }
                    goto __L1; /* break */

                    __L28: /*case 2*/ 
                    __L29: /*case 3*/ 
                    goto __L1; /* break */

                }
                __L1:;
            }
            p_type = p_type->next;
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void d_print_type_qualifier_flags(struct osstream * ss, unsigned char * first, int e_type_qualifier_flags)
{
    if (e_type_qualifier_flags & 1)
    {
        print_item(ss, first, "const");
    }
    if (e_type_qualifier_flags & 4)
    {
        print_item(ss, first, "volatile");
    }
}

static void d_print_type_core(struct d_visit_ctx * ctx, struct osstream * ss, struct type * p_type0, char * name_opt)
{
    struct type * p_type;

    p_type = p_type0;
    while (p_type)
    {
        /*switch*/
        {
            int __v0 = p_type->category;
            if (__v0 == 0) goto __L1; /*case 0*/
            if (__v0 == 2) goto __L14; /*case 2*/
            if (__v0 == 1) goto __L19; /*case 1*/
            if (__v0 == 3) goto __L27; /*case 3*/
            goto __L0;

            {
                unsigned char  b;
                struct param * pa;

                __L1: /*case 0*/ 
                {
                    struct osstream  local;
                    unsigned char  first;
                    struct osstream  local2;

                    _cake_zmem(&local, 12);
                    first = 1;
                    if (ctx->print_qualifiers)
                    {
                        d_print_type_qualifier_flags(&local, &first, p_type->type_qualifier_flags);
                    }
                    if (!first)
                    {
                        ss_fprintf(&local, " ");
                    }
                    if (p_type->struct_or_union_specifier)
                    {
                        struct struct_or_union_specifier * p_complete;

                        p_complete = get_complete_struct_or_union_specifier2(p_type->struct_or_union_specifier);
                        if (p_complete)
                        {
                            if (struct_or_union_specifier_is_union(p_type->struct_or_union_specifier))
                            {
                                ss_fprintf(&local, "union %s", p_complete->tag_name);
                            }
                            else
                            {
                                ss_fprintf(&local, "struct %s", p_complete->tag_name);
                            }
                        }
                        else
                        {
                            if (struct_or_union_specifier_is_union(p_type->struct_or_union_specifier))
                            {
                                ss_fprintf(&local, "union %s", p_type->struct_or_union_specifier->tag_name);
                            }
                            else
                            {
                                ss_fprintf(&local, "struct %s", p_type->struct_or_union_specifier->tag_name);
                            }
                        }
                    }
                    else
                    {
                        if (p_type->enum_specifier)
                        {
                            int enum_type_specifier_flags;

                            enum_type_specifier_flags = get_enum_type_specifier_flags(p_type->enum_specifier);
                            print_type_specifier_flags(&local, &first, enum_type_specifier_flags);
                        }
                        else
                        {
                            if (p_type->type_specifier_flags & 512)
                            {
                                unsigned char  first0;

                                first0 = 1;
                                print_type_specifier_flags(&local, &first0, object_type_to_type_specifier(get_platform(ctx->options.target)->bool_type));
                            }
                            else
                            {
                                print_type_alignment_flags(&local, &first, p_type->alignment_specifier_flags, ctx->options.target);
                                print_msvc_declspec(&local, &first, p_type->msvc_declspec_flags);
                                if (p_type->type_qualifier_flags & 4)
                                {
                                    print_item(&local, &first, "volatile");
                                }
                                print_type_specifier_flags(&local, &first, p_type->type_specifier_flags);
                            }
                        }
                    }
                    if (name_opt)
                    {
                        if (first)
                        {
                            ss_fprintf(ss, " ");
                            first = 0;
                        }
                        ss_fprintf(ss, "%s", name_opt);
                        name_opt = 0;
                    }
                    _cake_zmem(&local2, 12);
                    if (ss->c_str)
                    {
                        ss_fprintf(&local2, "%s %s", local.c_str, ss->c_str);
                    }
                    else
                    {
                        ss_fprintf(&local2, "%s", local.c_str);
                    }
                    ss_swap(ss, &local2);
                    ss_close(&local2);
                    ss_close(&local);
                }
                goto __L0; /* break */

                __L14: /*case 2*/ 
                if (name_opt)
                {
                    ss_fprintf(ss, "%s", name_opt);
                    name_opt = 0;
                }
                ss_fprintf(ss, "[");
                b = 1;
                if (ctx->print_qualifiers)
                {
                    d_print_type_qualifier_flags(ss, &b, p_type->type_qualifier_flags);
                }
                if (p_type->num_of_elements > 0)
                {
                    if (!b)
                    {
                        ss_fprintf(ss, " ");
                    }
                    ss_fprintf(ss, "%zu", p_type->num_of_elements);
                }
                else
                {
                }
                ss_fprintf(ss, "]");
                goto __L0; /* break */

                __L19: /*case 1*/ 
                if (name_opt)
                {
                    if (p_type->attributes_flags & 268435456)
                    {
                        ss_fprintf(ss, "__stdcall ");
                    }
                    else
                    {
                        if (p_type->attributes_flags & 134217728)
                        {
                            ss_fprintf(ss, "__fastcall ");
                        }
                        else
                        {
                            if (p_type->attributes_flags & 536870912)
                            {
                                ss_fprintf(ss, "__cdecl ");
                            }
                        }
                    }
                    ss_fprintf(ss, "%s", name_opt);
                    name_opt = 0;
                }
                ss_fprintf(ss, "(");
                pa = p_type->params.head;
                while (pa)
                {
                    struct osstream  sslocal;
                    struct osstream  local2;

                    _cake_zmem(&sslocal, 12);
                    _cake_zmem(&local2, 12);
                    d_print_type_core(ctx, &local2, &pa->type, pa->type.name_opt);
                    ss_fprintf(&sslocal, "%s", local2.c_str);
                    ss_fprintf(ss, "%s", sslocal.c_str);
                    if (pa->next)
                    {
                        ss_fprintf(ss, ", ");
                    }
                    ss_close(&sslocal);
                    pa = pa->next;
                    ss_close(&local2);
                }
                if (p_type->params.is_var_args)
                {
                    if (p_type->params.head)
                    {
                        ss_fprintf(ss, ", ");
                    }
                    ss_fprintf(ss, "...");
                }
                ss_fprintf(ss, ")");
                goto __L0; /* break */

                __L27: /*case 3*/ 
                {
                    struct osstream  local;
                    unsigned char  first;

                    _cake_zmem(&local, 12);
                    if (p_type->next && (p_type->next->category == 1 || p_type->next->category == 2))
                    {
                        ss_fprintf(&local, "(");
                    }
                    if (p_type->attributes_flags & 268435456)
                    {
                        ss_fprintf(&local, "__stdcall ");
                    }
                    else
                    {
                        if (p_type->attributes_flags & 134217728)
                        {
                            ss_fprintf(&local, "__fastcall ");
                        }
                        else
                        {
                            if (p_type->attributes_flags & 536870912)
                            {
                                ss_fprintf(&local, "__cdecl ");
                            }
                        }
                    }
                    ss_fprintf(&local, "*");
                    first = 0;
                    if (ctx->print_qualifiers)
                    {
                        d_print_type_qualifier_flags(ss, &b, p_type->type_qualifier_flags);
                    }
                    if (name_opt)
                    {
                        if (!first)
                        {
                            ss_fprintf(ss, " ");
                        }
                        ss_fprintf(ss, "%s", name_opt);
                        name_opt = 0;
                        first = 0;
                    }
                    if (ss->c_str)
                    {
                        ss_fprintf(&local, "%s", ss->c_str);
                    }
                    if (p_type->next && (p_type->next->category == 1 || p_type->next->category == 2))
                    {
                        ss_fprintf(&local, ")", ss->c_str);
                    }
                    ss_swap(ss, &local);
                    ss_close(&local);
                }
                goto __L0; /* break */

            }
            __L0:;
        }
        p_type = p_type->next;
    }
}

static void d_print_type(struct d_visit_ctx * ctx, struct osstream * ss, struct type * p_type, char * name_opt, unsigned char  print_storage_qualifiers)
{
    struct osstream  local;

    register_struct_types_and_functions(ctx, p_type, 0);
    _cake_zmem(&local, 12);
    d_print_type_core(ctx, &local, p_type, name_opt);
    if (print_storage_qualifiers && p_type->storage_class_specifier_flags & 2)
    {
        ss_fprintf(ss, "extern ");
    }
    if (print_storage_qualifiers && p_type->storage_class_specifier_flags & 4)
    {
        ss_fprintf(ss, "static ");
    }
    if (p_type->storage_class_specifier_flags & 8)
    {
        char * ta;

        ta = get_platform(ctx->options.target)->thread_local_attr;
        ss_fprintf(ss, "%s ", ta);
    }
    ss_fprintf(ss, "%s", local.c_str);
    ss_close(&local);
}

static void d_print_struct(struct d_visit_ctx * ctx, struct osstream * ss, struct struct_or_union_specifier * p_struct_or_union_specifier)
{
    struct struct_or_union_specifier * p_complete;
    struct member_declaration * member_declaration;
    int no_name_index;

    p_complete = get_complete_struct_or_union_specifier2(p_struct_or_union_specifier);
    if (p_complete == 0)
    {
        if (struct_or_union_specifier_is_union(p_struct_or_union_specifier))
        {
            ss_fprintf(ss, "union %s;\n\n", p_struct_or_union_specifier->tag_name);
        }
        else
        {
            ss_fprintf(ss, "struct %s;\n\n", p_struct_or_union_specifier->tag_name);
        }
        return;
    }
    member_declaration = p_complete->member_declaration_list.head;
    if (struct_or_union_specifier_is_union(p_complete))
    {
        ss_fprintf(ss, "union %s", p_complete->tag_name);
    }
    else
    {
        ss_fprintf(ss, "struct %s", p_complete->tag_name);
    }
    if (p_complete->member_declaration_list.head)
    {
        ss_fprintf(ss, " ");
        ss_fprintf(ss, "{\n");
    }
    no_name_index = 0;
    while (member_declaration)
    {
        struct member_declarator * member_declarator;

        member_declarator = 0;
        if (member_declaration->member_declarator_list_opt)
        {
            member_declarator = member_declaration->member_declarator_list_opt->head;
            while (member_declarator)
            {
                if (member_declarator->declarator && member_declarator->declarator->name_opt)
                {
                    ss_fprintf(ss, "    ");
                    if (type_is_array(&member_declarator->declarator->type) && member_declarator->declarator->type.num_of_elements == 0)
                    {
                        member_declarator->declarator->type.num_of_elements = 1;
                        d_print_type(ctx, ss, &member_declarator->declarator->type, member_declarator->declarator->name_opt->lexeme, 0);
                        member_declarator->declarator->type.num_of_elements = 0;
                    }
                    else
                    {
                        d_print_type(ctx, ss, &member_declarator->declarator->type, member_declarator->declarator->name_opt->lexeme, 0);
                    }
                    ss_fprintf(ss, ";\n");
                }
                member_declarator = member_declarator->next;
            }
        }
        else
        {
            if (member_declaration->specifier_qualifier_list != 0)
            {
                if (member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                {
                    struct type  t;
                    char name[100];

                    _cake_zmem(&t, 68);
                    t.category = 0;
                    t.struct_or_union_specifier = member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                    t.type_specifier_flags = 32768;
                    _cake_zmem(&name, 100);
                    snprintf(name, 100, "__m%d", no_name_index++);
                    ss_fprintf(ss, "    ");
                    d_print_type(ctx, ss, &t, name, 0);
                    ss_fprintf(ss, ";\n");
                    type_destroy(&t);
                }
            }
        }
        member_declaration = member_declaration->next;
    }
    if (p_complete->member_declaration_list.head)
    {
        ss_fprintf(ss, "};\n\n");
    }
    else
    {
        ss_fprintf(ss, ";\n");
    }
}
static void d_visit_declaration(struct d_visit_ctx * ctx, struct osstream * oss, struct declaration * p_declaration);
static void d_visit_init_declarator_list(struct d_visit_ctx * ctx, struct osstream * oss, struct init_declarator_list * p_init_declarator_list, int function_specifier_flags, int storage_class_specifier_flags);
static void d_visit_init_declarator(struct d_visit_ctx * ctx, struct osstream * oss, struct init_declarator * p_init_declarator, int function_specifier_flags, int storage_class_specifier_flags);
static void print_initializer(struct d_visit_ctx * ctx, struct osstream * oss, struct init_declarator * p_init_declarator, unsigned char  bstatic);
static void print_identation_core(struct osstream * ss, int indentation);
static void d_visit_expression(struct d_visit_ctx * ctx, struct osstream * oss, struct expression * p_expression);
static void d_visit_function_body(struct d_visit_ctx * ctx, struct osstream * oss, struct declarator * function_definition);
static void d_visit_compound_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct compound_statement * p_compound_statement);
static void d_visit_block_item_list(struct d_visit_ctx * ctx, struct osstream * oss, struct block_item_list * p_block_item_list);
static void d_visit_block_item(struct d_visit_ctx * ctx, struct osstream * oss, struct block_item * p_block_item);
static void d_visit_unlabeled_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct unlabeled_statement * p_unlabeled_statement);
static void d_visit_primary_block(struct d_visit_ctx * ctx, struct osstream * oss, struct primary_block * p_primary_block);
static void d_visit_iteration_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct iteration_statement * p_iteration_statement);
static void print_identation(struct d_visit_ctx * ctx, struct osstream * oss);
static void d_visit_secondary_block(struct d_visit_ctx * ctx, struct osstream * oss, struct secondary_block * p_secondary_block);
static void d_visit_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct statement * p_statement);
static void d_visit_labeled_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct labeled_statement * p_labeled_statement);
static void d_visit_label(struct d_visit_ctx * ctx, struct osstream * oss, struct label * p_label);
static void d_visit_selection_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct selection_statement * p_selection_statement);
static void d_visit_condition(struct d_visit_ctx * ctx, struct osstream * oss, struct condition * p_condition);
static void d_visit_init_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct init_statement * p_init_statement);
static void d_visit_expression_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct expression_statement * p_expression_statement);
static void d_visit_simple_declaration(struct d_visit_ctx * ctx, struct osstream * oss, struct simple_declaration * p_simple_declaration);
static unsigned char is_compound_statement(struct secondary_block * p_secondary_block);
static void d_visit_try_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct try_statement * p_try_statement);
static void d_visit_jump_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct jump_statement * p_jump_statement);
static void il_print_defer_list(struct d_visit_ctx * ctx, struct osstream * oss, struct defer_list * p_defer_list);
static void il_print_defer_new(struct d_visit_ctx * ctx, struct osstream * oss, struct defer_list_item * p_item);
static int il_defer_count(struct defer_list * p_defer_list);
static void expression_to_bool_value(struct d_visit_ctx * ctx, struct osstream * oss, struct expression * p_expression);
static void il_print_string(struct token * first_token, struct token * last_token, struct osstream * oss);
static int il_visit_literal_string2(struct token * current, struct osstream * oss);
static int find_member_name(struct type * p_type, int index, char name[100]);
static struct member_declarator *find_member_declarator_name_by_index(struct member_declaration_list * list, int member_index, char name[100], int * p_count);
static void object_print_non_constant_initialization(struct d_visit_ctx * ctx, struct osstream * ss, struct object * object, char * declarator_name, unsigned char  all, unsigned char  initialize_objects_that_does_not_have_initializer);
static void object_print_constant_initialization(struct d_visit_ctx * ctx, struct osstream * ss, struct object * object, unsigned char * first);
static char *get_op_by_expression_type(int type);
static unsigned char is_all_zero(struct object * object);

void d_visit(struct d_visit_ctx * ctx, struct osstream * oss)
{
    struct osstream  declarations;
    struct declaration * p_declaration;

    _cake_zmem(&declarations, 12);
    ctx->print_qualifiers = 0;
    ss_fprintf(oss, "/* Cake %s */\n", get_platform(ctx->options.target)->name);
    ctx->indentation = 0;
    p_declaration = ctx->ast.declaration_list.head;
    while (p_declaration)
    {
        struct osstream  declaration;

        ss_clear(&ctx->add_this_after_external_decl);
        ss_clear(&ctx->add_this_before_external_decl);
        _cake_zmem(&declaration, 12);
        d_visit_declaration(ctx, &declaration, p_declaration);
        if (ctx->add_this_before.size > 0)
        {
            ss_fprintf(oss, "%s", ctx->add_this_before.c_str);
            ss_clear(&ctx->add_this_before);
        }
        if (ctx->add_this_before_external_decl.size > 0)
        {
            ss_fprintf(&declarations, "%s\n", ctx->add_this_before_external_decl.c_str);
            ss_clear(&ctx->add_this_before_external_decl);
        }
        if (declaration.size > 0)
        {
            ss_fprintf(&declarations, "%s", declaration.c_str);
        }
        if (ctx->add_this_after_external_decl.c_str)
        {
            ss_fprintf(&declarations, "%s", ctx->add_this_after_external_decl.c_str);
        }
        ss_close(&declaration);
        p_declaration = p_declaration->next;
    }
    {
        int i;

        i = 0;
        for (; i < ctx->structs_map.capacity; i++)
        {
            struct map_entry * entry;

            entry = ctx->structs_map.table[i];
            while (entry)
            {
                ;
                d_print_structs(ctx, oss, entry->data.p_struct_entry);
                entry = entry->next;
            }
        }
    }
    ss_fprintf(oss, "\n");
    if (ctx->define_nullptr && ctx->null_pointer_constant_used)
    {
        ss_fprintf(oss, "static const void* NULL = 0;\n");
    }
    if (ctx->zero_mem_used)
    {
        struct osstream  local;
        unsigned char  first;

        _cake_zmem(&local, 12);
        first = 1;
        print_type_specifier_flags(&local, &first, object_type_to_type_specifier(get_platform(ctx->options.target)->size_t_type));
        ss_fprintf(oss, "static void _cake_zmem(void *dest, %s len)\n{\n  unsigned char *ptr;\n\n  ptr = (unsigned char*)dest;\n  while (len-- > 0) *ptr++ = 0;\n}\n\n", local.c_str);
        ss_close(&local);
    }
    if (ctx->memcpy_used)
    {
        struct osstream  local;
        unsigned char  first;

        _cake_zmem(&local, 12);
        first = 1;
        print_type_specifier_flags(&local, &first, object_type_to_type_specifier(get_platform(ctx->options.target)->size_t_type));
        ss_fprintf(oss, "static void _cake_memcpy(void * dest, const void * src, %s n)\n{\n  char *csrc;\n  char *cdest;\n  %s i; \n\n  csrc = (char *)src;\n  cdest = (char *)dest;\n  for (i = 0; i < n; i++) cdest[i] = csrc[i]; \n}\n\n", local.c_str, local.c_str);
        ss_close(&local);
    }
    if (declarations.c_str)
    {
        ss_fprintf(oss, "%s", declarations.c_str);
    }
    ss_close(&declarations);
}



static void print_identation_core(struct osstream * ss, int indentation)
{
    {
        int i;

        i = 0;
        for (; i < indentation; i++)
        {
            ss_fprintf(ss, "    ");
        }
    }
}

static void print_identation(struct d_visit_ctx * ctx, struct osstream * oss)
{
    {
        int i;

        i = 0;
        for (; i < ctx->indentation; i++)
        {
            ss_fprintf(oss, "    ");
        }
    }
}

static void d_visit_label(struct d_visit_ctx * ctx, struct osstream * oss, struct label * p_label)
{
    if (p_label->p_first_token->type == 9001)
    {
        char str[50];

        print_identation(ctx, oss);
        ss_fprintf(oss, "__L%d:", p_label->label_id);
        _cake_zmem(&str, 50);
        object_to_str(&p_label->constant_expression->object, 50, str);
        if (p_label->constant_expression_end == 0)
        {
            ss_fprintf(oss, " /*case %s*/ ", str);
        }
        else
        {
            char str2[50];

            _cake_zmem(&str2, 50);
            object_to_str(&p_label->constant_expression_end->object, 50, str2);
            ss_fprintf(oss, " /*case %s ... %s*/ ", str, str2);
        }
        ss_fprintf(oss, "\n");
    }
    else
    {
        if (p_label->p_first_token->type == 8996)
        {
            print_identation(ctx, oss);
            ss_fprintf(oss, "%s:\n", p_label->p_first_token->lexeme);
        }
        else
        {
            if (p_label->p_first_token->type == 9007)
            {
                print_identation(ctx, oss);
                ss_fprintf(oss, "__L%d: /* default */ \n", p_label->label_id);
            }
        }
    }
}

static void d_visit_labeled_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct labeled_statement * p_labeled_statement)
{
    ;
    d_visit_label(ctx, oss, p_labeled_statement->label);
    d_visit_statement(ctx, oss, p_labeled_statement->statement);
}

static void d_visit_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct statement * p_statement)
{
    if (p_statement->labeled_statement)
    {
        d_visit_labeled_statement(ctx, oss, p_statement->labeled_statement);
    }
    else
    {
        if (p_statement->unlabeled_statement)
        {
            d_visit_unlabeled_statement(ctx, oss, p_statement->unlabeled_statement);
        }
    }
}

static void d_visit_secondary_block(struct d_visit_ctx * ctx, struct osstream * oss, struct secondary_block * p_secondary_block)
{
    d_visit_statement(ctx, oss, p_secondary_block->statement);
}

static void d_visit_iteration_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct iteration_statement * p_iteration_statement)
{
    struct break_reference  old;

    old = ctx->break_reference;
    ctx->break_reference.p_iteration_statement = p_iteration_statement;
    ctx->break_reference.p_selection_statement = 0;
    print_identation(ctx, oss);
    if (p_iteration_statement->first_token->type == 9042)
    {
        ss_fprintf(oss, "while (");
        if (p_iteration_statement->expression1)
        {
            d_visit_expression(ctx, oss, p_iteration_statement->expression1);
        }
        ss_fprintf(oss, ")\n");
        d_visit_secondary_block(ctx, oss, p_iteration_statement->secondary_block);
    }
    else
    {
        if (p_iteration_statement->first_token->type == 9008)
        {
            ss_fprintf(oss, "do\n");
            d_visit_secondary_block(ctx, oss, p_iteration_statement->secondary_block);
            print_identation(ctx, oss);
            ss_fprintf(oss, "while (");
            ;
            d_visit_expression(ctx, oss, p_iteration_statement->expression1);
            ss_fprintf(oss, ");\n");
        }
        else
        {
            if (p_iteration_statement->first_token->type == 9015)
            {
                if (p_iteration_statement->declaration)
                {
                    struct osstream  block_scope_declarators;
                    struct osstream  local;

                    ss_fprintf(oss, "{\n");
                    ctx->indentation++;
                    _cake_zmem(&block_scope_declarators, 12);
                    ss_swap(&block_scope_declarators, &ctx->block_scope_declarators);
                    _cake_zmem(&local, 12);
                    d_visit_declaration(ctx, &local, p_iteration_statement->declaration);
                    if (ctx->block_scope_declarators.c_str)
                    {
                        ss_fprintf(oss, "%s", ctx->block_scope_declarators.c_str);
                        ss_fprintf(oss, "\n");
                    }
                    if (local.c_str)
                    {
                        ss_fprintf(oss, "%s", local.c_str);
                    }
                    ss_swap(&block_scope_declarators, &ctx->block_scope_declarators);
                    print_identation(ctx, oss);
                    ss_fprintf(oss, "for (");
                    ss_close(&block_scope_declarators);
                    ss_close(&local);
                }
                else
                {
                    if (p_iteration_statement->expression0)
                    {
                        ss_fprintf(oss, "for (");
                        d_visit_expression(ctx, oss, p_iteration_statement->expression0);
                    }
                    else
                    {
                        ss_fprintf(oss, "for (");
                    }
                }
                ss_fprintf(oss, "; ");
                if (p_iteration_statement->expression1)
                {
                    d_visit_expression(ctx, oss, p_iteration_statement->expression1);
                }
                ss_fprintf(oss, "; ");
                if (p_iteration_statement->expression2)
                {
                    d_visit_expression(ctx, oss, p_iteration_statement->expression2);
                }
                ss_fprintf(oss, ")\n");
                d_visit_secondary_block(ctx, oss, p_iteration_statement->secondary_block);
                if (p_iteration_statement->declaration)
                {
                    ctx->indentation--;
                    print_identation(ctx, oss);
                    ss_fprintf(oss, "}\n");
                }
            }
        }
    }
    ctx->break_reference = old;
}

static void d_visit_condition(struct d_visit_ctx * ctx, struct osstream * oss, struct condition * p_condition)
{
    if (p_condition->p_init_declarator)
    {
        d_visit_init_declarator(ctx, oss, p_condition->p_init_declarator, 0, 0);
    }
    if (p_condition->expression)
    {
        d_visit_expression(ctx, oss, p_condition->expression);
    }
}

static void d_visit_expression_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct expression_statement * p_expression_statement)
{
    struct osstream  local;

    ss_clear(&ctx->add_this_before);
    _cake_zmem(&local, 12);
    print_identation(ctx, &local);
    if (p_expression_statement->expression_opt)
    {
        d_visit_expression(ctx, &local, p_expression_statement->expression_opt);
    }
    if (ctx->add_this_before.size > 0)
    {
        ss_fprintf(oss, "%s", ctx->add_this_before.c_str);
        ss_clear(&ctx->add_this_before);
    }
    ss_fprintf(oss, "%s;\n", local.c_str);
    ss_close(&local);
}

static void d_visit_simple_declaration(struct d_visit_ctx * ctx, struct osstream * oss, struct simple_declaration * p_simple_declaration)
{
    d_visit_init_declarator_list(ctx, oss, &p_simple_declaration->init_declarator_list, 0, 0);
}

static void d_visit_init_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct init_statement * p_init_statement)
{
    if (p_init_statement->p_expression_statement)
    {
        d_visit_expression_statement(ctx, oss, p_init_statement->p_expression_statement);
    }
    if (p_init_statement->p_simple_declaration)
    {
        d_visit_simple_declaration(ctx, oss, p_init_statement->p_simple_declaration);
    }
}

static unsigned char is_compound_statement(struct secondary_block * p_secondary_block)
{
    ;
    if (p_secondary_block->statement->unlabeled_statement && p_secondary_block->statement->unlabeled_statement->primary_block && p_secondary_block->statement->unlabeled_statement->primary_block->compound_statement)
    {
        return 1;
    }
    return 0;
}

static void d_visit_selection_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct selection_statement * p_selection_statement)
{
    print_identation(ctx, oss);
    if (p_selection_statement->first_token->type == 9034)
    {
        struct break_reference  old;
        struct osstream  ss;
        char name[100];
        struct label * p_label;
        struct label * p_label_default;

        old = ctx->break_reference;
        ctx->break_reference.p_iteration_statement = 0;
        ctx->break_reference.p_selection_statement = p_selection_statement;
        ;
        _cake_zmem(&ss, 12);
        ss_fprintf(&ss, "/*switch*/\n");
        print_identation(ctx, &ss);
        ss_fprintf(&ss, "{\n");
        ctx->indentation++;
        _cake_zmem(&name, 100);
        snprintf(name, 100, "__v%d", ctx->cake_local_declarator_number++);
        print_identation(ctx, &ss);
        d_print_type(ctx, &ss, &p_selection_statement->condition->expression->type, name, 0);
        ss_fprintf(&ss, " = ");
        ;
        d_visit_condition(ctx, &ss, p_selection_statement->condition);
        ss_fprintf(&ss, ";\n");
        p_label = p_selection_statement->label_list.head;
        p_label_default = 0;
        while (p_label)
        {
            if (p_label->p_first_token->type == 9007)
            {
                p_label_default = p_label;
            }
            else
            {
                print_identation(ctx, &ss);
                if (p_label->constant_expression_end == 0)
                {
                    char str[50];

                    _cake_zmem(&str, 50);
                    object_to_str(&p_label->constant_expression->object, 50, str);
                    ss_fprintf(&ss, "if (%s == %s) goto __L%d; /*case %s*/\n", name, str, p_label->label_id, str);
                }
                else
                {
                    char str_begin[50];
                    char str_end[50];

                    _cake_zmem(&str_begin, 50);
                    object_to_str(&p_label->constant_expression->object, 50, str_begin);
                    _cake_zmem(&str_end, 50);
                    object_to_str(&p_label->constant_expression_end->object, 50, str_end);
                    ss_fprintf(&ss, "if (%s >= %s && %s <= %s) goto __L%d; /*case %s ... %s*/\n", name, str_begin, name, str_end, p_label->label_id, str_begin, str_end);
                }
            }
            p_label = p_label->next;
        }
        print_identation(ctx, &ss);
        if (p_label_default)
        {
            ss_fprintf(&ss, "goto __L%d; /* default */\n", p_label_default->label_id);
        }
        else
        {
            ss_fprintf(&ss, "goto __L%d;\n", p_selection_statement->label_id);
        }
        ss_fprintf(&ss, "\n");
        d_visit_secondary_block(ctx, &ss, p_selection_statement->secondary_block);
        print_identation(ctx, &ss);
        ss_fprintf(&ss, "__L%d:;\n", ctx->break_reference.p_selection_statement->label_id);
        ctx->indentation--;
        print_identation(ctx, &ss);
        ss_fprintf(&ss, "}\n");
        ss_fprintf(oss, "%s", ss.c_str);
        ss_close(&ss);
        ctx->break_reference = old;
    }
    else
    {
        if (p_selection_statement->first_token->type == 9017)
        {
            unsigned char  addclose;

            addclose = 0;
            if (p_selection_statement->p_init_statement)
            {
                struct osstream  block_scope_declarators;
                struct osstream  local2;

                ss_fprintf(oss, "{\n");
                addclose = 1;
                ctx->indentation++;
                _cake_zmem(&block_scope_declarators, 12);
                ss_swap(&block_scope_declarators, &ctx->block_scope_declarators);
                _cake_zmem(&local2, 12);
                print_identation(ctx, &local2);
                d_visit_init_statement(ctx, &local2, p_selection_statement->p_init_statement);
                if (ctx->block_scope_declarators.c_str)
                {
                    ss_fprintf(oss, "%s", ctx->block_scope_declarators.c_str);
                    ss_fprintf(oss, "\n");
                }
                ss_fprintf(oss, "%s", local2.c_str);
                ss_close(&local2);
                print_identation(ctx, oss);
                ss_swap(&block_scope_declarators, &ctx->block_scope_declarators);
                ss_close(&block_scope_declarators);
            }
            if (p_selection_statement->condition)
            {
                if (p_selection_statement->condition->p_init_declarator)
                {
                    struct osstream  block_scope_declarators;
                    struct osstream  local2;

                    ss_fprintf(oss, "{\n");
                    ctx->indentation++;
                    addclose = 1;
                    _cake_zmem(&block_scope_declarators, 12);
                    ss_swap(&block_scope_declarators, &ctx->block_scope_declarators);
                    _cake_zmem(&local2, 12);
                    print_identation(ctx, &local2);
                    d_visit_init_declarator(ctx, &local2, p_selection_statement->condition->p_init_declarator, 0, 0);
                    if (ctx->block_scope_declarators.c_str)
                    {
                        ss_fprintf(oss, "%s", ctx->block_scope_declarators.c_str);
                        ss_fprintf(oss, "\n");
                    }
                    ss_fprintf(oss, "%s", local2.c_str);
                    ss_close(&local2);
                    ss_swap(&block_scope_declarators, &ctx->block_scope_declarators);
                    print_identation(ctx, oss);
                    ss_fprintf(oss, "if (");
                    ss_fprintf(oss, "%s", p_selection_statement->condition->p_init_declarator->p_declarator->name_opt->lexeme);
                    ss_fprintf(oss, ")\n");
                    ss_close(&block_scope_declarators);
                }
                else
                {
                    if (p_selection_statement->condition->expression)
                    {
                        ss_fprintf(oss, "if (");
                        d_visit_expression(ctx, oss, p_selection_statement->condition->expression);
                        ss_fprintf(oss, ")\n");
                    }
                }
            }
            ;
            if (is_compound_statement(p_selection_statement->secondary_block))
            {
                d_visit_secondary_block(ctx, oss, p_selection_statement->secondary_block);
            }
            else
            {
                print_identation(ctx, oss);
                ss_fprintf(oss, "{\n");
                ctx->indentation++;
                d_visit_secondary_block(ctx, oss, p_selection_statement->secondary_block);
                ctx->indentation--;
                print_identation(ctx, oss);
                ss_fprintf(oss, "}\n");
            }
            if (p_selection_statement->else_secondary_block_opt)
            {
                print_identation(ctx, oss);
                ss_fprintf(oss, "else\n");
                if (is_compound_statement(p_selection_statement->else_secondary_block_opt))
                {
                    d_visit_secondary_block(ctx, oss, p_selection_statement->else_secondary_block_opt);
                }
                else
                {
                    print_identation(ctx, oss);
                    ss_fprintf(oss, "{\n");
                    ctx->indentation++;
                    d_visit_secondary_block(ctx, oss, p_selection_statement->else_secondary_block_opt);
                    ctx->indentation--;
                    print_identation(ctx, oss);
                    ss_fprintf(oss, "}\n");
                }
            }
            if (addclose)
            {
                ctx->indentation--;
                print_identation(ctx, oss);
                ss_fprintf(oss, "}\n");
            }
        }
    }
}

static void d_visit_try_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct try_statement * p_try_statement)
{
    print_identation(ctx, oss);
    if (p_try_statement->first_token->type == 9036)
    {
        ss_fprintf(oss, "if (1) /*try*/\n");
    }
    else
    {
        if (p_try_statement->first_token->type == 9060)
        {
            ss_fprintf(oss, "__try\n");
        }
    }
    d_visit_secondary_block(ctx, oss, p_try_statement->secondary_block);
    print_identation(ctx, oss);
    if (p_try_statement->catch_token_opt)
    {
        if (p_try_statement->catch_token_opt->type == 9006)
        {
            ss_fprintf(oss, "else __L%d: /*catch*/ \n", p_try_statement->catch_label_id);
        }
        else
        {
            if (p_try_statement->catch_token_opt->type == 9062)
            {
                ss_fprintf(oss, "__finally\n");
            }
            else
            {
                if (p_try_statement->catch_token_opt->type == 9061)
                {
                    ss_fprintf(oss, "__except(");
                    d_visit_expression(ctx, oss, p_try_statement->msvc_except_expression);
                    ss_fprintf(oss, ")\n");
                }
            }
        }
    }
    if (p_try_statement->catch_secondary_block_opt)
    {
        d_visit_secondary_block(ctx, oss, p_try_statement->catch_secondary_block_opt);
    }
}

static void d_visit_primary_block(struct d_visit_ctx * ctx, struct osstream * oss, struct primary_block * p_primary_block)
{
    if (p_primary_block->defer_statement)
    {
    }
    else
    {
        if (p_primary_block->compound_statement)
        {
            d_visit_compound_statement(ctx, oss, p_primary_block->compound_statement);
        }
        else
        {
            if (p_primary_block->iteration_statement)
            {
                d_visit_iteration_statement(ctx, oss, p_primary_block->iteration_statement);
            }
            else
            {
                if (p_primary_block->selection_statement)
                {
                    d_visit_selection_statement(ctx, oss, p_primary_block->selection_statement);
                }
                else
                {
                    if (p_primary_block->try_statement)
                    {
                        d_visit_try_statement(ctx, oss, p_primary_block->try_statement);
                    }
                    else
                    {
                        if (p_primary_block->asm_statement)
                        {
                            struct token * p;

                            print_identation(ctx, oss);
                            p = p_primary_block->asm_statement->p_first_token;
                            while (p)
                            {
                                ss_fprintf(oss, "%s", p->lexeme);
                                if (p == p_primary_block->asm_statement->p_last_token)
                                {
                                    break;
                                }
                                p = p->next;
                            }
                            ss_fprintf(oss, "\n");
                        }
                    }
                }
            }
        }
    }
}

static void il_print_defer_new(struct d_visit_ctx * ctx, struct osstream * oss, struct defer_list_item * p_item)
{
    if (p_item->defer_statement == 0)
    {
        return;
    }
    d_visit_secondary_block(ctx, oss, p_item->defer_statement->secondary_block);
}

static void il_print_defer_list(struct d_visit_ctx * ctx, struct osstream * oss, struct defer_list * p_defer_list)
{
    struct defer_list_item * p_item;

    p_item = p_defer_list->head;
    while (p_item)
    {
        il_print_defer_new(ctx, oss, p_item);
        p_item = p_item->next;
    }
}

static int il_defer_count(struct defer_list * p_defer_list)
{
    int count;
    struct defer_list_item * p_item;

    count = 0;
    p_item = p_defer_list->head;
    while (p_item)
    {
        if (p_item->defer_statement)
        {
            count++;
        }
        p_item = p_item->next;
    }
    return count;
}

static void expression_to_bool_value(struct d_visit_ctx * ctx, struct osstream * oss, struct expression * p_expression)
{
    if (object_has_constant_value(&p_expression->object))
    {
        if (object_is_true(&p_expression->object))
        {
            ss_fprintf(oss, "1");
        }
        else
        {
            ss_fprintf(oss, "0");
        }
    }
    else
    {
        if (type_is_bool(&p_expression->type) || type_is_essential_bool(&p_expression->type))
        {
            d_visit_expression(ctx, oss, p_expression);
        }
        else
        {
            /*switch*/
            {
                int __v0 = p_expression->expression_type;
                if (__v0 == 54) goto __L4; /*case 54*/
                if (__v0 == 55) goto __L5; /*case 55*/
                if (__v0 == 56) goto __L6; /*case 56*/
                if (__v0 == 57) goto __L7; /*case 57*/
                if (__v0 == 58) goto __L8; /*case 58*/
                if (__v0 == 59) goto __L9; /*case 59*/
                if (__v0 == 60) goto __L10; /*case 60*/
                if (__v0 == 61) goto __L11; /*case 61*/
                if (__v0 == 62) goto __L12; /*case 62*/
                if (__v0 == 63) goto __L13; /*case 63*/
                if (__v0 == 64) goto __L14; /*case 64*/
                if (__v0 == 65) goto __L15; /*case 65*/
                if (__v0 == 66) goto __L16; /*case 66*/
                if (__v0 == 67) goto __L17; /*case 67*/
                if (__v0 == 68) goto __L18; /*case 68*/
                if (__v0 == 69) goto __L19; /*case 69*/
                if (__v0 == 70) goto __L20; /*case 70*/
                if (__v0 == 71) goto __L21; /*case 71*/
                if (__v0 == 72) goto __L22; /*case 72*/
                if (__v0 == 73) goto __L23; /*case 73*/
                goto __L24; /* default */

                {
                    __L4: /*case 54*/ 
                    __L5: /*case 55*/ 
                    __L6: /*case 56*/ 
                    __L7: /*case 57*/ 
                    __L8: /*case 58*/ 
                    __L9: /*case 59*/ 
                    __L10: /*case 60*/ 
                    __L11: /*case 61*/ 
                    __L12: /*case 62*/ 
                    __L13: /*case 63*/ 
                    __L14: /*case 64*/ 
                    __L15: /*case 65*/ 
                    __L16: /*case 66*/ 
                    __L17: /*case 67*/ 
                    __L18: /*case 68*/ 
                    __L19: /*case 69*/ 
                    __L20: /*case 70*/ 
                    __L21: /*case 71*/ 
                    __L22: /*case 72*/ 
                    __L23: /*case 73*/ 
                    ss_fprintf(oss, "((");
                    d_visit_expression(ctx, oss, p_expression);
                    ss_fprintf(oss, ") != 0)");
                    goto __L3; /* break */

                    __L24: /* default */ 
                    ss_fprintf(oss, "(");
                    d_visit_expression(ctx, oss, p_expression);
                    ss_fprintf(oss, " != 0)");
                    goto __L3; /* break */

                }
                __L3:;
            }
        }
    }
}

static void d_visit_jump_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct jump_statement * p_jump_statement)
{
    if (p_jump_statement->first_token->type == 9037)
    {
        il_print_defer_list(ctx, oss, &p_jump_statement->defer_list);
        print_identation(ctx, oss);
        ss_fprintf(oss, "goto __L%d; /* throw */\n", p_jump_statement->label_id);
    }
    else
    {
        if (p_jump_statement->first_token->type == 9027)
        {
            struct type  return_type;
            unsigned char  constant_expression_or_void;

            return_type = get_function_return_type(&ctx->p_current_function_opt->type);
            constant_expression_or_void = p_jump_statement->expression_opt == 0 || object_has_constant_value(&p_jump_statement->expression_opt->object) || il_defer_count(&p_jump_statement->defer_list) == 0;
            if (constant_expression_or_void)
            {
                il_print_defer_list(ctx, oss, &p_jump_statement->defer_list);
                print_identation(ctx, oss);
                ss_fprintf(oss, "return");
                if (p_jump_statement->expression_opt)
                {
                    ss_fprintf(oss, " ");
                    if (type_is_bool(&return_type))
                    {
                        expression_to_bool_value(ctx, oss, p_jump_statement->expression_opt);
                    }
                    else
                    {
                        d_visit_expression(ctx, oss, p_jump_statement->expression_opt);
                    }
                }
                ss_fprintf(oss, ";\n");
            }
            else
            {
                char name[100];

                _cake_zmem(&name, 100);
                snprintf(name, 100, "__v%d", ctx->cake_local_declarator_number++);
                {
                    struct osstream  local;

                    _cake_zmem(&local, 12);
                    print_identation(ctx, &local);
                    d_print_type(ctx, &local, &return_type, name, 0);
                    ss_fprintf(&local, ";\n", name);
                    ss_fprintf(&ctx->block_scope_declarators, "%s", local.c_str);
                    ss_close(&local);
                }
                print_identation(ctx, oss);
                ss_fprintf(oss, "%s = ", name);
                if (p_jump_statement->expression_opt)
                {
                    if (type_is_bool(&return_type))
                    {
                        expression_to_bool_value(ctx, oss, p_jump_statement->expression_opt);
                    }
                    else
                    {
                        d_visit_expression(ctx, oss, p_jump_statement->expression_opt);
                    }
                }
                ss_fprintf(oss, ";\n");
                il_print_defer_list(ctx, oss, &p_jump_statement->defer_list);
                print_identation(ctx, oss);
                ss_fprintf(oss, "return %s;\n", name);
            }
            type_destroy(&return_type);
        }
        else
        {
            if (p_jump_statement->first_token->type == 9000 || p_jump_statement->first_token->type == 9005)
            {
                il_print_defer_list(ctx, oss, &p_jump_statement->defer_list);
                print_identation(ctx, oss);
                if (p_jump_statement->first_token->type == 9000)
                {
                    if (ctx->break_reference.p_selection_statement)
                    {
                        ss_fprintf(oss, "goto __L%d; /* break */\n\n", ctx->break_reference.p_selection_statement->label_id);
                    }
                    else
                    {
                        ss_fprintf(oss, "break;\n");
                    }
                }
                else
                {
                    ss_fprintf(oss, "continue;\n");
                }
            }
            else
            {
                if (p_jump_statement->first_token->type == 9016)
                {
                    il_print_defer_list(ctx, oss, &p_jump_statement->defer_list);
                    print_identation(ctx, oss);
                    ss_fprintf(oss, "goto %s;\n", p_jump_statement->label->lexeme);
                }
                else
                {
                    ;
                }
            }
        }
    }
}

static void d_visit_unlabeled_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct unlabeled_statement * p_unlabeled_statement)
{
    if (p_unlabeled_statement->primary_block)
    {
        d_visit_primary_block(ctx, oss, p_unlabeled_statement->primary_block);
    }
    else
    {
        if (p_unlabeled_statement->expression_statement)
        {
            d_visit_expression_statement(ctx, oss, p_unlabeled_statement->expression_statement);
        }
        else
        {
            if (p_unlabeled_statement->jump_statement)
            {
                d_visit_jump_statement(ctx, oss, p_unlabeled_statement->jump_statement);
            }
            else
            {
                ;
            }
        }
    }
}

static void d_visit_block_item(struct d_visit_ctx * ctx, struct osstream * oss, struct block_item * p_block_item)
{
    struct osstream  ss0;

    _cake_zmem(&ss0, 12);
    ss_swap(oss, &ss0);
    ss_clear(&ctx->add_this_before);
    if (p_block_item->declaration)
    {
        d_visit_declaration(ctx, oss, p_block_item->declaration);
    }
    else
    {
        if (p_block_item->unlabeled_statement)
        {
            d_visit_unlabeled_statement(ctx, oss, p_block_item->unlabeled_statement);
        }
        else
        {
            if (p_block_item->label)
            {
                d_visit_label(ctx, oss, p_block_item->label);
            }
        }
    }
    if (ctx->add_this_before.size > 0)
    {
        ss_fprintf(&ss0, "%s", ctx->add_this_before.c_str);
        ss_clear(&ctx->add_this_before);
    }
    if (oss->c_str)
    {
        ss_fprintf(&ss0, "%s", oss->c_str);
    }
    ss_swap(oss, &ss0);
    ss_close(&ss0);
}

static void d_visit_block_item_list(struct d_visit_ctx * ctx, struct osstream * oss, struct block_item_list * p_block_item_list)
{
    struct block_item * p_block_item;

    p_block_item = p_block_item_list->head;
    while (p_block_item)
    {
        d_visit_block_item(ctx, oss, p_block_item);
        p_block_item = p_block_item->next;
    }
}

static void d_visit_compound_statement(struct d_visit_ctx * ctx, struct osstream * oss, struct compound_statement * p_compound_statement)
{
    unsigned char  is_local;
    struct osstream  block_scope_declarators;
    struct osstream  local;
    unsigned char  ends_with_jump;

    is_local = ctx->is_local;
    ctx->is_local = 1;
    _cake_zmem(&block_scope_declarators, 12);
    ss_swap(&ctx->block_scope_declarators, &block_scope_declarators);
    _cake_zmem(&local, 12);
    ctx->indentation++;
    d_visit_block_item_list(ctx, &local, &p_compound_statement->block_item_list);
    ends_with_jump = 0;
    if (p_compound_statement->block_item_list.tail && p_compound_statement->block_item_list.tail->unlabeled_statement && p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement != 0)
    {
        ends_with_jump = 1;
    }
    if (!ends_with_jump)
    {
        il_print_defer_list(ctx, &local, &p_compound_statement->defer_list);
    }
    ctx->indentation--;
    print_identation(ctx, oss);
    ss_fprintf(oss, "{\n");
    if (ctx->block_scope_declarators.c_str)
    {
        ss_fprintf(oss, "%s", ctx->block_scope_declarators.c_str);
        ss_fprintf(oss, "\n");
    }
    if (local.c_str)
    {
        ss_fprintf(oss, "%s", local.c_str);
    }
    print_identation(ctx, oss);
    ss_fprintf(oss, "}\n");
    ctx->is_local = is_local;
    ss_swap(&ctx->block_scope_declarators, &block_scope_declarators);
    ss_close(&block_scope_declarators);
    ss_close(&local);
}

static void d_visit_function_body(struct d_visit_ctx * ctx, struct osstream * oss, struct declarator * function_definition)
{
    int indentation;
    struct declarator * previous_func;

    if (function_definition->function_body == 0)
    {
        ;
        return;
    }
    ctx->cake_local_declarator_number = 0;
    indentation = ctx->indentation;
    ctx->indentation = 0;
    previous_func = ctx->p_current_function_opt;
    ctx->p_current_function_opt = function_definition;
    d_visit_compound_statement(ctx, oss, function_definition->function_body);
    ctx->p_current_function_opt = previous_func;
    ctx->indentation = indentation;
}

static int il_visit_literal_string2(struct token * current, struct osstream * oss)
{
    unsigned char  has_u8_prefix;
    unsigned char  has_wide_prefix;
    unsigned char * psz;

    has_u8_prefix = current->lexeme[0] == 117 && current->lexeme[1] == 56;
    has_wide_prefix = current->lexeme[0] == 76;
    psz = (unsigned char *)(current->lexeme + 0);
    if (has_u8_prefix)
    {
        psz = (unsigned char *)(current->lexeme + 2 + 1);
    }
    else
    {
        if (has_wide_prefix)
        {
            psz = (unsigned char *)(current->lexeme + 1 + 1);
        }
        else
        {
            psz = (unsigned char *)(current->lexeme + 1);
        }
    }
    while (*psz)
    {
        if (*(psz + 1) == 0)
        {
            break;
        }
        if (*psz >= 128)
        {
            ss_fprintf(oss, "\\x%x", *psz);
        }
        else
        {
            ss_fprintf(oss, "%c", *psz);
        }
        psz++;
    }
    return 0;
}

static void il_print_string(struct token * first_token, struct token * last_token, struct osstream * oss)
{
    unsigned char  opened;
    struct token * ptk;

    opened = 0;
    ptk = first_token;
    do
    {
        if (ptk == 0)
        {
            break;
        }
        if ((ptk->flags & 1) && ptk->type == 130)
        {
            if (!opened)
            {
                if (ptk->lexeme[0] == 76)
                {
                    ss_fprintf(oss, "L");
                }
                ss_fprintf(oss, "\"");
                opened = 1;
            }
            il_visit_literal_string2(ptk, oss);
        }
        if (ptk == last_token)
        {
            break;
        }
        ptk = ptk->next;
    }
    while (ptk);
    ss_fprintf(oss, "\"");
}

static struct member_declarator *find_member_declarator_name_by_index(struct member_declaration_list * list, int member_index, char name[100], int * p_count)
{
    int no_name_index;
    struct member_declaration * p_member_declaration;

    if (list->head == 0)
    {
        return 0;
    }
    no_name_index = 0;
    p_member_declaration = list->head;
    while (p_member_declaration)
    {
        struct member_declarator * p_member_declarator;

        p_member_declarator = 0;
        if (p_member_declaration->member_declarator_list_opt)
        {
            p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
            while (p_member_declarator)
            {
                if (p_member_declarator->declarator)
                {
                    if (member_index == *p_count)
                    {
                        snprintf(name, 100, "%s", p_member_declarator->declarator->name_opt->lexeme);
                        return p_member_declarator;
                    }
                }
                (*p_count)++;
                p_member_declarator = p_member_declarator->next;
            }
        }
        else
        {
            if (p_member_declaration->specifier_qualifier_list)
            {
                if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                {
                    struct struct_or_union_specifier * p_complete;

                    p_complete = get_complete_struct_or_union_specifier(p_member_declaration->specifier_qualifier_list->struct_or_union_specifier);
                    if (p_complete)
                    {
                        char mname[100];

                        _cake_zmem(&mname, 100);
                        p_member_declarator = find_member_declarator_name_by_index(&p_complete->member_declaration_list, member_index, mname, p_count);
                        if (p_member_declarator)
                        {
                            snprintf(name, 100, "__m%d.%s", no_name_index++, mname);
                            return p_member_declarator;
                        }
                    }
                }
            }
        }
        p_member_declaration = p_member_declaration->next;
    }
    return 0;
}

static int find_member_name(struct type * p_type, int index, char name[100])
{
    struct struct_or_union_specifier * p_complete;

    if (!type_is_struct_or_union(p_type))
    {
        return 1;
    }
    ;
    p_complete = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
    if (p_complete)
    {
        int count;
        struct member_declarator * p;

        count = 0;
        p = find_member_declarator_name_by_index(&p_complete->member_declaration_list, index, name, &count);
        if (p)
        {
            return 0;
        }
    }
    return 1;
}

static void object_print_non_constant_initialization(struct d_visit_ctx * ctx, struct osstream * ss, struct object * object, char * declarator_name, unsigned char  all, unsigned char  initialize_objects_that_does_not_have_initializer)
{
    if (object_is_reference(object))
    {
        object = object_get_referenced(object);
    }
    if (object->members.head != 0)
    {
        if (type_is_union(&object->type))
        {
            struct object * member;

            member = object->members.head;
            if (member->p_init_expression && object_has_constant_value(&member->p_init_expression->object) && !all)
            {
            }
            else
            {
                while (member)
                {
                    if (member->p_init_expression)
                    {
                        struct osstream  local;

                        print_identation_core(ss, ctx->indentation);
                        ss_fprintf(ss, "%s%s = ", declarator_name, member->member_designator);
                        _cake_zmem(&local, 12);
                        d_visit_expression(ctx, &local, member->p_init_expression);
                        ss_fprintf(ss, "%s", local.c_str);
                        ss_fprintf(ss, ";\n");
                        ss_close(&local);
                        break;
                    }
                    else
                    {
                        if (all)
                        {
                            if (initialize_objects_that_does_not_have_initializer)
                            {
                                print_identation_core(ss, ctx->indentation);
                                ss_fprintf(ss, "%s%s = 0;\n", declarator_name, member->member_designator);
                            }
                        }
                    }
                    member = member->next;
                }
            }
        }
        else
        {
            if (object->p_init_expression && object->p_init_expression->expression_type == 3 && type_is_array(&object->type))
            {
                struct osstream  local;
                unsigned int string_size;

                print_identation_core(ss, ctx->indentation);
                ss_fprintf(ss, "_cake_memcpy(%s%s, ", declarator_name, object->member_designator);
                _cake_zmem(&local, 12);
                d_visit_expression(ctx, &local, object->p_init_expression);
                string_size = object->p_init_expression->type.num_of_elements;
                ss_fprintf(ss, "%s, %zu", local.c_str, string_size);
                ss_fprintf(ss, ");\n");
                ss_close(&local);
                ctx->memcpy_used = 1;
            }
            else
            {
                if (object->p_init_expression)
                {
                    struct osstream  local;
                    unsigned int sz;
                    struct object * member;

                    print_identation_core(ss, ctx->indentation);
                    ss_fprintf(ss, "_cake_memcpy(&%s%s, ", declarator_name, object->member_designator);
                    _cake_zmem(&local, 12);
                    d_visit_expression(ctx, &local, object->p_init_expression);
                    sz = 0;
                    type_get_sizeof(&object->type, &sz, ctx->options.target);
                    ss_fprintf(ss, "&%s, %d", local.c_str, sz);
                    ss_fprintf(ss, ");\n");
                    ss_close(&local);
                    ctx->memcpy_used = 1;
                    member = object->members.head;
                    while (member)
                    {
                        object_print_non_constant_initialization(ctx, ss, member, declarator_name, all, 0);
                        member = member->next;
                    }
                }
                else
                {
                    struct object * member;

                    member = object->members.head;
                    while (member)
                    {
                        object_print_non_constant_initialization(ctx, ss, member, declarator_name, all, 1);
                        member = member->next;
                    }
                }
            }
        }
    }
    else
    {
        if (object->p_init_expression)
        {
            if (!all)
            {
                if (object->p_init_expression->expression_type == 3)
                {
                }
                else
                {
                    if (!object_has_constant_value(&object->p_init_expression->object))
                    {
                        struct osstream  local;

                        print_identation_core(ss, ctx->indentation);
                        ss_fprintf(ss, "%s%s = ", declarator_name, object->member_designator);
                        _cake_zmem(&local, 12);
                        d_visit_expression(ctx, &local, object->p_init_expression);
                        ss_fprintf(ss, "%s", local.c_str);
                        ss_fprintf(ss, ";\n");
                        ss_close(&local);
                    }
                }
            }
            else
            {
                struct osstream  local;

                print_identation_core(ss, ctx->indentation);
                ss_fprintf(ss, "%s%s = ", declarator_name, object->member_designator);
                _cake_zmem(&local, 12);
                d_visit_expression(ctx, &local, object->p_init_expression);
                ss_fprintf(ss, "%s", local.c_str);
                ss_fprintf(ss, ";\n");
                ss_close(&local);
            }
        }
        else
        {
            if (all)
            {
                if (initialize_objects_that_does_not_have_initializer)
                {
                    print_identation_core(ss, ctx->indentation);
                    ss_fprintf(ss, "%s%s = 0;\n", declarator_name, object->member_designator);
                }
            }
        }
    }
}

static void object_print_constant_initialization(struct d_visit_ctx * ctx, struct osstream * ss, struct object * object, unsigned char * first)
{
    if (object_is_reference(object))
    {
        object = object_get_referenced(object);
    }
    if (object->p_init_expression && object->p_init_expression->expression_type == 3)
    {
        if (!(*first))
        {
            ss_fprintf(ss, ",");
        }
        *first = 0;
        il_print_string(object->p_init_expression->first_token, object->p_init_expression->last_token, ss);
        return;
    }
    if (object->members.head != 0)
    {
        if (type_is_union(&object->type))
        {
            struct object * member;

            member = object->members.head;
            object_print_constant_initialization(ctx, ss, member, first);
        }
        else
        {
            struct object * member;

            member = object->members.head;
            while (member)
            {
                object_print_constant_initialization(ctx, ss, member, first);
                member = member->next;
            }
        }
    }
    else
    {
        if (!(*first))
        {
            ss_fprintf(ss, ",");
        }
        *first = 0;
        if (object->p_init_expression)
        {
            if (object_has_constant_value(&object->p_init_expression->object))
            {
                object_print_value(ss, &object->p_init_expression->object, ctx->options.target);
            }
            else
            {
                if (object->p_init_expression->expression_type == 3)
                {
                    il_print_string(object->p_init_expression->first_token, object->p_init_expression->last_token, ss);
                }
                else
                {
                    d_visit_expression(ctx, ss, object->p_init_expression);
                }
            }
        }
        else
        {
            ss_fprintf(ss, "0");
        }
    }
}

static char *get_op_by_expression_type(int type)
{
    /*switch*/
    {
        int __v0 = type;
        if (__v0 == 61) goto __L1; /*case 61*/
        if (__v0 == 62) goto __L2; /*case 62*/
        if (__v0 == 63) goto __L3; /*case 63*/
        if (__v0 == 64) goto __L4; /*case 64*/
        if (__v0 == 65) goto __L5; /*case 65*/
        if (__v0 == 66) goto __L6; /*case 66*/
        if (__v0 == 67) goto __L7; /*case 67*/
        if (__v0 == 68) goto __L8; /*case 68*/
        if (__v0 == 69) goto __L9; /*case 69*/
        if (__v0 == 70) goto __L10; /*case 70*/
        if (__v0 == 71) goto __L11; /*case 71*/
        goto __L12; /* default */

        {
            __L1: /*case 61*/ 
            return "=";
            __L2: /*case 62*/ 
            return "+=";
            __L3: /*case 63*/ 
            return "-=";
            __L4: /*case 64*/ 
            return "*=";
            __L5: /*case 65*/ 
            return "/=";
            __L6: /*case 66*/ 
            return "%=";
            __L7: /*case 67*/ 
            return "<<=";
            __L8: /*case 68*/ 
            return ">>=";
            __L9: /*case 69*/ 
            return "&=";
            __L10: /*case 70*/ 
            return "|=";
            __L11: /*case 71*/ 
            return "^=";
            __L12: /* default */ 
            goto __L0; /* break */

        }
        __L0:;
    }
    ;
    return "";
}

static void d_visit_expression(struct d_visit_ctx * ctx, struct osstream * oss, struct expression * p_expression)
{
    if (!ctx->address_of_argument && object_has_constant_value(&p_expression->object))
    {
        if (type_is_void_ptr(&p_expression->type) || type_is_nullptr_t(&p_expression->type))
        {
            if (object_is_zero(&p_expression->object))
            {
                if (ctx->define_nullptr)
                {
                    ss_fprintf(oss, "NULL");
                    ctx->null_pointer_constant_used = 1;
                }
                else
                {
                    ss_fprintf(oss, "0");
                }
                return;
            }
        }
        else
        {
            if (type_is_arithmetic(&p_expression->type))
            {
                object_print_value(oss, &p_expression->object, ctx->options.target);
                return;
            }
        }
    }
    ctx->address_of_argument = 0;
    /*switch*/
    {
        int __v0 = p_expression->expression_type;
        if (__v0 == 0) goto __L6; /*case 0*/
        if (__v0 == 4) goto __L7; /*case 4*/
        if (__v0 == 2) goto __L10; /*case 2*/
        if (__v0 == 3) goto __L20; /*case 3*/
        if (__v0 == 1) goto __L21; /*case 1*/
        if (__v0 == 5) goto __L22; /*case 5*/
        if (__v0 == 8) goto __L23; /*case 8*/
        if (__v0 == 6) goto __L24; /*case 6*/
        if (__v0 == 9) goto __L25; /*case 9*/
        if (__v0 == 7) goto __L27; /*case 7*/
        if (__v0 == 26) goto __L29; /*case 26*/
        if (__v0 == 25) goto __L31; /*case 25*/
        if (__v0 == 21) goto __L33; /*case 21*/
        if (__v0 == 22) goto __L35; /*case 22*/
        if (__v0 == 23) goto __L36; /*case 23*/
        if (__v0 == 24) goto __L37; /*case 24*/
        if (__v0 == 14) goto __L39; /*case 14*/
        if (__v0 == 15) goto __L41; /*case 15*/
        if (__v0 == 16) goto __L43; /*case 16*/
        if (__v0 == 17) goto __L44; /*case 17*/
        if (__v0 == 13) goto __L45; /*case 13*/
        if (__v0 == 12) goto __L46; /*case 12*/
        if (__v0 == 41) goto __L50; /*case 41*/
        if (__v0 == 10) goto __L51; /*case 10*/
        if (__v0 == 11) goto __L53; /*case 11*/
        if (__v0 == 18) goto __L55; /*case 18*/
        if (__v0 == 19) goto __L56; /*case 19*/
        if (__v0 == 31) goto __L57; /*case 31*/
        if (__v0 == 30) goto __L58; /*case 30*/
        if (__v0 == 20) goto __L59; /*case 20*/
        if (__v0 == 33) goto __L60; /*case 33*/
        if (__v0 == 34) goto __L61; /*case 34*/
        if (__v0 == 35) goto __L62; /*case 35*/
        if (__v0 == 36) goto __L63; /*case 36*/
        if (__v0 == 37) goto __L64; /*case 37*/
        if (__v0 == 38) goto __L65; /*case 38*/
        if (__v0 == 39) goto __L66; /*case 39*/
        if (__v0 == 40) goto __L67; /*case 40*/
        if (__v0 == 32) goto __L68; /*case 32*/
        if (__v0 == 47) goto __L69; /*case 47*/
        if (__v0 == 46) goto __L70; /*case 46*/
        if (__v0 == 43) goto __L71; /*case 43*/
        if (__v0 == 44) goto __L72; /*case 44*/
        if (__v0 == 45) goto __L73; /*case 45*/
        if (__v0 == 72) goto __L74; /*case 72*/
        if (__v0 == 61) goto __L75; /*case 61*/
        if (__v0 == 62) goto __L77; /*case 62*/
        if (__v0 == 63) goto __L78; /*case 63*/
        if (__v0 == 64) goto __L79; /*case 64*/
        if (__v0 == 65) goto __L80; /*case 65*/
        if (__v0 == 66) goto __L81; /*case 66*/
        if (__v0 == 67) goto __L82; /*case 67*/
        if (__v0 == 68) goto __L83; /*case 68*/
        if (__v0 == 69) goto __L84; /*case 69*/
        if (__v0 == 70) goto __L85; /*case 70*/
        if (__v0 == 71) goto __L86; /*case 71*/
        if (__v0 == 42) goto __L87; /*case 42*/
        if (__v0 == 48) goto __L88; /*case 48*/
        if (__v0 == 49) goto __L89; /*case 49*/
        if (__v0 == 50) goto __L90; /*case 50*/
        if (__v0 == 51) goto __L91; /*case 51*/
        if (__v0 == 54) goto __L92; /*case 54*/
        if (__v0 == 55) goto __L93; /*case 55*/
        if (__v0 == 56) goto __L94; /*case 56*/
        if (__v0 == 57) goto __L95; /*case 57*/
        if (__v0 == 58) goto __L96; /*case 58*/
        if (__v0 == 53) goto __L97; /*case 53*/
        if (__v0 == 52) goto __L98; /*case 52*/
        if (__v0 == 60) goto __L99; /*case 60*/
        if (__v0 == 59) goto __L100; /*case 59*/
        if (__v0 == 27) goto __L101; /*case 27*/
        if (__v0 == 28) goto __L102; /*case 28*/
        if (__v0 == 29) goto __L103; /*case 29*/
        if (__v0 == 73) goto __L104; /*case 73*/
        goto __L5;

        {
            __L6: /*case 0*/ 
            ;
            goto __L5; /* break */

            __L7: /*case 4*/ 
            {
                char func_name[200];
                char name[100];

                ;
                _cake_zmem(&func_name, 200);
                _cake_zmem(&name, 100);
                if (ctx->p_current_function_opt->name_opt)
                {
                    snprintf(func_name, 200, "%s", ctx->p_current_function_opt->name_opt->lexeme);
                    snprintf(name, 100, "__cake_func_%s", func_name);
                }
                else
                {
                    snprintf(func_name, 200, "unnamed");
                    snprintf(name, 100, "__cake_func_%p", ctx->p_current_function_opt);
                }
                if (!ctx->is__func__predefined_identifier_added)
                {
                    ;
                    ctx->is__func__predefined_identifier_added = 1;
                    ss_fprintf(&ctx->add_this_before_external_decl, "static const char %s[] = \"%s\";\n", name, func_name);
                }
                ss_fprintf(oss, "%s", name);
            }
            goto __L5; /* break */

            __L10: /*case 2*/ 
            {
                char * declarator_name;
                unsigned char  is_function;
                unsigned char  is_local_function_definition;
                unsigned char  is_static;
                unsigned char  is_auto;
                unsigned char  is_inline;
                unsigned char  is_extern;
                unsigned char  is_local;

                ;
                ;
                declarator_name = "";
                if (p_expression->declarator->name_opt)
                {
                    declarator_name = p_expression->declarator->name_opt->lexeme;
                }
                is_function = type_is_function(&p_expression->declarator->type);
                is_local_function_definition = 0;
                if (is_function)
                {
                    is_local_function_definition = p_expression->type.storage_class_specifier_flags & 4096 && p_expression->declarator->function_body != 0;
                }
                is_static = ((p_expression->declarator->declaration_specifiers->storage_class_specifier_flags & 4) != 0);
                is_auto = ((p_expression->declarator->declaration_specifiers->storage_class_specifier_flags & 16) != 0);
                is_inline = ((p_expression->declarator->declaration_specifiers->function_specifier_flags & 1) != 0);
                is_extern = ((p_expression->type.storage_class_specifier_flags & 2) != 0);
                is_local = (!is_static && !is_extern) && p_expression->type.storage_class_specifier_flags & 4096;
                if (is_function)
                {
                    struct map_entry * p;

                    ss_fprintf(oss, "%s", p_expression->declarator->name_opt->lexeme);
                    p = hashmap_find(&ctx->file_scope_declarator_map, declarator_name);
                    if (p == 0)
                    {
                        struct hash_item_set  i;
                        struct osstream  ss;
                        struct declarator * p_function_defined;

                        _cake_zmem(&i, 32);
                        i.number = 1;
                        hashmap_set(&ctx->file_scope_declarator_map, declarator_name, &i);
                        hash_item_set_destroy(&i);
                        _cake_zmem(&ss, 12);
                        if ((is_inline || is_local_function_definition || is_auto) && !is_static)
                        {
                            ss_fprintf(&ss, "static ");
                        }
                        d_print_type(ctx, &ss, &p_expression->type, declarator_name, 1);
                        ss_fprintf(&ctx->add_this_before_external_decl, "%s", ss.c_str);
                        ss_fprintf(&ctx->add_this_before_external_decl, ";\n");
                        ;
                        p_function_defined = declarator_get_function_definition(p_expression->declarator);
                        if (p_function_defined && (is_static || is_inline || is_auto || is_local_function_definition))
                        {
                            struct osstream  local3;
                            struct osstream  local4;

                            _cake_zmem(&local3, 12);
                            _cake_zmem(&local4, 12);
                            d_print_type(ctx, &local4, &p_function_defined->type, declarator_name, 0);
                            ss_fprintf(&local3, "static %s\n", local4.c_str);
                            d_visit_function_body(ctx, &local3, p_function_defined);
                            ;
                            ;
                            ss_fprintf(&ctx->add_this_after_external_decl, "\n");
                            ss_fprintf(&ctx->add_this_after_external_decl, "%s", local3.c_str);
                            ss_close(&local3);
                            ss_close(&local4);
                        }
                        ss_close(&ss);
                    }
                }
                else
                {
                    if (is_local)
                    {
                        ss_fprintf(oss, "%s", p_expression->declarator->name_opt->lexeme);
                    }
                    else
                    {
                        void * p;

                        p = hashmap_find(&ctx->file_scope_declarator_map, declarator_name);
                        if (p == 0)
                        {
                            struct hash_item_set  i;
                            struct osstream  ss;

                            _cake_zmem(&i, 32);
                            i.number = 1;
                            hashmap_set(&ctx->file_scope_declarator_map, declarator_name, &i);
                            ;
                            ;
                            _cake_zmem(&ss, 12);
                            d_print_type(ctx, &ss, &p_expression->type, declarator_name, 1);
                            if (p_expression->p_init_declarator && p_expression->p_init_declarator->initializer)
                            {
                                print_initializer(ctx, &ss, p_expression->p_init_declarator, 1);
                                ;
                                ss_fprintf(&ctx->add_this_before_external_decl, "%s\n", ss.c_str);
                            }
                            else
                            {
                                ;
                                ss_fprintf(&ctx->add_this_before_external_decl, "%s;\n", ss.c_str);
                            }
                            ss_close(&ss);
                            hash_item_set_destroy(&i);
                        }
                        ss_fprintf(oss, "%s", p_expression->declarator->name_opt->lexeme);
                    }
                }
            }
            goto __L5; /* break */

            __L20: /*case 3*/ 
            il_print_string(p_expression->first_token, p_expression->last_token, oss);
            goto __L5; /* break */

            __L21: /*case 1*/ 
            __L22: /*case 5*/ 
            __L23: /*case 8*/ 
            __L24: /*case 6*/ 
            object_print_value(oss, &p_expression->object, ctx->options.target);
            goto __L5; /* break */

            __L25: /*case 9*/ 
            ;
            if (p_expression->right->expression_type == 9)
            {
                d_visit_expression(ctx, oss, p_expression->right);
            }
            else
            {
                ss_fprintf(oss, "(");
                d_visit_expression(ctx, oss, p_expression->right);
                ss_fprintf(oss, ")");
            }
            goto __L5; /* break */

            __L27: /*case 7*/ 
            ;
            if (p_expression->generic_selection->p_view_selected_expression)
            {
                d_visit_expression(ctx, oss, p_expression->generic_selection->p_view_selected_expression);
            }
            goto __L5; /* break */

            __L29: /*case 26*/ 
            {
                struct argument_expression * arg;

                ss_fprintf(oss, "%s(", p_expression->first_token->lexeme);
                arg = p_expression->argument_expression_list.head;
                while (arg)
                {
                    d_visit_expression(ctx, oss, arg->expression);
                    if (arg->next)
                    {
                        ss_fprintf(oss, ", ");
                    }
                    arg = arg->next;
                }
                ss_fprintf(oss, ")");
            }
            goto __L5; /* break */

            __L31: /*case 25*/ 
            ss_fprintf(oss, "__builtin_offsetof(");
            if (p_expression->type_name)
            {
                d_print_type(ctx, oss, &p_expression->type_name->type, 0, 0);
            }
            ss_fprintf(oss, ", ");
            ss_fprintf(oss, "%s", p_expression->offsetof_member_designator->lexeme);
            ss_fprintf(oss, ")");
            goto __L5; /* break */

            __L33: /*case 21*/ 
            ;
            if (p_expression->right != 0)
            {
                ss_fprintf(oss, "__builtin_va_start(");
                d_visit_expression(ctx, oss, p_expression->left);
                ss_fprintf(oss, ", ");
                d_visit_expression(ctx, oss, p_expression->right);
                ss_fprintf(oss, ")");
            }
            else
            {
                ss_fprintf(oss, "__builtin_c23_va_start(");
                d_visit_expression(ctx, oss, p_expression->left);
                ss_fprintf(oss, ")");
            }
            goto __L5; /* break */

            __L35: /*case 22*/ 
            ;
            ss_fprintf(oss, "__builtin_va_end(");
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, ")");
            goto __L5; /* break */

            __L36: /*case 23*/ 
            ;
            ;
            ss_fprintf(oss, "__builtin_va_copy(");
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, ", ");
            d_visit_expression(ctx, oss, p_expression->right);
            ss_fprintf(oss, ")");
            goto __L5; /* break */

            __L37: /*case 24*/ 
            ;
            ss_fprintf(oss, "__builtin_va_arg(");
            d_visit_expression(ctx, oss, p_expression->left);
            if (p_expression->type_name)
            {
                ss_fprintf(oss, ", ");
                d_print_type(ctx, oss, &p_expression->type_name->type, 0, 0);
            }
            ss_fprintf(oss, ")");
            goto __L5; /* break */

            __L39: /*case 14*/ 
            {
                char name[100];
                int r;

                ;
                d_visit_expression(ctx, oss, p_expression->left);
                _cake_zmem(&name, 100);
                r = find_member_name(&p_expression->left->type, p_expression->member_index, name);
                if (r == 0)
                {
                    ss_fprintf(oss, ".%s", name);
                }
            }
            goto __L5; /* break */

            __L41: /*case 15*/ 
            {
                ;
                d_visit_expression(ctx, oss, p_expression->left);
                {
                    struct type  t;
                    char name[100];
                    int r;

                    t = type_remove_pointer(&p_expression->left->type);
                    _cake_zmem(&name, 100);
                    r = find_member_name(&t, p_expression->member_index, name);
                    if (r == 0)
                    {
                        ss_fprintf(oss, "->%s", name);
                    }
                    type_destroy(&t);
                }
            }
            goto __L5; /* break */

            __L43: /*case 16*/ 
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, "++");
            goto __L5; /* break */

            __L44: /*case 17*/ 
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, "--");
            goto __L5; /* break */

            __L45: /*case 13*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, "[");
            d_visit_expression(ctx, oss, p_expression->right);
            ss_fprintf(oss, "]");
            goto __L5; /* break */

            __L46: /*case 12*/ 
            {
                struct param * param;
                struct argument_expression * arg;

                ;
                d_visit_expression(ctx, oss, p_expression->left);
                param = p_expression->left->type.params.head;
                ss_fprintf(oss, "(");
                arg = p_expression->argument_expression_list.head;
                while (arg)
                {
                    unsigned char  to_bool;

                    to_bool = param && type_is_bool(&param->type) && !(type_is_bool(&arg->expression->type) || type_is_essential_bool(&arg->expression->type));
                    if (to_bool)
                    {
                        expression_to_bool_value(ctx, oss, arg->expression);
                    }
                    else
                    {
                        d_visit_expression(ctx, oss, arg->expression);
                    }
                    if (param)
                    {
                        param = param->next;
                    }
                    if (arg->next)
                    {
                        ss_fprintf(oss, ", ");
                    }
                    arg = arg->next;
                }
                ss_fprintf(oss, ")");
            }
            goto __L5; /* break */

            __L50: /*case 41*/ 
            {
                ;
                ss_fprintf(oss, "&");
                ctx->address_of_argument = 1;
                d_visit_expression(ctx, oss, p_expression->right);
                ctx->address_of_argument = 0;
            }
            goto __L5; /* break */

            __L51: /*case 10*/ 
            {
                char generated_function_literal_name[100];
                struct osstream  function_literal_nameless;
                struct declarator * p_current_function_opt;
                int current_indentation;
                struct osstream  function_literal_body;
                struct osstream  function_literal;
                struct map_entry * l;

                ;
                _cake_zmem(&generated_function_literal_name, 100);
                print_identation_core(&ctx->add_this_before, ctx->indentation);
                _cake_zmem(&function_literal_nameless, 12);
                d_print_type(ctx, &function_literal_nameless, &p_expression->type, 0, 0);
                ;
                p_current_function_opt = ctx->p_current_function_opt;
                ctx->p_current_function_opt = p_expression->type_name->abstract_declarator;
                current_indentation = ctx->indentation;
                ctx->indentation = 0;
                _cake_zmem(&function_literal_body, 12);
                d_visit_compound_statement(ctx, &function_literal_body, p_expression->compound_statement);
                ctx->p_current_function_opt = p_current_function_opt;
                ctx->indentation = current_indentation;
                _cake_zmem(&function_literal, 12);
                ss_fprintf(&function_literal, "%s%s", function_literal_nameless.c_str, function_literal_body.c_str);
                ;
                l = hashmap_find(&ctx->instantiated_function_literals, function_literal.c_str);
                if (l != 0)
                {
                    snprintf(generated_function_literal_name, 100, "__c%zu_f", l->data.number);
                }
                else
                {
                    unsigned int current_cake_declarator_number;
                    struct hash_item_set  i;
                    struct osstream  lambda_sig;

                    current_cake_declarator_number = ctx->cake_file_scope_declarator_number++;
                    _cake_zmem(&i, 32);
                    i.number = current_cake_declarator_number;
                    hashmap_set(&ctx->instantiated_function_literals, function_literal.c_str, &i);
                    hash_item_set_destroy(&i);
                    snprintf(generated_function_literal_name, 100, "__c%d_f", current_cake_declarator_number);
                    _cake_zmem(&lambda_sig, 12);
                    d_print_type(ctx, &lambda_sig, &p_expression->type, generated_function_literal_name, 0);
                    ss_fprintf(&ctx->add_this_before_external_decl, "static %s\n%s", lambda_sig.c_str, function_literal_body.c_str);
                    ss_close(&lambda_sig);
                }
                ss_fprintf(oss, "%s", generated_function_literal_name);
                ss_close(&function_literal_nameless);
                ss_close(&function_literal);
            }
            goto __L5; /* break */

            __L53: /*case 11*/ 
            {
                char name[100];

                _cake_zmem(&name, 100);
                snprintf(name, 100, "__v%d", ctx->cake_local_declarator_number++);
                if (ctx->is_local)
                {
                    struct osstream  local;

                    _cake_zmem(&local, 12);
                    ss_swap(&ctx->block_scope_declarators, &local);
                    print_identation_core(&local, ctx->indentation);
                    d_print_type(ctx, &local, &p_expression->type, name, 0);
                    ss_fprintf(&local, ";\n", name);
                    ss_fprintf(&ctx->block_scope_declarators, "%s", local.c_str);
                    ss_clear(&local);
                    object_print_non_constant_initialization(ctx, &local, &p_expression->object, name, 1, 1);
                    ;
                    ss_fprintf(&ctx->add_this_before, "%s", local.c_str);
                    ss_close(&local);
                    ss_fprintf(oss, "%s", name);
                }
                else
                {
                    struct osstream  local;
                    unsigned char  first;

                    _cake_zmem(&local, 12);
                    print_identation_core(&local, ctx->indentation);
                    d_print_type(ctx, &local, &p_expression->type, name, 0);
                    first = 1;
                    ss_fprintf(&local, " = {");
                    object_print_constant_initialization(ctx, &local, &p_expression->object, &first);
                    ss_fprintf(&local, "};\n");
                    ss_fprintf(&ctx->add_this_before, "%s", local.c_str);
                    ss_close(&local);
                    ss_fprintf(oss, "%s", name);
                }
            }
            goto __L5; /* break */

            __L55: /*case 18*/ 
            object_print_value(oss, &p_expression->object, ctx->options.target);
            goto __L5; /* break */

            __L56: /*case 19*/ 
            object_print_value(oss, &p_expression->object, ctx->options.target);
            goto __L5; /* break */

            __L57: /*case 31*/ 
            __L58: /*case 30*/ 
            __L59: /*case 20*/ 
            object_print_value(oss, &p_expression->object, ctx->options.target);
            goto __L5; /* break */

            __L60: /*case 33*/ 
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L61: /*case 34*/ 
            ;
            ss_fprintf(oss, "++");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L62: /*case 35*/ 
            ;
            ss_fprintf(oss, "--");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L63: /*case 36*/ 
            ;
            ss_fprintf(oss, "!");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L64: /*case 37*/ 
            ;
            ss_fprintf(oss, "~");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L65: /*case 38*/ 
            ;
            ss_fprintf(oss, "-");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L66: /*case 39*/ 
            ;
            ss_fprintf(oss, "+");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L67: /*case 40*/ 
            ;
            ss_fprintf(oss, "*");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L68: /*case 32*/ 
            goto __L5; /* break */

            __L69: /*case 47*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " - ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L70: /*case 46*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " + ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L71: /*case 43*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " * ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L72: /*case 44*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " / ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L73: /*case 45*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, "%s", " % ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L74: /*case 72*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, ", ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L75: /*case 61*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " %s ", get_op_by_expression_type(p_expression->expression_type));
            if (type_is_bool(&p_expression->left->type))
            {
                expression_to_bool_value(ctx, oss, p_expression->right);
            }
            else
            {
                d_visit_expression(ctx, oss, p_expression->right);
            }
            goto __L5; /* break */

            __L77: /*case 62*/ 
            __L78: /*case 63*/ 
            __L79: /*case 64*/ 
            __L80: /*case 65*/ 
            __L81: /*case 66*/ 
            __L82: /*case 67*/ 
            __L83: /*case 68*/ 
            __L84: /*case 69*/ 
            __L85: /*case 70*/ 
            __L86: /*case 71*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " %s ", get_op_by_expression_type(p_expression->expression_type));
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L87: /*case 42*/ 
            {
                struct osstream  local2;

                ;
                _cake_zmem(&local2, 12);
                d_print_type(ctx, &local2, &p_expression->type, 0, 0);
                ss_fprintf(oss, "(%s)", local2.c_str);
                ss_close(&local2);
                d_visit_expression(ctx, oss, p_expression->left);
            }
            goto __L5; /* break */

            __L88: /*case 48*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " >> ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L89: /*case 49*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " << ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L90: /*case 50*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " > ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L91: /*case 51*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " < ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L92: /*case 54*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " == ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L93: /*case 55*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " != ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L94: /*case 56*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " & ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L95: /*case 57*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " ^ ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L96: /*case 58*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " | ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L97: /*case 53*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " <= ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L98: /*case 52*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " >= ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L99: /*case 60*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " && ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L100: /*case 59*/ 
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " || ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

            __L101: /*case 27*/ 
            __L102: /*case 28*/ 
            __L103: /*case 29*/ 
            goto __L5; /* break */

            __L104: /*case 73*/ 
            ;
            ;
            ;
            d_visit_expression(ctx, oss, p_expression->condition_expr);
            ss_fprintf(oss, " ? ");
            d_visit_expression(ctx, oss, p_expression->left);
            ss_fprintf(oss, " : ");
            d_visit_expression(ctx, oss, p_expression->right);
            goto __L5; /* break */

        }
        __L5:;
    }
}

static unsigned char is_all_zero(struct object * object)
{
    if (object_is_reference(object))
    {
        object = object_get_referenced(object);
    }
    if (object->members.head != 0)
    {
        struct object * member;

        member = object->members.head;
        while (member)
        {
            if (!is_all_zero(member))
            {
                return 0;
            }
            member = member->next;
        }
    }
    if (object->p_init_expression)
    {
        if (object_has_constant_value(&object->p_init_expression->object))
        {
            if (object_is_true(&object->p_init_expression->object) != 0)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

static void print_initializer(struct d_visit_ctx * ctx, struct osstream * oss, struct init_declarator * p_init_declarator, unsigned char  bstatic)
{
    ;
    if (1) /*try*/
    {
        unsigned char  is_local;

        is_local = ctx->is_local;
        if (p_init_declarator->initializer->assignment_expression)
        {
            if (is_local && !bstatic)
            {
                if (p_init_declarator->initializer->assignment_expression->expression_type == 3 && type_is_array(&p_init_declarator->p_declarator->type))
                {
                    struct osstream  local;

                    print_identation_core(oss, ctx->indentation);
                    ss_fprintf(oss, "_cake_memcpy(%s, ", p_init_declarator->p_declarator->name_opt->lexeme);
                    _cake_zmem(&local, 12);
                    d_visit_expression(ctx, &local, p_init_declarator->initializer->assignment_expression);
                    ss_fprintf(oss, "%s, %d", local.c_str, p_init_declarator->p_declarator->type.num_of_elements);
                    ss_fprintf(oss, ");\n");
                    ss_close(&local);
                    ctx->memcpy_used = 1;
                }
                else
                {
                    print_identation_core(oss, ctx->indentation);
                    ss_fprintf(oss, "%s%s = ", p_init_declarator->p_declarator->name_opt->lexeme, "");
                    if (type_is_bool(&p_init_declarator->p_declarator->type))
                    {
                        expression_to_bool_value(ctx, oss, p_init_declarator->initializer->assignment_expression);
                    }
                    else
                    {
                        d_visit_expression(ctx, oss, p_init_declarator->initializer->assignment_expression);
                    }
                    ss_fprintf(oss, ";\n");
                }
            }
            else
            {
                ss_fprintf(oss, " = ");
                d_visit_expression(ctx, oss, p_init_declarator->initializer->assignment_expression);
                ss_fprintf(oss, ";\n");
            }
        }
        else
        {
            if (p_init_declarator->initializer->braced_initializer)
            {
                if (p_init_declarator->initializer->braced_initializer->initializer_list && p_init_declarator->initializer->braced_initializer->initializer_list->head)
                {
                    if (is_all_zero(&p_init_declarator->p_declarator->object))
                    {
                        if (is_local && !bstatic)
                        {
                            unsigned int sz;

                            sz = 0;
                            if (type_get_sizeof(&p_init_declarator->p_declarator->type, &sz, ctx->options.target) != 0)
                            {
                                goto __L0; /* throw */
                            }
                            print_identation_core(oss, ctx->indentation);
                            ss_fprintf(oss, "_cake_zmem(&%s, %zu);\n", p_init_declarator->p_declarator->name_opt->lexeme, sz);
                            ctx->zero_mem_used = 1;
                        }
                        else
                        {
                            ss_fprintf(oss, " = ");
                            ss_fprintf(oss, "{0};\n");
                        }
                    }
                    else
                    {
                        unsigned char  first;

                        first = 1;
                        if (!is_local || bstatic)
                        {
                            ss_fprintf(oss, " = ");
                            ss_fprintf(oss, "{");
                            object_print_constant_initialization(ctx, oss, &p_init_declarator->p_declarator->object, &first);
                            ss_fprintf(oss, "}");
                            ss_fprintf(oss, ";\n");
                        }
                        else
                        {
                            object_print_non_constant_initialization(ctx, oss, &p_init_declarator->p_declarator->object, p_init_declarator->p_declarator->name_opt->lexeme, 1, 1);
                        }
                    }
                }
                else
                {
                    if (is_local && !bstatic)
                    {
                        unsigned int sz;

                        sz = 0;
                        if (type_get_sizeof(&p_init_declarator->p_declarator->type, &sz, ctx->options.target) != 0)
                        {
                            goto __L0; /* throw */
                        }
                        print_identation_core(oss, ctx->indentation);
                        ss_fprintf(oss, "_cake_zmem(&%s, %zu);\n", p_init_declarator->p_declarator->name_opt->lexeme, sz);
                        ctx->zero_mem_used = 1;
                    }
                    else
                    {
                        ss_fprintf(oss, " = ");
                        ss_fprintf(oss, "{0};\n");
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void d_visit_init_declarator(struct d_visit_ctx * ctx, struct osstream * oss0, struct init_declarator * p_init_declarator, int function_specifier_flags, int storage_class_specifier_flags)
{
    unsigned char  is_function;
    unsigned char  is_inline;
    unsigned char  is_block_scope;
    unsigned char  is_typedef;
    unsigned char  is_extern;
    unsigned char  is_function_body;
    unsigned char  is_static;
    unsigned char  is_auto;

    is_function = type_is_function(&p_init_declarator->p_declarator->type);
    is_inline = ((function_specifier_flags & 1) != 0);
    is_block_scope = ((storage_class_specifier_flags & 4096) != 0);
    is_typedef = ((storage_class_specifier_flags & 1) != 0);
    is_extern = ((storage_class_specifier_flags & 2) != 0);
    is_function_body = p_init_declarator->p_declarator->function_body != 0;
    if (is_typedef)
    {
        return;
    }
    is_static = ((storage_class_specifier_flags & 4) != 0);
    is_auto = ((storage_class_specifier_flags & 16) != 0);
    if (!is_extern && !is_block_scope && !is_inline && !is_static && !is_function && !is_function_body)
    {
        struct hash_item_set  i;
        struct osstream  ss;

        _cake_zmem(&i, 32);
        i.number = 1;
        hashmap_set(&ctx->file_scope_declarator_map, p_init_declarator->p_declarator->name_opt->lexeme, &i);
        _cake_zmem(&ss, 12);
        d_print_type(ctx, &ss, &p_init_declarator->p_declarator->type, p_init_declarator->p_declarator->name_opt->lexeme, 1);
        ss_fprintf(oss0, "%s", ss.c_str);
        if (p_init_declarator->initializer)
        {
            print_initializer(ctx, oss0, p_init_declarator, 1);
        }
        else
        {
            ss_fprintf(oss0, ";\n");
        }
        ss_close(&ss);
        hash_item_set_destroy(&i);
        return;
    }
    else
    {
        if (!is_extern && is_block_scope && !is_inline && !is_static && !is_function && !is_function_body)
        {
            struct osstream  ss;

            _cake_zmem(&ss, 12);
            d_print_type(ctx, &ss, &p_init_declarator->p_declarator->type, p_init_declarator->p_declarator->name_opt->lexeme, 0);
            print_identation(ctx, &ctx->block_scope_declarators);
            ss_fprintf(&ctx->block_scope_declarators, "%s;\n", ss.c_str);
            ss_close(&ss);
            if (p_init_declarator->initializer)
            {
                print_initializer(ctx, oss0, p_init_declarator, 0);
            }
            return;
        }
        else
        {
            if (!is_block_scope && !is_inline && !is_static && is_function && is_function_body)
            {
                struct osstream  ss;
                struct hash_item_set  i;

                _cake_zmem(&ss, 12);
                d_print_type(ctx, &ss, &p_init_declarator->p_declarator->type, p_init_declarator->p_declarator->name_opt->lexeme, 1);
                _cake_zmem(&i, 32);
                i.number = 1;
                hashmap_set(&ctx->file_scope_declarator_map, p_init_declarator->p_declarator->name_opt->lexeme, &i);
                ss_fprintf(&ss, "\n");
                d_visit_function_body(ctx, &ss, p_init_declarator->p_declarator);
                ss_fprintf(&ss, "\n");
                ss_fprintf(oss0, "%s\n", ss.c_str);
                ss_close(&ss);
                hash_item_set_destroy(&i);
                return;
            }
            else
            {
                unsigned char  rename_declarator;

                rename_declarator = 0;
                if (!is_extern && is_block_scope && !is_inline && is_static && !is_function)
                {
                    rename_declarator = 1;
                }
                else
                {
                    if (!is_inline && !is_static && !is_auto && is_function && !is_function_body)
                    {
                    }
                    else
                    {
                        if (!is_extern && is_block_scope && is_function)
                        {
                            rename_declarator = 1;
                        }
                    }
                }
                if (rename_declarator)
                {
                    if (!p_init_declarator->p_declarator->declarator_renamed)
                    {
                        char name[100];

                        p_init_declarator->p_declarator->declarator_renamed = 1;
                        _cake_zmem(&name, 100);
                        snprintf(name, 100, "__c%d_%s", ctx->cake_file_scope_declarator_number++, p_init_declarator->p_declarator->name_opt->lexeme);
                        free(p_init_declarator->p_declarator->name_opt->lexeme);
                        p_init_declarator->p_declarator->name_opt->lexeme = strdup(name);
                    }
                }
                return;
            }
        }
    }
}

static void d_visit_init_declarator_list(struct d_visit_ctx * ctx, struct osstream * oss, struct init_declarator_list * p_init_declarator_list, int function_specifier_flags, int storage_class_specifier_flags)
{
    struct init_declarator * p_init_declarator;

    p_init_declarator = p_init_declarator_list->head;
    while (p_init_declarator)
    {
        d_visit_init_declarator(ctx, oss, p_init_declarator, function_specifier_flags, storage_class_specifier_flags);
        p_init_declarator = p_init_declarator->next;
    }
}

static void d_visit_declaration(struct d_visit_ctx * ctx, struct osstream * oss, struct declaration * p_declaration)
{
    if (p_declaration->pragma_declaration)
    {
    }
    if (p_declaration->init_declarator_list.head)
    {
        int storage_class_specifier_flags;
        int function_specifier_flags;

        ;
        storage_class_specifier_flags = p_declaration->declaration_specifiers->storage_class_specifier_flags;
        function_specifier_flags = p_declaration->declaration_specifiers->function_specifier_flags;
        d_visit_init_declarator_list(ctx, oss, &p_declaration->init_declarator_list, function_specifier_flags, storage_class_specifier_flags);
    }
}
unsigned int s_visit_number = 1;
unsigned char flow_object_is_not_null(struct flow_object * p)
{
    int e;

    e = p->current.state;
    return (!(e & 2) && ((e & 4) || (e & 8)));
}


unsigned char flow_object_can_be_not_null_or_moved(struct flow_object * p)
{
    int e;

    e = p->current.state;
    return (e & 4) || (e & 8);
}


unsigned char flow_object_is_null(struct flow_object * p)
{
    int e;

    e = p->current.state;
    return ((e & 2) && !(e & 4) && !(e & 8));
}


unsigned char flow_object_is_zero(struct flow_object * p)
{
    int e;

    e = p->current.state;
    return ((e & 32) && !(e & 64));
}


unsigned char flow_object_is_not_zero(struct flow_object * p)
{
    int e;

    e = p->current.state;
    return (!(e & 32) && (e & 64));
}


unsigned char flow_object_can_be_zero(struct flow_object * p)
{
    int e;

    e = p->current.state;
    return ((e & 32) != 0);
}


unsigned char flow_object_can_be_moved(struct flow_object * p)
{
    int e;

    e = p->current.state;
    return ((e & 8) != 0);
}


unsigned char flow_object_can_be_null(struct flow_object * p)
{
    int e;

    e = p->current.state;
    return ((e & 2) != 0);
}


unsigned char flow_object_is_uninitialized(struct flow_object * p)
{
    int e;

    e = p->current.state;
    return e == 1;
}


unsigned char flow_object_can_be_uninitialized(struct flow_object * p)
{
    int e;

    e = p->current.state;
    return ((e & 1) != 0);
}


unsigned char flow_object_can_have_its_lifetime_ended(struct flow_object * p)
{
    int e;

    e = p->current.state;
    return ((e & 128) != 0);
}


void objects_view_destroy(struct flow_objects_view * p);

void flow_object_state_delete(struct flow_object_state * p)
{
    if (p)
    {
        objects_view_destroy(&p->alternatives);
        ;
        free(p);
    }
}


void objects_view_copy(struct flow_objects_view * dest, struct flow_objects_view * source);

void flow_object_state_copy(struct flow_object_state * to, struct flow_object_state * from)
{
    to->state = from->state;
    to->pointed = from->pointed;
    objects_view_copy(&to->alternatives, &from->alternatives);
}


static void object_state_to_string_core(int e);

void flow_object_print_state(struct flow_object * p)
{
    object_state_to_string_core(p->current.state);
}



static void object_state_to_string_core(int e)
{
    unsigned char  first;

    first = 1;
    printf("\"");
    if (e & 1)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            printf(" | ");
        }
        printf("uninitialized");
    }
    if (e & 4)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            printf(" | ");
        }
        printf("not-null");
    }
    if (e & 2)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            printf(" | ");
        }
        printf("null");
    }
    if (e & 32)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            printf(" | ");
        }
        printf("zero");
    }
    if (e & 64)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            printf(" | ");
        }
        printf("not-zero");
    }
    if (e & 128)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            printf(" | ");
        }
        printf("lifetime-ended");
    }
    if (e & 8)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            printf(" | ");
        }
        printf("moved");
    }
    printf("\"");
}
void object_state_set_item_print(struct flow_object_state * item)
{
    object_state_to_string_core(item->state);
}


unsigned char flow_object_is_expansible(struct flow_object * p_object)
{
    return (p_object && p_object->current.state != 2 && p_object->current.state != 1 && p_object->current.pointed == 0);
}


struct flow_object *make_flow_object(struct flow_visit_ctx * ctx, struct type * p_type, struct declarator * p_declarator_opt, struct expression * p_expression_origin);
void flow_object_set_unknown(struct type * p_type, unsigned char  t_is_nullable, struct flow_object * p_object, unsigned char  nullable_enabled);
void object_set_pointer(struct flow_object * p_object, struct flow_object * p_object2);
void flow_object_push_states_from(struct flow_object * p_object_from, struct flow_object * p_object_to);

void flow_object_expand_pointer(struct flow_visit_ctx * ctx, struct type * p_type, struct flow_object * p_object)
{
    ;
    if (flow_object_is_expansible(p_object))
    {
        unsigned char  nullable_enabled;
        struct type  t2;

        nullable_enabled = ctx->ctx->options.null_checks_enabled;
        t2 = type_remove_pointer(p_type);
        if (!type_is_void(&t2))
        {
            struct flow_object * p_object2;

            p_object2 = make_flow_object(ctx, &t2, p_object->p_declarator_origin, p_object->p_expression_origin);
            if (p_object2)
            {
                unsigned char  is_nullable;

                is_nullable = type_is_opt(&t2, nullable_enabled);
                flow_object_set_unknown(&t2, is_nullable, p_object2, nullable_enabled);
                object_set_pointer(p_object, p_object2);
                flow_object_push_states_from(p_object, p_object2);
            }
            else
            {
            }
        }
        type_destroy(&t2);
    }
}


void flow_object_swap(struct flow_object * a, struct flow_object * b)
{
    struct flow_object  temp;

    temp = *a;
    *a = *b;
    *b = temp;
}


void flow_object_destroy(struct flow_object * p);

void flow_object_delete(struct flow_object * p)
{
    if (p)
    {
        flow_object_destroy(p);
        free(p);
    }
}


void object_set_pointer(struct flow_object * p_object, struct flow_object * p_object2)
{
    p_object->current.pointed = p_object2;
}


void flow_object_destroy(struct flow_object * p)
{
    struct flow_object_state * p_flow_object_state;

    objects_view_destroy(&p->members);
    p_flow_object_state = p->current.next;
    while (p_flow_object_state)
    {
        struct flow_object_state * temp;

        temp = p_flow_object_state->next;
        p_flow_object_state->next = 0;
        flow_object_state_delete(p_flow_object_state);
        p_flow_object_state = temp;
    }
    objects_view_destroy(&p->current.alternatives);
}


void flow_object_update_current(struct flow_object * p)
{
    if (p->current.alternatives.size > 0)
    {
        p->current.state = 0;
        {
            int i;

            i = 0;
            for (; i < p->current.alternatives.size; i++)
            {
                flow_object_update_current(p->current.alternatives.data[i]);
                p->current.state |= p->current.alternatives.data[i]->current.state;
            }
        }
    }
}


void flow_object_set_current_state_to_can_be_null(struct flow_object * p)
{
    p->current.state |= 2;
}


void flow_object_set_current_state_to_is_null(struct flow_object * p)
{
    p->current.state = 2;
    if (p->current.alternatives.size > 0)
    {
        {
            int i;

            i = 0;
            for (; i < p->current.alternatives.size; i++)
            {
                flow_object_set_current_state_to_can_be_null(p->current.alternatives.data[i]);
            }
        }
    }
}


int flow_object_add_state(struct flow_object * p, struct flow_object_state * pnew)
{
    ;
    pnew->next = p->current.next;
    p->current.next = pnew;
    return 0;
}


void objects_view_destroy(struct flow_objects_view * p)
{
    free(p->data);
}


int objects_view_reserve(struct flow_objects_view * p, int n)
{
    if (n > p->capacity)
    {
        void * pnew;

        if ((unsigned int)n > 1073741823)
        {
            return 132;
        }
        pnew = realloc(p->data, n * 4);
        if (pnew == 0)
        {
            return 12;
        }
        p->data = pnew;
        p->capacity = n;
    }
    return 0;
}


int objects_view_push_back(struct flow_objects_view * p, struct flow_object * p_object)
{
    if (p->size == 2147483647)
    {
        return 132;
    }
    if (p->size + 1 > p->capacity)
    {
        int new_capacity;
        int error;

        new_capacity = 0;
        if (p->capacity > (2147483647 - p->capacity / 2))
        {
            new_capacity = 2147483647;
        }
        else
        {
            new_capacity = p->capacity + p->capacity / 2;
            if (new_capacity < p->size + 1)
            {
                new_capacity = p->size + 1;
            }
        }
        error = objects_view_reserve(p, new_capacity);
        if (error != 0)
        {
            return error;
        }
    }
    p->data[p->size] = p_object;
    p->size++;
    return 0;
}


void objects_view_clear(struct flow_objects_view * p)
{
    p->size = 0;
}


unsigned char objects_view_find(struct flow_objects_view * p, struct flow_object * p_object);

void objects_view_merge(struct flow_objects_view * dest, struct flow_objects_view * source)
{
    {
        int i;

        i = 0;
        for (; i < source->size; i++)
        {
            if (!objects_view_find(dest, source->data[i]))
            {
                objects_view_push_back(dest, source->data[i]);
            }
        }
    }
}


void objects_view_copy(struct flow_objects_view * dest, struct flow_objects_view * source)
{
    objects_view_reserve(dest, source->size);
    {
        int i;

        i = 0;
        for (; i < source->size; i++)
        {
            dest->data[i] = source->data[i];
        }
    }
    dest->size = source->size;
}


unsigned char objects_view_find(struct flow_objects_view * p, struct flow_object * p_object)
{
    {
        int i;

        i = 0;
        for (; i < p->size; i++)
        {
            if (p->data[i] == p_object)
            {
                return 1;
            }
        }
    }
    return 0;
}


void flow_objects_destroy(struct flow_objects * p)
{
    {
        int i;

        i = 0;
        for (; i < p->size; i++)
        {
            flow_object_delete(p->data[i]);
        }
    }
    free(p->data);
}


void flow_objects_clear(struct flow_objects * p)
{
    {
        int i;

        i = 0;
        for (; i < p->size; i++)
        {
            flow_object_delete(p->data[i]);
        }
    }
    p->size = 0;
}


int objects_reserve(struct flow_objects * p, int n)
{
    if (n > p->capacity)
    {
        void * pnew;

        if ((unsigned int)n > 1073741823)
        {
            return 132;
        }
        pnew = realloc(p->data, n * 4);
        if (pnew == 0)
        {
            return 12;
        }
        p->data = pnew;
        p->capacity = n;
    }
    return 0;
}


struct flow_object *flow_objects_find(struct flow_objects * p_objects, struct flow_object * object)
{
    {
        int i;

        i = 0;
        for (; i < p_objects->size; i++)
        {
            if (p_objects->data[i] == object)
            {
                return object;
            }
        }
    }
    return 0;
}


int flow_objects_push_back(struct flow_objects * p, struct flow_object * p_object)
{
    if (p->size == 2147483647)
    {
        flow_object_delete(p_object);
        return 132;
    }
    if (p->size + 1 > p->capacity)
    {
        int new_capacity;
        int error;

        new_capacity = 0;
        if (p->capacity > (2147483647 - p->capacity / 2))
        {
            new_capacity = 2147483647;
        }
        else
        {
            new_capacity = p->capacity + p->capacity / 2;
            if (new_capacity < p->size + 1)
            {
                new_capacity = p->size + 1;
            }
        }
        error = objects_reserve(p, new_capacity);
        if (error != 0)
        {
            flow_object_delete(p_object);
            return error;
        }
        ;
    }
    p->data[p->size] = p_object;
    p->size++;
    return 0;
}


unsigned char has_name(char * name, struct object_name_list * list)
{
    struct object_name_list * p;

    p = list;
    while (p)
    {
        if (strcmp(p->name, name) == 0)
        {
            return 1;
        }
        p = p->previous;
    }
    return 0;
}


struct flow_object *arena_new_object(struct flow_visit_ctx * ctx);

struct flow_object *make_object_core(struct flow_visit_ctx * ctx, struct type * p_type, struct object_name_list * list, struct declarator * p_declarator_opt, struct expression * p_expression_origin)
{
    struct flow_object * p_object;

    if (p_declarator_opt == 0)
    {
    }
    if (p_expression_origin == 0)
    {
    }
    p_object = arena_new_object(ctx);
    if (1) /*try*/
    {
        if (p_object == 0)
        {
            goto __L2; /* throw */
        }
        p_object->p_expression_origin = p_expression_origin;
        p_object->p_declarator_origin = p_declarator_opt;
        if (p_type->struct_or_union_specifier)
        {
            struct struct_or_union_specifier * p_struct_or_union_specifier;

            p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
            if (p_struct_or_union_specifier)
            {
                struct member_declaration * p_member_declaration;
                struct object_name_list  l;

                p_object->current.state = 0;
                p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
                l.name = p_struct_or_union_specifier->tag_name;
                l.previous = list;
                while (p_member_declaration)
                {
                    if (p_member_declaration->member_declarator_list_opt)
                    {
                        struct member_declarator * p_member_declarator;

                        p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                        while (p_member_declarator)
                        {
                            if (p_member_declarator->declarator)
                            {
                                char * tag;

                                tag = 0;
                                if (p_member_declarator->declarator->type.struct_or_union_specifier)
                                {
                                    tag = p_member_declarator->declarator->type.struct_or_union_specifier->tag_name;
                                }
                                else
                                {
                                    if (p_member_declarator->declarator->type.next && p_member_declarator->declarator->type.next->struct_or_union_specifier)
                                    {
                                        tag = p_member_declarator->declarator->type.next->struct_or_union_specifier->tag_name;
                                    }
                                }
                                if (tag && has_name(tag, &l))
                                {
                                    struct flow_object * member_obj;

                                    member_obj = arena_new_object(ctx);
                                    if (member_obj == 0)
                                    {
                                        goto __L2; /* throw */
                                    }
                                    member_obj->parent = p_object;
                                    member_obj->p_expression_origin = p_expression_origin;
                                    member_obj->p_declarator_origin = p_declarator_opt;
                                    member_obj->current.state = 0;
                                    objects_view_push_back(&p_object->members, member_obj);
                                }
                                else
                                {
                                    struct flow_object * p_member_obj;

                                    p_member_obj = make_object_core(ctx, &p_member_declarator->declarator->type, &l, p_declarator_opt, p_expression_origin);
                                    if (p_member_obj == 0)
                                    {
                                        goto __L2; /* throw */
                                    }
                                    p_member_obj->parent = p_object;
                                    objects_view_push_back(&p_object->members, p_member_obj);
                                }
                            }
                            p_member_declarator = p_member_declarator->next;
                        }
                    }
                    else
                    {
                        if (p_member_declaration->specifier_qualifier_list != 0)
                        {
                            if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                            {
                                struct type  t;
                                struct flow_object * member_obj;

                                _cake_zmem(&t, 68);
                                t.category = 0;
                                t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                                t.type_specifier_flags = 32768;
                                member_obj = make_object_core(ctx, &t, &l, p_declarator_opt, p_expression_origin);
                                if (member_obj == 0)
                                {
                                    type_destroy(&t);
                                    goto __L2; /* throw */
                                }
                                {
                                    int k;

                                    k = 0;
                                    for (; k < member_obj->members.size; k++)
                                    {
                                        objects_view_push_back(&p_object->members, member_obj->members.data[k]);
                                        member_obj->members.data[k] = 0;
                                    }
                                }
                                type_destroy(&t);
                            }
                        }
                    }
                    p_member_declaration = p_member_declaration->next;
                }
                return p_object;
            }
            return p_object;
        }
        else
        {
            if (type_is_array(p_type))
            {
                return p_object;
            }
        }
        p_object->current.state = 1;
    }
    else __L2: /*catch*/ 
    {
        p_object = 0;
    }
    return p_object;
}


struct flow_object *make_flow_object(struct flow_visit_ctx * ctx, struct type * p_type, struct declarator * p_declarator_opt, struct expression * p_expression_origin)
{
    struct object_name_list  list;
    struct flow_object * p_object;

    list.name = "";
    list.previous = 0;
    p_object = make_object_core(ctx, p_type, &list, p_declarator_opt, p_expression_origin);
    return p_object;
}


struct token *flow_object_get_token(struct flow_object * object)
{
    if (object->p_declarator_origin)
    {
        return object->p_declarator_origin->name_opt;
    }
    if (object->p_expression_origin)
    {
        return object->p_expression_origin->first_token;
    }
    return 0;
}


void flow_object_add_new_state_as_a_copy_of_current_state(struct flow_object * object, char * name, int state_number)
{
    struct flow_object_state * pnew;

    pnew = calloc(1, 32);
    if (pnew == 0)
    {
        return;
    }
    pnew->dbg_name = name;
    pnew->state_number = state_number;
    pnew->next = object->current.next;
    object->current.next = pnew;
    flow_object_state_copy(pnew, &object->current);
}


void flow_object_remove_state(struct flow_object * object, int state_number)
{
    struct flow_object_state * previous;
    struct flow_object_state * it;

    previous = &object->current;
    it = object->current.next;
    while (it)
    {
        if (it->state_number == state_number)
        {
            struct flow_object_state * p_it_next;

            p_it_next = it->next;
            it->next = 0;
            flow_object_state_delete(previous->next);
            previous->next = p_it_next;
            break;
        }
        previous = it;
        it = it->next;
    }
}


void print_object_core(unsigned char  color_enabled, int ident, struct object_visitor * p_visitor, char * previous_names, unsigned char  is_pointer, unsigned char  short_version, unsigned int visit_number)
{
    if (p_visitor->p_object->visit_number == visit_number)
    {
        return;
    }
    p_visitor->p_object->visit_number = visit_number;
    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier * p_struct_or_union_specifier;

        ;
        p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);
        if (p_struct_or_union_specifier)
        {
            struct member_declaration * p_member_declaration;

            printf("%*c", ident + 1, 32);
            printf("#%02d {\n", p_visitor->p_object->id);
            p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator * p_member_declarator;

                    p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            char * name;
                            char buffer[200];
                            struct object_visitor  visitor;

                            name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "";
                            _cake_zmem(&buffer, 200);
                            if (is_pointer)
                            {
                                snprintf(buffer, 200, "%s->%s", previous_names, name);
                            }
                            else
                            {
                                snprintf(buffer, 200, "%s.%s", previous_names, name);
                            }
                            _cake_zmem(&visitor, 12);
                            visitor.p_type = &p_member_declarator->declarator->type;
                            visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                            print_object_core(color_enabled, ident + 2, &visitor, buffer, type_is_pointer(&p_member_declarator->declarator->type), short_version, visit_number);
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list != 0)
                    {
                        struct type  t;
                        struct type * temp;
                        int visit_number0;

                        _cake_zmem(&t, 68);
                        t.category = 0;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = 32768;
                        temp = p_visitor->p_type;
                        p_visitor->p_type = &t;
                        visit_number0 = p_visitor->p_object->visit_number;
                        p_visitor->p_object->visit_number = 0;
                        print_object_core(color_enabled, ident + 1, p_visitor, previous_names, 0, short_version, visit_number);
                        p_visitor->p_type = temp;
                        p_visitor->p_object->visit_number = visit_number0;
                        type_destroy(&t);
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            printf("%*c", ident + 1, 32);
            printf("}\n");
        }
    }
    else
    {
        if (type_is_pointer(p_visitor->p_type))
        {
            struct type  t2;

            t2 = type_remove_pointer(p_visitor->p_type);
            printf("%*c", ident, 32);
            if (short_version)
            {
                printf("#%02d %s == ", p_visitor->p_object->id, previous_names);
                flow_object_print_state(p_visitor->p_object);
                if (flow_object_is_null(p_visitor->p_object))
                {
                }
                else
                {
                    if (flow_object_can_be_uninitialized(p_visitor->p_object))
                    {
                    }
                    else
                    {
                        printf(" -> ");
                        if (p_visitor->p_object->current.pointed != 0)
                        {
                            printf(" #%02d", p_visitor->p_object->current.pointed->id);
                        }
                        else
                        {
                            printf("{...}");
                        }
                    }
                }
            }
            else
            {
                struct flow_object_state * it;

                printf("%p:%s == ", p_visitor->p_object, previous_names);
                printf("{");
                it = p_visitor->p_object->current.next;
                while (it)
                {
                    if (color_enabled)
                    {
                        printf("\x1b[36;1m");
                    }
                    printf("(#%02d %s)", it->state_number, it->dbg_name);
                    object_state_set_item_print(it);
                    if (color_enabled)
                    {
                        printf("\x1b[0m");
                    }
                    printf(",");
                    it = it->next;
                }
                if (color_enabled)
                {
                    printf("\x1b[95m");
                }
                printf("(current)");
                flow_object_print_state(p_visitor->p_object);
                if (color_enabled)
                {
                    printf("\x1b[0m");
                }
                printf("}");
            }
            printf("\n");
            type_destroy(&t2);
        }
        else
        {
            printf("%*c", ident, 32);
            if (short_version)
            {
                printf("#%02d %s == ", p_visitor->p_object->id, previous_names);
                flow_object_print_state(p_visitor->p_object);
            }
            else
            {
                struct flow_object_state * it;

                printf("%p:%s == ", p_visitor->p_object, previous_names);
                printf("{");
                it = p_visitor->p_object->current.next;
                while (it)
                {
                    printf("(#%02d %s)", it->state_number, it->dbg_name);
                    object_state_set_item_print(it);
                    printf(",");
                    it = it->next;
                }
                flow_object_print_state(p_visitor->p_object);
                printf("}");
            }
            printf("\n");
        }
    }
}


void flow_object_merge_state(struct flow_object * pdest, struct flow_object * object1, struct flow_object * object2)
{
    pdest->current.state = object1->current.state | object2->current.state;
    if (pdest->members.size == object1->members.size && object1->members.size == object2->members.size)
    {
        {
            int i;

            i = 0;
            for (; i < object1->members.size; i++)
            {
                struct flow_object * m1;
                struct flow_object * m2;

                m1 = object1->members.data[i];
                m2 = object2->members.data[i];
                flow_object_merge_state(pdest->members.data[i], m1, m2);
            }
        }
    }
}


int object_restore_current_state_from_core(struct flow_object * object, int state_number, unsigned int visit_number)
{
    struct flow_object_state * it;

    if (object->visit_number == visit_number)
    {
        return 1;
    }
    object->visit_number = visit_number;
    it = object->current.next;
    while (it)
    {
        if (it->state_number == state_number)
        {
            object->current.state = it->state;
            break;
        }
        it = it->next;
    }
    {
        int i;

        i = 0;
        for (; i < object->members.size; i++)
        {
            object_restore_current_state_from_core(object->members.data[i], state_number, visit_number);
        }
    }
    return 1;
}


int flow_object_restore_current_state_from(struct flow_object * object, int state_number)
{
    return object_restore_current_state_from_core(object, state_number, s_visit_number++);
}


int object_merge_current_state_with_state_number_core(struct flow_object * object, int state_number, unsigned int visit_number)
{
    struct flow_object_state * it;

    if (object->visit_number == visit_number)
    {
        return 1;
    }
    object->visit_number = visit_number;
    it = object->current.next;
    while (it)
    {
        if (it->state_number == state_number)
        {
            it->state |= object->current.state;
            break;
        }
        it = it->next;
    }
    {
        int i;

        i = 0;
        for (; i < object->members.size; i++)
        {
            object_merge_current_state_with_state_number_core(object->members.data[i], state_number, visit_number);
        }
    }
    if (object->current.state == 2 || object->current.state == 1)
    {
    }
    else
    {
    }
    return 1;
}


void object_get_name(struct type * p_type, struct flow_object * p_object, char * outname, int out_size);

void print_flow_object(unsigned char  color_enabled, struct type * p_type, struct flow_object * p_object, unsigned char  short_version)
{
    char name[100];
    struct object_visitor  visitor;

    _cake_zmem(&name, 100);
    object_get_name(p_type, p_object, name, 100);
    _cake_zmem(&visitor, 12);
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    print_object_core(color_enabled, 0, &visitor, name, type_is_pointer(p_type), short_version, s_visit_number++);
}


void object_set_uninitialized_core(struct object_visitor * p_visitor)
{
    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier * p_struct_or_union_specifier;

        p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);
        if (p_struct_or_union_specifier)
        {
            struct member_declaration * p_member_declaration;

            p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator * p_member_declarator;

                    p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                struct object_visitor  visitor;

                                _cake_zmem(&visitor, 12);
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_uninitialized_core(&visitor);
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list != 0)
                    {
                        if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                        {
                            struct type  t;
                            struct type * type_temp;

                            _cake_zmem(&t, 68);
                            t.category = 0;
                            t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                            t.type_specifier_flags = 32768;
                            type_temp = p_visitor->p_type;
                            p_visitor->p_type = &t;
                            object_set_uninitialized_core(p_visitor);
                            p_visitor->p_type = type_temp;
                            type_destroy(&t);
                        }
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
    }
    if (type_is_pointer(p_visitor->p_type))
    {
        p_visitor->p_object->current.state = 1;
    }
    else
    {
        p_visitor->p_object->current.state = 1;
    }
}


void flow_object_set_uninitialized(struct type * p_type, struct flow_object * p_object)
{
    struct object_visitor  visitor;

    _cake_zmem(&visitor, 12);
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_uninitialized_core(&visitor);
}


static void checked_empty_core(struct flow_visit_ctx * ctx, struct type * p_type, struct flow_object * p_object, char * previous_names, struct marker * p_marker);

void checked_empty(struct flow_visit_ctx * ctx, struct type * p_type, struct flow_object * p_object, struct marker * p_marker)
{
    char name[100];

    _cake_zmem(&name, 100);
    object_get_name(p_type, p_object, name, 100);
    checked_empty_core(ctx, p_type, p_object, name, p_marker);
}



static void checked_empty_core(struct flow_visit_ctx * ctx, struct type * p_type, struct flow_object * p_object, char * previous_names, struct marker * p_marker)
{
    if (p_type->struct_or_union_specifier && p_object->members.size > 0)
    {
        struct struct_or_union_specifier * p_struct_or_union_specifier;
        struct member_declaration * p_member_declaration;
        int member_index;

        p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
        p_member_declaration = p_struct_or_union_specifier ? p_struct_or_union_specifier->member_declaration_list.head : 0;
        member_index = 0;
        while (p_member_declaration)
        {
            if (p_member_declaration->member_declarator_list_opt)
            {
                struct member_declarator * p_member_declarator;

                p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                while (p_member_declarator)
                {
                    if (p_member_declarator->declarator)
                    {
                        char * name;
                        char buffer[200];

                        name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "";
                        _cake_zmem(&buffer, 200);
                        if (type_is_pointer(p_type))
                        {
                            snprintf(buffer, 200, "%s->%s", previous_names, name);
                        }
                        else
                        {
                            snprintf(buffer, 200, "%s.%s", previous_names, name);
                        }
                        checked_empty_core(ctx, &p_member_declarator->declarator->type, p_object->members.data[member_index], name, p_marker);
                        member_index++;
                    }
                    p_member_declarator = p_member_declarator->next;
                }
            }
            else
            {
                if (p_member_declaration->specifier_qualifier_list != 0)
                {
                }
            }
            p_member_declaration = p_member_declaration->next;
        }
        return;
    }
    if (type_is_owner_or_pointer_to_dtor(p_type))
    {
        if (p_object->current.state == 11 || p_object->current.state == 10 || p_object->current.state == 2 || p_object->current.state == 8 || p_object->current.state == 1 || p_object->current.state == 3 || p_object->current.state == 9)
        {
        }
        else
        {
            compiler_diagnostic(29, ctx->ctx, 0, p_marker, "object '%s' may not be empty", previous_names);
        }
    }
}
static void object_set_moved_core(struct object_visitor * p_visitor);

void flow_object_set_moved(struct type * p_type, struct flow_object * p_object)
{
    struct object_visitor  visitor;

    _cake_zmem(&visitor, 12);
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_moved_core(&visitor);
}



static void object_set_moved_core(struct object_visitor * p_visitor)
{
    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier * p_struct_or_union_specifier;

        p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);
        if (p_struct_or_union_specifier)
        {
            struct member_declaration * p_member_declaration;

            p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator * p_member_declarator;

                    p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                struct object_visitor  visitor;

                                _cake_zmem(&visitor, 12);
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_moved_core(&visitor);
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list != 0)
                    {
                        if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                        {
                            struct type  t;
                            struct type * type_temp;

                            _cake_zmem(&t, 68);
                            t.category = 0;
                            t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                            t.type_specifier_flags = 32768;
                            type_temp = p_visitor->p_type;
                            p_visitor->p_type = &t;
                            object_set_moved_core(p_visitor);
                            p_visitor->p_type = type_temp;
                            type_destroy(&t);
                        }
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
    }
    if (type_is_pointer(p_visitor->p_type))
    {
        p_visitor->p_object->current.state = 8;
    }
    else
    {
        p_visitor->p_object->current.state = 8;
    }
}
static void object_set_unknown_core(struct object_visitor * p_visitor, unsigned char  t_is_nullable, unsigned int visit_number, unsigned char  nullable_enabled);

void flow_object_set_unknown(struct type * p_type, unsigned char  t_is_nullable, struct flow_object * p_object, unsigned char  nullable_enabled)
{
    struct object_visitor  visitor;

    _cake_zmem(&visitor, 12);
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_unknown_core(&visitor, t_is_nullable, s_visit_number++, nullable_enabled);
}



static void object_set_unknown_core(struct object_visitor * p_visitor, unsigned char  t_is_nullable, unsigned int visit_number, unsigned char  nullable_enabled)
{
    if (p_visitor->p_object->visit_number == visit_number)
    {
        return;
    }
    p_visitor->p_object->visit_number = visit_number;
    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier * p_struct_or_union_specifier;

        p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);
        if (p_struct_or_union_specifier)
        {
            struct member_declaration * p_member_declaration;

            p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator * p_member_declarator;

                    p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                struct object_visitor  visitor;

                                _cake_zmem(&visitor, 12);
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_unknown_core(&visitor, t_is_nullable, visit_number, nullable_enabled);
                            }
                            else
                            {
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list != 0)
                    {
                        if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                        {
                            struct type  t;
                            struct type * temp;
                            int vn;

                            _cake_zmem(&t, 68);
                            t.category = 0;
                            t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                            t.type_specifier_flags = 32768;
                            temp = p_visitor->p_type;
                            p_visitor->p_type = &t;
                            vn = p_visitor->p_object->visit_number;
                            p_visitor->p_object->visit_number = 0;
                            object_set_unknown_core(p_visitor, t_is_nullable, visit_number, nullable_enabled);
                            p_visitor->p_object->visit_number = vn;
                            p_visitor->p_type = temp;
                            type_destroy(&t);
                        }
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
        return;
    }
    if (type_is_pointer(p_visitor->p_type))
    {
        struct flow_object * pointed;

        if (t_is_nullable || type_is_opt(p_visitor->p_type, nullable_enabled))
        {
            p_visitor->p_object->current.state = 6;
        }
        else
        {
            p_visitor->p_object->current.state = 4;
        }
        pointed = p_visitor->p_object->current.pointed;
        if (pointed)
        {
            struct type  t2;
            unsigned char  t2_is_nullable;
            struct object_visitor  visitor;

            t2 = type_remove_pointer(p_visitor->p_type);
            t2_is_nullable = type_is_opt(&t2, nullable_enabled);
            _cake_zmem(&visitor, 12);
            visitor.p_type = &t2;
            visitor.p_object = pointed;
            object_set_unknown_core(&visitor, t2_is_nullable, visit_number, nullable_enabled);
            type_destroy(&t2);
        }
    }
    else
    {
        if (!type_is_struct_or_union(p_visitor->p_type))
        {
            p_visitor->p_object->current.state = 96;
        }
    }
}
void flow_object_set_can_be_uninitialized(struct flow_object * p_object)
{
    p_object->current.state |= 1;
}


void flow_object_set_is_unitialized(struct flow_object * p_object)
{
    p_object->current.state = 1;
    if (p_object->current.alternatives.size > 0)
    {
        {
            int i;

            i = 0;
            for (; i < p_object->current.alternatives.size; i++)
            {
                flow_object_set_can_be_uninitialized(p_object->current.alternatives.data[i]);
            }
        }
    }
}


void flow_object_set_can_be_moved(struct flow_object * p_object)
{
    if (p_object->current.state & 4)
    {
        p_object->current.state &= -5;
        p_object->current.state |= 8;
        p_object->current.state |= 8;
    }
}


void flow_object_set_is_moved(struct flow_object * p_object)
{
    p_object->current.state = 8;
    if (p_object->current.alternatives.size > 0)
    {
        {
            int i;

            i = 0;
            for (; i < p_object->current.alternatives.size; i++)
            {
                flow_object_set_can_be_moved(p_object->current.alternatives.data[i]);
            }
        }
    }
}


static void object_set_deleted_core(struct type * p_type, struct flow_object * p_object, unsigned int visit_number);

void object_set_deleted(struct type * p_type, struct flow_object * p_object)
{
    object_set_deleted_core(p_type, p_object, s_visit_number++);
}



static void object_set_deleted_core(struct type * p_type, struct flow_object * p_object, unsigned int visit_number)
{
    if (p_object->visit_number == visit_number)
    {
        return;
    }
    p_object->visit_number = visit_number;
    if (p_type->struct_or_union_specifier && p_object->members.size > 0)
    {
        struct struct_or_union_specifier * p_struct_or_union_specifier;

        p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
        if (p_struct_or_union_specifier)
        {
            struct member_declaration * p_member_declaration;
            int member_index;

            p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
            member_index = 0;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator * p_member_declarator;

                    p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (member_index < p_object->members.size)
                            {
                                object_set_deleted_core(&p_member_declarator->declarator->type, p_object->members.data[member_index], visit_number);
                            }
                            else
                            {
                            }
                            member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list != 0)
                    {
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
        return;
    }
    if (type_is_pointer(p_type))
    {
        p_object->current.state = 128;
    }
    else
    {
        if (!type_is_struct_or_union(p_type))
        {
            p_object->current.state = 128;
        }
    }
}
void object_set_zero_core(struct object_visitor * p_visitor)
{
    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier * p_struct_or_union_specifier;

        p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);
        if (p_struct_or_union_specifier)
        {
            struct member_declaration * p_member_declaration;

            p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator * p_member_declarator;

                    p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                struct object_visitor  visitor;

                                _cake_zmem(&visitor, 12);
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_zero_core(&visitor);
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list != 0)
                    {
                        if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                        {
                            struct type  t;
                            struct type * temp;

                            _cake_zmem(&t, 68);
                            t.category = 0;
                            t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                            t.type_specifier_flags = 32768;
                            temp = p_visitor->p_type;
                            p_visitor->p_type = &t;
                            object_set_zero_core(p_visitor);
                            p_visitor->p_type = temp;
                            type_destroy(&t);
                        }
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
        return;
    }
    if (type_is_pointer(p_visitor->p_type))
    {
        p_visitor->p_object->current.state = 2;
    }
    else
    {
        p_visitor->p_object->current.state = 32;
    }
}


void flow_object_set_zero(struct type * p_type, struct flow_object * p_object)
{
    struct object_visitor  visitor;

    _cake_zmem(&visitor, 12);
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_zero_core(&visitor);
}


void object_set_end_of_lifetime_core(struct object_visitor * p_visitor)
{
    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier * p_struct_or_union_specifier;

        p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);
        if (p_struct_or_union_specifier)
        {
            struct member_declaration * p_member_declaration;

            p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator * p_member_declarator;

                    p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                struct object_visitor  visitor;

                                _cake_zmem(&visitor, 12);
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_end_of_lifetime_core(&visitor);
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list != 0)
                    {
                        if (p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                        {
                            struct type  t;
                            struct type * temp;

                            _cake_zmem(&t, 68);
                            t.category = 0;
                            t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                            t.type_specifier_flags = 32768;
                            temp = p_visitor->p_type;
                            p_visitor->p_type = &t;
                            object_set_end_of_lifetime_core(p_visitor);
                            p_visitor->p_type = temp;
                            type_destroy(&t);
                        }
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
        return;
    }
    p_visitor->p_object->current.state = 128;
}


void flow_object_set_end_of_lifetime(struct type * p_type, struct flow_object * p_object)
{
    struct object_visitor  visitor;

    _cake_zmem(&visitor, 12);
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_end_of_lifetime_core(&visitor);
}


unsigned char object_check(struct type * p_type, struct flow_object * p_object)
{
    if (1) /*try*/
    {
        if (p_type->type_qualifier_flags & 32)
        {
            return 0;
        }
        if (!type_is_owner_or_pointer_to_dtor(p_type))
        {
            return 0;
        }
        if (p_type->struct_or_union_specifier && p_object->members.size > 0)
        {
            struct struct_or_union_specifier * p_struct_or_union_specifier;
            struct member_declaration * p_member_declaration;
            int possible_need_destroy_count;
            int need_destroy_count;
            int member_index;

            p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
            if (p_struct_or_union_specifier == 0)
            {
                goto __L0; /* throw */
            }
            p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
            possible_need_destroy_count = 0;
            need_destroy_count = 0;
            member_index = 0;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator * p_member_declarator;

                    p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (type_is_owner(&p_member_declarator->declarator->type))
                            {
                                possible_need_destroy_count++;
                            }
                            if (object_check(&p_member_declarator->declarator->type, p_object->members.data[member_index]))
                            {
                                need_destroy_count++;
                            }
                            member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list != 0)
                    {
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return need_destroy_count > 1 && (need_destroy_count == possible_need_destroy_count);
        }
        else
        {
            unsigned char  should_had_been_moved;

            should_had_been_moved = 0;
            if (type_is_pointer(p_type))
            {
                should_had_been_moved = ((p_object->current.state & 4) != 0);
            }
            else
            {
                if (p_object->current.state == 1 || (p_object->current.state & 8) || p_object->current.state == 4 || p_object->current.state == 1)
                {
                }
                else
                {
                    should_had_been_moved = 1;
                }
            }
            return should_had_been_moved;
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return 0;
}


void object_get_name_core(struct type * p_type, struct flow_object * p_object, struct flow_object * p_object_target, char * previous_names, char * outname, int out_size, unsigned int visit_number)
{
    if (1) /*try*/
    {
        if (p_object->visit_number == visit_number)
        {
            return;
        }
        ((struct flow_object *)p_object)->visit_number = visit_number;
        if (p_object == p_object_target)
        {
            snprintf(outname, out_size, "%s", previous_names);
            return;
        }
        if (p_type->struct_or_union_specifier && p_object->members.size > 0)
        {
            struct struct_or_union_specifier * p_struct_or_union_specifier;
            struct member_declaration * p_member_declaration;
            int member_index;

            p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
            if (p_struct_or_union_specifier == 0)
            {
                goto __L0; /* throw */
            }
            p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
            member_index = 0;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator * p_member_declarator;

                    p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            char * name;
                            char buffer[200];

                            name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "";
                            _cake_zmem(&buffer, 200);
                            if (type_is_pointer(p_type))
                            {
                                snprintf(buffer, 200, "%s->%s", previous_names, name);
                            }
                            else
                            {
                                snprintf(buffer, 200, "%s.%s", previous_names, name);
                            }
                            object_get_name_core(&p_member_declarator->declarator->type, p_object->members.data[member_index], p_object_target, buffer, outname, out_size, visit_number);
                            member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list != 0)
                    {
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
        }
        else
        {
            snprintf(outname, out_size, "%s", previous_names);
        }
    }
    else __L0: /*catch*/ 
    {
    }
}


void object_get_name(struct type * p_type, struct flow_object * p_object, char * outname, int out_size)
{
    outname[0] = 0;
    if (p_object->p_declarator_origin)
    {
        char * root_name;
        struct flow_object * root;

        root_name = p_object->p_declarator_origin->name_opt ? p_object->p_declarator_origin->name_opt->lexeme : "?";
        root = p_object->p_declarator_origin->p_flow_object;
        object_get_name_core(&p_object->p_declarator_origin->type, root, p_object, root_name, outname, out_size, s_visit_number++);
    }
    else
    {
        if (p_object->p_expression_origin)
        {
            int bytes_written;
            struct token * p;

            bytes_written = 0;
            p = p_object->p_expression_origin->first_token;
            {
                int i;

                i = 0;
                for (; i < 10; i++)
                {
                    char * ps;

                    ps = p->lexeme;
                    while (*ps)
                    {
                        if (bytes_written < (out_size - 1))
                        {
                            outname[bytes_written] = *ps;
                        }
                        bytes_written++;
                        ps++;
                    }
                    if (p == p_object->p_expression_origin->last_token)
                    {
                        break;
                    }
                    p = p->next;
                    ;
                }
            }
            if (bytes_written < (out_size - 1))
            {
                outname[bytes_written] = 0;
            }
            else
            {
                outname[out_size - 1] = 0;
            }
        }
        else
        {
            outname[0] = 63;
            outname[1] = 0;
        }
    }
}


static void checked_read_object_core(struct flow_visit_ctx * ctx, struct object_visitor * p_visitor, unsigned char  is_nullable, struct token * position_token_opt, struct marker * p_marker_opt, unsigned char  check_pointed_object, char * previous_names, unsigned int visit_number);

void checked_read_object(struct flow_visit_ctx * ctx, struct type * p_type, unsigned char  is_nullable, struct flow_object * p_object, struct token * position_token, struct marker * p_marker_opt, unsigned char  check_pointed_object)
{
    char * s;
    char name[200];
    struct object_visitor  visitor;

    s = 0;
    _cake_zmem(&name, 200);
    object_get_name(p_type, p_object, name, 200);
    _cake_zmem(&visitor, 12);
    visitor.p_object = p_object;
    visitor.p_type = p_type;
    checked_read_object_core(ctx, &visitor, is_nullable, position_token, p_marker_opt, check_pointed_object, name, s_visit_number++);
    free((void *)s);
}



static void checked_read_object_core(struct flow_visit_ctx * ctx, struct object_visitor * p_visitor, unsigned char  is_nullable, struct token * position_token_opt, struct marker * p_marker_opt, unsigned char  check_pointed_object, char * previous_names, unsigned int visit_number)
{
    ;
    if (p_visitor->p_object->visit_number == visit_number)
    {
        return;
    }
    p_visitor->p_object->visit_number = visit_number;
    if (p_visitor->p_type->struct_or_union_specifier && p_visitor->p_object->members.size > 0)
    {
        struct struct_or_union_specifier * p_struct_or_union_specifier;
        struct member_declaration * p_member_declaration;

        p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);
        p_member_declaration = p_struct_or_union_specifier ? p_struct_or_union_specifier->member_declaration_list.head : 0;
        while (p_member_declaration)
        {
            if (p_member_declaration->member_declarator_list_opt)
            {
                struct member_declarator * p_member_declarator;

                p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                while (p_member_declarator)
                {
                    if (p_member_declarator->declarator)
                    {
                        char * name;
                        char buffer[200];
                        struct object_visitor  visitor;

                        name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "?";
                        _cake_zmem(&buffer, 200);
                        if (type_is_pointer(p_visitor->p_type))
                        {
                            snprintf(buffer, 200, "%s->%s", previous_names, name);
                        }
                        else
                        {
                            snprintf(buffer, 200, "%s.%s", previous_names, name);
                        }
                        _cake_zmem(&visitor, 12);
                        visitor.p_type = &p_member_declarator->declarator->type;
                        visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                        checked_read_object_core(ctx, &visitor, is_nullable, position_token_opt, p_marker_opt, check_pointed_object, buffer, visit_number);
                        p_visitor->member_index++;
                    }
                    p_member_declarator = p_member_declarator->next;
                }
            }
            else
            {
                if (p_member_declaration->specifier_qualifier_list)
                {
                    struct type  t;
                    char buffer[200];
                    struct type * temp;
                    int visit_number0;

                    _cake_zmem(&t, 68);
                    t.category = 0;
                    t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                    t.type_specifier_flags = 32768;
                    _cake_zmem(&buffer, 200);
                    if (type_is_pointer(p_visitor->p_type))
                    {
                        snprintf(buffer, 200, "%s->", previous_names);
                    }
                    else
                    {
                        snprintf(buffer, 200, "%s.", previous_names);
                    }
                    temp = p_visitor->p_type;
                    p_visitor->p_type = &t;
                    visit_number0 = p_visitor->p_object->visit_number;
                    p_visitor->p_object->visit_number = 0;
                    checked_read_object_core(ctx, p_visitor, is_nullable, position_token_opt, p_marker_opt, check_pointed_object, buffer, visit_number);
                    p_visitor->p_type = temp;
                    p_visitor->p_object->visit_number = visit_number0;
                    type_destroy(&t);
                }
            }
            p_member_declaration = p_member_declaration->next;
        }
        return;
    }
    else
    {
        if (type_is_pointer(p_visitor->p_type) && !is_nullable && !type_is_opt(p_visitor->p_type, ctx->ctx->options.null_checks_enabled) && flow_object_can_be_null(p_visitor->p_object))
        {
            compiler_diagnostic(33, ctx->ctx, 0, p_marker_opt, "non-nullable pointer '%s' may be null", previous_names);
        }
        if (type_is_pointer(p_visitor->p_type) && check_pointed_object && flow_object_can_be_not_null_or_moved(p_visitor->p_object))
        {
            struct type  t2;

            t2 = type_remove_pointer(p_visitor->p_type);
            if (p_visitor->p_object->current.pointed)
            {
                struct object_visitor  visitor;

                _cake_zmem(&visitor, 12);
                visitor.p_type = &t2;
                visitor.p_object = p_visitor->p_object->current.pointed;
                checked_read_object_core(ctx, &visitor, is_nullable, position_token_opt, p_marker_opt, 1, previous_names, visit_number);
            }
            type_destroy(&t2);
        }
        if (p_visitor->p_object->current.state & 1)
        {
            if (type_is_array(p_visitor->p_type))
            {
            }
            else
            {
                compiler_diagnostic(30, ctx->ctx, position_token_opt, p_marker_opt, "uninitialized object '%s'", previous_names);
            }
        }
        if (p_visitor->p_object->current.state & 128)
        {
        }
    }
}
static void flow_end_of_block_visit_core(struct flow_visit_ctx * ctx, struct object_visitor * p_visitor, unsigned char  b_type_is_view, struct token * position_token, char * previous_names, unsigned int visit_number);
unsigned char type_is_view(struct type * p_type);

void flow_end_of_block_visit(struct flow_visit_ctx * ctx, struct type * p_type, unsigned char  type_is_view, struct flow_object * p_object, struct token * position_token, char * previous_names)
{
    struct object_visitor  visitor;

    _cake_zmem(&visitor, 12);
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    flow_end_of_block_visit_core(ctx, &visitor, type_is_view, position_token, previous_names, s_visit_number++);
}



static void flow_end_of_block_visit_core(struct flow_visit_ctx * ctx, struct object_visitor * p_visitor, unsigned char  b_type_is_view, struct token * position_token, char * previous_names, unsigned int visit_number)
{
    if (p_visitor->p_object->visit_number == visit_number)
    {
        return;
    }
    p_visitor->p_object->visit_number = visit_number;
    if (p_visitor->p_type->struct_or_union_specifier && p_visitor->p_object->members.size > 0)
    {
        struct struct_or_union_specifier * p_struct_or_union_specifier;
        struct member_declaration * p_member_declaration;

        p_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);
        if (p_struct_or_union_specifier == 0)
        {
            return;
        }
        p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;
        if (object_check(p_visitor->p_type, p_visitor->p_object))
        {
            struct token * name;

            name = flow_object_get_token(p_visitor->p_object);
            if (compiler_diagnostic(29, ctx->ctx, name, 0, "members of '%s' were not released.", previous_names))
            {
                if (p_visitor->p_object->p_declarator_origin)
                {
                    compiler_diagnostic(0, ctx->ctx, position_token, 0, "end of '%s' scope", previous_names);
                }
            }
        }
        else
        {
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator * p_member_declarator;

                    p_member_declarator = p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            char * name;
                            char buffer[200];
                            unsigned char  member_is_view;
                            struct object_visitor  visitor;

                            name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "?";
                            _cake_zmem(&buffer, 200);
                            if (type_is_pointer(p_visitor->p_type))
                            {
                                snprintf(buffer, 200, "%s->%s", previous_names, name);
                            }
                            else
                            {
                                snprintf(buffer, 200, "%s.%s", previous_names, name);
                            }
                            member_is_view = type_is_view(&p_member_declarator->declarator->type);
                            _cake_zmem(&visitor, 12);
                            visitor.p_type = &p_member_declarator->declarator->type;
                            visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                            flow_end_of_block_visit_core(ctx, &visitor, b_type_is_view || member_is_view, position_token, buffer, visit_number);
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list != 0)
                    {
                        struct type  t;
                        struct type * temp;
                        unsigned char  member_is_view;
                        int visit_number0;

                        _cake_zmem(&t, 68);
                        t.category = 0;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = 32768;
                        temp = p_visitor->p_type;
                        p_visitor->p_type = &t;
                        member_is_view = type_is_view(&t);
                        visit_number0 = p_visitor->p_object->visit_number;
                        p_visitor->p_object->visit_number = 0;
                        flow_end_of_block_visit_core(ctx, p_visitor, member_is_view, position_token, previous_names, visit_number);
                        p_visitor->p_type = temp;
                        p_visitor->p_object->visit_number = visit_number0;
                        type_destroy(&t);
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
        }
    }
    else
    {
        char * name;
        struct token * position;

        name = previous_names;
        position = 0;
        if (p_visitor->p_object->p_declarator_origin)
        {
            position = p_visitor->p_object->p_declarator_origin->name_opt ? p_visitor->p_object->p_declarator_origin->name_opt : p_visitor->p_object->p_declarator_origin->first_token_opt;
        }
        else
        {
            if (p_visitor->p_object->p_expression_origin)
            {
                position = p_visitor->p_object->p_expression_origin->first_token;
            }
            else
            {
                ;
            }
        }
        if (name[0] == 0)
        {
            name = "?";
        }
        if (type_is_pointer(p_visitor->p_type) && !b_type_is_view && type_is_owner(p_visitor->p_type) && p_visitor->p_object->current.state & 4)
        {
            unsigned char  show_warning;

            show_warning = 1;
            if (p_visitor->p_object->p_declarator_origin && p_visitor->p_object->p_declarator_origin->direct_declarator && p_visitor->p_object->p_declarator_origin->direct_declarator->p_attribute_specifier_sequence)
            {
                int attributes_flags;

                attributes_flags = p_visitor->p_object->p_declarator_origin->direct_declarator->p_attribute_specifier_sequence->attributes_flags;
                if (attributes_flags & 1073741824)
                {
                    show_warning = 0;
                }
            }
            if (show_warning && compiler_diagnostic(29, ctx->ctx, position, 0, "object pointed by '%s' was not released.", previous_names))
            {
                compiler_diagnostic(0, ctx->ctx, position_token, 0, "end of '%s' lifetime", previous_names);
            }
        }
        else
        {
            if (!b_type_is_view && type_is_pointed_dtor(p_visitor->p_type) && type_is_pointer(p_visitor->p_type))
            {
                char buffer[100];
                struct type  t2;

                _cake_zmem(&buffer, 100);
                snprintf(buffer, 100, "%s", previous_names);
                t2 = type_remove_pointer(p_visitor->p_type);
                if (p_visitor->p_object->current.pointed)
                {
                    struct object_visitor  visitor;

                    _cake_zmem(&visitor, 12);
                    visitor.p_type = &t2;
                    visitor.p_object = p_visitor->p_object->current.pointed;
                    flow_end_of_block_visit_core(ctx, &visitor, b_type_is_view, position, buffer, visit_number);
                }
                type_destroy(&t2);
            }
            else
            {
                if (type_is_owner(p_visitor->p_type) && !type_is_pointer(p_visitor->p_type))
                {
                    if (p_visitor->p_object->current.state == 1 || p_visitor->p_object->current.state == 2 || p_visitor->p_object->current.state == 8)
                    {
                    }
                    else
                    {
                        unsigned char  show_warning;

                        show_warning = 1;
                        if (p_visitor->p_object->p_declarator_origin && p_visitor->p_object->p_declarator_origin->direct_declarator && p_visitor->p_object->p_declarator_origin->direct_declarator->p_attribute_specifier_sequence)
                        {
                            int attributes_flags;

                            attributes_flags = p_visitor->p_object->p_declarator_origin->direct_declarator->p_attribute_specifier_sequence->attributes_flags;
                            if (attributes_flags & 1073741824)
                            {
                                show_warning = 0;
                            }
                        }
                        if (show_warning && compiler_diagnostic(29, ctx->ctx, position, 0, "object pointed by '%s' was not released.", previous_names))
                        {
                            compiler_diagnostic(0, ctx->ctx, position_token, 0, "end of '%s' lifetime", previous_names);
                        }
                    }
                }
                else
                {
                    if (type_is_pointer(p_visitor->p_type))
                    {
                        if (p_visitor->p_type->storage_class_specifier_flags & 2048)
                        {
                            if (type_is_owner_or_pointer_to_dtor(p_visitor->p_type))
                            {
                            }
                            else
                            {
                                struct type  t2;

                                t2 = type_remove_pointer(p_visitor->p_type);
                                if (p_visitor->p_object->current.pointed && p_visitor->p_object->p_declarator_origin)
                                {
                                    struct token * name_token;

                                    name_token = p_visitor->p_object->p_declarator_origin->name_opt ? p_visitor->p_object->p_declarator_origin->name_opt : p_visitor->p_object->p_declarator_origin->first_token_opt;
                                    checked_read_object(ctx, &t2, 0, p_visitor->p_object->current.pointed, name_token, 0, 1);
                                }
                                type_destroy(&t2);
                            }
                        }
                    }
                    else
                    {
                    }
                }
            }
        }
    }
}
unsigned char flow_object_is_zero_or_null(struct flow_object * p_object)
{
    return (p_object->current.state == 2) || (p_object->current.state == 32);
}


struct flow_object *expression_get_flow_object(struct flow_visit_ctx * ctx, struct expression * p_expression, unsigned char  nullable_enabled)
{
    if (1) /*try*/
    {
        if (p_expression->expression_type == 2)
        {
            ;
            if (p_expression->declarator->p_alias_of_expression)
            {
                return expression_get_flow_object(ctx, p_expression->declarator->p_alias_of_expression, nullable_enabled);
            }
            else
            {
                ;
                if (p_expression->declarator->declaration_specifiers && !is_automatic_variable(p_expression->declarator->declaration_specifiers->storage_class_specifier_flags))
                {
                    ;
                    if (flow_objects_find(&ctx->arena, p_expression->declarator->p_flow_object) == 0)
                    {
                        p_expression->declarator->p_flow_object = make_flow_object(ctx, &p_expression->declarator->type, p_expression->declarator, 0);
                        if (p_expression->declarator->p_flow_object == 0)
                        {
                            goto __L0; /* throw */
                        }
                        flow_object_set_unknown(&p_expression->declarator->type, type_is_opt(&p_expression->declarator->type, ctx->ctx->options.null_checks_enabled), p_expression->declarator->p_flow_object, ctx->ctx->options.null_checks_enabled);
                    }
                }
                return p_expression->declarator->p_flow_object;
            }
        }
        else
        {
            if (p_expression->expression_type == 41)
            {
                struct flow_object * p_object;
                struct flow_object * p_object_pointed;

                ;
                p_object = make_flow_object(ctx, &p_expression->type, 0, p_expression);
                if (p_object == 0)
                {
                    goto __L0; /* throw */
                }
                p_object_pointed = expression_get_flow_object(ctx, p_expression->right, nullable_enabled);
                if (p_object_pointed)
                {
                    object_set_pointer(p_object, p_object_pointed);
                }
                p_object->current.state = 4;
                p_object->is_temporary = 1;
                return p_object;
            }
            else
            {
                if (p_expression->expression_type == 9)
                {
                    ;
                    return expression_get_flow_object(ctx, p_expression->right, nullable_enabled);
                }
                else
                {
                    if (p_expression->expression_type == 42)
                    {
                        struct flow_object * p;

                        ;
                        p = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
                        if (p)
                        {
                            if (type_is_pointer(&p_expression->type_name->type))
                            {
                                if (p->current.state & 32)
                                {
                                    p->current.state &= -33;
                                    p->current.state |= 2;
                                }
                                if (p->current.state & 64)
                                {
                                    p->current.state &= -65;
                                    p->current.state |= 4;
                                }
                            }
                        }
                        return p;
                    }
                    else
                    {
                        if (p_expression->expression_type == 14)
                        {
                            struct flow_object * p_obj;

                            ;
                            p_obj = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
                            if (p_obj)
                            {
                                if (p_expression->member_index < p_obj->members.size)
                                {
                                    return p_obj->members.data[p_expression->member_index];
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            if (p_expression->expression_type == 13)
                            {
                                struct flow_object * p_obj;

                                ;
                                p_obj = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
                                if (p_obj)
                                {
                                    if (p_obj->current.pointed == 0)
                                    {
                                        flow_object_expand_pointer(ctx, &p_expression->left->type, p_obj);
                                    }
                                    if (p_obj->current.pointed)
                                    {
                                        struct flow_object * pointed;

                                        pointed = p_obj->current.pointed;
                                        return pointed;
                                    }
                                }
                                return 0;
                            }
                            else
                            {
                                if (p_expression->expression_type == 15)
                                {
                                    struct flow_object * p_obj;

                                    ;
                                    p_obj = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
                                    if (p_obj)
                                    {
                                        struct flow_object * pointed;
                                        struct flow_object * p_obj2;

                                        if (p_obj->current.pointed == 0)
                                        {
                                            flow_object_expand_pointer(ctx, &p_expression->left->type, p_obj);
                                        }
                                        pointed = p_obj->current.pointed;
                                        if (pointed == 0 || p_expression->member_index >= pointed->members.size)
                                        {
                                            return 0;
                                        }
                                        p_obj2 = pointed->members.data[p_expression->member_index];
                                        p_obj2->p_declarator_origin = 0;
                                        p_obj2->p_expression_origin = p_expression;
                                        return p_obj2;
                                    }
                                    return 0;
                                }
                                else
                                {
                                    if (p_expression->expression_type == 40)
                                    {
                                        struct flow_object * p_obj;

                                        ;
                                        p_obj = expression_get_flow_object(ctx, p_expression->right, nullable_enabled);
                                        if (p_obj)
                                        {
                                            if (p_obj->current.pointed == 0)
                                            {
                                                flow_object_expand_pointer(ctx, &p_expression->right->type, p_obj);
                                            }
                                            if (p_obj->current.pointed != 0)
                                            {
                                                return p_obj->current.pointed;
                                            }
                                        }
                                        return p_obj;
                                    }
                                    else
                                    {
                                        if (p_expression->expression_type == 12)
                                        {
                                            struct flow_object * p_object;
                                            unsigned char  is_nullable;

                                            p_object = make_flow_object(ctx, &p_expression->type, 0, p_expression);
                                            if (p_object == 0)
                                            {
                                                goto __L0; /* throw */
                                            }
                                            is_nullable = type_is_opt(&p_expression->type, nullable_enabled);
                                            flow_object_set_unknown(&p_expression->type, is_nullable, p_object, nullable_enabled);
                                            p_object->is_temporary = 1;
                                            if (type_is_pointer(&p_expression->type) && flow_object_is_expansible(p_object))
                                            {
                                                flow_object_expand_pointer(ctx, &p_expression->type, p_object);
                                            }
                                            return p_object;
                                        }
                                        else
                                        {
                                            if (p_expression->expression_type == 11)
                                            {
                                                ;
                                                return p_expression->type_name->abstract_declarator->p_flow_object;
                                            }
                                            else
                                            {
                                                if (p_expression->expression_type == 3)
                                                {
                                                    struct flow_object * p_object;

                                                    p_object = make_flow_object(ctx, &p_expression->type, 0, p_expression);
                                                    if (p_object == 0)
                                                    {
                                                        goto __L0; /* throw */
                                                    }
                                                    p_object->current.state = 4;
                                                    return p_object;
                                                }
                                                else
                                                {
                                                    if (p_expression->expression_type == 6)
                                                    {
                                                        struct flow_object * p_object;

                                                        p_object = make_flow_object(ctx, &p_expression->type, 0, p_expression);
                                                        if (p_object == 0)
                                                        {
                                                            goto __L0; /* throw */
                                                        }
                                                        if (p_expression->type.type_specifier_flags == 16777216)
                                                        {
                                                            p_object->current.state = 2;
                                                        }
                                                        else
                                                        {
                                                            if (object_has_constant_value(&p_expression->object))
                                                            {
                                                                unsigned char  not_zero;

                                                                not_zero = object_is_true(&p_expression->object);
                                                                p_object->current.state = not_zero ? 64 : 32;
                                                            }
                                                        }
                                                        return p_object;
                                                    }
                                                    else
                                                    {
                                                        if (p_expression->expression_type == 61)
                                                        {
                                                            struct flow_object * p_obj;

                                                            ;
                                                            p_obj = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
                                                            return p_obj;
                                                        }
                                                        else
                                                        {
                                                            if (p_expression->expression_type == 73)
                                                            {
                                                                struct flow_object * p_object;
                                                                struct flow_object * p_obj1;
                                                                struct flow_object * p_obj2;

                                                                ;
                                                                ;
                                                                p_object = make_flow_object(ctx, &p_expression->type, 0, p_expression);
                                                                if (p_object == 0)
                                                                {
                                                                    goto __L0; /* throw */
                                                                }
                                                                p_obj1 = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
                                                                p_obj2 = expression_get_flow_object(ctx, p_expression->right, nullable_enabled);
                                                                if (p_obj1 && p_obj2)
                                                                {
                                                                    flow_object_merge_state(p_object, p_obj1, p_obj2);
                                                                }
                                                                return p_object;
                                                            }
                                                            else
                                                            {
                                                                if (p_expression->expression_type == 54 || p_expression->expression_type == 55)
                                                                {
                                                                    struct flow_object * p_object;

                                                                    p_object = make_flow_object(ctx, &p_expression->type, 0, p_expression);
                                                                    if (p_object == 0)
                                                                    {
                                                                        goto __L0; /* throw */
                                                                    }
                                                                    if (object_has_constant_value(&p_expression->object))
                                                                    {
                                                                        unsigned char  not_zero;

                                                                        not_zero = object_is_true(&p_expression->object);
                                                                        p_object->current.state = not_zero ? 64 : 32;
                                                                    }
                                                                    else
                                                                    {
                                                                        p_object->current.state = 96;
                                                                    }
                                                                    return p_object;
                                                                }
                                                                else
                                                                {
                                                                    if (p_expression->expression_type == 46)
                                                                    {
                                                                        struct flow_object * p_object;

                                                                        p_object = make_flow_object(ctx, &p_expression->type, 0, p_expression);
                                                                        if (p_object == 0)
                                                                        {
                                                                            goto __L0; /* throw */
                                                                        }
                                                                        if (type_is_pointer(&p_expression->type))
                                                                        {
                                                                            p_object->current.state = 4;
                                                                        }
                                                                        else
                                                                        {
                                                                            if (object_has_constant_value(&p_expression->object))
                                                                            {
                                                                                unsigned char  not_zero;

                                                                                not_zero = object_is_true(&p_expression->object);
                                                                                p_object->current.state = not_zero ? 4 : 2;
                                                                            }
                                                                            else
                                                                            {
                                                                                p_object->current.state = 6;
                                                                            }
                                                                        }
                                                                        return p_object;
                                                                    }
                                                                    else
                                                                    {
                                                                        if (p_expression->expression_type == 38 || p_expression->expression_type == 39)
                                                                        {
                                                                            struct flow_object * p_obj_right;
                                                                            struct flow_object * p_object;

                                                                            ;
                                                                            p_obj_right = expression_get_flow_object(ctx, p_expression->right, nullable_enabled);
                                                                            p_object = make_flow_object(ctx, &p_expression->type, 0, p_expression);
                                                                            if (p_object == 0)
                                                                            {
                                                                                goto __L0; /* throw */
                                                                            }
                                                                            if (p_obj_right)
                                                                            {
                                                                                p_object->current.state = p_obj_right->current.state;
                                                                            }
                                                                            return p_object;
                                                                        }
                                                                        else
                                                                        {
                                                                            struct flow_object * p_object;

                                                                            p_object = make_flow_object(ctx, &p_expression->type, 0, p_expression);
                                                                            if (p_object == 0)
                                                                            {
                                                                                goto __L0; /* throw */
                                                                            }
                                                                            if (type_is_pointer(&p_expression->type))
                                                                            {
                                                                                if (object_has_constant_value(&p_expression->object))
                                                                                {
                                                                                    unsigned char  not_zero;

                                                                                    not_zero = object_is_true(&p_expression->object);
                                                                                    p_object->current.state = not_zero ? 4 : 2;
                                                                                }
                                                                                else
                                                                                {
                                                                                    p_object->current.state = 6;
                                                                                }
                                                                            }
                                                                            else
                                                                            {
                                                                                if (object_has_constant_value(&p_expression->object))
                                                                                {
                                                                                    unsigned char  not_zero;

                                                                                    not_zero = object_is_true(&p_expression->object);
                                                                                    p_object->current.state = not_zero ? 64 : 32;
                                                                                }
                                                                                else
                                                                                {
                                                                                    p_object->current.state = 96;
                                                                                }
                                                                            }
                                                                            return p_object;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return 0;
}


static void flow_assignment_core(struct flow_visit_ctx * ctx, struct token * error_position, struct marker * p_a_marker, struct marker * p_b_marker, int assigment_type, unsigned char  check_uninitialized_b, unsigned char  a_type_is_view, unsigned char  a_type_is_nullable, struct object_visitor * p_visitor_a, struct object_visitor * p_visitor_b, unsigned char * set_argument_to_unkown);
unsigned char type_is_ctor(struct type * p_type);

void flow_check_assignment(struct flow_visit_ctx * ctx, struct token * error_position, struct marker * p_a_marker, struct marker * p_b_marker, int assigment_type, unsigned char  check_uninitialized_b, unsigned char  a_type_is_view, unsigned char  a_type_is_nullable, struct type * p_a_type, struct flow_object * p_a_object, struct type * p_b_type, struct flow_object * p_b_object, unsigned char * set_argument_to_unkown)
{
    struct object_visitor  visitor_a;
    struct object_visitor  visitor_b;

    if (type_is_pointer(p_b_type) && flow_object_is_expansible(p_b_object))
    {
    }
    visitor_a.member_index = 0;
    visitor_a.p_type = p_a_type;
    visitor_a.p_object = p_a_object;
    visitor_b.member_index = 0;
    visitor_b.p_type = p_b_type;
    visitor_b.p_object = p_b_object;
    flow_assignment_core(ctx, error_position, p_a_marker, p_b_marker, assigment_type, check_uninitialized_b, a_type_is_view, a_type_is_nullable, &visitor_a, &visitor_b, set_argument_to_unkown);
}



static void flow_assignment_core(struct flow_visit_ctx * ctx, struct token * error_position, struct marker * p_a_marker, struct marker * p_b_marker, int assigment_type, unsigned char  check_uninitialized_b, unsigned char  a_type_is_view, unsigned char  a_type_is_nullable, struct object_visitor * p_visitor_a, struct object_visitor * p_visitor_b, unsigned char * set_argument_to_unkown)
{
    if (check_uninitialized_b && flow_object_can_be_uninitialized(p_visitor_b->p_object))
    {
        if (type_is_array(p_visitor_b->p_type))
        {
            if (assigment_type == 1)
            {
                struct type  item_type;
                unsigned char  cannot_be_uninitialized;

                _cake_zmem(&item_type, 68);
                if (type_is_array(p_visitor_a->p_type))
                {
                    item_type = get_array_item_type(p_visitor_a->p_type);
                }
                else
                {
                    item_type = type_remove_pointer(p_visitor_a->p_type);
                }
                cannot_be_uninitialized = (ctx->ctx->options.ownership_enabled && !type_is_ctor(&item_type)) || type_is_const(&item_type);
                if (cannot_be_uninitialized)
                {
                    char b_object_name[100];

                    _cake_zmem(&b_object_name, 100);
                    object_get_name(p_visitor_b->p_type, p_visitor_b->p_object, b_object_name, 100);
                    compiler_diagnostic(30, ctx->ctx, 0, p_b_marker, "uninitialized object '%s' passed to non-optional parameter", b_object_name);
                }
                type_destroy(&item_type);
            }
        }
        else
        {
            char b_object_name[100];

            _cake_zmem(&b_object_name, 100);
            object_get_name(p_visitor_b->p_type, p_visitor_b->p_object, b_object_name, 100);
            if (assigment_type == 1)
            {
                compiler_diagnostic(30, ctx->ctx, 0, p_b_marker, "passing an uninitialized argument '%s' object", b_object_name);
            }
            else
            {
                if (assigment_type == 0)
                {
                    compiler_diagnostic(30, ctx->ctx, 0, p_b_marker, "returning an uninitialized '%s' object", b_object_name);
                }
                else
                {
                    compiler_diagnostic(30, ctx->ctx, 0, p_b_marker, "reading an uninitialized '%s' object", b_object_name);
                }
            }
        }
        return;
    }
    if (check_uninitialized_b && flow_object_can_have_its_lifetime_ended(p_visitor_a->p_object))
    {
        char buffer[100];

        _cake_zmem(&buffer, 100);
        object_get_name(p_visitor_a->p_type, p_visitor_a->p_object, buffer, 100);
        compiler_diagnostic(31, ctx->ctx, 0, p_a_marker, "The object '%s' may have been deleted or its lifetime have ended.", buffer);
        return;
    }
    if (type_is_pointer(p_visitor_a->p_type) && (!type_is_opt(p_visitor_a->p_type, ctx->ctx->options.null_checks_enabled)) && flow_object_can_be_null(p_visitor_b->p_object))
    {
        if (!a_type_is_nullable)
        {
            char buffer[100];

            _cake_zmem(&buffer, 100);
            object_get_name(p_visitor_b->p_type, p_visitor_b->p_object, buffer, 100);
            if (assigment_type == 1)
            {
                compiler_diagnostic(35, ctx->ctx, 0, p_b_marker, "passing a possible null pointer '%s' to non-nullable pointer parameter", buffer);
            }
            else
            {
                if (assigment_type == 0)
                {
                    compiler_diagnostic(35, ctx->ctx, 0, p_b_marker, "returning a possible null pointer '%s' to non-nullable pointer", buffer);
                }
                else
                {
                    compiler_diagnostic(35, ctx->ctx, 0, p_b_marker, "assignment of possible null pointer '%s' to non-nullable pointer", buffer);
                }
            }
        }
    }
    if (type_is_pointer(p_visitor_a->p_type))
    {
        if (!a_type_is_view && type_is_owner(p_visitor_a->p_type))
        {
            checked_empty(ctx, p_visitor_a->p_type, p_visitor_a->p_object, p_a_marker);
        }
        if (flow_object_is_zero_or_null(p_visitor_b->p_object))
        {
            if (type_is_array(p_visitor_b->p_type))
            {
                p_visitor_a->p_object->current.state = 4;
                return;
            }
            else
            {
                if (type_is_nullptr_t(p_visitor_b->p_type) || type_is_integer(p_visitor_b->p_type))
                {
                    flow_object_set_current_state_to_is_null(p_visitor_a->p_object);
                    return;
                }
            }
        }
    }
    if (!a_type_is_view && type_is_pointed_dtor(p_visitor_a->p_type) && type_is_pointer(p_visitor_a->p_type))
    {
        checked_empty(ctx, p_visitor_a->p_type, p_visitor_a->p_object, p_a_marker);
        if (flow_object_is_zero_or_null(p_visitor_b->p_object))
        {
            return;
        }
    }
    if (type_is_void_ptr(p_visitor_a->p_type) && type_is_pointer(p_visitor_b->p_type))
    {
        p_visitor_a->p_object->current.state = p_visitor_b->p_object->current.state;
        if (!a_type_is_view && type_is_owner(p_visitor_a->p_type))
        {
            struct type  t;

            if (flow_object_can_be_moved(p_visitor_b->p_object))
            {
                compiler_diagnostic(32, ctx->ctx, 0, p_b_marker, "object may be already moved");
            }
            t = type_remove_pointer(p_visitor_b->p_type);
            if (p_visitor_b->p_object->current.pointed == 0)
            {
                if (flow_object_is_expansible(p_visitor_b->p_object) && type_is_owner(&t))
                {
                    compiler_diagnostic(29, ctx->ctx, 0, p_a_marker, "pointed object may be not empty");
                }
            }
            else
            {
                checked_empty(ctx, &t, p_visitor_b->p_object->current.pointed, p_b_marker);
                object_set_deleted(&t, p_visitor_b->p_object->current.pointed);
            }
            type_destroy(&t);
            if (assigment_type == 1)
            {
                flow_object_set_is_unitialized(p_visitor_b->p_object);
                p_visitor_b->p_object->current.state = 1;
            }
            else
            {
                flow_object_set_is_moved(p_visitor_b->p_object);
            }
        }
        return;
    }
    if (type_is_pointer(p_visitor_a->p_type) && type_is_pointer(p_visitor_b->p_type))
    {
        struct type  t;
        unsigned char  checked_pointed_object_read;
        unsigned char  is_nullable;

        p_visitor_a->p_object->current.state = p_visitor_b->p_object->current.state;
        p_visitor_a->p_object->current.pointed = p_visitor_b->p_object->current.pointed;
        t = type_remove_pointer(p_visitor_a->p_type);
        checked_pointed_object_read = ctx->ctx->options.ownership_enabled && !type_is_ctor(&t);
        is_nullable = a_type_is_nullable || type_is_opt(&t, ctx->ctx->options.null_checks_enabled);
        checked_read_object(ctx, p_visitor_b->p_type, is_nullable, p_visitor_b->p_object, error_position, p_b_marker, checked_pointed_object_read);
        type_destroy(&t);
        if (!a_type_is_view && type_is_owner(p_visitor_a->p_type))
        {
            if (flow_object_can_be_moved(p_visitor_b->p_object))
            {
                compiler_diagnostic(32, ctx->ctx, error_position, 0, "source object has already been moved");
            }
            if (assigment_type == 1)
            {
                p_visitor_b->p_object->current.state = 1;
                if (p_visitor_b->p_object->current.pointed)
                {
                    struct flow_object * pointed;
                    struct type  t2;

                    pointed = p_visitor_b->p_object->current.pointed;
                    t2 = type_remove_pointer(p_visitor_b->p_type);
                    object_set_deleted(&t2, pointed);
                    type_destroy(&t2);
                }
            }
            else
            {
                p_visitor_a->p_object->current.state = p_visitor_a->p_object->current.state & -9;
                if (p_visitor_b->p_object->current.state & 4)
                {
                    p_visitor_b->p_object->current.state &= -5;
                    p_visitor_b->p_object->current.state |= 8;
                }
            }
        }
        else
        {
            if (!a_type_is_view && type_is_pointed_dtor(p_visitor_a->p_type))
            {
                if (type_is_owner_or_pointer_to_dtor(p_visitor_b->p_type))
                {
                    if (assigment_type == 1)
                    {
                        if (p_visitor_b->p_object->current.pointed)
                        {
                            struct flow_object * pointed;
                            struct type  t2;

                            pointed = p_visitor_b->p_object->current.pointed;
                            t2 = type_remove_pointer(p_visitor_b->p_type);
                            flow_object_set_uninitialized(&t2, pointed);
                            type_destroy(&t2);
                        }
                    }
                    else
                    {
                        flow_object_set_moved(p_visitor_b->p_type, p_visitor_b->p_object);
                    }
                }
                else
                {
                    if (p_visitor_b->p_type->address_of)
                    {
                        if (assigment_type == 1)
                        {
                            p_visitor_b->p_object->current.state = 1;
                            if (p_visitor_b->p_object->current.pointed)
                            {
                                struct flow_object * pointed;
                                struct type  t2;

                                pointed = p_visitor_b->p_object->current.pointed;
                                t2 = type_remove_pointer(p_visitor_b->p_type);
                                flow_object_set_uninitialized(&t2, pointed);
                                type_destroy(&t2);
                            }
                        }
                        else
                        {
                            flow_object_set_moved(p_visitor_b->p_type, p_visitor_b->p_object);
                        }
                    }
                    else
                    {
                    }
                }
            }
            else
            {
                if (a_type_is_view || !type_is_owner(p_visitor_a->p_type))
                {
                    p_visitor_a->p_object->current.state = p_visitor_b->p_object->current.state;
                }
                if (assigment_type == 1)
                {
                    struct type  t3;

                    t3 = type_remove_pointer(p_visitor_a->p_type);
                    if (!type_is_const(&t3))
                    {
                        if (p_visitor_b->p_object->current.pointed)
                        {
                            if (set_argument_to_unkown)
                            {
                                *set_argument_to_unkown = 1;
                            }
                        }
                    }
                    type_destroy(&t3);
                }
            }
        }
        return;
    }
    if (p_visitor_a->p_type->struct_or_union_specifier && p_visitor_a->p_object->members.size > 0)
    {
        struct struct_or_union_specifier * p_a_struct_or_union_specifier;
        struct struct_or_union_specifier * p_b_struct_or_union_specifier;

        p_a_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_visitor_a->p_type->struct_or_union_specifier);
        if (p_visitor_b->p_type->struct_or_union_specifier == 0)
        {
            return;
        }
        p_b_struct_or_union_specifier = get_complete_struct_or_union_specifier(p_visitor_b->p_type->struct_or_union_specifier);
        if (p_a_struct_or_union_specifier && p_b_struct_or_union_specifier)
        {
            struct member_declaration * p_a_member_declaration;
            struct member_declaration * p_b_member_declaration;

            p_a_member_declaration = p_a_struct_or_union_specifier->member_declaration_list.head;
            p_b_member_declaration = p_b_struct_or_union_specifier->member_declaration_list.head;
            while (p_a_member_declaration && p_b_member_declaration)
            {
                if (p_a_member_declaration->member_declarator_list_opt && p_b_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator * p_a_member_declarator;
                    struct member_declarator * p_b_member_declarator;

                    p_a_member_declarator = p_a_member_declaration->member_declarator_list_opt->head;
                    p_b_member_declarator = p_b_member_declaration->member_declarator_list_opt->head;
                    while (p_a_member_declarator && p_b_member_declarator)
                    {
                        if (p_a_member_declarator->declarator && p_b_member_declarator->declarator)
                        {
                            if (p_visitor_a->member_index < p_visitor_a->p_object->members.size && p_visitor_b->member_index < p_visitor_b->p_object->members.size)
                            {
                                struct object_visitor  visitor_a;
                                struct object_visitor  visitor_b;

                                _cake_zmem(&visitor_a, 12);
                                visitor_a.p_type = &p_a_member_declarator->declarator->type;
                                visitor_a.p_object = p_visitor_a->p_object->members.data[p_visitor_a->member_index];
                                _cake_zmem(&visitor_b, 12);
                                visitor_b.p_type = &p_b_member_declarator->declarator->type;
                                visitor_b.p_object = p_visitor_b->p_object->members.data[p_visitor_b->member_index];
                                flow_assignment_core(ctx, error_position, p_a_marker, p_b_marker, assigment_type, check_uninitialized_b, a_type_is_view, a_type_is_nullable, &visitor_a, &visitor_b, set_argument_to_unkown);
                            }
                            else
                            {
                            }
                            p_visitor_a->member_index++;
                            p_visitor_b->member_index++;
                        }
                        p_a_member_declarator = p_a_member_declarator->next;
                        p_b_member_declarator = p_b_member_declarator->next;
                    }
                }
                else
                {
                    if (p_a_member_declaration->specifier_qualifier_list && p_a_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type  t;
                        struct type * temp1;
                        struct type * temp2;

                        _cake_zmem(&t, 68);
                        t.category = 0;
                        t.struct_or_union_specifier = p_a_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = 32768;
                        temp1 = p_visitor_a->p_type;
                        temp2 = p_visitor_b->p_type;
                        p_visitor_a->p_type = &t;
                        p_visitor_b->p_type = &t;
                        flow_assignment_core(ctx, error_position, p_a_marker, p_b_marker, assigment_type, check_uninitialized_b, a_type_is_view, a_type_is_nullable, p_visitor_a, p_visitor_b, set_argument_to_unkown);
                        p_visitor_a->p_type = temp1;
                        p_visitor_b->p_type = temp2;
                        type_destroy(&t);
                    }
                }
                p_a_member_declaration = p_a_member_declaration->next;
                p_b_member_declaration = p_b_member_declaration->next;
            }
            return;
        }
    }
    p_visitor_a->p_object->current.state = p_visitor_b->p_object->current.state;
    if (!a_type_is_view && type_is_owner(p_visitor_a->p_type))
    {
        if (assigment_type == 1)
        {
            flow_object_set_uninitialized(p_visitor_b->p_type, p_visitor_b->p_object);
        }
        else
        {
            flow_object_set_moved(p_visitor_b->p_type, p_visitor_b->p_object);
        }
    }
}
void print_object_state_to_str(int e, char str[], int sz)
{
    unsigned char  first;
    struct osstream  ss;

    first = 1;
    _cake_zmem(&ss, 12);
    if (e == 0)
    {
        ss_fprintf(&ss, "--");
    }
    if (e & 1)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            ss_fprintf(&ss, ",");
        }
        ss_fprintf(&ss, "unset");
    }
    if (e & 4)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            ss_fprintf(&ss, ",");
        }
        ss_fprintf(&ss, "not-null");
    }
    if (e & 2)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            ss_fprintf(&ss, ",");
        }
        ss_fprintf(&ss, "null");
    }
    if (e & 32)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            ss_fprintf(&ss, ",");
        }
        ss_fprintf(&ss, "zero");
    }
    if (e & 64)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            ss_fprintf(&ss, ",");
        }
        ss_fprintf(&ss, "not-zero");
    }
    if (e & 128)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            ss_fprintf(&ss, ",");
        }
        ss_fprintf(&ss, "lifetime-ended");
    }
    if (e & 8)
    {
        if (first)
        {
            first = 0;
        }
        else
        {
            ss_fprintf(&ss, ",");
        }
        ss_fprintf(&ss, "moved");
    }
    snprintf(str, sz, "%s", ss.c_str);
    ss_close(&ss);
}


void flow_object_state_print(struct flow_object_state * p_state)
{
    struct osstream  ss;
    char temp[200];

    _cake_zmem(&ss, 12);
    _cake_zmem(&temp, 200);
    print_object_state_to_str(p_state->state, temp, 200);
    ss_fprintf(&ss, "%d %s", p_state->state_number, temp);
    if (p_state->pointed)
    {
        ss_fprintf(&ss, " ->%d", p_state->pointed->id);
    }
    if (p_state->alternatives.size > 0)
    {
        ss_fprintf(&ss, " ");
    }
    {
        int i;

        i = 0;
        for (; i < p_state->alternatives.size; i++)
        {
            if (i != 0)
            {
                ss_fprintf(&ss, ",");
            }
            ss_fprintf(&ss, "%d", p_state->alternatives.data[i]->id);
        }
    }
    printf("%-25s\xe2\x94\x82", ss.c_str);
    ss_close(&ss);
}


void print_object_line(struct flow_object * p_object, int extra_cols)
{
    struct osstream  ss;
    int cols;
    struct flow_object_state * p_state;

    _cake_zmem(&ss, 12);
    if (p_object->parent)
    {
        ss_fprintf(&ss, "\xe2\x86\x91%d", p_object->parent->id);
        printf("\xe2\x94\x82%-2d\xe2\x94\x82", p_object->id);
        printf("%-20s\xe2\x94\x82", ss.c_str);
    }
    else
    {
        int line;
        int col;

        line = 0;
        col = 0;
        if (p_object->p_declarator_origin)
        {
            if (p_object->p_declarator_origin->name_opt)
            {
                line = p_object->p_declarator_origin->name_opt->line;
                col = p_object->p_declarator_origin->name_opt->col;
                ss_fprintf(&ss, "%2d:%2d ", line, col);
                ss_fprintf(&ss, "%s", p_object->p_declarator_origin->name_opt->lexeme);
            }
            else
            {
                ss_fprintf(&ss, "%2d:%2d ", line, col);
                ss_fprintf(&ss, "%s", "?");
            }
        }
        else
        {
            if (p_object->p_expression_origin)
            {
                line = p_object->p_expression_origin->first_token->line;
                col = p_object->p_expression_origin->first_token->col;
                ss_fprintf(&ss, "%2d:%2d ", line, col);
                ss_fprintf(&ss, "%s", p_object->p_expression_origin->first_token->lexeme);
            }
            else
            {
                ss_fprintf(&ss, "&");
            }
        }
        printf("\xe2\x94\x82%-2d\xe2\x94\x82", p_object->id);
        printf("%-18s\xe2\x94\x82", ss.c_str);
    }
    ss_close(&ss);
    cols = 0;
    p_state = &p_object->current;
    while (p_state)
    {
        cols++;
        flow_object_state_print(p_state);
        p_state = p_state->next;
    }
    {
        int i;

        i = 0;
        for (; i <= extra_cols - cols; i++)
        {
            printf("%-25s\xe2\x94\x82", " ");
        }
    }
    printf("\n");
}


void true_false_set_destroy(struct true_false_set * p)
{
    free(p->data);
}


void print_arena(struct flow_visit_ctx * ctx)
{
    int extra_cols;

    extra_cols = 0;
    {
        int i;

        i = 0;
        for (; i < ctx->arena.size; i++)
        {
            struct flow_object * p_object;
            struct flow_object_state * p_state;
            int count;

            p_object = ctx->arena.data[i];
            p_state = p_object->current.next;
            count = 0;
            while (p_state)
            {
                count++;
                p_state = p_state->next;
            }
            if (count > extra_cols)
            {
                extra_cols = count;
            }
        }
    }
    printf("\n");
    printf("\xe2\x94\x8c\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80");
    if (extra_cols > 0)
    {
        {
            int i;

            i = 0;
            for (; i < extra_cols; i++)
            {
                if (i < extra_cols - 1)
                {
                    printf("\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80");
                }
                else
                {
                    printf("\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80");
                }
            }
        }
    }
    printf("\xe2\x94\x90");
    printf("\n");
    {
        int i;

        i = 0;
        for (; i < ctx->arena.size; i++)
        {
            struct flow_object * p;

            p = ctx->arena.data[i];
            print_object_line(p, extra_cols);
        }
    }
    printf("\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80");
    if (extra_cols > 0)
    {
        {
            int i;

            i = 0;
            for (; i < extra_cols; i++)
            {
                if (i < extra_cols - 1)
                {
                    printf("\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80");
                }
                else
                {
                    printf("\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80");
                }
            }
        }
    }
    printf("\xe2\x94\x98");
    printf("\n");
    printf("\n");
}


void flow_object_push_states_from(struct flow_object * p_object_from, struct flow_object * p_object_to)
{
    struct flow_object_state * it_from;

    it_from = p_object_from->current.next;
    while (it_from)
    {
        it_from = it_from->next;
    }
    {
        int i;

        i = 0;
        for (; i < p_object_to->members.size; i++)
        {
            flow_object_push_states_from(p_object_from, p_object_to->members.data[i]);
        }
    }
}


static void flow_visit_static_assert_declaration(struct flow_visit_ctx * ctx, struct static_assert_declaration * p_static_assert_declaration);
static void flow_visit_expression(struct flow_visit_ctx * ctx, struct expression * p_expression, struct true_false_set * a);
static void true_false_set_clear(struct true_false_set * p);
static int true_false_set_push_back(struct true_false_set * p, struct true_false_set_item * book);
static int true_false_set_reserve(struct true_false_set * p, int n);
static void check_uninitialized(struct flow_visit_ctx * ctx, struct expression * p_expression);
static void flow_visit_generic_selection(struct flow_visit_ctx * ctx, struct generic_selection * p_generic_selection);
static void flow_compare_function_arguments(struct flow_visit_ctx * ctx, struct type * p_type, struct argument_expression_list * p_argument_expression_list);
static void flow_clear_alias(struct expression * p_expression);
static void flow_expression_bind(struct flow_visit_ctx * ctx, struct expression * p_expression, struct param_list * p_param_list, struct argument_expression_list * p_argument_expression_list);
static struct argument_expression *param_list_find_argument_by_name(struct param_list * p_param_list, struct argument_expression_list * list, char * name);
static void true_false_set_set_objects_to_true_branch(struct flow_visit_ctx * ctx, struct true_false_set * a, unsigned char  nullable_enabled);
static void true_false_set_set_objects_to_core_branch(struct flow_visit_ctx * ctx, struct true_false_set * a, unsigned char  nullable_enabled, unsigned char  true_branch);
static int find_item_index_by_expression(struct true_false_set * a, struct expression * p_expression);
static void flow_visit_compound_statement(struct flow_visit_ctx * ctx, struct compound_statement * p_compound_statement);
static void flow_visit_block_item_list(struct flow_visit_ctx * ctx, struct block_item_list * p_block_item_list);
static void flow_visit_block_item(struct flow_visit_ctx * ctx, struct block_item * p_block_item);
static void flow_visit_unlabeled_statement(struct flow_visit_ctx * ctx, struct unlabeled_statement * p_unlabeled_statement);
static void flow_visit_primary_block(struct flow_visit_ctx * ctx, struct primary_block * p_primary_block);
static void flow_visit_defer_statement(struct flow_visit_ctx * ctx, struct defer_statement * p_defer_statement);
static void flow_visit_iteration_statement(struct flow_visit_ctx * ctx, struct iteration_statement * p_iteration_statement);
static void flow_visit_while_statement(struct flow_visit_ctx * ctx, struct iteration_statement * p_iteration_statement);
static int arena_add_copy_of_current_state(struct flow_visit_ctx * ctx, char * name);
static int arena_add_empty_state(struct flow_visit_ctx * ctx, char * name);
static void flow_visit_secondary_block(struct flow_visit_ctx * ctx, struct secondary_block * p_secondary_block);
static void flow_visit_statement(struct flow_visit_ctx * ctx, struct statement * p_statement);
static void flow_visit_labeled_statement(struct flow_visit_ctx * ctx, struct labeled_statement * p_labeled_statement);
static void flow_visit_label(struct flow_visit_ctx * ctx, struct label * p_label);
static void arena_restore_current_state_from(struct flow_visit_ctx * ctx, int number_state);
static void object_restore_current_state_from(struct flow_visit_ctx * ctx, struct flow_object * object, int state_number);
static void flow_exit_block_visit_defer_list(struct flow_visit_ctx * ctx, struct defer_list * p_defer_list, struct token * position_token);
static void flow_exit_block_visit_defer_item(struct flow_visit_ctx * ctx, struct defer_list_item * p_item, struct token * position_token);
static void true_false_set_set_objects_to_false_branch(struct flow_visit_ctx * ctx, struct true_false_set * a, unsigned char  nullable_enabled);
static void arena_merge_current_state_with_state_number(struct flow_visit_ctx * ctx, int number_state);
static int flow_object_merge_current_with_state(struct flow_visit_ctx * ctx, struct flow_object * object, int state_number);
static void flow_defer_list_set_end_of_lifetime(struct flow_visit_ctx * ctx, struct defer_list * p_defer_list, struct token * position_token);
static void flow_defer_item_set_end_of_lifetime(struct flow_visit_ctx * ctx, struct defer_list_item * p_item, struct token * position_token);
static void arena_remove_state(struct flow_visit_ctx * ctx, int state_number);
static void flow_visit_do_while_statement(struct flow_visit_ctx * ctx, struct iteration_statement * p_iteration_statement);
static void flow_visit_for_statement(struct flow_visit_ctx * ctx, struct iteration_statement * p_iteration_statement);
static void flow_visit_init_declarator_list(struct flow_visit_ctx * ctx, struct init_declarator_list * p_init_declarator_list);
static void flow_visit_init_declarator(struct flow_visit_ctx * ctx, struct init_declarator * p_init_declarator);
static void flow_visit_declarator(struct flow_visit_ctx * ctx, struct declarator * p_declarator);
unsigned char type_is_pointer_to_out(struct type * p_type);
static void flow_visit_direct_declarator(struct flow_visit_ctx * ctx, struct direct_declarator * p_direct_declarator);
static void flow_visit_declaration_specifiers(struct flow_visit_ctx * ctx, struct declaration_specifiers * p_declaration_specifiers, struct type * p_type);
static void flow_visit_declaration_specifier(struct flow_visit_ctx * ctx, struct declaration_specifier * p_declaration_specifier);
static void flow_visit_type_specifier_qualifier(struct flow_visit_ctx * ctx, struct type_specifier_qualifier * p_type_specifier_qualifier);
static void flow_visit_type_specifier(struct flow_visit_ctx * ctx, struct type_specifier * p_type_specifier);
static void flow_visit_struct_or_union_specifier(struct flow_visit_ctx * ctx, struct struct_or_union_specifier * p_struct_or_union_specifier);
static void flow_visit_member_declaration_list(struct flow_visit_ctx * ctx, struct member_declaration_list * p_member_declaration_list);
static void flow_visit_member_declaration(struct flow_visit_ctx * ctx, struct member_declaration * p_member_declaration);
static void flow_visit_member_declarator_list(struct flow_visit_ctx * ctx, struct member_declarator_list * p_member_declarator_list);
static void flow_visit_member_declarator(struct flow_visit_ctx * ctx, struct member_declarator * p_member_declarator);
static void flow_visit_enum_specifier(struct flow_visit_ctx * ctx, struct enum_specifier * p_enum_specifier);
static void flow_visit_enumerator_list(struct flow_visit_ctx * ctx, struct enumerator_list * p_enumerator_list);
static void flow_visit_enumerator(struct flow_visit_ctx * ctx, struct enumerator * p_enumerator);
static void flow_visit_bracket_initializer_list(struct flow_visit_ctx * ctx, struct braced_initializer * p_bracket_initializer_list);
static void flow_visit_initializer_list(struct flow_visit_ctx * ctx, struct initializer_list * p_initializer_list);
static void flow_visit_initializer_list_item(struct flow_visit_ctx * ctx, struct initializer_list_item * p_initializer);
static void flow_visit_initializer(struct flow_visit_ctx * ctx, struct initializer * p_initializer);
static void braced_initializer_flow(struct flow_visit_ctx * ctx, struct object * obj, struct flow_object * flow_obj);
static void braced_initializer_flow_core(struct flow_visit_ctx * ctx, struct object * obj, struct flow_object * flow_obj);
static void flow_check_pointer_used_as_bool(struct flow_visit_ctx * ctx, struct expression * p_expression);
static void flow_visit_selection_statement(struct flow_visit_ctx * ctx, struct selection_statement * p_selection_statement);
static void flow_visit_if_statement(struct flow_visit_ctx * ctx, struct selection_statement * p_selection_statement);
static void flow_visit_expression_statement(struct flow_visit_ctx * ctx, struct expression_statement * p_expression_statement);
static void flow_visit_simple_declaration(struct flow_visit_ctx * ctx, struct simple_declaration * p_simple_declaration);
static void flow_visit_switch_statement(struct flow_visit_ctx * ctx, struct selection_statement * p_selection_statement);
static void flow_visit_try_statement(struct flow_visit_ctx * ctx, struct try_statement * p_try_statement);
static void arena_set_state_from_current(struct flow_visit_ctx * ctx, int number_state);
static void flow_object_set_state_from_current(struct flow_object * object, int state_number);
static void flow_visit_jump_statement(struct flow_visit_ctx * ctx, struct jump_statement * p_jump_statement);
static void true_false_set_invert(struct true_false_set * true_false_set);
static void true_false_set_swap(struct true_false_set * a, struct true_false_set * b);
static void arena_broadcast_change(struct flow_visit_ctx * ctx, struct flow_object * p);
static void true_false_set_merge(struct true_false_set * result, struct true_false_set * a, struct true_false_set * b, int options_true, int options_false);
static int parse_string_state(char * s, unsigned char * invalid);
int __cdecl isalpha(int _C);
static void flow_visit_pragma_declaration(struct flow_visit_ctx * ctx, struct pragma_declaration * p_pragma_declaration);
static unsigned char flow_is_last_item_return(struct compound_statement * p_compound_statement);

void flow_visit_declaration(struct flow_visit_ctx * ctx, struct declaration * p_declaration)
{
    struct diagnostic_id_stack  stack;
    struct diagnostic_id_stack * p_diagnostic_id_stack;

    _cake_zmem(&stack, 44);
    p_diagnostic_id_stack = build_diagnostic_id_stack(ctx->ctx, p_declaration->p_attribute_specifier_sequence, &stack, 2);
    if (p_declaration->static_assert_declaration)
    {
        flow_visit_static_assert_declaration(ctx, p_declaration->static_assert_declaration);
    }
    if (p_declaration->pragma_declaration)
    {
        flow_visit_pragma_declaration(ctx, p_declaration->pragma_declaration);
    }
    if (p_declaration->declaration_specifiers)
    {
        if (p_declaration->init_declarator_list.head)
        {
            flow_visit_declaration_specifiers(ctx, p_declaration->declaration_specifiers, &p_declaration->init_declarator_list.head->p_declarator->type);
        }
        else
        {
            flow_visit_declaration_specifiers(ctx, p_declaration->declaration_specifiers, 0);
        }
    }
    if (p_declaration->init_declarator_list.head)
    {
        flow_visit_init_declarator_list(ctx, &p_declaration->init_declarator_list);
    }
    if (p_declaration->function_body)
    {
        struct type  type;

        ;
        type = get_function_return_type(&p_declaration->init_declarator_list.head->p_declarator->type);
        ctx->p_return_type = &type;
        flow_visit_compound_statement(ctx, p_declaration->function_body);
        type_destroy(&type);
        ctx->p_return_type = 0;
    }
    if (p_declaration->function_body && !flow_is_last_item_return(p_declaration->function_body))
    {
        flow_exit_block_visit_defer_list(ctx, &p_declaration->defer_list, p_declaration->function_body->last_token);
    }
    warn_unrecognized_warnings(ctx->ctx, &stack, p_declaration->p_attribute_specifier_sequence, p_diagnostic_id_stack);
}



static void true_false_set_clear(struct true_false_set * p)
{
    free(p->data);
    p->data = 0;
    p->size = 0;
    p->capacity = 0;
}

static int true_false_set_reserve(struct true_false_set * p, int n)
{
    if (n > p->capacity)
    {
        void * pnew;

        if ((unsigned int)n > 357913941)
        {
            return 132;
        }
        pnew = realloc(p->data, n * 12);
        if (pnew == 0)
        {
            return 12;
        }
        p->data = pnew;
        p->capacity = n;
    }
    return 0;
}

static int true_false_set_push_back(struct true_false_set * p, struct true_false_set_item * book)
{
    if (p->size == 2147483647)
    {
        return 132;
    }
    if (p->size + 1 > p->capacity)
    {
        int new_capacity;
        int error;

        new_capacity = 0;
        if (p->capacity > (2147483647 - p->capacity / 2))
        {
            new_capacity = 2147483647;
        }
        else
        {
            new_capacity = p->capacity + p->capacity / 2;
            if (new_capacity < p->size + 1)
            {
                new_capacity = p->size + 1;
            }
        }
        error = true_false_set_reserve(p, new_capacity);
        if (error != 0)
        {
            return error;
        }
    }
    p->data[p->size] = *book;
    p->size++;
    return 0;
}

static void check_uninitialized(struct flow_visit_ctx * ctx, struct expression * p_expression)
{
    unsigned char  nullable_enabled;
    struct flow_object * p_object;

    if (p_expression->is_assignment_expression)
    {
        return;
    }
    nullable_enabled = ctx->ctx->options.null_checks_enabled;
    if (type_is_function(&p_expression->type) || type_is_void(&p_expression->type) || type_is_nullptr_t(&p_expression->type))
    {
        return;
    }
    p_object = expression_get_flow_object(ctx, p_expression, nullable_enabled);
    if (!ctx->expression_is_not_evaluated)
    {
        if (p_object && p_object->current.state == 1)
        {
            if (p_expression->expression_type == 2 && p_expression->declarator && p_expression->declarator->name_opt)
            {
                compiler_diagnostic(30, ctx->ctx, p_expression->first_token, 0, "using a uninitialized object '%s'", p_expression->declarator->name_opt->lexeme);
            }
            else
            {
                compiler_diagnostic(30, ctx->ctx, p_expression->first_token, 0, "using a uninitialized object");
            }
        }
        else
        {
            if (p_object && p_object->current.state & 1)
            {
                if (ctx->ctx->options.ownership_enabled)
                {
                    if (p_expression->declarator && p_expression->declarator->name_opt)
                    {
                        compiler_diagnostic(30, ctx->ctx, p_expression->first_token, 0, "object '%s' can be uninitialized ", p_expression->declarator->name_opt->lexeme);
                    }
                    else
                    {
                        compiler_diagnostic(30, ctx->ctx, p_expression->first_token, 0, "maybe using a uninitialized object");
                    }
                }
            }
        }
    }
}

static void flow_visit_generic_selection(struct flow_visit_ctx * ctx, struct generic_selection * p_generic_selection)
{
    if (p_generic_selection->expression)
    {
        struct true_false_set  a;

        _cake_zmem(&a, 12);
        flow_visit_expression(ctx, p_generic_selection->expression, &a);
        true_false_set_destroy(&a);
    }
}

static void flow_compare_function_arguments(struct flow_visit_ctx * ctx, struct type * p_type, struct argument_expression_list * p_argument_expression_list)
{
    if (1) /*try*/
    {
        unsigned char  nullable_enabled;
        struct param_list * p_param_list;
        struct param * p_current_parameter_type;
        struct argument_expression * p_current_argument;

        nullable_enabled = ctx->ctx->options.null_checks_enabled;
        p_param_list = type_get_func_or_func_ptr_params(p_type);
        if (p_param_list == 0)
        {
            goto __L0; /* throw */
        }
        p_current_parameter_type = p_param_list->head;
        p_current_argument = p_argument_expression_list->head;
        while (p_current_argument && p_current_parameter_type)
        {
            struct true_false_set  a;
            struct diagnostic  temp;
            struct flow_object * p_argument_object;

            _cake_zmem(&a, 12);
            temp = ctx->ctx->options.diagnostic_stack.stack[ctx->ctx->options.diagnostic_stack.top_index];
            diagnostic_remove(&ctx->ctx->options.diagnostic_stack.stack[ctx->ctx->options.diagnostic_stack.top_index], 30);
            flow_visit_expression(ctx, p_current_argument->expression, &a);
            ctx->ctx->options.diagnostic_stack.stack[ctx->ctx->options.diagnostic_stack.top_index] = temp;
            true_false_set_destroy(&a);
            p_argument_object = expression_get_flow_object(ctx, p_current_argument->expression, nullable_enabled);
            if (p_argument_object)
            {
                struct flow_object * parameter_object;
                struct marker  a_marker;
                struct marker  b_marker;

                parameter_object = make_flow_object(ctx, &p_current_parameter_type->type, 0, p_current_argument->expression);
                if (parameter_object == 0)
                {
                    goto __L0; /* throw */
                }
                flow_object_set_uninitialized(&p_current_parameter_type->type, parameter_object);
                a_marker.file = 0;
                a_marker.line = 0;
                a_marker.start_col = 0;
                a_marker.end_col = 0;
                a_marker.p_token_caret = 0;
                a_marker.p_token_begin = p_current_argument->expression->first_token;
                a_marker.p_token_end = p_current_argument->expression->last_token;
                b_marker.file = 0;
                b_marker.line = 0;
                b_marker.start_col = 0;
                b_marker.end_col = 0;
                b_marker.p_token_caret = 0;
                b_marker.p_token_begin = p_current_argument->expression->first_token;
                b_marker.p_token_end = p_current_argument->expression->last_token;
                flow_check_assignment(ctx, p_current_argument->expression->first_token, &a_marker, &b_marker, 1, 1, type_is_view(&p_current_parameter_type->type), type_is_opt(&p_current_parameter_type->type, ctx->ctx->options.null_checks_enabled), &p_current_parameter_type->type, parameter_object, &p_current_argument->expression->type, p_argument_object, &p_current_argument->set_unkown);
            }
            p_current_argument = p_current_argument->next;
            p_current_parameter_type = p_current_parameter_type->next;
        }
        while (p_current_argument)
        {
            struct flow_object * p_argument_object;

            p_argument_object = expression_get_flow_object(ctx, p_current_argument->expression, nullable_enabled);
            if (p_argument_object)
            {
                struct marker  marker;

                marker.file = 0;
                marker.line = 0;
                marker.start_col = 0;
                marker.end_col = 0;
                marker.p_token_caret = 0;
                marker.p_token_begin = p_current_argument->expression->first_token;
                marker.p_token_end = p_current_argument->expression->last_token;
                checked_read_object(ctx, &p_current_argument->expression->type, type_is_opt(&p_current_argument->expression->type, ctx->ctx->options.null_checks_enabled), p_argument_object, p_current_argument->expression->first_token, &marker, 0);
            }
            else
            {
            }
            p_current_argument = p_current_argument->next;
        }
        p_current_parameter_type = p_param_list->head;
        p_current_argument = p_argument_expression_list->head;
        while (p_current_argument && p_current_parameter_type)
        {
            if (p_current_argument->set_unkown && type_is_pointer(&p_current_argument->expression->type))
            {
                struct type  pointed_type;
                struct flow_object * p_argument_object;

                pointed_type = type_remove_pointer(&p_current_argument->expression->type);
                p_argument_object = expression_get_flow_object(ctx, p_current_argument->expression, nullable_enabled);
                if (p_argument_object)
                {
                    unsigned char  argument_type_is_nullable;

                    argument_type_is_nullable = type_is_opt(&pointed_type, ctx->ctx->options.null_checks_enabled);
                    if (p_argument_object->current.pointed)
                    {
                        flow_object_set_unknown(&pointed_type, argument_type_is_nullable, p_argument_object->current.pointed, ctx->ctx->options.null_checks_enabled);
                    }
                    else
                    {
                    }
                }
                type_destroy(&pointed_type);
            }
            p_current_argument = p_current_argument->next;
            p_current_parameter_type = p_current_parameter_type->next;
        }
        while (p_current_argument)
        {
            struct flow_object * p_argument_object;

            p_argument_object = expression_get_flow_object(ctx, p_current_argument->expression, nullable_enabled);
            if (p_argument_object)
            {
            }
            else
            {
            }
            p_current_argument = p_current_argument->next;
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void flow_clear_alias(struct expression * p_expression)
{
    struct argument_expression * p;

    if (p_expression->declarator)
    {
        p_expression->declarator->p_alias_of_expression = 0;
    }
    p = p_expression->argument_expression_list.head;
    while (p)
    {
        flow_clear_alias(p->expression);
        p = p->next;
    }
    if (p_expression->left)
    {
        flow_clear_alias(p_expression->left);
    }
    if (p_expression->right)
    {
        flow_clear_alias(p_expression->right);
    }
}

static struct argument_expression *param_list_find_argument_by_name(struct param_list * p_param_list, struct argument_expression_list * list, char * name)
{
    struct param * p_param;
    struct argument_expression * p_argument_expression;

    p_param = p_param_list->head;
    p_argument_expression = list->head;
    while (p_param && p_argument_expression)
    {
        if (p_param->type.name_opt && strcmp(p_param->type.name_opt, name) == 0)
        {
            return p_argument_expression;
        }
        p_argument_expression = p_argument_expression->next;
        p_param = p_param->next;
    }
    return 0;
}

static void flow_expression_bind(struct flow_visit_ctx * ctx, struct expression * p_expression, struct param_list * p_param_list, struct argument_expression_list * p_argument_expression_list)
{
    struct argument_expression * p;

    if (p_expression->expression_type == 2)
    {
        struct argument_expression * p_argument_expression;

        ;
        ;
        p_argument_expression = param_list_find_argument_by_name(p_param_list, p_argument_expression_list, p_expression->declarator->name_opt->lexeme);
        if (p_argument_expression)
        {
            if (p_argument_expression->expression->declarator && p_argument_expression->expression->declarator->p_alias_of_expression)
            {
                p_expression->declarator->p_alias_of_expression = p_argument_expression->expression->declarator->p_alias_of_expression;
            }
            else
            {
                p_expression->declarator->p_alias_of_expression = p_argument_expression->expression;
            }
            return;
        }
    }
    p = p_expression->argument_expression_list.head;
    while (p)
    {
        flow_expression_bind(ctx, p->expression, p_param_list, p_argument_expression_list);
        p = p->next;
    }
    if (p_expression->left)
    {
        flow_expression_bind(ctx, p_expression->left, p_param_list, p_argument_expression_list);
    }
    if (p_expression->right)
    {
        flow_expression_bind(ctx, p_expression->right, p_param_list, p_argument_expression_list);
    }
}

static void true_false_set_set_objects_to_core_branch(struct flow_visit_ctx * ctx, struct true_false_set * a, unsigned char  nullable_enabled, unsigned char  true_branch)
{
    {
        int i;

        i = 0;
        for (; i < a->size; i++)
        {
            struct flow_object * p_object;

            ;
            p_object = expression_get_flow_object(ctx, a->data[i].p_expression, nullable_enabled);
            if (p_object)
            {
                int flag;

                if (p_object->current.state == 4 || p_object->current.state == 2 || p_object->current.state == 8 || p_object->current.state == 32 || p_object->current.state == 64 || p_object->current.state == 128)
                {
                    continue;
                }
                flag = true_branch ? a->data[i].true_branch_state : a->data[i].false_branch_state;
                if ((flag & 1) && (flag & 2))
                {
                }
                else
                {
                    if (flag & 2)
                    {
                        p_object->current.state &= -5;
                        p_object->current.state &= -9;
                    }
                    else
                    {
                        if (flag & 1)
                        {
                            p_object->current.state &= -3;
                            p_object->current.state &= -33;
                        }
                    }
                }
            }
        }
    }
}

static void true_false_set_set_objects_to_true_branch(struct flow_visit_ctx * ctx, struct true_false_set * a, unsigned char  nullable_enabled)
{
    true_false_set_set_objects_to_core_branch(ctx, a, nullable_enabled, 1);
}

static int find_item_index_by_expression(struct true_false_set * a, struct expression * p_expression)
{
    {
        int i;

        i = 0;
        for (; i < a->size; i++)
        {
            if (a->data[i].p_expression == p_expression)
            {
                return i;
            }
        }
    }
    return -1;
}

static void flow_visit_defer_statement(struct flow_visit_ctx * ctx, struct defer_statement * p_defer_statement)
{
}

static int arena_add_copy_of_current_state(struct flow_visit_ctx * ctx, char * name)
{
    int state_number;

    state_number = ctx->state_number_generator;
    ctx->state_number_generator++;
    {
        int i;

        i = 0;
        for (; i < ctx->arena.size; i++)
        {
            flow_object_add_new_state_as_a_copy_of_current_state(ctx->arena.data[i], name, state_number);
        }
    }
    return state_number;
}

static int arena_add_empty_state(struct flow_visit_ctx * ctx, char * name)
{
    int state_number;

    state_number = ctx->state_number_generator;
    ctx->state_number_generator++;
    {
        int i;

        i = 0;
        for (; i < ctx->arena.size; i++)
        {
            struct flow_object * p_object;
            struct flow_object_state * p_flow_object_state;

            p_object = ctx->arena.data[i];
            p_flow_object_state = calloc(1, 32);
            if (p_flow_object_state)
            {
                p_flow_object_state->dbg_name = name;
                p_flow_object_state->state_number = state_number;
                flow_object_add_state(p_object, p_flow_object_state);
            }
        }
    }
    return state_number;
}

static void object_restore_current_state_from(struct flow_visit_ctx * ctx, struct flow_object * object, int state_number)
{
    struct flow_object_state * it;

    it = object->current.next;
    while (it)
    {
        if (it->state_number == state_number)
        {
            flow_object_state_copy(&object->current, it);
            break;
        }
        it = it->next;
    }
}

static void arena_restore_current_state_from(struct flow_visit_ctx * ctx, int number_state)
{
    {
        int i;

        i = 0;
        for (; i < ctx->arena.size; i++)
        {
            object_restore_current_state_from(ctx, ctx->arena.data[i], number_state);
        }
    }
}

static void flow_visit_label(struct flow_visit_ctx * ctx, struct label * p_label)
{
    struct diagnostic_id_stack  stack;
    struct diagnostic_id_stack * p_diagnostic_id_stack;

    _cake_zmem(&stack, 44);
    p_diagnostic_id_stack = build_diagnostic_id_stack(ctx->ctx, p_label->p_attribute_specifier_sequence, &stack, 2);
    if (p_label->p_identifier_opt)
    {
        {
            int i;

            i = 0;
            for (; i < ctx->labels_size; i++)
            {
                if (strcmp(ctx->labels[i].label_name, p_label->p_identifier_opt->lexeme) == 0)
                {
                    arena_restore_current_state_from(ctx, ctx->labels[i].state_number);
                    break;
                }
            }
        }
    }
    else
    {
        arena_restore_current_state_from(ctx, ctx->initial_state);
    }
    warn_unrecognized_warnings(ctx->ctx, &stack, p_label->p_attribute_specifier_sequence, p_diagnostic_id_stack);
}

static void flow_visit_labeled_statement(struct flow_visit_ctx * ctx, struct labeled_statement * p_labeled_statement)
{
    flow_visit_label(ctx, p_labeled_statement->label);
    flow_visit_statement(ctx, p_labeled_statement->statement);
}

static void flow_visit_statement(struct flow_visit_ctx * ctx, struct statement * p_statement)
{
    if (p_statement->labeled_statement)
    {
        flow_visit_labeled_statement(ctx, p_statement->labeled_statement);
    }
    else
    {
        if (p_statement->unlabeled_statement)
        {
            flow_visit_unlabeled_statement(ctx, p_statement->unlabeled_statement);
        }
    }
}

static void flow_visit_secondary_block(struct flow_visit_ctx * ctx, struct secondary_block * p_secondary_block)
{
    flow_visit_statement(ctx, p_secondary_block->statement);
}

static void flow_exit_block_visit_defer_item(struct flow_visit_ctx * ctx, struct defer_list_item * p_item, struct token * position_token)
{
    if (p_item->defer_statement)
    {
        int error_count;
        int warnings_count;
        int info_count;

        error_count = ctx->ctx->p_report->error_count;
        warnings_count = ctx->ctx->p_report->warnings_count;
        info_count = ctx->ctx->p_report->info_count;
        flow_visit_secondary_block(ctx, p_item->defer_statement->secondary_block);
        if (error_count != ctx->ctx->p_report->error_count || warnings_count != ctx->ctx->p_report->warnings_count || info_count != ctx->ctx->p_report->info_count)
        {
            compiler_diagnostic(0, ctx->ctx, position_token, 0, "defer end of scope");
        }
    }
    else
    {
        if (p_item->declarator)
        {
            struct declarator * p_declarator;
            char * name;

            p_declarator = p_item->declarator;
            name = p_declarator->name_opt ? p_declarator->name_opt->lexeme : "?";
            if (p_declarator->p_flow_object)
            {
                flow_end_of_block_visit(ctx, &p_declarator->type, type_is_view(&p_declarator->type), p_declarator->p_flow_object, position_token, name);
            }
            else
            {
                ;
            }
        }
    }
}

static void flow_exit_block_visit_defer_list(struct flow_visit_ctx * ctx, struct defer_list * p_defer_list, struct token * position_token)
{
    struct defer_list_item * p_item;

    p_item = p_defer_list->head;
    while (p_item)
    {
        flow_exit_block_visit_defer_item(ctx, p_item, position_token);
        p_item = p_item->next;
    }
}

static void true_false_set_set_objects_to_false_branch(struct flow_visit_ctx * ctx, struct true_false_set * a, unsigned char  nullable_enabled)
{
    true_false_set_set_objects_to_core_branch(ctx, a, nullable_enabled, 0);
}

static int flow_object_merge_current_with_state(struct flow_visit_ctx * ctx, struct flow_object * object, int state_number)
{
    if (1) /*try*/
    {
        struct flow_object_state * it;

        it = object->current.next;
        while (it)
        {
            if (it->state_number == state_number)
            {
                it->state |= object->current.state;
                if (object->current.pointed == 0 && it->pointed == 0)
                {
                }
                else
                {
                    if (object->current.pointed == 0 && it->pointed != 0)
                    {
                    }
                    else
                    {
                        if (object->current.pointed != 0 && it->pointed == 0)
                        {
                            it->pointed = object->current.pointed;
                        }
                        else
                        {
                            if (object->current.pointed != it->pointed)
                            {
                                struct flow_object * p_new_object;
                                struct flow_object_state * p_new_state;
                                int n_childs_1;
                                int n_childs_2;

                                ;
                                ;
                                p_new_object = arena_new_object(ctx);
                                if (p_new_object == 0)
                                {
                                    goto __L0; /* throw */
                                }
                                p_new_state = calloc(1, 32);
                                if (p_new_state == 0)
                                {
                                    goto __L0; /* throw */
                                }
                                p_new_state->dbg_name = "merged";
                                p_new_state->state_number = state_number;
                                objects_view_push_back(&p_new_state->alternatives, object->current.pointed);
                                objects_view_push_back(&p_new_state->alternatives, it->pointed);
                                flow_object_add_state(p_new_object, p_new_state);
                                n_childs_1 = object->current.pointed->members.size;
                                n_childs_2 = it->pointed->members.size;
                                if (n_childs_1 == n_childs_2)
                                {
                                    {
                                        int j;

                                        j = 0;
                                        for (; j < n_childs_1; j++)
                                        {
                                            struct flow_object * p_new_child;
                                            struct flow_object * child1;
                                            struct flow_object * child2;
                                            struct flow_object_state * p_child_new_state;

                                            p_new_child = arena_new_object(ctx);
                                            if (p_new_child == 0)
                                            {
                                                goto __L0; /* throw */
                                            }
                                            p_new_child->parent = p_new_object;
                                            child1 = object->current.pointed->members.data[j];
                                            child2 = it->pointed->members.data[j];
                                            p_child_new_state = calloc(1, 32);
                                            if (p_child_new_state == 0)
                                            {
                                                goto __L0; /* throw */
                                            }
                                            p_child_new_state->dbg_name = "merged";
                                            p_child_new_state->state_number = state_number;
                                            p_child_new_state->state = child1->current.state | it->state;
                                            objects_view_push_back(&p_child_new_state->alternatives, child1);
                                            objects_view_push_back(&p_child_new_state->alternatives, child2);
                                            flow_object_add_state(p_new_child, p_child_new_state);
                                            objects_view_push_back(&p_new_object->members, p_new_child);
                                        }
                                    }
                                }
                                else
                                {
                                }
                                it->pointed = p_new_object;
                            }
                        }
                    }
                }
                break;
            }
            it = it->next;
        }
    }
    else __L0: /*catch*/ 
    {
    }
    return 0;
}

static void arena_merge_current_state_with_state_number(struct flow_visit_ctx * ctx, int number_state)
{
    {
        int i;

        i = 0;
        for (; i < ctx->arena.size; i++)
        {
            flow_object_merge_current_with_state(ctx, ctx->arena.data[i], number_state);
        }
    }
}

static void flow_defer_item_set_end_of_lifetime(struct flow_visit_ctx * ctx, struct defer_list_item * p_item, struct token * position_token)
{
    if (p_item->defer_statement)
    {
    }
    else
    {
        if (p_item->declarator)
        {
            struct declarator * p_declarator;

            p_declarator = p_item->declarator;
            if (p_declarator->p_flow_object)
            {
                flow_object_set_end_of_lifetime(&p_declarator->type, p_declarator->p_flow_object);
            }
            else
            {
                ;
            }
        }
    }
}

static void flow_defer_list_set_end_of_lifetime(struct flow_visit_ctx * ctx, struct defer_list * p_defer_list, struct token * position_token)
{
    struct defer_list_item * p_item;

    p_item = p_defer_list->head;
    while (p_item)
    {
        flow_defer_item_set_end_of_lifetime(ctx, p_item, position_token);
        p_item = p_item->next;
    }
}

static void arena_remove_state(struct flow_visit_ctx * ctx, int state_number)
{
    {
        int i;

        i = 0;
        for (; i < ctx->arena.size; i++)
        {
            flow_object_remove_state(ctx->arena.data[i], state_number);
        }
    }
}

static void flow_visit_while_statement(struct flow_visit_ctx * ctx, struct iteration_statement * p_iteration_statement)
{
    unsigned char  nullable_enabled;
    int old_initial_state;
    int old_break_join_state;
    struct true_false_set  true_false_set;
    struct true_false_set  true_false_set2;
    unsigned char  was_last_statement_inside_true_branch_return;

    ;
    if (p_iteration_statement->expression1 == 0)
    {
        return;
    }
    nullable_enabled = ctx->ctx->options.null_checks_enabled;
    old_initial_state = ctx->initial_state;
    old_break_join_state = ctx->break_join_state;
    ctx->initial_state = arena_add_copy_of_current_state(ctx, "original");
    ctx->break_join_state = arena_add_empty_state(ctx, "break join");
    _cake_zmem(&true_false_set, 12);
    diagnostic_stack_push_empty(&ctx->ctx->options.diagnostic_stack);
    flow_visit_expression(ctx, p_iteration_statement->expression1, &true_false_set);
    true_false_set_set_objects_to_true_branch(ctx, &true_false_set, nullable_enabled);
    flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
    diagnostic_stack_pop(&ctx->ctx->options.diagnostic_stack);
    _cake_zmem(&true_false_set2, 12);
    flow_visit_expression(ctx, p_iteration_statement->expression1, &true_false_set2);
    true_false_set_destroy(&true_false_set2);
    true_false_set_set_objects_to_true_branch(ctx, &true_false_set, nullable_enabled);
    flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
    flow_exit_block_visit_defer_list(ctx, &p_iteration_statement->defer_list, p_iteration_statement->secondary_block->last_token);
    was_last_statement_inside_true_branch_return = secondary_block_ends_with_jump(p_iteration_statement->secondary_block);
    if (was_last_statement_inside_true_branch_return)
    {
        arena_restore_current_state_from(ctx, ctx->initial_state);
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
    }
    else
    {
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
        arena_merge_current_state_with_state_number(ctx, ctx->break_join_state);
        arena_restore_current_state_from(ctx, ctx->break_join_state);
    }
    flow_defer_list_set_end_of_lifetime(ctx, &p_iteration_statement->defer_list, p_iteration_statement->secondary_block->last_token);
    arena_remove_state(ctx, ctx->initial_state);
    arena_remove_state(ctx, ctx->break_join_state);
    ctx->initial_state = old_initial_state;
    ctx->break_join_state = old_break_join_state;
    true_false_set_destroy(&true_false_set);
}

static void flow_visit_do_while_statement(struct flow_visit_ctx * ctx, struct iteration_statement * p_iteration_statement)
{
    unsigned char  nullable_enabled;
    struct true_false_set  true_false_set;
    unsigned char  was_last_statement_inside_true_branch_return;

    ;
    nullable_enabled = ctx->ctx->options.null_checks_enabled;
    _cake_zmem(&true_false_set, 12);
    if (p_iteration_statement->expression1)
    {
        flow_visit_expression(ctx, p_iteration_statement->expression1, &true_false_set);
    }
    flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
    flow_exit_block_visit_defer_list(ctx, &p_iteration_statement->defer_list, p_iteration_statement->secondary_block->last_token);
    flow_defer_list_set_end_of_lifetime(ctx, &p_iteration_statement->defer_list, p_iteration_statement->secondary_block->last_token);
    was_last_statement_inside_true_branch_return = secondary_block_ends_with_jump(p_iteration_statement->secondary_block);
    if (was_last_statement_inside_true_branch_return)
    {
    }
    else
    {
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
    }
    true_false_set_destroy(&true_false_set);
}

static void flow_visit_member_declarator(struct flow_visit_ctx * ctx, struct member_declarator * p_member_declarator)
{
    if (p_member_declarator->declarator)
    {
        flow_visit_declarator(ctx, p_member_declarator->declarator);
    }
}

static void flow_visit_member_declarator_list(struct flow_visit_ctx * ctx, struct member_declarator_list * p_member_declarator_list)
{
    struct member_declarator * p_member_declarator;

    p_member_declarator = p_member_declarator_list->head;
    while (p_member_declarator)
    {
        flow_visit_member_declarator(ctx, p_member_declarator);
        p_member_declarator = p_member_declarator->next;
    }
}

static void flow_visit_member_declaration(struct flow_visit_ctx * ctx, struct member_declaration * p_member_declaration)
{
    if (p_member_declaration->member_declarator_list_opt)
    {
        flow_visit_member_declarator_list(ctx, p_member_declaration->member_declarator_list_opt);
    }
}

static void flow_visit_member_declaration_list(struct flow_visit_ctx * ctx, struct member_declaration_list * p_member_declaration_list)
{
    struct member_declaration * p_member_declaration;

    p_member_declaration = p_member_declaration_list->head;
    while (p_member_declaration)
    {
        flow_visit_member_declaration(ctx, p_member_declaration);
        p_member_declaration = p_member_declaration->next;
    }
}

static void flow_visit_struct_or_union_specifier(struct flow_visit_ctx * ctx, struct struct_or_union_specifier * p_struct_or_union_specifier)
{
    flow_visit_member_declaration_list(ctx, &p_struct_or_union_specifier->member_declaration_list);
}

static void flow_visit_enumerator(struct flow_visit_ctx * ctx, struct enumerator * p_enumerator)
{
    struct true_false_set  a;

    _cake_zmem(&a, 12);
    if (p_enumerator->constant_expression_opt)
    {
        flow_visit_expression(ctx, p_enumerator->constant_expression_opt, &a);
    }
    true_false_set_destroy(&a);
}

static void flow_visit_enumerator_list(struct flow_visit_ctx * ctx, struct enumerator_list * p_enumerator_list)
{
    struct enumerator * current;

    current = p_enumerator_list->head;
    while (current)
    {
        flow_visit_enumerator(ctx, current);
        current = current->next;
    }
}

static void flow_visit_enum_specifier(struct flow_visit_ctx * ctx, struct enum_specifier * p_enum_specifier)
{
    flow_visit_enumerator_list(ctx, &p_enum_specifier->enumerator_list);
}

static void flow_visit_type_specifier(struct flow_visit_ctx * ctx, struct type_specifier * p_type_specifier)
{
    if (p_type_specifier->struct_or_union_specifier)
    {
        flow_visit_struct_or_union_specifier(ctx, p_type_specifier->struct_or_union_specifier);
    }
    if (p_type_specifier->enum_specifier)
    {
        flow_visit_enum_specifier(ctx, p_type_specifier->enum_specifier);
    }
}

static void flow_visit_type_specifier_qualifier(struct flow_visit_ctx * ctx, struct type_specifier_qualifier * p_type_specifier_qualifier)
{
    if (p_type_specifier_qualifier->type_specifier)
    {
        flow_visit_type_specifier(ctx, p_type_specifier_qualifier->type_specifier);
    }
}

static void flow_visit_declaration_specifier(struct flow_visit_ctx * ctx, struct declaration_specifier * p_declaration_specifier)
{
    if (p_declaration_specifier->type_specifier_qualifier)
    {
        flow_visit_type_specifier_qualifier(ctx, p_declaration_specifier->type_specifier_qualifier);
    }
}

static void flow_visit_declaration_specifiers(struct flow_visit_ctx * ctx, struct declaration_specifiers * p_declaration_specifiers, struct type * p_type_opt)
{
    struct declaration_specifier * p_declaration_specifier;

    p_declaration_specifier = p_declaration_specifiers->head;
    while (p_declaration_specifier)
    {
        flow_visit_declaration_specifier(ctx, p_declaration_specifier);
        p_declaration_specifier = p_declaration_specifier->next;
    }
}

static void flow_visit_direct_declarator(struct flow_visit_ctx * ctx, struct direct_declarator * p_direct_declarator)
{
    if (p_direct_declarator->function_declarator)
    {
        struct parameter_declaration * parameter;

        parameter = 0;
        if (p_direct_declarator->function_declarator->parameter_type_list_opt && p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list)
        {
            parameter = p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head;
        }
        ctx->parameter_list++;
        while (parameter)
        {
            flow_visit_declaration_specifiers(ctx, parameter->declaration_specifiers, &parameter->declarator->type);
            if (parameter->declarator)
            {
                flow_visit_declarator(ctx, parameter->declarator);
            }
            parameter = parameter->next;
        }
        ctx->parameter_list--;
    }
    else
    {
        if (p_direct_declarator->array_declarator)
        {
            if (p_direct_declarator->array_declarator->assignment_expression)
            {
                struct true_false_set  a;

                _cake_zmem(&a, 12);
                flow_visit_expression(ctx, p_direct_declarator->array_declarator->assignment_expression, &a);
                true_false_set_destroy(&a);
            }
        }
    }
}

static void flow_visit_declarator(struct flow_visit_ctx * ctx, struct declarator * p_declarator)
{
    unsigned char  nullable_enabled;

    nullable_enabled = ctx->ctx->options.null_checks_enabled;
    if (1) /*try*/
    {
        if (p_declarator->type.category != 1)
        {
            if (ctx->parameter_list > 1)
            {
                return;
            }
            p_declarator->p_flow_object = make_flow_object(ctx, &p_declarator->type, p_declarator, 0);
            if (p_declarator->p_flow_object == 0)
            {
                goto __L0; /* throw */
            }
            flow_object_set_uninitialized(&p_declarator->type, p_declarator->p_flow_object);
            if (p_declarator->declaration_specifiers && p_declarator->declaration_specifiers->storage_class_specifier_flags & 2048)
            {
                if (type_is_pointer(&p_declarator->type))
                {
                    if (type_is_opt(&p_declarator->type, ctx->ctx->options.null_checks_enabled))
                    {
                        p_declarator->p_flow_object->current.state = 6;
                    }
                    else
                    {
                        p_declarator->p_flow_object->current.state = 4;
                    }
                    if (type_is_pointer_to_out(&p_declarator->type))
                    {
                        struct type  t;
                        struct flow_object * po;

                        t = type_remove_pointer(&p_declarator->type);
                        po = make_flow_object(ctx, &t, p_declarator, 0);
                        if (po == 0)
                        {
                            type_destroy(&t);
                            goto __L0; /* throw */
                        }
                        flow_object_set_uninitialized(&t, po);
                        object_set_pointer(p_declarator->p_flow_object, po);
                        type_destroy(&t);
                    }
                    else
                    {
                        if (type_is_owner_or_pointer_to_dtor(&p_declarator->type))
                        {
                            struct type  t;
                            struct flow_object * po;
                            unsigned char  t_is_nullable;

                            t = type_remove_pointer(&p_declarator->type);
                            po = make_flow_object(ctx, &t, p_declarator, 0);
                            if (po == 0)
                            {
                                type_destroy(&t);
                                goto __L0; /* throw */
                            }
                            t_is_nullable = type_is_opt(&t, ctx->ctx->options.null_checks_enabled);
                            flow_object_set_unknown(&t, t_is_nullable, po, nullable_enabled);
                            object_set_pointer(p_declarator->p_flow_object, po);
                            type_destroy(&t);
                        }
                    }
                }
                else
                {
                    if (type_is_struct_or_union(&p_declarator->type))
                    {
                        unsigned char  is_nullable;

                        is_nullable = type_is_opt(&p_declarator->type, nullable_enabled);
                        flow_object_set_unknown(&p_declarator->type, is_nullable, p_declarator->p_flow_object, nullable_enabled);
                    }
                    else
                    {
                        if (type_is_array(&p_declarator->type))
                        {
                            p_declarator->p_flow_object->current.state = 64;
                        }
                        else
                        {
                            p_declarator->p_flow_object->current.state = 96;
                        }
                    }
                }
            }
        }
        if (p_declarator->direct_declarator)
        {
            flow_visit_direct_declarator(ctx, p_declarator->direct_declarator);
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void flow_visit_initializer(struct flow_visit_ctx * ctx, struct initializer * p_initializer)
{
    if (p_initializer->assignment_expression)
    {
        struct true_false_set  a;

        _cake_zmem(&a, 12);
        flow_visit_expression(ctx, p_initializer->assignment_expression, &a);
        true_false_set_destroy(&a);
    }
    else
    {
        if (p_initializer->braced_initializer)
        {
            flow_visit_bracket_initializer_list(ctx, p_initializer->braced_initializer);
        }
    }
}

static void flow_visit_initializer_list_item(struct flow_visit_ctx * ctx, struct initializer_list_item * p_initializer)
{
    ;
    flow_visit_initializer(ctx, p_initializer->initializer);
}

static void flow_visit_initializer_list(struct flow_visit_ctx * ctx, struct initializer_list * p_initializer_list)
{
    struct initializer_list_item * p_initializer;

    p_initializer = p_initializer_list->head;
    while (p_initializer)
    {
        flow_visit_initializer_list_item(ctx, p_initializer);
        p_initializer = p_initializer->next;
    }
}

static void flow_visit_bracket_initializer_list(struct flow_visit_ctx * ctx, struct braced_initializer * p_bracket_initializer_list)
{
    if (p_bracket_initializer_list->initializer_list == 0)
    {
    }
    else
    {
        flow_visit_initializer_list(ctx, p_bracket_initializer_list->initializer_list);
    }
}

static void braced_initializer_flow_core(struct flow_visit_ctx * ctx, struct object * obj, struct flow_object * flow_obj)
{
    unsigned char  nullable_enabled;

    nullable_enabled = ctx->ctx->options.null_checks_enabled;
    if (obj->p_init_expression)
    {
        struct flow_object * p_right_object;

        p_right_object = expression_get_flow_object(ctx, obj->p_init_expression, nullable_enabled);
        if (p_right_object)
        {
            struct marker  a_marker;
            struct marker  b_marker;

            _cake_zmem(&a_marker, 28);
            b_marker.file = 0;
            b_marker.line = 0;
            b_marker.start_col = 0;
            b_marker.end_col = 0;
            b_marker.p_token_caret = 0;
            b_marker.p_token_begin = obj->p_init_expression->first_token;
            b_marker.p_token_end = obj->p_init_expression->last_token;
            flow_check_assignment(ctx, obj->p_init_expression->first_token, &a_marker, &b_marker, 2, 0, type_is_view(&obj->type), type_is_opt(&obj->type, ctx->ctx->options.null_checks_enabled), &obj->type, flow_obj, &obj->p_init_expression->type, p_right_object, 0);
        }
    }
    else
    {
        flow_object_set_zero(&obj->type, flow_obj);
    }
    if (flow_obj->members.size > 0)
    {
        int i;
        struct object * m;

        i = 0;
        m = obj->members.head;
        while (m)
        {
            braced_initializer_flow_core(ctx, m, flow_obj->members.data[i]);
            m = m->next;
            i++;
        }
    }
}

static void braced_initializer_flow(struct flow_visit_ctx * ctx, struct object * obj, struct flow_object * flow_obj)
{
    if (1) /*try*/
    {
        braced_initializer_flow_core(ctx, obj, flow_obj);
        if (flow_obj->p_declarator_origin == 0)
        {
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void flow_visit_init_declarator(struct flow_visit_ctx * ctx, struct init_declarator * p_init_declarator)
{
    unsigned char  nullable_enabled;

    nullable_enabled = ctx->ctx->options.null_checks_enabled;
    if (1) /*try*/
    {
        flow_visit_declarator(ctx, p_init_declarator->p_declarator);
        if (p_init_declarator->initializer)
        {
            if (p_init_declarator->initializer->assignment_expression)
            {
                struct true_false_set  a;

                _cake_zmem(&a, 12);
                flow_visit_expression(ctx, p_init_declarator->initializer->assignment_expression, &a);
                true_false_set_destroy(&a);
            }
            else
            {
                if (p_init_declarator->initializer->braced_initializer)
                {
                    flow_visit_bracket_initializer_list(ctx, p_init_declarator->initializer->braced_initializer);
                }
                else
                {
                    ;
                }
            }
        }
        if (p_init_declarator->p_declarator->type.category != 1)
        {
            if (p_init_declarator->initializer && p_init_declarator->initializer->assignment_expression)
            {
                struct flow_object * p_right_object;

                p_right_object = expression_get_flow_object(ctx, p_init_declarator->initializer->assignment_expression, nullable_enabled);
                if (p_right_object)
                {
                    struct marker  a_marker;
                    struct marker  b_marker;

                    a_marker.file = 0;
                    a_marker.line = 0;
                    a_marker.start_col = 0;
                    a_marker.end_col = 0;
                    a_marker.p_token_caret = 0;
                    a_marker.p_token_begin = p_init_declarator->p_declarator->first_token_opt;
                    a_marker.p_token_end = p_init_declarator->p_declarator->last_token_opt;
                    b_marker.file = 0;
                    b_marker.line = 0;
                    b_marker.start_col = 0;
                    b_marker.end_col = 0;
                    b_marker.p_token_caret = 0;
                    b_marker.p_token_begin = p_init_declarator->initializer->assignment_expression->first_token;
                    b_marker.p_token_end = p_init_declarator->initializer->assignment_expression->last_token;
                    ;
                    flow_check_assignment(ctx, p_init_declarator->initializer->assignment_expression->first_token, &a_marker, &b_marker, 2, 0, type_is_view(&p_init_declarator->p_declarator->type), type_is_opt(&p_init_declarator->p_declarator->type, ctx->ctx->options.null_checks_enabled), &p_init_declarator->p_declarator->type, p_init_declarator->p_declarator->p_flow_object, &p_init_declarator->initializer->assignment_expression->type, p_right_object, 0);
                }
                if (expression_is_malloc(p_init_declarator->initializer->assignment_expression))
                {
                    struct type  t;
                    struct flow_object * po;

                    ;
                    t = type_remove_pointer(&p_init_declarator->p_declarator->type);
                    po = make_flow_object(ctx, &t, p_init_declarator->p_declarator, 0);
                    if (po == 0)
                    {
                        type_destroy(&t);
                        goto __L0; /* throw */
                    }
                    object_set_pointer(p_init_declarator->p_declarator->p_flow_object, po);
                    type_destroy(&t);
                    p_init_declarator->p_declarator->p_flow_object->current.state = 6;
                }
                else
                {
                    if (expression_is_calloc(p_init_declarator->initializer->assignment_expression))
                    {
                        struct type  t;
                        struct flow_object * pointed_calloc_object;

                        ;
                        t = type_remove_pointer(&p_init_declarator->p_declarator->type);
                        pointed_calloc_object = make_flow_object(ctx, &t, p_init_declarator->p_declarator, 0);
                        if (pointed_calloc_object == 0)
                        {
                            type_destroy(&t);
                            goto __L0; /* throw */
                        }
                        flow_object_set_zero(&t, pointed_calloc_object);
                        object_set_pointer(p_init_declarator->p_declarator->p_flow_object, pointed_calloc_object);
                        type_destroy(&t);
                        p_init_declarator->p_declarator->p_flow_object->current.state = 6;
                    }
                }
            }
            else
            {
                if (p_init_declarator->initializer && p_init_declarator->initializer->braced_initializer)
                {
                    ;
                    braced_initializer_flow(ctx, &p_init_declarator->p_declarator->object, p_init_declarator->p_declarator->p_flow_object);
                }
                else
                {
                    if (p_init_declarator->p_declarator->declaration_specifiers && ((!(p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & 4096)) || (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & 4)))
                    {
                        ;
                        flow_object_set_zero(&p_init_declarator->p_declarator->type, p_init_declarator->p_declarator->p_flow_object);
                    }
                    else
                    {
                        ;
                        flow_object_set_uninitialized(&p_init_declarator->p_declarator->type, p_init_declarator->p_declarator->p_flow_object);
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void flow_visit_init_declarator_list(struct flow_visit_ctx * ctx, struct init_declarator_list * p_init_declarator_list)
{
    struct init_declarator * p_init_declarator;

    p_init_declarator = p_init_declarator_list->head;
    while (p_init_declarator)
    {
        flow_visit_init_declarator(ctx, p_init_declarator);
        p_init_declarator = p_init_declarator->next;
    }
}

static void flow_check_pointer_used_as_bool(struct flow_visit_ctx * ctx, struct expression * p_expression)
{
    unsigned char  nullable_enabled;

    nullable_enabled = ctx->ctx->options.null_checks_enabled;
    if (type_is_pointer(&p_expression->type))
    {
        struct flow_object * p_object;

        p_object = expression_get_flow_object(ctx, p_expression, nullable_enabled);
        if (p_object)
        {
            struct marker  marker;

            marker.file = 0;
            marker.line = 0;
            marker.start_col = 0;
            marker.end_col = 0;
            marker.p_token_caret = 0;
            marker.p_token_begin = p_expression->first_token;
            marker.p_token_end = p_expression->last_token;
            if (!ctx->inside_loop && flow_object_is_null(p_object))
            {
                compiler_diagnostic(28, ctx->ctx, 0, &marker, "pointer is always null");
            }
            else
            {
                if (!ctx->inside_loop && flow_object_is_not_null(p_object))
                {
                    compiler_diagnostic(28, ctx->ctx, 0, &marker, "pointer is always not-null");
                }
            }
        }
    }
}

static void flow_visit_for_statement(struct flow_visit_ctx * ctx, struct iteration_statement * p_iteration_statement)
{
    struct true_false_set  d;
    unsigned char  b_secondary_block_ends_with_jump;

    ;
    _cake_zmem(&d, 12);
    if (p_iteration_statement->declaration && p_iteration_statement->declaration->init_declarator_list.head)
    {
        flow_visit_init_declarator_list(ctx, &p_iteration_statement->declaration->init_declarator_list);
    }
    if (p_iteration_statement->expression0)
    {
        flow_visit_expression(ctx, p_iteration_statement->expression0, &d);
    }
    if (p_iteration_statement->expression1)
    {
        flow_check_pointer_used_as_bool(ctx, p_iteration_statement->expression1);
        flow_visit_expression(ctx, p_iteration_statement->expression1, &d);
    }
    diagnostic_stack_push_empty(&ctx->ctx->options.diagnostic_stack);
    flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
    diagnostic_stack_pop(&ctx->ctx->options.diagnostic_stack);
    if (p_iteration_statement->expression2)
    {
        flow_visit_expression(ctx, p_iteration_statement->expression2, &d);
    }
    b_secondary_block_ends_with_jump = secondary_block_ends_with_jump(p_iteration_statement->secondary_block);
    if (!b_secondary_block_ends_with_jump)
    {
        flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
        flow_exit_block_visit_defer_list(ctx, &p_iteration_statement->defer_list, p_iteration_statement->secondary_block->last_token);
        flow_defer_list_set_end_of_lifetime(ctx, &p_iteration_statement->defer_list, p_iteration_statement->secondary_block->last_token);
    }
    true_false_set_destroy(&d);
}

static void flow_visit_iteration_statement(struct flow_visit_ctx * ctx, struct iteration_statement * p_iteration_statement)
{
    unsigned char  inside_loop;

    inside_loop = ctx->inside_loop;
    ctx->inside_loop = 1;
    /*switch*/
    {
        int __v0 = p_iteration_statement->first_token->type;
        if (__v0 == 9042) goto __L1; /*case 9042*/
        if (__v0 == 9008) goto __L2; /*case 9008*/
        if (__v0 == 9015) goto __L3; /*case 9015*/
        goto __L4; /* default */

        {
            __L1: /*case 9042*/ 
            flow_visit_while_statement(ctx, p_iteration_statement);
            goto __L0; /* break */

            __L2: /*case 9008*/ 
            flow_visit_do_while_statement(ctx, p_iteration_statement);
            goto __L0; /* break */

            __L3: /*case 9015*/ 
            flow_visit_for_statement(ctx, p_iteration_statement);
            goto __L0; /* break */

            __L4: /* default */ 
            ;
            goto __L0; /* break */

        }
        __L0:;
    }
    ctx->inside_loop = inside_loop;
}

static void flow_visit_expression_statement(struct flow_visit_ctx * ctx, struct expression_statement * p_expression_statement)
{
    struct diagnostic_id_stack  stack;
    struct diagnostic_id_stack * p_diagnostic_id_stack;
    struct true_false_set  d;

    _cake_zmem(&stack, 44);
    p_diagnostic_id_stack = build_diagnostic_id_stack(ctx->ctx, p_expression_statement->p_attribute_specifier_sequence, &stack, 2);
    _cake_zmem(&d, 12);
    if (p_expression_statement->expression_opt)
    {
        flow_visit_expression(ctx, p_expression_statement->expression_opt, &d);
    }
    warn_unrecognized_warnings(ctx->ctx, &stack, p_expression_statement->p_attribute_specifier_sequence, p_diagnostic_id_stack);
    true_false_set_destroy(&d);
}

static void flow_visit_simple_declaration(struct flow_visit_ctx * ctx, struct simple_declaration * p_simple_declaration)
{
    flow_visit_declaration_specifiers(ctx, p_simple_declaration->p_declaration_specifiers, 0);
    flow_visit_init_declarator_list(ctx, &p_simple_declaration->init_declarator_list);
}

static void flow_visit_if_statement(struct flow_visit_ctx * ctx, struct selection_statement * p_selection_statement)
{
    unsigned char  nullable_enabled;
    struct expression  hidden_expression;
    struct true_false_set  true_false_set;
    int before_if_state_number;
    unsigned char  true_branch_ends_with_jump;
    int left_true_branch_state_number;
    unsigned char  else_ends_with_jump;

    nullable_enabled = ctx->ctx->options.null_checks_enabled;
    if (p_selection_statement->p_init_statement && p_selection_statement->p_init_statement->p_expression_statement)
    {
        flow_visit_expression_statement(ctx, p_selection_statement->p_init_statement->p_expression_statement);
    }
    if (p_selection_statement->p_init_statement && p_selection_statement->p_init_statement->p_simple_declaration)
    {
        flow_visit_simple_declaration(ctx, p_selection_statement->p_init_statement->p_simple_declaration);
    }
    _cake_zmem(&hidden_expression, 256);
    _cake_zmem(&true_false_set, 12);
    if (p_selection_statement->condition && p_selection_statement->condition->expression)
    {
        flow_check_pointer_used_as_bool(ctx, p_selection_statement->condition->expression);
        flow_visit_expression(ctx, p_selection_statement->condition->expression, &true_false_set);
    }
    if (p_selection_statement->condition && p_selection_statement->condition->p_init_declarator)
    {
        flow_visit_init_declarator(ctx, p_selection_statement->condition->p_init_declarator);
    }
    if (p_selection_statement->condition && p_selection_statement->condition->expression == 0 && p_selection_statement->condition->p_init_declarator != 0)
    {
        hidden_expression.expression_type = 2;
        hidden_expression.declarator = p_selection_statement->condition->p_init_declarator->p_declarator;
        ;
        hidden_expression.first_token = p_selection_statement->condition->p_init_declarator->p_declarator->first_token_opt;
        hidden_expression.last_token = hidden_expression.first_token;
        flow_visit_expression(ctx, &hidden_expression, &true_false_set);
    }
    ;
    before_if_state_number = arena_add_copy_of_current_state(ctx, "before-if");
    true_false_set_set_objects_to_true_branch(ctx, &true_false_set, nullable_enabled);
    flow_visit_secondary_block(ctx, p_selection_statement->secondary_block);
    true_branch_ends_with_jump = secondary_block_ends_with_jump(p_selection_statement->secondary_block);
    left_true_branch_state_number = arena_add_copy_of_current_state(ctx, "left-true-branch");
    arena_restore_current_state_from(ctx, before_if_state_number);
    if (p_selection_statement->else_secondary_block_opt)
    {
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
        flow_visit_secondary_block(ctx, p_selection_statement->else_secondary_block_opt);
    }
    else
    {
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
    }
    else_ends_with_jump = ((p_selection_statement->else_secondary_block_opt ? secondary_block_ends_with_jump(p_selection_statement->else_secondary_block_opt) : 0) != 0);
    if (true_branch_ends_with_jump)
    {
        if (else_ends_with_jump)
        {
        }
        else
        {
        }
    }
    else
    {
        if (else_ends_with_jump)
        {
            arena_restore_current_state_from(ctx, left_true_branch_state_number);
        }
        else
        {
            arena_merge_current_state_with_state_number(ctx, left_true_branch_state_number);
            arena_restore_current_state_from(ctx, left_true_branch_state_number);
        }
    }
    flow_exit_block_visit_defer_list(ctx, &p_selection_statement->defer_list, p_selection_statement->last_token);
    flow_defer_list_set_end_of_lifetime(ctx, &p_selection_statement->defer_list, p_selection_statement->last_token);
    arena_remove_state(ctx, before_if_state_number);
    arena_remove_state(ctx, left_true_branch_state_number);
    true_false_set_destroy(&true_false_set);
}

static void flow_visit_switch_statement(struct flow_visit_ctx * ctx, struct selection_statement * p_selection_statement)
{
    int old_initial_state;
    int old_break_join_state;
    unsigned char  reached_the_end;

    old_initial_state = ctx->initial_state;
    old_break_join_state = ctx->break_join_state;
    ctx->initial_state = arena_add_copy_of_current_state(ctx, "original");
    ctx->break_join_state = arena_add_empty_state(ctx, "break join");
    flow_visit_secondary_block(ctx, p_selection_statement->secondary_block);
    reached_the_end = !secondary_block_ends_with_jump(p_selection_statement->secondary_block);
    if (!reached_the_end)
    {
        arena_restore_current_state_from(ctx, ctx->break_join_state);
    }
    flow_exit_block_visit_defer_list(ctx, &p_selection_statement->defer_list, p_selection_statement->secondary_block->last_token);
    flow_defer_list_set_end_of_lifetime(ctx, &p_selection_statement->defer_list, p_selection_statement->secondary_block->last_token);
    arena_remove_state(ctx, ctx->initial_state);
    arena_remove_state(ctx, ctx->break_join_state);
    ctx->initial_state = old_initial_state;
    ctx->break_join_state = old_break_join_state;
}

static void flow_visit_selection_statement(struct flow_visit_ctx * ctx, struct selection_statement * p_selection_statement)
{
    if (p_selection_statement->first_token->type == 9017)
    {
        flow_visit_if_statement(ctx, p_selection_statement);
    }
    else
    {
        if (p_selection_statement->first_token->type == 9034)
        {
            flow_visit_switch_statement(ctx, p_selection_statement);
        }
        else
        {
            ;
        }
    }
}

static void flow_object_set_state_from_current(struct flow_object * object, int state_number)
{
    struct flow_object_state * p_flow_object_state;

    p_flow_object_state = object->current.next;
    while (p_flow_object_state)
    {
        if (p_flow_object_state->state_number == state_number)
        {
            flow_object_state_copy(p_flow_object_state, &object->current);
            break;
        }
        p_flow_object_state = p_flow_object_state->next;
    }
}

static void arena_set_state_from_current(struct flow_visit_ctx * ctx, int number_state)
{
    {
        int i;

        i = 0;
        for (; i < ctx->arena.size; i++)
        {
            struct flow_object * p_object;

            p_object = ctx->arena.data[i];
            flow_object_set_state_from_current(p_object, number_state);
        }
    }
}

static void flow_visit_try_statement(struct flow_visit_ctx * ctx, struct try_statement * p_try_statement)
{
    int throw_join_state_old;
    struct secondary_block * catch_secondary_block_old;
    int original_state_number;
    unsigned char  try_reached_the_end;
    unsigned char  catch_reached_the_end;

    throw_join_state_old = ctx->throw_join_state;
    catch_secondary_block_old = ctx->catch_secondary_block_opt;
    ctx->catch_secondary_block_opt = p_try_statement->catch_secondary_block_opt;
    ctx->throw_join_state = arena_add_empty_state(ctx, "try");
    original_state_number = arena_add_copy_of_current_state(ctx, "original");
    flow_visit_secondary_block(ctx, p_try_statement->secondary_block);
    arena_set_state_from_current(ctx, original_state_number);
    if (p_try_statement->catch_secondary_block_opt)
    {
        arena_restore_current_state_from(ctx, ctx->throw_join_state);
        flow_visit_secondary_block(ctx, p_try_statement->catch_secondary_block_opt);
    }
    try_reached_the_end = !secondary_block_ends_with_jump(p_try_statement->secondary_block);
    catch_reached_the_end = !secondary_block_ends_with_jump(p_try_statement->catch_secondary_block_opt);
    if (try_reached_the_end && catch_reached_the_end)
    {
        arena_merge_current_state_with_state_number(ctx, original_state_number);
        arena_restore_current_state_from(ctx, original_state_number);
    }
    else
    {
        if (try_reached_the_end)
        {
            arena_restore_current_state_from(ctx, original_state_number);
        }
        else
        {
            if (catch_reached_the_end)
            {
            }
        }
    }
    arena_remove_state(ctx, original_state_number);
    arena_remove_state(ctx, ctx->throw_join_state);
    ctx->throw_join_state = throw_join_state_old;
    ctx->catch_secondary_block_opt = catch_secondary_block_old;
}

static void flow_visit_primary_block(struct flow_visit_ctx * ctx, struct primary_block * p_primary_block)
{
    if (p_primary_block->defer_statement)
    {
        flow_visit_defer_statement(ctx, p_primary_block->defer_statement);
    }
    else
    {
        if (p_primary_block->compound_statement)
        {
            flow_visit_compound_statement(ctx, p_primary_block->compound_statement);
        }
        else
        {
            if (p_primary_block->iteration_statement)
            {
                flow_visit_iteration_statement(ctx, p_primary_block->iteration_statement);
            }
            else
            {
                if (p_primary_block->selection_statement)
                {
                    flow_visit_selection_statement(ctx, p_primary_block->selection_statement);
                }
                else
                {
                    if (p_primary_block->try_statement)
                    {
                        flow_visit_try_statement(ctx, p_primary_block->try_statement);
                    }
                }
            }
        }
    }
}

static void flow_visit_jump_statement(struct flow_visit_ctx * ctx, struct jump_statement * p_jump_statement)
{
    unsigned char  nullable_enabled;

    nullable_enabled = ctx->ctx->options.null_checks_enabled;
    if (1) /*try*/
    {
        if (p_jump_statement->first_token->type == 9037)
        {
            arena_merge_current_state_with_state_number(ctx, ctx->throw_join_state);
            flow_exit_block_visit_defer_list(ctx, &p_jump_statement->defer_list, p_jump_statement->first_token);
        }
        else
        {
            if (p_jump_statement->first_token->type == 9027)
            {
                if (ctx->p_return_type == 0)
                {
                    goto __L0; /* throw */
                }
                if (p_jump_statement->expression_opt)
                {
                    struct true_false_set  d;

                    _cake_zmem(&d, 12);
                    flow_visit_expression(ctx, p_jump_statement->expression_opt, &d);
                    true_false_set_destroy(&d);
                }
                if (p_jump_statement->expression_opt)
                {
                    struct flow_object * p_object;

                    p_object = expression_get_flow_object(ctx, p_jump_statement->expression_opt, nullable_enabled);
                    if (p_object)
                    {
                        struct flow_object * p_dest_object;
                        struct marker  a_marker;
                        struct marker  b_marker;
                        int state_before_return;

                        ;
                        p_dest_object = make_flow_object(ctx, ctx->p_return_type, 0, p_jump_statement->expression_opt);
                        if (p_dest_object == 0)
                        {
                            goto __L0; /* throw */
                        }
                        ;
                        flow_object_set_zero(ctx->p_return_type, p_dest_object);
                        a_marker.file = 0;
                        a_marker.line = 0;
                        a_marker.start_col = 0;
                        a_marker.end_col = 0;
                        a_marker.p_token_caret = 0;
                        a_marker.p_token_begin = p_jump_statement->expression_opt->first_token;
                        a_marker.p_token_end = p_jump_statement->expression_opt->last_token;
                        b_marker.file = 0;
                        b_marker.line = 0;
                        b_marker.start_col = 0;
                        b_marker.end_col = 0;
                        b_marker.p_token_caret = 0;
                        b_marker.p_token_begin = p_jump_statement->expression_opt->first_token;
                        b_marker.p_token_end = p_jump_statement->expression_opt->last_token;
                        ;
                        flow_check_assignment(ctx, p_jump_statement->expression_opt->first_token, &a_marker, &b_marker, 0, 1, type_is_view(ctx->p_return_type), type_is_opt(ctx->p_return_type, ctx->ctx->options.null_checks_enabled), ctx->p_return_type, p_dest_object, &p_jump_statement->expression_opt->type, p_object, 0);
                        state_before_return = arena_add_copy_of_current_state(ctx, "before-return");
                        flow_defer_list_set_end_of_lifetime(ctx, &p_jump_statement->defer_list, p_jump_statement->first_token);
                        if (ctx->p_return_type == 0)
                        {
                            goto __L0; /* throw */
                        }
                        checked_read_object(ctx, ctx->p_return_type, type_is_opt(ctx->p_return_type, ctx->ctx->options.null_checks_enabled), p_dest_object, 0, &a_marker, 1);
                        arena_restore_current_state_from(ctx, state_before_return);
                    }
                    if (p_object && p_object->is_temporary)
                    {
                        p_object->current.state = 128;
                    }
                }
                flow_exit_block_visit_defer_list(ctx, &p_jump_statement->defer_list, p_jump_statement->first_token);
            }
            else
            {
                if (p_jump_statement->first_token->type == 9005)
                {
                    flow_exit_block_visit_defer_list(ctx, &p_jump_statement->defer_list, p_jump_statement->first_token);
                }
                else
                {
                    if (p_jump_statement->first_token->type == 9000)
                    {
                        arena_merge_current_state_with_state_number(ctx, ctx->break_join_state);
                        flow_exit_block_visit_defer_list(ctx, &p_jump_statement->defer_list, p_jump_statement->first_token);
                    }
                    else
                    {
                        if (p_jump_statement->first_token->type == 9016)
                        {
                            int label_state_number;

                            ;
                            label_state_number = -1;
                            {
                                int i;

                                i = 0;
                                for (; i < ctx->labels_size; i++)
                                {
                                    if (ctx->labels[i].state_number == label_state_number)
                                    {
                                        break;
                                    }
                                }
                            }
                            if (label_state_number == -1)
                            {
                                label_state_number = arena_add_empty_state(ctx, p_jump_statement->label->lexeme);
                                ctx->labels[ctx->labels_size].state_number = label_state_number;
                                ctx->labels[ctx->labels_size].label_name = p_jump_statement->label->lexeme;
                                ctx->labels_size++;
                            }
                            arena_merge_current_state_with_state_number(ctx, label_state_number);
                            flow_exit_block_visit_defer_list(ctx, &p_jump_statement->defer_list, p_jump_statement->first_token);
                        }
                        else
                        {
                            ;
                        }
                    }
                }
            }
        }
    }
    else __L0: /*catch*/ 
    {
    }
}

static void flow_visit_unlabeled_statement(struct flow_visit_ctx * ctx, struct unlabeled_statement * p_unlabeled_statement)
{
    if (p_unlabeled_statement->primary_block)
    {
        struct diagnostic_id_stack  stack;
        struct diagnostic_id_stack * p_diagnostic_id_stack;

        _cake_zmem(&stack, 44);
        p_diagnostic_id_stack = build_diagnostic_id_stack(ctx->ctx, p_unlabeled_statement->p_attribute_specifier_sequence, &stack, 2);
        flow_visit_primary_block(ctx, p_unlabeled_statement->primary_block);
        warn_unrecognized_warnings(ctx->ctx, &stack, p_unlabeled_statement->p_attribute_specifier_sequence, p_diagnostic_id_stack);
    }
    else
    {
        if (p_unlabeled_statement->expression_statement)
        {
            flow_visit_expression_statement(ctx, p_unlabeled_statement->expression_statement);
        }
        else
        {
            if (p_unlabeled_statement->jump_statement)
            {
                struct diagnostic_id_stack  stack;
                struct diagnostic_id_stack * p_diagnostic_id_stack;

                _cake_zmem(&stack, 44);
                p_diagnostic_id_stack = build_diagnostic_id_stack(ctx->ctx, p_unlabeled_statement->p_attribute_specifier_sequence, &stack, 2);
                flow_visit_jump_statement(ctx, p_unlabeled_statement->jump_statement);
                warn_unrecognized_warnings(ctx->ctx, &stack, p_unlabeled_statement->p_attribute_specifier_sequence, p_diagnostic_id_stack);
            }
            else
            {
                ;
            }
        }
    }
}

static void flow_visit_block_item(struct flow_visit_ctx * ctx, struct block_item * p_block_item)
{
    if (p_block_item->declaration)
    {
        flow_visit_declaration(ctx, p_block_item->declaration);
    }
    else
    {
        if (p_block_item->unlabeled_statement)
        {
            flow_visit_unlabeled_statement(ctx, p_block_item->unlabeled_statement);
        }
        else
        {
            if (p_block_item->label)
            {
                flow_visit_label(ctx, p_block_item->label);
            }
        }
    }
}

static void flow_visit_block_item_list(struct flow_visit_ctx * ctx, struct block_item_list * p_block_item_list)
{
    struct block_item * p_block_item;

    p_block_item = p_block_item_list->head;
    while (p_block_item)
    {
        flow_visit_block_item(ctx, p_block_item);
        p_block_item = p_block_item->next;
    }
}

static void flow_visit_compound_statement(struct flow_visit_ctx * ctx, struct compound_statement * p_compound_statement)
{
    flow_visit_block_item_list(ctx, &p_compound_statement->block_item_list);
    flow_exit_block_visit_defer_list(ctx, &p_compound_statement->defer_list, p_compound_statement->last_token);
    flow_defer_list_set_end_of_lifetime(ctx, &p_compound_statement->defer_list, p_compound_statement->last_token);
}

static void true_false_set_invert(struct true_false_set * true_false_set)
{
    {
        int i;

        i = 0;
        for (; i < true_false_set->size; i++)
        {
            int temp;

            temp = true_false_set->data[i].true_branch_state;
            true_false_set->data[i].true_branch_state = true_false_set->data[i].false_branch_state;
            true_false_set->data[i].false_branch_state = temp;
        }
    }
}

static void true_false_set_swap(struct true_false_set * a, struct true_false_set * b)
{
    struct true_false_set  temp;

    temp = *a;
    *a = *b;
    *b = temp;
}

static void arena_broadcast_change(struct flow_visit_ctx * ctx, struct flow_object * p)
{
    {
        int i;

        i = 0;
        for (; i < ctx->arena.size; i++)
        {
            struct flow_object * p_obj;

            p_obj = ctx->arena.data[i];
            {
                int j;

                j = 0;
                for (; j < p_obj->current.alternatives.size; j++)
                {
                    if (p_obj->current.alternatives.data[j] == p)
                    {
                        flow_object_update_current(p_obj);
                        break;
                    }
                }
            }
        }
    }
}

static void true_false_set_merge(struct true_false_set * result, struct true_false_set * a, struct true_false_set * b, int options_true, int options_false)
{
    {
        int i;

        i = 0;
        for (; i < a->size; i++)
        {
            struct true_false_set_item * p_item_a;
            struct true_false_set_item  new_item;

            p_item_a = &a->data[i];
            _cake_zmem(&new_item, 12);
            new_item.p_expression = p_item_a->p_expression;
            if (options_true & 1)
            {
                new_item.true_branch_state |= p_item_a->true_branch_state;
            }
            if (options_true & 2)
            {
                new_item.true_branch_state |= p_item_a->false_branch_state;
            }
            if (options_false & 1)
            {
                new_item.false_branch_state |= p_item_a->true_branch_state;
            }
            if (options_false & 2)
            {
                new_item.true_branch_state |= p_item_a->false_branch_state;
            }
            true_false_set_push_back(result, &new_item);
        }
    }
    {
        int k;

        k = 0;
        for (; k < b->size; k++)
        {
            struct true_false_set_item * p_item_b;
            int index;
            struct true_false_set_item * p_item_result;

            p_item_b = &b->data[k];
            index = find_item_index_by_expression(result, p_item_b->p_expression);
            if (index == -1)
            {
                struct true_false_set_item  item2;

                index = result->size;
                _cake_zmem(&item2, 12);
                item2.p_expression = p_item_b->p_expression;
                true_false_set_push_back(result, &item2);
            }
            p_item_result = &result->data[index];
            if (options_true & 4)
            {
                p_item_result->true_branch_state |= p_item_b->true_branch_state;
            }
            if (options_true & 8)
            {
                p_item_result->true_branch_state |= p_item_b->false_branch_state;
            }
            if (options_false & 4)
            {
                p_item_result->false_branch_state |= p_item_b->true_branch_state;
            }
            if (options_false & 8)
            {
                p_item_result->true_branch_state |= p_item_b->false_branch_state;
            }
        }
    }
}

static void flow_visit_expression(struct flow_visit_ctx * ctx, struct expression * p_expression, struct true_false_set * expr_true_false_set)
{
    unsigned char  nullable_enabled;

    true_false_set_clear(expr_true_false_set);
    nullable_enabled = ctx->ctx->options.null_checks_enabled;
    /*switch*/
    {
        int __v0 = p_expression->expression_type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 4) goto __L2; /*case 4*/
        if (__v0 == 1) goto __L3; /*case 1*/
        if (__v0 == 2) goto __L4; /*case 2*/
        if (__v0 == 9) goto __L6; /*case 9*/
        if (__v0 == 3) goto __L7; /*case 3*/
        if (__v0 == 5) goto __L8; /*case 5*/
        if (__v0 == 8) goto __L9; /*case 8*/
        if (__v0 == 6) goto __L10; /*case 6*/
        if (__v0 == 7) goto __L11; /*case 7*/
        if (__v0 == 14) goto __L12; /*case 14*/
        if (__v0 == 15) goto __L13; /*case 15*/
        if (__v0 == 16) goto __L23; /*case 16*/
        if (__v0 == 17) goto __L24; /*case 17*/
        if (__v0 == 13) goto __L28; /*case 13*/
        if (__v0 == 12) goto __L29; /*case 12*/
        if (__v0 == 10) goto __L36; /*case 10*/
        if (__v0 == 11) goto __L37; /*case 11*/
        if (__v0 == 31) goto __L40; /*case 31*/
        if (__v0 == 30) goto __L42; /*case 30*/
        if (__v0 == 32) goto __L43; /*case 32*/
        if (__v0 == 18) goto __L45; /*case 18*/
        if (__v0 == 38) goto __L47; /*case 38*/
        if (__v0 == 39) goto __L48; /*case 39*/
        if (__v0 == 36) goto __L49; /*case 36*/
        if (__v0 == 19) goto __L50; /*case 19*/
        if (__v0 == 20) goto __L51; /*case 20*/
        if (__v0 == 34) goto __L52; /*case 34*/
        if (__v0 == 35) goto __L53; /*case 35*/
        if (__v0 == 37) goto __L54; /*case 37*/
        if (__v0 == 41) goto __L55; /*case 41*/
        if (__v0 == 40) goto __L56; /*case 40*/
        if (__v0 == 61) goto __L61; /*case 61*/
        if (__v0 == 62) goto __L62; /*case 62*/
        if (__v0 == 63) goto __L63; /*case 63*/
        if (__v0 == 64) goto __L64; /*case 64*/
        if (__v0 == 65) goto __L65; /*case 65*/
        if (__v0 == 66) goto __L66; /*case 66*/
        if (__v0 == 67) goto __L67; /*case 67*/
        if (__v0 == 68) goto __L68; /*case 68*/
        if (__v0 == 69) goto __L69; /*case 69*/
        if (__v0 == 70) goto __L70; /*case 70*/
        if (__v0 == 71) goto __L71; /*case 71*/
        if (__v0 == 44) goto __L77; /*case 44*/
        if (__v0 == 42) goto __L80; /*case 42*/
        if (__v0 == 43) goto __L81; /*case 43*/
        if (__v0 == 45) goto __L82; /*case 45*/
        if (__v0 == 46) goto __L83; /*case 46*/
        if (__v0 == 47) goto __L84; /*case 47*/
        if (__v0 == 48) goto __L85; /*case 48*/
        if (__v0 == 49) goto __L86; /*case 49*/
        if (__v0 == 52) goto __L89; /*case 52*/
        if (__v0 == 53) goto __L90; /*case 53*/
        if (__v0 == 50) goto __L91; /*case 50*/
        if (__v0 == 51) goto __L92; /*case 51*/
        if (__v0 == 55) goto __L99; /*case 55*/
        if (__v0 == 54) goto __L100; /*case 54*/
        if (__v0 == 59) goto __L125; /*case 59*/
        if (__v0 == 60) goto __L128; /*case 60*/
        if (__v0 == 58) goto __L130; /*case 58*/
        if (__v0 == 56) goto __L131; /*case 56*/
        if (__v0 == 57) goto __L132; /*case 57*/
        if (__v0 == 27) goto __L133; /*case 27*/
        if (__v0 == 28) goto __L134; /*case 28*/
        if (__v0 == 29) goto __L135; /*case 29*/
        if (__v0 == 72) goto __L136; /*case 72*/
        if (__v0 == 73) goto __L137; /*case 73*/
        goto __L0;

        {
            struct flow_object * temp2;

            __L1: /*case 0*/ 
            ;
            goto __L0; /* break */

            __L2: /*case 4*/ 
            goto __L0; /* break */

            __L3: /*case 1*/ 
            goto __L0; /* break */

            __L4: /*case 2*/ 
            {
                ;
                if (p_expression->declarator->p_alias_of_expression)
                {
                    flow_visit_expression(ctx, p_expression->declarator->p_alias_of_expression, expr_true_false_set);
                }
                else
                {
                    struct true_false_set_item  item;

                    _cake_zmem(&item, 12);
                    item.p_expression = p_expression;
                    item.true_branch_state = 1;
                    item.false_branch_state = 2;
                    true_false_set_push_back(expr_true_false_set, &item);
                    check_uninitialized(ctx, p_expression);
                }
            }
            goto __L0; /* break */

            __L6: /*case 9*/ 
            ;
            flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
            goto __L0; /* break */

            __L7: /*case 3*/ 
            __L8: /*case 5*/ 
            __L9: /*case 8*/ 
            __L10: /*case 6*/ 
            goto __L0; /* break */

            __L11: /*case 7*/ 
            ;
            flow_visit_generic_selection(ctx, p_expression->generic_selection);
            goto __L0; /* break */

            __L12: /*case 14*/ 
            {
                struct true_false_set  left_set;
                struct true_false_set_item  item;

                ;
                _cake_zmem(&left_set, 12);
                flow_visit_expression(ctx, p_expression->left, &left_set);
                true_false_set_destroy(&left_set);
                item.p_expression = p_expression;
                item.true_branch_state = 1;
                item.false_branch_state = 2;
                true_false_set_push_back(expr_true_false_set, &item);
            }
            goto __L0; /* break */

            __L13: /*case 15*/ 
            {
                struct true_false_set  left_set;
                struct flow_object * p_object;
                struct true_false_set_item  item;

                ;
                _cake_zmem(&left_set, 12);
                flow_visit_expression(ctx, p_expression->left, &left_set);
                true_false_set_destroy(&left_set);
                p_object = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
                if (p_object != 0)
                {
                    if (flow_object_can_be_null(p_object))
                    {
                        if (ctx->expression_is_not_evaluated)
                        {
                        }
                        else
                        {
                            struct marker  marker;

                            _cake_zmem(&marker, 28);
                            marker.p_token_begin = p_expression->left->first_token;
                            marker.p_token_end = p_expression->left->last_token;
                            compiler_diagnostic(33, ctx->ctx, 0, &marker, "pointer may be null");
                        }
                    }
                    else
                    {
                        if (flow_object_can_be_uninitialized(p_object))
                        {
                            if (ctx->expression_is_not_evaluated)
                            {
                            }
                            else
                            {
                                compiler_diagnostic(33, ctx->ctx, p_expression->left->first_token, 0, "object is possibly uninitialized");
                            }
                        }
                        else
                        {
                            if (flow_object_can_have_its_lifetime_ended(p_object))
                            {
                                if (ctx->expression_is_not_evaluated)
                                {
                                }
                                else
                                {
                                    compiler_diagnostic(31, ctx->ctx, p_expression->left->first_token, 0, "object lifetime ended");
                                }
                            }
                        }
                    }
                }
                if (!ctx->expression_is_not_evaluated)
                {
                    struct flow_object * p_object2;

                    p_object2 = expression_get_flow_object(ctx, p_expression, nullable_enabled);
                    if (p_object2 && flow_object_can_have_its_lifetime_ended(p_object2))
                    {
                        struct marker  marker;

                        marker.file = 0;
                        marker.line = 0;
                        marker.start_col = 0;
                        marker.end_col = 0;
                        marker.p_token_caret = 0;
                        marker.p_token_begin = p_expression->first_token;
                        marker.p_token_end = p_expression->last_token;
                        compiler_diagnostic(31, ctx->ctx, 0, &marker, "object lifetime ended");
                    }
                }
                item.p_expression = p_expression;
                item.true_branch_state = 1;
                item.false_branch_state = 2;
                true_false_set_push_back(expr_true_false_set, &item);
            }
            goto __L0; /* break */

            __L23: /*case 16*/ 
            __L24: /*case 17*/ 
            {
                struct flow_object * p_object;

                ;
                p_object = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
                if (p_object)
                {
                    if (flow_object_is_null(p_object))
                    {
                        p_object->current.state = 4;
                    }
                    else
                    {
                        if (flow_object_is_zero(p_object))
                        {
                            p_object->current.state = 64;
                        }
                    }
                }
                flow_visit_expression(ctx, p_expression->left, expr_true_false_set);
            }
            goto __L0; /* break */

            __L28: /*case 13*/ 
            {
                struct true_false_set_item  item;

                ;
                ;
                flow_visit_expression(ctx, p_expression->left, expr_true_false_set);
                flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
                true_false_set_clear(expr_true_false_set);
                item.p_expression = p_expression;
                item.true_branch_state = 1;
                item.false_branch_state = 2;
                true_false_set_push_back(expr_true_false_set, &item);
            }
            goto __L0; /* break */

            __L29: /*case 12*/ 
            {
                if (!ctx->inside_contract)
                {
                    struct true_false_set  left_local;

                    ;
                    _cake_zmem(&left_local, 12);
                    flow_visit_expression(ctx, p_expression->left, &left_local);
                    flow_compare_function_arguments(ctx, &p_expression->left->type, &p_expression->argument_expression_list);
                    true_false_set_destroy(&left_local);
                }
                if (p_expression->left->declarator && type_is_function(&p_expression->left->declarator->type))
                {
                    struct type  return_type;

                    return_type = get_function_return_type(&p_expression->left->declarator->type);
                    if (p_expression->left->declarator->p_expression_true)
                    {
                        struct expression * p_expression_true;

                        p_expression_true = p_expression->left->declarator->p_expression_true;
                        flow_clear_alias(p_expression_true);
                        flow_expression_bind(ctx, p_expression_true, &p_expression->left->declarator->type.params, &p_expression->argument_expression_list);
                        if (type_is_scalar(&return_type))
                        {
                            struct true_false_set  local;
                            unsigned char  inside_contract;

                            _cake_zmem(&local, 12);
                            inside_contract = ctx->inside_contract;
                            ctx->inside_contract = 1;
                            flow_visit_expression(ctx, p_expression_true, &local);
                            ctx->inside_contract = inside_contract;
                            {
                                int i;

                                i = 0;
                                for (; i < local.size; i++)
                                {
                                    struct true_false_set_item  item5;

                                    item5.p_expression = local.data[i].p_expression;
                                    item5.true_branch_state = local.data[i].true_branch_state;
                                    item5.false_branch_state = 0;
                                    true_false_set_push_back(expr_true_false_set, &item5);
                                }
                            }
                            true_false_set_destroy(&local);
                        }
                        else
                        {
                            struct true_false_set  true_false_set4;
                            unsigned char  old;
                            unsigned char  inside_contract;

                            _cake_zmem(&true_false_set4, 12);
                            old = ctx->inside_assert;
                            ctx->inside_assert = 1;
                            inside_contract = ctx->inside_contract;
                            ctx->inside_contract = 1;
                            flow_visit_expression(ctx, p_expression->left->declarator->p_expression_true, &true_false_set4);
                            ctx->inside_contract = inside_contract;
                            ctx->inside_assert = old;
                            true_false_set_set_objects_to_true_branch(ctx, &true_false_set4, nullable_enabled);
                            true_false_set_destroy(&true_false_set4);
                        }
                    }
                    if (p_expression->left->declarator->p_expression_false)
                    {
                        struct expression * p_expression_false;
                        struct true_false_set  local;
                        unsigned char  inside_contract;

                        p_expression_false = p_expression->left->declarator->p_expression_false;
                        flow_clear_alias(p_expression_false);
                        flow_expression_bind(ctx, p_expression_false, &p_expression->left->declarator->type.params, &p_expression->argument_expression_list);
                        _cake_zmem(&local, 12);
                        inside_contract = ctx->inside_contract;
                        ctx->inside_contract = 1;
                        flow_visit_expression(ctx, p_expression_false, &local);
                        ctx->inside_contract = inside_contract;
                        {
                            int i;

                            i = 0;
                            for (; i < local.size; i++)
                            {
                                int index;

                                index = find_item_index_by_expression(expr_true_false_set, local.data[i].p_expression);
                                if (index == -1)
                                {
                                    struct true_false_set_item  item5;

                                    item5.p_expression = local.data[i].p_expression;
                                    item5.true_branch_state = 0;
                                    item5.false_branch_state = local.data[i].true_branch_state;
                                    true_false_set_push_back(expr_true_false_set, &item5);
                                }
                                else
                                {
                                    expr_true_false_set->data[index].false_branch_state |= local.data[i].false_branch_state;
                                }
                            }
                        }
                        true_false_set_destroy(&local);
                    }
                    type_destroy(&return_type);
                }
            }
            goto __L0; /* break */

            __L36: /*case 10*/ 
            ;
            flow_visit_compound_statement(ctx, p_expression->compound_statement);
            goto __L0; /* break */

            __L37: /*case 11*/ 
            ;
            ;
            ;
            ;
            flow_visit_bracket_initializer_list(ctx, p_expression->braced_initializer);
            temp2 = make_flow_object(ctx, &p_expression->type, 0, p_expression);
            if (temp2 == 0)
            {
                return;
            }
            if (p_expression->type_name->abstract_declarator->p_flow_object)
            {
                flow_object_swap(temp2, p_expression->type_name->abstract_declarator->p_flow_object);
                flow_object_set_zero(&p_expression->type, p_expression->type_name->abstract_declarator->p_flow_object);
            }
            goto __L0; /* break */

            __L40: /*case 31*/ 
            if (p_expression->right)
            {
                flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
            }
            goto __L0; /* break */

            __L42: /*case 30*/ 
            goto __L0; /* break */

            __L43: /*case 32*/ 
            if (p_expression->right)
            {
                struct true_false_set  true_false_set4;
                unsigned char  old;

                _cake_zmem(&true_false_set4, 12);
                old = ctx->inside_assert;
                ctx->inside_assert = 1;
                flow_visit_expression(ctx, p_expression->right, &true_false_set4);
                ctx->inside_assert = old;
                true_false_set_set_objects_to_true_branch(ctx, &true_false_set4, nullable_enabled);
                true_false_set_destroy(&true_false_set4);
            }
            goto __L0; /* break */

            __L45: /*case 18*/ 
            if (p_expression->right)
            {
                unsigned char  t2;

                t2 = ctx->expression_is_not_evaluated;
                ctx->expression_is_not_evaluated = 1;
                flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
                ctx->expression_is_not_evaluated = t2;
            }
            goto __L0; /* break */

            __L47: /*case 38*/ 
            __L48: /*case 39*/ 
            ;
            flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
            goto __L0; /* break */

            __L49: /*case 36*/ 
            ;
            flow_check_pointer_used_as_bool(ctx, p_expression->right);
            flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
            true_false_set_invert(expr_true_false_set);
            goto __L0; /* break */

            __L50: /*case 19*/ 
            __L51: /*case 20*/ 
            __L52: /*case 34*/ 
            __L53: /*case 35*/ 
            __L54: /*case 37*/ 
            __L55: /*case 41*/ 
            goto __L0; /* break */

            __L56: /*case 40*/ 
            {
                struct flow_object * p_object0;
                struct true_false_set  local_true_false;

                ;
                p_object0 = expression_get_flow_object(ctx, p_expression->right, nullable_enabled);
                if (p_object0 && p_object0->current.state == 1)
                {
                    if (!ctx->expression_is_not_evaluated)
                    {
                        struct marker  marker;

                        _cake_zmem(&marker, 28);
                        marker.p_token_begin = p_expression->right->first_token;
                        marker.p_token_end = p_expression->right->last_token;
                        compiler_diagnostic(30, ctx->ctx, 0, &marker, "using a uninitialized object");
                    }
                }
                else
                {
                    if (p_object0 && flow_object_can_be_null(p_object0))
                    {
                        if (!ctx->expression_is_not_evaluated)
                        {
                            compiler_diagnostic(33, ctx->ctx, p_expression->right->first_token, 0, "dereference a NULL object");
                        }
                    }
                }
                _cake_zmem(&local_true_false, 12);
                flow_visit_expression(ctx, p_expression->right, &local_true_false);
                true_false_set_destroy(&local_true_false);
            }
            goto __L0; /* break */

            __L61: /*case 61*/ 
            __L62: /*case 62*/ 
            __L63: /*case 63*/ 
            __L64: /*case 64*/ 
            __L65: /*case 65*/ 
            __L66: /*case 66*/ 
            __L67: /*case 67*/ 
            __L68: /*case 68*/ 
            __L69: /*case 69*/ 
            __L70: /*case 70*/ 
            __L71: /*case 71*/ 
            {
                struct true_false_set  left_set;
                struct true_false_set  right_set;
                struct flow_object * p_right_object;
                struct flow_object * p_dest_object;
                struct marker  a_marker;
                struct marker  b_marker;

                ;
                ;
                _cake_zmem(&left_set, 12);
                flow_visit_expression(ctx, p_expression->left, &left_set);
                true_false_set_swap(expr_true_false_set, &left_set);
                true_false_set_destroy(&left_set);
                _cake_zmem(&right_set, 12);
                flow_visit_expression(ctx, p_expression->right, &right_set);
                true_false_set_destroy(&right_set);
                p_right_object = expression_get_flow_object(ctx, p_expression->right, nullable_enabled);
                p_dest_object = expression_get_flow_object(ctx, p_expression->left, nullable_enabled);
                if (p_dest_object == 0 || p_right_object == 0)
                {
                    return;
                }
                a_marker.file = 0;
                a_marker.line = 0;
                a_marker.start_col = 0;
                a_marker.end_col = 0;
                a_marker.p_token_caret = 0;
                a_marker.p_token_begin = p_expression->left->first_token;
                a_marker.p_token_end = p_expression->left->last_token;
                b_marker.file = 0;
                b_marker.line = 0;
                b_marker.start_col = 0;
                b_marker.end_col = 0;
                b_marker.p_token_caret = 0;
                b_marker.p_token_begin = p_expression->right->first_token;
                b_marker.p_token_end = p_expression->right->last_token;
                flow_check_assignment(ctx, p_expression->left->first_token, &a_marker, &b_marker, 2, 1, type_is_view(&p_expression->left->type), type_is_opt(&p_expression->left->type, ctx->ctx->options.null_checks_enabled), &p_expression->left->type, p_dest_object, &p_expression->right->type, p_right_object, 0);
                arena_broadcast_change(ctx, p_dest_object);
                if (expression_is_malloc(p_expression->right))
                {
                    struct type  t;
                    struct flow_object * po;

                    t = type_remove_pointer(&p_expression->left->type);
                    po = make_flow_object(ctx, &t, 0, p_expression->left);
                    if (po == 0)
                    {
                        type_destroy(&t);
                        return;
                    }
                    object_set_pointer(p_dest_object, po);
                    type_destroy(&t);
                    p_dest_object->current.state = 6;
                }
                else
                {
                    if (expression_is_calloc(p_expression->right))
                    {
                        struct type  t;
                        struct flow_object * po;

                        t = type_remove_pointer(&p_expression->left->type);
                        po = make_flow_object(ctx, &t, 0, p_expression->left);
                        if (po == 0)
                        {
                            type_destroy(&t);
                            return;
                        }
                        flow_object_set_zero(&t, po);
                        object_set_pointer(p_dest_object, po);
                        type_destroy(&t);
                        p_dest_object->current.state = 6;
                    }
                }
            }
            goto __L0; /* break */

            __L77: /*case 44*/ 
            {
                struct true_false_set  left_set;
                struct true_false_set  right_set;
                struct flow_object * p_object;

                ;
                ;
                _cake_zmem(&left_set, 12);
                _cake_zmem(&right_set, 12);
                flow_visit_expression(ctx, p_expression->left, &left_set);
                p_object = expression_get_flow_object(ctx, p_expression->right, ctx->ctx->options.null_checks_enabled);
                if (p_object)
                {
                    if (flow_object_can_be_zero(p_object))
                    {
                        compiler_diagnostic(36, ctx->ctx, p_expression->right->first_token, 0, "possible division by zero");
                    }
                }
                flow_visit_expression(ctx, p_expression->right, &right_set);
                true_false_set_merge(expr_true_false_set, &left_set, &right_set, 5, 5);
                true_false_set_destroy(&left_set);
                true_false_set_destroy(&right_set);
            }
            goto __L0; /* break */

            __L80: /*case 42*/ 
            __L81: /*case 43*/ 
            __L82: /*case 45*/ 
            __L83: /*case 46*/ 
            __L84: /*case 47*/ 
            __L85: /*case 48*/ 
            __L86: /*case 49*/ 
            {
                if (p_expression->left)
                {
                    struct true_false_set  left_set;

                    _cake_zmem(&left_set, 12);
                    flow_visit_expression(ctx, p_expression->left, &left_set);
                    true_false_set_destroy(&left_set);
                }
                if (p_expression->right)
                {
                    struct true_false_set  right_set;

                    _cake_zmem(&right_set, 12);
                    flow_visit_expression(ctx, p_expression->right, &right_set);
                    true_false_set_destroy(&right_set);
                }
            }
            goto __L0; /* break */

            __L89: /*case 52*/ 
            __L90: /*case 53*/ 
            __L91: /*case 50*/ 
            __L92: /*case 51*/ 
            {
                unsigned char  left_is_constant;
                unsigned char  right_is_constant;

                ;
                ;
                left_is_constant = object_has_constant_value(&p_expression->left->object);
                right_is_constant = object_has_constant_value(&p_expression->right->object);
                if (left_is_constant)
                {
                    long long left_value;
                    struct true_false_set  true_false_set_right;

                    left_value = object_to_signed_long_long(&p_expression->left->object);
                    _cake_zmem(&true_false_set_right, 12);
                    flow_visit_expression(ctx, p_expression->right, &true_false_set_right);
                    if (left_value == 0)
                    {
                        true_false_set_swap(expr_true_false_set, &true_false_set_right);
                        {
                            int i;

                            i = 0;
                            for (; i < expr_true_false_set->size; i++)
                            {
                                struct true_false_set_item * item;

                                item = &expr_true_false_set->data[i];
                                item->false_branch_state |= item->true_branch_state;
                            }
                        }
                        if (p_expression->expression_type == 52 || p_expression->expression_type == 53)
                        {
                            true_false_set_invert(expr_true_false_set);
                        }
                    }
                    true_false_set_destroy(&true_false_set_right);
                }
                else
                {
                    if (right_is_constant)
                    {
                        long long right_value;
                        struct true_false_set  true_false_set_left3;

                        right_value = object_to_signed_long_long(&p_expression->right->object);
                        _cake_zmem(&true_false_set_left3, 12);
                        flow_visit_expression(ctx, p_expression->left, &true_false_set_left3);
                        if (right_value == 0)
                        {
                            true_false_set_swap(expr_true_false_set, &true_false_set_left3);
                            {
                                int i;

                                i = 0;
                                for (; i < expr_true_false_set->size; i++)
                                {
                                    struct true_false_set_item * item;

                                    item = &expr_true_false_set->data[i];
                                    item->false_branch_state |= item->true_branch_state;
                                }
                            }
                            if (p_expression->expression_type == 52 || p_expression->expression_type == 53)
                            {
                                true_false_set_invert(expr_true_false_set);
                            }
                        }
                        true_false_set_destroy(&true_false_set_left3);
                    }
                    else
                    {
                        struct true_false_set  true_false_set;

                        _cake_zmem(&true_false_set, 12);
                        flow_visit_expression(ctx, p_expression->left, &true_false_set);
                        flow_visit_expression(ctx, p_expression->right, &true_false_set);
                        true_false_set_destroy(&true_false_set);
                    }
                }
            }
            goto __L0; /* break */

            __L99: /*case 55*/ 
            __L100: /*case 54*/ 
            {
                long long value;
                struct expression * p_comp_expression;

                ;
                ;
                value = 0;
                p_comp_expression = 0;
                if (object_has_constant_value(&p_expression->left->object) && !object_has_constant_value(&p_expression->right->object))
                {
                    value = object_to_signed_long_long(&p_expression->left->object);
                    p_comp_expression = p_expression->right;
                }
                else
                {
                    if (object_has_constant_value(&p_expression->right->object) && !object_has_constant_value(&p_expression->left->object))
                    {
                        value = object_to_signed_long_long(&p_expression->right->object);
                        p_comp_expression = p_expression->left;
                    }
                }
                if (p_comp_expression)
                {
                    struct true_false_set  true_false_set;
                    struct flow_object * p_object;

                    _cake_zmem(&true_false_set, 12);
                    flow_visit_expression(ctx, p_comp_expression, &true_false_set);
                    p_object = expression_get_flow_object(ctx, p_comp_expression, nullable_enabled);
                    if (p_object)
                    {
                        struct marker  marker;

                        marker.file = 0;
                        marker.line = 0;
                        marker.start_col = 0;
                        marker.end_col = 0;
                        marker.p_token_caret = 0;
                        marker.p_token_begin = p_comp_expression->first_token;
                        marker.p_token_end = p_comp_expression->last_token;
                        if ((flow_object_is_null(p_object) || flow_object_is_zero(p_object)) && value == 0)
                        {
                            if (p_expression->expression_type == 54)
                            {
                                if (ctx->inside_assert)
                                {
                                }
                                else
                                {
                                    if (type_is_pointer(&p_comp_expression->type))
                                    {
                                        if (!ctx->inside_loop)
                                        {
                                            compiler_diagnostic(28, ctx->ctx, 0, &marker, "pointer is always null");
                                        }
                                    }
                                    else
                                    {
                                        if (!ctx->inside_loop)
                                        {
                                            compiler_diagnostic(28, ctx->ctx, 0, &marker, "value is always zero");
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (p_expression->expression_type == 55)
                                {
                                    if (type_is_pointer(&p_comp_expression->type))
                                    {
                                        compiler_diagnostic(28, ctx->ctx, 0, &marker, "pointer is always null");
                                    }
                                    else
                                    {
                                        compiler_diagnostic(28, ctx->ctx, 0, &marker, "value is always zero");
                                    }
                                }
                            }
                        }
                        else
                        {
                            if ((flow_object_is_not_null(p_object) || flow_object_is_not_zero(p_object)) && value == 0)
                            {
                                if (p_expression->expression_type == 54)
                                {
                                    if (type_is_pointer(&p_comp_expression->type))
                                    {
                                        if (!ctx->inside_loop)
                                        {
                                            compiler_diagnostic(28, ctx->ctx, 0, &marker, "pointer is always non-null");
                                        }
                                    }
                                    else
                                    {
                                        if (!ctx->inside_loop)
                                        {
                                            compiler_diagnostic(28, ctx->ctx, 0, &marker, "value is always non-zero");
                                        }
                                    }
                                }
                                else
                                {
                                    if (p_expression->expression_type == 55)
                                    {
                                        if (ctx->inside_assert)
                                        {
                                        }
                                        else
                                        {
                                            if (type_is_pointer(&p_comp_expression->type))
                                            {
                                                if (!ctx->inside_loop)
                                                {
                                                    compiler_diagnostic(28, ctx->ctx, 0, &marker, "pointer is always non-null");
                                                }
                                            }
                                            else
                                            {
                                                if (!ctx->inside_loop)
                                                {
                                                    compiler_diagnostic(28, ctx->ctx, 0, &marker, "value is always non-zero");
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    true_false_set_swap(expr_true_false_set, &true_false_set);
                    if (p_expression->expression_type == 54 && value == 0)
                    {
                        true_false_set_invert(expr_true_false_set);
                    }
                    else
                    {
                        if (p_expression->expression_type == 55 && value != 0)
                        {
                            true_false_set_invert(expr_true_false_set);
                        }
                    }
                    true_false_set_destroy(&true_false_set);
                }
                else
                {
                    struct true_false_set  true_false_set;

                    _cake_zmem(&true_false_set, 12);
                    flow_visit_expression(ctx, p_expression->left, &true_false_set);
                    flow_visit_expression(ctx, p_expression->right, &true_false_set);
                    true_false_set_destroy(&true_false_set);
                }
            }
            goto __L0; /* break */

            __L125: /*case 59*/ 
            {
                struct true_false_set  left_set;

                ;
                ;
                flow_check_pointer_used_as_bool(ctx, p_expression->left);
                flow_check_pointer_used_as_bool(ctx, p_expression->right);
                _cake_zmem(&left_set, 12);
                flow_visit_expression(ctx, p_expression->left, &left_set);
                if (object_has_constant_value(&p_expression->left->object) && object_is_true(&p_expression->left->object) == 1)
                {
                }
                else
                {
                    int original_state_number;
                    struct true_false_set  right_set;

                    original_state_number = arena_add_copy_of_current_state(ctx, "original");
                    true_false_set_set_objects_to_false_branch(ctx, &left_set, nullable_enabled);
                    _cake_zmem(&right_set, 12);
                    flow_visit_expression(ctx, p_expression->right, &right_set);
                    {
                        int i;

                        i = 0;
                        for (; i < left_set.size; i++)
                        {
                            struct true_false_set_item  item5;

                            item5.p_expression = left_set.data[i].p_expression;
                            item5.true_branch_state |= (left_set.data[i].true_branch_state | left_set.data[i].false_branch_state);
                            item5.false_branch_state |= left_set.data[i].false_branch_state;
                            true_false_set_push_back(expr_true_false_set, &item5);
                        }
                    }
                    {
                        int k;

                        k = 0;
                        for (; k < right_set.size; k++)
                        {
                            int index;

                            index = find_item_index_by_expression(expr_true_false_set, right_set.data[k].p_expression);
                            if (index == -1)
                            {
                                struct true_false_set_item  item4;

                                index = expr_true_false_set->size;
                                item4.p_expression = right_set.data[k].p_expression;
                                item4.true_branch_state = 0;
                                item4.false_branch_state = 0;
                                true_false_set_push_back(expr_true_false_set, &item4);
                            }
                            expr_true_false_set->data[index].p_expression = right_set.data[k].p_expression;
                            expr_true_false_set->data[index].false_branch_state |= right_set.data[k].false_branch_state;
                            expr_true_false_set->data[index].true_branch_state |= 3;
                        }
                    }
                    arena_restore_current_state_from(ctx, original_state_number);
                    arena_remove_state(ctx, original_state_number);
                    true_false_set_destroy(&right_set);
                }
                true_false_set_destroy(&left_set);
            }
            goto __L0; /* break */

            __L128: /*case 60*/ 
            {
                struct true_false_set  left_set;
                int original_state_number;
                struct true_false_set  right_set;

                ;
                ;
                flow_check_pointer_used_as_bool(ctx, p_expression->left);
                flow_check_pointer_used_as_bool(ctx, p_expression->right);
                _cake_zmem(&left_set, 12);
                flow_visit_expression(ctx, p_expression->left, &left_set);
                original_state_number = arena_add_copy_of_current_state(ctx, "original");
                true_false_set_set_objects_to_true_branch(ctx, &left_set, nullable_enabled);
                _cake_zmem(&right_set, 12);
                flow_visit_expression(ctx, p_expression->right, &right_set);
                {
                    int i;

                    i = 0;
                    for (; i < left_set.size; i++)
                    {
                        struct true_false_set_item * p_item_left;
                        struct true_false_set_item  left_and_right;

                        p_item_left = &left_set.data[i];
                        _cake_zmem(&left_and_right, 12);
                        left_and_right.p_expression = p_item_left->p_expression;
                        left_and_right.true_branch_state |= p_item_left->true_branch_state;
                        left_and_right.false_branch_state |= p_item_left->true_branch_state | p_item_left->false_branch_state;
                        true_false_set_push_back(expr_true_false_set, &left_and_right);
                    }
                }
                {
                    int k;

                    k = 0;
                    for (; k < right_set.size; k++)
                    {
                        struct true_false_set_item * p_item_right;
                        int index;

                        p_item_right = &right_set.data[k];
                        index = find_item_index_by_expression(expr_true_false_set, p_item_right->p_expression);
                        if (index == -1)
                        {
                            struct true_false_set_item  item2;

                            index = expr_true_false_set->size;
                            item2.p_expression = p_item_right->p_expression;
                            item2.true_branch_state = 0;
                            item2.false_branch_state = 0;
                            true_false_set_push_back(expr_true_false_set, &item2);
                        }
                        expr_true_false_set->data[index].p_expression = p_item_right->p_expression;
                        expr_true_false_set->data[index].true_branch_state |= p_item_right->true_branch_state;
                        expr_true_false_set->data[index].false_branch_state |= p_item_right->false_branch_state;
                        expr_true_false_set->data[index].false_branch_state |= 3;
                    }
                }
                arena_restore_current_state_from(ctx, original_state_number);
                arena_remove_state(ctx, original_state_number);
                true_false_set_destroy(&left_set);
                true_false_set_destroy(&right_set);
            }
            goto __L0; /* break */

            __L130: /*case 58*/ 
            {
                struct true_false_set  true_false_set;

                ;
                ;
                _cake_zmem(&true_false_set, 12);
                flow_visit_expression(ctx, p_expression->left, &true_false_set);
                flow_visit_expression(ctx, p_expression->right, &true_false_set);
                true_false_set_destroy(&true_false_set);
            }
            goto __L0; /* break */

            __L131: /*case 56*/ 
            __L132: /*case 57*/ 
            ;
            ;
            flow_visit_expression(ctx, p_expression->left, expr_true_false_set);
            flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
            goto __L0; /* break */

            __L133: /*case 27*/ 
            goto __L0; /* break */

            __L134: /*case 28*/ 
            goto __L0; /* break */

            __L135: /*case 29*/ 
            goto __L0; /* break */

            __L136: /*case 72*/ 
            goto __L0; /* break */

            __L137: /*case 73*/ 
            {
                struct true_false_set  true_false_set;
                int before_if_state_number;
                struct true_false_set  set;
                int left_true_branch_state_number;
                struct true_false_set  set2;

                ;
                ;
                ;
                _cake_zmem(&true_false_set, 12);
                flow_check_pointer_used_as_bool(ctx, p_expression->condition_expr);
                flow_visit_expression(ctx, p_expression->condition_expr, &true_false_set);
                before_if_state_number = arena_add_copy_of_current_state(ctx, "before-if");
                true_false_set_set_objects_to_true_branch(ctx, &true_false_set, nullable_enabled);
                _cake_zmem(&set, 12);
                flow_visit_expression(ctx, p_expression->left, &set);
                true_false_set_destroy(&set);
                left_true_branch_state_number = arena_add_copy_of_current_state(ctx, "left-true-branch");
                arena_restore_current_state_from(ctx, before_if_state_number);
                true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
                _cake_zmem(&set2, 12);
                flow_visit_expression(ctx, p_expression->right, &set2);
                true_false_set_destroy(&set2);
                arena_merge_current_state_with_state_number(ctx, left_true_branch_state_number);
                arena_restore_current_state_from(ctx, left_true_branch_state_number);
                arena_remove_state(ctx, before_if_state_number);
                arena_remove_state(ctx, left_true_branch_state_number);
                true_false_set_destroy(&true_false_set);
            }
            goto __L0; /* break */

        }
        __L0:;
    }
}

static int parse_string_state(char * s, unsigned char * invalid)
{
    int e;
    char * p;

    *invalid = 0;
    e = 0;
    p = s;
    while (*p)
    {
        if (isalpha(*p))
        {
            int sz;
            char * start;

            sz = 0;
            start = p;
            while (isalpha(*p) || *p == 45)
            {
                sz++;
                p++;
            }
            if (strncmp(start, "moved", sz) == 0)
            {
                e |= 8;
            }
            else
            {
                if (strncmp(start, "null", sz) == 0)
                {
                    e |= 2;
                }
                else
                {
                    if (strncmp(start, "not-null", sz) == 0)
                    {
                        e |= 4;
                    }
                    else
                    {
                        if (strncmp(start, "maybe-null", sz) == 0)
                        {
                            e |= 6;
                        }
                        else
                        {
                            if (strncmp(start, "uninitialized", sz) == 0)
                            {
                                e |= 1;
                            }
                            else
                            {
                                if (strncmp(start, "zero", sz) == 0)
                                {
                                    e |= 32;
                                }
                                else
                                {
                                    if (strncmp(start, "not-zero", sz) == 0)
                                    {
                                        e |= 64;
                                    }
                                    else
                                    {
                                        if (strncmp(start, "any", sz) == 0)
                                        {
                                            e |= 96;
                                        }
                                        else
                                        {
                                            *invalid = 1;
                                            return 0;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        else
        {
            p++;
        }
    }
    return e;
}

static void flow_visit_static_assert_declaration(struct flow_visit_ctx * ctx, struct static_assert_declaration * p_static_assert_declaration)
{
    unsigned char  t2;
    unsigned char  nullable_enabled;
    struct true_false_set  a;

    t2 = ctx->expression_is_not_evaluated;
    ctx->expression_is_not_evaluated = 1;
    nullable_enabled = ctx->ctx->options.null_checks_enabled;
    _cake_zmem(&a, 12);
    flow_visit_expression(ctx, p_static_assert_declaration->constant_expression, &a);
    ctx->expression_is_not_evaluated = t2;
    if (p_static_assert_declaration->first_token->type == 9087 || p_static_assert_declaration->first_token->type == 9088)
    {
        unsigned char  ex;
        struct flow_object * p_obj;

        ex = p_static_assert_declaration->first_token->type == 9088;
        compiler_diagnostic(0, ctx->ctx, p_static_assert_declaration->first_token, 0, "static_debug");
        p_obj = expression_get_flow_object(ctx, p_static_assert_declaration->constant_expression, nullable_enabled);
        if (p_obj)
        {
            unsigned char  color_enabled;

            color_enabled = !ctx->ctx->options.color_disabled;
            print_flow_object(color_enabled, &p_static_assert_declaration->constant_expression->type, p_obj, !ex);
            if (p_obj->is_temporary)
            {
                p_obj->current.state = 128;
            }
        }
        if (ex)
        {
            print_arena(ctx);
        }
    }
    else
    {
        if (p_static_assert_declaration->first_token->type == 9089)
        {
            unsigned char  is_invalid;
            int e;

            is_invalid = 0;
            e = 0;
            if (p_static_assert_declaration->string_literal_opt)
            {
                e = parse_string_state(p_static_assert_declaration->string_literal_opt->lexeme, &is_invalid);
            }
            if (is_invalid)
            {
                compiler_diagnostic(1080, ctx->ctx, p_static_assert_declaration->first_token, 0, "invalid parameter %s", p_static_assert_declaration->string_literal_opt->lexeme);
            }
            else
            {
                struct flow_object * p_obj;

                p_obj = expression_get_flow_object(ctx, p_static_assert_declaration->constant_expression, nullable_enabled);
                if (p_obj)
                {
                    if (e != p_obj->current.state)
                    {
                        compiler_diagnostic(1080, ctx->ctx, p_static_assert_declaration->first_token, 0, "static_state failed");
                        if (p_static_assert_declaration->string_literal_opt)
                        {
                            printf("expected :%s\n", p_static_assert_declaration->string_literal_opt->lexeme);
                        }
                        printf("current  :");
                        flow_object_print_state(p_obj);
                        printf("\n");
                    }
                }
                else
                {
                    if (e != 0)
                    {
                        compiler_diagnostic(1080, ctx->ctx, p_static_assert_declaration->first_token, 0, "static_state failed");
                    }
                }
                if (p_obj && p_obj->is_temporary)
                {
                    p_obj->current.state = 128;
                }
            }
        }
        else
        {
            if (p_static_assert_declaration->first_token->type == 9090)
            {
                struct flow_object * p_obj;

                p_obj = expression_get_flow_object(ctx, p_static_assert_declaration->constant_expression, nullable_enabled);
                if (p_obj)
                {
                    if (p_static_assert_declaration->string_literal_opt)
                    {
                        char * lexeme;

                        lexeme = p_static_assert_declaration->string_literal_opt->lexeme;
                        if (strcmp(lexeme, "\"zero\"") == 0)
                        {
                            flow_object_set_zero(&p_static_assert_declaration->constant_expression->type, p_obj);
                        }
                        else
                        {
                            unsigned char  is_invalid;
                            int e;

                            is_invalid = 0;
                            e = parse_string_state(p_static_assert_declaration->string_literal_opt->lexeme, &is_invalid);
                            if (!is_invalid)
                            {
                                if (p_obj->members.size > 0)
                                {
                                    compiler_diagnostic(1070, ctx->ctx, p_static_assert_declaration->first_token, 0, "use only for non agregates");
                                }
                                p_obj->current.state = e;
                            }
                            else
                            {
                                compiler_diagnostic(1070, ctx->ctx, p_static_assert_declaration->first_token, 0, "invalid parameter %s", p_static_assert_declaration->string_literal_opt->lexeme);
                            }
                        }
                    }
                }
                if (p_obj && p_obj->is_temporary)
                {
                    p_obj->current.state = 128;
                }
            }
        }
    }
    true_false_set_destroy(&a);
}

static void flow_visit_pragma_declaration(struct flow_visit_ctx * ctx, struct pragma_declaration * p_pragma_declaration)
{
    execute_pragma_declaration(ctx->ctx, p_pragma_declaration, 1);
}

static unsigned char flow_is_last_item_return(struct compound_statement * p_compound_statement)
{
    if (p_compound_statement && p_compound_statement->block_item_list.tail && p_compound_statement->block_item_list.tail->unlabeled_statement && p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement && p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement->first_token && p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement->first_token->type == 9027)
    {
        return 1;
    }
    return 0;
}
void flow_start_visit_declaration(struct flow_visit_ctx * ctx, struct declaration * p_declaration)
{
    ctx->labels_size = 0;
    flow_objects_clear(&ctx->arena);
    ctx->state_number_generator = 1;
    if (p_declaration->function_body)
    {
        flow_visit_declaration(ctx, p_declaration);
    }
    else
    {
        flow_visit_declaration(ctx, p_declaration);
    }
    flow_objects_clear(&ctx->arena);
}


struct flow_object *arena_new_object(struct flow_visit_ctx * ctx)
{
    struct flow_object * p;

    p = calloc(1, 68);
    if (p != 0)
    {
        p->current.dbg_name = "current";
        p->id = ctx->arena.size + 1;
        if (flow_objects_push_back(&ctx->arena, p) != 0)
        {
            p = 0;
        }
    }
    return (struct flow_object *)p;
}


void flow_visit_ctx_destroy(struct flow_visit_ctx * p)
{
    flow_objects_destroy(&p->arena);
}


void throw_break_point()
{
}


char *get_posix_error_message(int error)
{
    /*switch*/
    {
        int __v0 = error;
        if (__v0 == 1) goto __L1; /*case 1*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 3) goto __L3; /*case 3*/
        if (__v0 == 4) goto __L4; /*case 4*/
        if (__v0 == 5) goto __L5; /*case 5*/
        if (__v0 == 6) goto __L6; /*case 6*/
        if (__v0 == 7) goto __L7; /*case 7*/
        if (__v0 == 8) goto __L8; /*case 8*/
        if (__v0 == 9) goto __L9; /*case 9*/
        if (__v0 == 10) goto __L10; /*case 10*/
        if (__v0 == 11) goto __L11; /*case 11*/
        if (__v0 == 12) goto __L12; /*case 12*/
        if (__v0 == 13) goto __L13; /*case 13*/
        if (__v0 == 14) goto __L14; /*case 14*/
        if (__v0 == 16) goto __L15; /*case 16*/
        if (__v0 == 17) goto __L16; /*case 17*/
        if (__v0 == 18) goto __L17; /*case 18*/
        if (__v0 == 19) goto __L18; /*case 19*/
        if (__v0 == 20) goto __L19; /*case 20*/
        if (__v0 == 21) goto __L20; /*case 21*/
        if (__v0 == 22) goto __L21; /*case 22*/
        if (__v0 == 23) goto __L22; /*case 23*/
        if (__v0 == 24) goto __L23; /*case 24*/
        if (__v0 == 25) goto __L24; /*case 25*/
        if (__v0 == 139) goto __L25; /*case 139*/
        if (__v0 == 27) goto __L26; /*case 27*/
        if (__v0 == 28) goto __L27; /*case 28*/
        if (__v0 == 29) goto __L28; /*case 29*/
        if (__v0 == 30) goto __L29; /*case 30*/
        if (__v0 == 31) goto __L30; /*case 31*/
        if (__v0 == 32) goto __L31; /*case 32*/
        if (__v0 == 33) goto __L32; /*case 33*/
        if (__v0 == 34) goto __L33; /*case 34*/
        if (__v0 == 36) goto __L34; /*case 36*/
        if (__v0 == 38) goto __L35; /*case 38*/
        if (__v0 == 39) goto __L36; /*case 39*/
        if (__v0 == 40) goto __L37; /*case 40*/
        if (__v0 == 41) goto __L38; /*case 41*/
        if (__v0 == 114) goto __L39; /*case 114*/
        if (__v0 == 122) goto __L40; /*case 122*/
        if (__v0 == 111) goto __L41; /*case 111*/
        if (__v0 == 125) goto __L42; /*case 125*/
        if (__v0 == 120) goto __L43; /*case 120*/
        if (__v0 == 137) goto __L44; /*case 137*/
        if (__v0 == 124) goto __L45; /*case 124*/
        if (__v0 == 121) goto __L46; /*case 121*/
        if (__v0 == 134) goto __L47; /*case 134*/
        if (__v0 == 104) goto __L48; /*case 104*/
        if (__v0 == 132) goto __L49; /*case 132*/
        if (__v0 == 42) goto __L50; /*case 42*/
        if (__v0 == 128) goto __L51; /*case 128*/
        if (__v0 == 109) goto __L52; /*case 109*/
        if (__v0 == 115) goto __L53; /*case 115*/
        if (__v0 == 136) goto __L54; /*case 136*/
        if (__v0 == 123) goto __L55; /*case 123*/
        if (__v0 == 135) goto __L56; /*case 135*/
        if (__v0 == 130) goto __L57; /*case 130*/
        if (__v0 == 102) goto __L58; /*case 102*/
        if (__v0 == 100) goto __L59; /*case 100*/
        if (__v0 == 101) goto __L60; /*case 101*/
        if (__v0 == 116) goto __L61; /*case 116*/
        if (__v0 == 118) goto __L62; /*case 118*/
        if (__v0 == 117) goto __L63; /*case 117*/
        if (__v0 == 106) goto __L64; /*case 106*/
        if (__v0 == 108) goto __L65; /*case 108*/
        if (__v0 == 119) goto __L66; /*case 119*/
        if (__v0 == 113) goto __L67; /*case 113*/
        if (__v0 == 126) goto __L68; /*case 126*/
        if (__v0 == 138) goto __L69; /*case 138*/
        if (__v0 == 107) goto __L70; /*case 107*/
        if (__v0 == 110) goto __L71; /*case 110*/
        if (__v0 == 103) goto __L72; /*case 103*/
        if (__v0 == 112) goto __L73; /*case 112*/
        goto __L74; /* default */

        {
            __L1: /*case 1*/ 
            return "Operation not permitted";
            __L2: /*case 2*/ 
            return "No such file or directory";
            __L3: /*case 3*/ 
            return "No such process";
            __L4: /*case 4*/ 
            return "Interrupted system call";
            __L5: /*case 5*/ 
            return "I/O error";
            __L6: /*case 6*/ 
            return "No such device or address";
            __L7: /*case 7*/ 
            return "Arg list too long";
            __L8: /*case 8*/ 
            return "Exec string_format error";
            __L9: /*case 9*/ 
            return "Bad file number";
            __L10: /*case 10*/ 
            return "No child processes";
            __L11: /*case 11*/ 
            return "Try again";
            __L12: /*case 12*/ 
            return "Out of memory";
            __L13: /*case 13*/ 
            return "Permission denied";
            __L14: /*case 14*/ 
            return "Bad address";
            __L15: /*case 16*/ 
            return "Device or resource busy";
            __L16: /*case 17*/ 
            return "File exists";
            __L17: /*case 18*/ 
            return "Cross-device link";
            __L18: /*case 19*/ 
            return "No such device";
            __L19: /*case 20*/ 
            return "Not a directory";
            __L20: /*case 21*/ 
            return "Is a directory";
            __L21: /*case 22*/ 
            return "Invalid argument";
            __L22: /*case 23*/ 
            return "File table overflow";
            __L23: /*case 24*/ 
            return "Too many open files";
            __L24: /*case 25*/ 
            return "Not a typewriter";
            __L25: /*case 139*/ 
            return "Text file busy";
            __L26: /*case 27*/ 
            return "File too large";
            __L27: /*case 28*/ 
            return "No space left on device";
            __L28: /*case 29*/ 
            return "Illegal seek";
            __L29: /*case 30*/ 
            return "Read-only file system";
            __L30: /*case 31*/ 
            return "Too many links";
            __L31: /*case 32*/ 
            return "Broken pipe";
            __L32: /*case 33*/ 
            return "Math argument out of domain of func";
            __L33: /*case 34*/ 
            return "Math result not representable";
            __L34: /*case 36*/ 
            return "Resource deadlock would occur";
            __L35: /*case 38*/ 
            return "File name too long";
            __L36: /*case 39*/ 
            return "No record locks available";
            __L37: /*case 40*/ 
            return "Function not implemented";
            __L38: /*case 41*/ 
            return "Directory not empty";
            __L39: /*case 114*/ 
            return "Too many symbolic links encountered";
            __L40: /*case 122*/ 
            return "No message of desired type";
            __L41: /*case 111*/ 
            return "Identifier removed";
            __L42: /*case 125*/ 
            return "Device not a stream";
            __L43: /*case 120*/ 
            return "No data available";
            __L44: /*case 137*/ 
            return "Timer expired";
            __L45: /*case 124*/ 
            return "Out of streams resources";
            __L46: /*case 121*/ 
            return "Link has been severed";
            __L47: /*case 134*/ 
            return "Protocol error";
            __L48: /*case 104*/ 
            return "Not a data message";
            __L49: /*case 132*/ 
            return "Value too large for defined data type";
            __L50: /*case 42*/ 
            return "Illegal byte sequence";
            __L51: /*case 128*/ 
            return "Socket operation on non-socket";
            __L52: /*case 109*/ 
            return "Destination address required";
            __L53: /*case 115*/ 
            return "Message too long";
            __L54: /*case 136*/ 
            return "Protocol wrong type for socket";
            __L55: /*case 123*/ 
            return "Protocol not available";
            __L56: /*case 135*/ 
            return "Protocol not supported";
            __L57: /*case 130*/ 
            return "Operation not supported on transport endpoint";
            __L58: /*case 102*/ 
            return "Address family not supported by protocol";
            __L59: /*case 100*/ 
            return "Address already in use";
            __L60: /*case 101*/ 
            return "Cannot assign requested address";
            __L61: /*case 116*/ 
            return "Network is down";
            __L62: /*case 118*/ 
            return "Network is unreachable";
            __L63: /*case 117*/ 
            return "Network dropped connection because of reset";
            __L64: /*case 106*/ 
            return "Software caused connection abort";
            __L65: /*case 108*/ 
            return "Connection reset by peer";
            __L66: /*case 119*/ 
            return "No buffer space available";
            __L67: /*case 113*/ 
            return "Transport endpoint is already connected";
            __L68: /*case 126*/ 
            return "Transport endpoint is not connected";
            __L69: /*case 138*/ 
            return "Connection timed out";
            __L70: /*case 107*/ 
            return "Connection refused";
            __L71: /*case 110*/ 
            return "No route to host";
            __L72: /*case 103*/ 
            return "Operation already in progress";
            __L73: /*case 112*/ 
            return "Operation now in progress";
            __L74: /* default */ 
            goto __L0; /* break */

        }
        __L0:;
    }
    return "Unknown";
}


int windows_error_to_posix(int i)
{
    /*switch*/
    {
        int __v0 = i;
        if (__v0 == 5L) goto __L1; /*case 5L*/
        if (__v0 == 183L) goto __L2; /*case 183L*/
        if (__v0 == 20L) goto __L3; /*case 20L*/
        if (__v0 == 111L) goto __L4; /*case 111L*/
        if (__v0 == 170L) goto __L5; /*case 170L*/
        if (__v0 == 142L) goto __L6; /*case 142L*/
        if (__v0 == 82L) goto __L7; /*case 82L*/
        if (__v0 == 1011L) goto __L8; /*case 1011L*/
        if (__v0 == 1012L) goto __L9; /*case 1012L*/
        if (__v0 == 1013L) goto __L10; /*case 1013L*/
        if (__v0 == 16L) goto __L11; /*case 16L*/
        if (__v0 == 55L) goto __L12; /*case 55L*/
        if (__v0 == 2404L) goto __L13; /*case 2404L*/
        if (__v0 == 145L) goto __L14; /*case 145L*/
        if (__v0 == 267L) goto __L15; /*case 267L*/
        if (__v0 == 112L) goto __L16; /*case 112L*/
        if (__v0 == 80L) goto __L17; /*case 80L*/
        if (__v0 == 2L) goto __L18; /*case 2L*/
        if (__v0 == 39L) goto __L19; /*case 39L*/
        if (__v0 == 12L) goto __L20; /*case 12L*/
        if (__v0 == 15L) goto __L21; /*case 15L*/
        if (__v0 == 1L) goto __L22; /*case 1L*/
        if (__v0 == 6L) goto __L23; /*case 6L*/
        if (__v0 == 123L) goto __L24; /*case 123L*/
        if (__v0 == 33L) goto __L25; /*case 33L*/
        if (__v0 == 212L) goto __L26; /*case 212L*/
        if (__v0 == 131L) goto __L27; /*case 131L*/
        if (__v0 == 998L) goto __L28; /*case 998L*/
        if (__v0 == 8L) goto __L29; /*case 8L*/
        if (__v0 == 21L) goto __L30; /*case 21L*/
        if (__v0 == 17L) goto __L31; /*case 17L*/
        if (__v0 == 110L) goto __L32; /*case 110L*/
        if (__v0 == 2401L) goto __L33; /*case 2401L*/
        if (__v0 == 995L) goto __L34; /*case 995L*/
        if (__v0 == 14L) goto __L35; /*case 14L*/
        if (__v0 == 3L) goto __L36; /*case 3L*/
        if (__v0 == 30L) goto __L37; /*case 30L*/
        if (__v0 == 1237L) goto __L38; /*case 1237L*/
        if (__v0 == 25L) goto __L39; /*case 25L*/
        if (__v0 == 32L) goto __L40; /*case 32L*/
        if (__v0 == 4L) goto __L41; /*case 4L*/
        if (__v0 == 29L) goto __L42; /*case 29L*/
        if (__v0 == 19L) goto __L43; /*case 19L*/
        if (__v0 == 10013L) goto __L44; /*case 10013L*/
        if (__v0 == 10048L) goto __L45; /*case 10048L*/
        if (__v0 == 10049L) goto __L46; /*case 10049L*/
        if (__v0 == 10047L) goto __L47; /*case 10047L*/
        if (__v0 == 10037L) goto __L48; /*case 10037L*/
        if (__v0 == 10009L) goto __L49; /*case 10009L*/
        if (__v0 == 10053L) goto __L50; /*case 10053L*/
        if (__v0 == 10061L) goto __L51; /*case 10061L*/
        if (__v0 == 10054L) goto __L52; /*case 10054L*/
        if (__v0 == 10039L) goto __L53; /*case 10039L*/
        if (__v0 == 10014L) goto __L54; /*case 10014L*/
        if (__v0 == 10065L) goto __L55; /*case 10065L*/
        if (__v0 == 10036L) goto __L56; /*case 10036L*/
        if (__v0 == 10004L) goto __L57; /*case 10004L*/
        if (__v0 == 10022L) goto __L58; /*case 10022L*/
        if (__v0 == 10056L) goto __L59; /*case 10056L*/
        if (__v0 == 10024L) goto __L60; /*case 10024L*/
        if (__v0 == 10040L) goto __L61; /*case 10040L*/
        if (__v0 == 10050L) goto __L62; /*case 10050L*/
        if (__v0 == 10052L) goto __L63; /*case 10052L*/
        if (__v0 == 10051L) goto __L64; /*case 10051L*/
        if (__v0 == 10055L) goto __L65; /*case 10055L*/
        if (__v0 == 10042L) goto __L66; /*case 10042L*/
        if (__v0 == 10057L) goto __L67; /*case 10057L*/
        if (__v0 == 10038L) goto __L68; /*case 10038L*/
        if (__v0 == 10045L) goto __L69; /*case 10045L*/
        if (__v0 == 10043L) goto __L70; /*case 10043L*/
        if (__v0 == 10041L) goto __L71; /*case 10041L*/
        if (__v0 == 10060L) goto __L72; /*case 10060L*/
        if (__v0 == 10035L) goto __L73; /*case 10035L*/
        goto __L74; /* default */

        {
            __L1: /*case 5L*/ 
            return 13;
            __L2: /*case 183L*/ 
            return 17;
            __L3: /*case 20L*/ 
            return 19;
            __L4: /*case 111L*/ 
            return 38;
            __L5: /*case 170L*/ 
            return 16;
            __L6: /*case 142L*/ 
            return 16;
            __L7: /*case 82L*/ 
            return 13;
            __L8: /*case 1011L*/ 
            return 5;
            __L9: /*case 1012L*/ 
            return 5;
            __L10: /*case 1013L*/ 
            return 5;
            __L11: /*case 16L*/ 
            return 13;
            __L12: /*case 55L*/ 
            return 19;
            __L13: /*case 2404L*/ 
            return 16;
            __L14: /*case 145L*/ 
            return 41;
            __L15: /*case 267L*/ 
            return 22;
            __L16: /*case 112L*/ 
            return 28;
            __L17: /*case 80L*/ 
            return 17;
            __L18: /*case 2L*/ 
            return 2;
            __L19: /*case 39L*/ 
            return 28;
            __L20: /*case 12L*/ 
            return 13;
            __L21: /*case 15L*/ 
            return 19;
            __L22: /*case 1L*/ 
            return 40;
            __L23: /*case 6L*/ 
            return 22;
            __L24: /*case 123L*/ 
            return 22;
            __L25: /*case 33L*/ 
            return 39;
            __L26: /*case 212L*/ 
            return 39;
            __L27: /*case 131L*/ 
            return 22;
            __L28: /*case 998L*/ 
            return 13;
            __L29: /*case 8L*/ 
            return 12;
            __L30: /*case 21L*/ 
            return 11;
            __L31: /*case 17L*/ 
            return 18;
            __L32: /*case 110L*/ 
            return 5;
            __L33: /*case 2401L*/ 
            return 16;
            __L34: /*case 995L*/ 
            return 105;
            __L35: /*case 14L*/ 
            return 12;
            __L36: /*case 3L*/ 
            return 2;
            __L37: /*case 30L*/ 
            return 5;
            __L38: /*case 1237L*/ 
            return 11;
            __L39: /*case 25L*/ 
            return 5;
            __L40: /*case 32L*/ 
            return 13;
            __L41: /*case 4L*/ 
            return 24;
            __L42: /*case 29L*/ 
            return 5;
            __L43: /*case 19L*/ 
            return 13;
            __L44: /*case 10013L*/ 
            return 13;
            __L45: /*case 10048L*/ 
            return 100;
            __L46: /*case 10049L*/ 
            return 101;
            __L47: /*case 10047L*/ 
            return 102;
            __L48: /*case 10037L*/ 
            return 103;
            __L49: /*case 10009L*/ 
            return 9;
            __L50: /*case 10053L*/ 
            return 106;
            __L51: /*case 10061L*/ 
            return 107;
            __L52: /*case 10054L*/ 
            return 108;
            __L53: /*case 10039L*/ 
            return 109;
            __L54: /*case 10014L*/ 
            return 14;
            __L55: /*case 10065L*/ 
            return 110;
            __L56: /*case 10036L*/ 
            return 112;
            __L57: /*case 10004L*/ 
            return 4;
            __L58: /*case 10022L*/ 
            return 22;
            __L59: /*case 10056L*/ 
            return 113;
            __L60: /*case 10024L*/ 
            return 24;
            __L61: /*case 10040L*/ 
            return 115;
            __L62: /*case 10050L*/ 
            return 116;
            __L63: /*case 10052L*/ 
            return 117;
            __L64: /*case 10051L*/ 
            return 118;
            __L65: /*case 10055L*/ 
            return 119;
            __L66: /*case 10042L*/ 
            return 123;
            __L67: /*case 10057L*/ 
            return 126;
            __L68: /*case 10038L*/ 
            return 128;
            __L69: /*case 10045L*/ 
            return 130;
            __L70: /*case 10043L*/ 
            return 135;
            __L71: /*case 10041L*/ 
            return 136;
            __L72: /*case 10060L*/ 
            return 138;
            __L73: /*case 10035L*/ 
            return 140;
            __L74: /* default */ 
            goto __L0; /* break */

        }
        __L0:;
    }
    return 1;
}


static struct platform  platform_x86_x64_gcc = {"x86_x64_gcc","__thread","__attribute__((aligned(%d)))",8,1,1,8,0,1,16,2,32,4,64,8,64,8,32,4,64,8,128,16,64,8,4,0,2,4,6,7,6};

static struct platform  platform_x86_msvc = {"x86_msvc","__declspec(thread)","__declspec(align(%d))",8,1,1,8,0,1,16,2,32,4,32,4,64,8,32,4,64,8,64,8,32,4,3,0,2,4,8,5,4};

static struct platform  platform_x64_msvc = {"x64_msvc","__declspec(thread)","__declspec(align(%d))",8,1,1,8,0,1,16,2,32,4,32,4,64,8,32,4,64,8,64,8,64,8,3,0,2,4,8,9,8};

static struct platform  platform_ccu8 = {"ccu8","/*thread*/","__attribute__((aligned(%d)))",8,1,1,8,0,1,16,2,16,2,64,4,64,8,32,32,64,8,64,8,32,8,3,0,2,4,8,5,4};

static struct platform  platform_catalina = {"catalina","/*thread*/","__attribute__((aligned(%d)))",8,1,1,8,1,1,16,2,32,4,32,4,32,4,32,4,32,4,32,4,32,4,3,0,2,4,8,5,4};

static struct platform *platforms[6] = {&platform_x86_x64_gcc,&platform_x86_msvc,&platform_x64_msvc,&platform_ccu8,&platform_ccu8,&platform_catalina};


int parse_target(char * targetstr, int * target)
{
    {
        int i;

        i = 0;
        for (; i < 6; i++)
        {
            if (strcmp(targetstr, platforms[i]->name) == 0)
            {
                *target = i;
                return 0;
            }
        }
    }
    return 1;
}


void print_target_options()
{
    {
        int i;

        i = 0;
        for (; i < 6; i++)
        {
            printf("%s ", platforms[i]->name);
        }
    }
    printf("\n");
}


struct platform *get_platform(int target)
{
    return platforms[target];
}


long long target_signed_max(int target, int type)
{
    int bits;

    bits = target_get_num_of_bits(target, type);
    ;
    if (bits >= 64)
    {
        return 9223372036854775807LL;
    }
    return (1LL << (bits - 1)) - 1;
}


unsigned long long target_unsigned_max(int target, int type)
{
    int bits;

    bits = target_get_num_of_bits(target, type);
    ;
    if (bits >= 64)
    {
        return 18446744073709551615ULL;
    }
    return (1ULL << bits) - 1;
}


int target_get_num_of_bits(int target, int type)
{
    /*switch*/
    {
        int __v0 = type;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 1) goto __L2; /*case 1*/
        if (__v0 == 2) goto __L3; /*case 2*/
        if (__v0 == 3) goto __L4; /*case 3*/
        if (__v0 == 4) goto __L5; /*case 4*/
        if (__v0 == 5) goto __L6; /*case 5*/
        if (__v0 == 6) goto __L7; /*case 6*/
        if (__v0 == 7) goto __L8; /*case 7*/
        if (__v0 == 8) goto __L9; /*case 8*/
        if (__v0 == 9) goto __L10; /*case 9*/
        if (__v0 == 10) goto __L11; /*case 10*/
        if (__v0 == 11) goto __L12; /*case 11*/
        if (__v0 == 12) goto __L13; /*case 12*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            __L2: /*case 1*/ 
            return get_platform(target)->char_n_bits;
            __L3: /*case 2*/ 
            __L4: /*case 3*/ 
            return get_platform(target)->short_n_bits;
            __L5: /*case 4*/ 
            __L6: /*case 5*/ 
            return get_platform(target)->int_n_bits;
            __L7: /*case 6*/ 
            __L8: /*case 7*/ 
            return get_platform(target)->long_n_bits;
            __L9: /*case 8*/ 
            __L10: /*case 9*/ 
            return get_platform(target)->long_long_n_bits;
            __L11: /*case 10*/ 
            return get_platform(target)->float_n_bits;
            __L12: /*case 11*/ 
            return get_platform(target)->double_n_bits;
            __L13: /*case 12*/ 
            return get_platform(target)->long_double_n_bits;
        }
        __L0:;
    }
    ;
    return 0;
}


static char x86_x64_gcc_macros[5700] = {10,35,100,101,102,105,110,101,32,95,67,79,78,83,79,76,69,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,78,79,95,65,84,79,77,73,67,83,95,95,32,95,95,83,84,68,67,95,78,79,95,65,84,79,77,73,67,83,95,95,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,78,79,95,67,79,77,80,76,69,88,95,95,32,32,95,95,83,84,68,67,95,78,79,95,67,79,77,80,76,69,88,95,95,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,78,79,95,84,72,82,69,65,68,83,95,95,32,32,32,95,95,83,84,68,67,95,78,79,95,84,72,82,69,65,68,83,95,95,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,78,79,95,86,76,65,95,95,32,32,32,32,95,95,83,84,68,67,95,78,79,95,86,76,65,95,95,10,35,100,101,102,105,110,101,32,95,95,108,105,110,117,120,95,95,32,32,32,32,32,32,32,32,32,32,32,32,49,10,35,100,101,102,105,110,101,32,95,95,101,120,116,101,110,115,105,111,110,95,95,32,32,32,32,32,32,32,32,10,35,100,101,102,105,110,101,32,95,95,71,78,85,67,95,95,32,32,32,32,32,32,32,32,32,32,32,32,32,52,10,35,100,101,102,105,110,101,32,95,95,71,78,85,67,95,77,73,78,79,82,95,95,32,32,32,32,32,32,32,49,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,72,79,83,84,69,68,95,95,32,32,32,32,32,32,49,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,95,32,32,32,32,32,32,32,32,32,32,32,32,32,49,10,35,100,101,102,105,110,101,32,95,95,120,56,54,95,54,52,95,95,32,32,32,32,32,32,32,32,32,32,32,49,10,35,100,101,102,105,110,101,32,95,95,67,72,65,82,95,66,73,84,95,95,32,32,32,32,32,32,32,32,32,56,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,95,84,89,80,69,95,95,32,32,32,32,32,32,32,32,117,110,115,105,103,110,101,100,32,108,111,110,103,10,35,100,101,102,105,110,101,32,95,95,80,84,82,68,73,70,70,95,84,89,80,69,95,95,32,32,32,32,32,108,111,110,103,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,87,67,72,65,82,95,84,89,80,69,95,95,32,32,32,32,32,32,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,87,73,78,84,95,84,89,80,69,95,95,32,32,32,32,32,32,32,32,117,110,115,105,103,110,101,100,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,73,78,84,77,65,88,95,84,89,80,69,95,95,32,32,32,32,32,32,108,111,110,103,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,77,65,88,95,84,89,80,69,95,95,32,32,32,32,32,108,111,110,103,32,117,110,115,105,103,110,101,100,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,83,73,71,95,65,84,79,77,73,67,95,84,89,80,69,95,95,32,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,73,78,84,56,95,84,89,80,69,95,95,32,32,32,32,32,32,32,32,115,105,103,110,101,100,32,99,104,97,114,10,35,100,101,102,105,110,101,32,95,95,73,78,84,49,54,95,84,89,80,69,95,95,32,32,32,32,32,32,32,115,104,111,114,116,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,73,78,84,51,50,95,84,89,80,69,95,95,32,32,32,32,32,32,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,73,78,84,54,52,95,84,89,80,69,95,95,32,32,32,32,32,32,32,108,111,110,103,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,56,95,84,89,80,69,95,95,32,32,32,32,32,32,32,117,110,115,105,103,110,101,100,32,99,104,97,114,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,49,54,95,84,89,80,69,95,95,32,32,32,32,32,32,115,104,111,114,116,32,117,110,115,105,103,110,101,100,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,51,50,95,84,89,80,69,95,95,32,32,32,32,32,32,117,110,115,105,103,110,101,100,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,54,52,95,84,89,80,69,95,95,32,32,32,32,32,32,108,111,110,103,32,117,110,115,105,103,110,101,100,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,76,69,65,83,84,56,95,84,89,80,69,95,95,32,32,115,105,103,110,101,100,32,99,104,97,114,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,76,69,65,83,84,49,54,95,84,89,80,69,95,95,32,115,104,111,114,116,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,76,69,65,83,84,51,50,95,84,89,80,69,95,95,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,76,69,65,83,84,54,52,95,84,89,80,69,95,95,32,108,111,110,103,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,76,69,65,83,84,56,95,84,89,80,69,95,95,32,117,110,115,105,103,110,101,100,32,99,104,97,114,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,76,69,65,83,84,49,54,95,84,89,80,69,95,95,32,115,104,111,114,116,32,117,110,115,105,103,110,101,100,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,76,69,65,83,84,51,50,95,84,89,80,69,95,95,32,117,110,115,105,103,110,101,100,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,76,69,65,83,84,54,52,95,84,89,80,69,95,95,32,108,111,110,103,32,117,110,115,105,103,110,101,100,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,70,65,83,84,56,95,84,89,80,69,95,95,32,32,32,32,115,105,103,110,101,100,32,99,104,97,114,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,70,65,83,84,49,54,95,84,89,80,69,95,95,32,32,32,108,111,110,103,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,70,65,83,84,51,50,95,84,89,80,69,95,95,32,32,32,108,111,110,103,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,70,65,83,84,54,52,95,84,89,80,69,95,95,32,32,32,108,111,110,103,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,70,65,83,84,56,95,84,89,80,69,95,95,32,32,32,117,110,115,105,103,110,101,100,32,99,104,97,114,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,70,65,83,84,49,54,95,84,89,80,69,95,95,32,32,108,111,110,103,32,117,110,115,105,103,110,101,100,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,70,65,83,84,51,50,95,84,89,80,69,95,95,32,32,108,111,110,103,32,117,110,115,105,103,110,101,100,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,70,65,83,84,54,52,95,84,89,80,69,95,95,32,32,108,111,110,103,32,117,110,115,105,103,110,101,100,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,73,78,84,80,84,82,95,84,89,80,69,95,95,32,32,32,32,32,32,32,108,111,110,103,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,80,84,82,95,84,89,80,69,95,95,32,32,32,32,32,32,108,111,110,103,32,117,110,115,105,103,110,101,100,32,105,110,116,10,35,100,101,102,105,110,101,32,95,95,68,66,76,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,32,32,40,40,100,111,117,98,108,101,41,49,46,55,57,55,54,57,51,49,51,52,56,54,50,51,49,53,55,48,56,49,52,53,50,55,52,50,51,55,51,49,55,48,52,51,53,55,101,43,51,48,56,76,41,10,35,100,101,102,105,110,101,32,95,95,68,66,76,95,77,73,78,95,95,32,32,32,32,32,32,32,32,32,32,32,40,40,100,111,117,98,108,101,41,50,46,50,50,53,48,55,51,56,53,56,53,48,55,50,48,49,51,56,51,48,57,48,50,51,50,55,49,55,51,51,50,52,48,52,48,54,101,45,51,48,56,76,41,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,82,65,68,73,88,95,95,32,32,32,32,32,32,32,32,32,50,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,69,80,83,73,76,79,78,95,95,32,32,32,32,32,32,32,49,46,49,57,50,48,57,50,56,57,53,53,48,55,56,49,50,53,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,101,45,55,70,10,35,100,101,102,105,110,101,32,95,95,68,66,76,95,69,80,83,73,76,79,78,95,95,32,32,32,32,32,32,32,40,40,100,111,117,98,108,101,41,50,46,50,50,48,52,52,54,48,52,57,50,53,48,51,49,51,48,56,48,56,52,55,50,54,51,51,51,54,49,56,49,54,52,48,54,50,101,45,49,54,76,41,10,35,100,101,102,105,110,101,32,95,95,76,68,66,76,95,69,80,83,73,76,79,78,95,95,32,32,32,32,32,32,49,46,48,56,52,50,48,50,49,55,50,52,56,53,53,48,52,52,51,52,48,48,55,52,53,50,56,48,48,56,54,57,57,52,49,55,49,101,45,49,57,76,10,35,100,101,102,105,110,101,32,95,95,68,66,76,95,68,69,67,73,77,65,76,95,68,73,71,95,95,32,32,32,49,55,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,69,86,65,76,95,77,69,84,72,79,68,95,95,32,32,32,48,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,82,65,68,73,88,95,95,32,32,32,32,32,32,32,32,32,50,10,35,100,101,102,105,110,101,32,95,95,68,66,76,95,77,65,88,95,69,88,80,95,95,32,32,32,32,32,32,32,49,48,50,52,10,35,100,101,102,105,110,101,32,95,95,68,69,67,73,77,65,76,95,68,73,71,95,95,32,32,32,32,32,32,32,50,49,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,68,69,67,73,77,65,76,95,68,73,71,95,95,32,32,32,57,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,77,73,78,95,49,48,95,69,88,80,95,95,32,32,32,32,40,45,51,55,41,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,77,73,78,95,95,32,32,32,32,32,32,32,32,32,32,32,49,46,49,55,53,52,57,52,51,53,48,56,50,50,50,56,55,53,48,55,57,54,56,55,51,54,53,51,55,50,50,50,50,52,53,54,56,101,45,51,56,70,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,32,32,51,46,52,48,50,56,50,51,52,54,54,51,56,53,50,56,56,53,57,56,49,49,55,48,52,49,56,51,52,56,52,53,49,54,57,50,53,101,43,51,56,70,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,69,80,83,73,76,79,78,95,95,32,32,32,32,32,32,32,49,46,49,57,50,48,57,50,56,57,53,53,48,55,56,49,50,53,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,101,45,55,70,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,68,73,71,95,95,32,32,32,32,32,32,32,32,32,32,32,54,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,77,65,78,84,95,68,73,71,95,95,32,32,32,32,32,32,50,52,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,77,73,78,95,69,88,80,95,95,32,32,32,32,32,32,32,40,45,49,50,53,41,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,77,65,88,95,49,48,95,69,88,80,95,95,32,32,32,32,51,56,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,69,86,65,76,95,77,69,84,72,79,68,95,95,32,32,32,48,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,77,65,88,95,69,88,80,95,95,32,32,32,32,32,32,32,49,50,56,10,35,100,101,102,105,110,101,32,95,95,70,76,84,95,72,65,83,95,68,69,78,79,82,77,95,95,32,32,32,32,49,10,35,100,101,102,105,110,101,32,95,95,83,67,72,65,82,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,48,120,55,102,10,35,100,101,102,105,110,101,32,95,95,87,67,72,65,82,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,48,120,55,102,102,102,102,102,102,102,10,35,100,101,102,105,110,101,32,95,95,83,72,82,84,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,32,48,120,55,102,102,102,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,32,32,48,120,55,102,102,102,102,102,102,102,10,35,100,101,102,105,110,101,32,95,95,76,79,78,71,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,32,48,120,55,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,76,10,35,100,101,102,105,110,101,32,95,95,76,79,78,71,95,76,79,78,71,95,77,65,88,95,95,32,32,32,32,32,48,120,55,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,76,76,10,35,100,101,102,105,110,101,32,95,95,87,73,78,84,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,32,48,120,102,102,102,102,102,102,102,102,85,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,32,48,120,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,85,76,10,35,100,101,102,105,110,101,32,95,95,80,84,82,68,73,70,70,95,77,65,88,95,95,32,32,32,32,32,32,32,48,120,55,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,76,10,35,100,101,102,105,110,101,32,95,95,73,78,84,77,65,88,95,77,65,88,95,95,32,32,32,32,32,32,32,32,48,120,55,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,76,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,77,65,88,95,77,65,88,95,95,32,32,32,32,32,32,32,48,120,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,85,76,10,35,100,101,102,105,110,101,32,95,95,83,73,71,95,65,84,79,77,73,67,95,77,65,88,95,95,32,32,32,32,48,120,55,102,102,102,102,102,102,102,10,35,100,101,102,105,110,101,32,95,95,73,78,84,56,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,32,48,120,55,102,10,35,100,101,102,105,110,101,32,95,95,73,78,84,49,54,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,48,120,55,102,102,102,10,35,100,101,102,105,110,101,32,95,95,73,78,84,51,50,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,48,120,55,102,102,102,102,102,102,102,10,35,100,101,102,105,110,101,32,95,95,73,78,84,54,52,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,48,120,55,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,76,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,56,95,77,65,88,95,95,32,32,32,32,32,32,32,32,32,48,120,102,102,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,49,54,95,77,65,88,95,95,32,32,32,32,32,32,32,32,48,120,102,102,102,102,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,51,50,95,77,65,88,95,95,32,32,32,32,32,32,32,32,48,120,102,102,102,102,102,102,102,102,85,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,54,52,95,77,65,88,95,95,32,32,32,32,32,32,32,32,48,120,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,85,76,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,76,69,65,83,84,56,95,77,65,88,95,95,32,32,32,32,48,120,55,102,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,76,69,65,83,84,49,54,95,77,65,88,95,95,32,32,32,48,120,55,102,102,102,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,76,69,65,83,84,51,50,95,77,65,88,95,95,32,32,32,48,120,55,102,102,102,102,102,102,102,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,76,69,65,83,84,54,52,95,77,65,88,95,95,32,32,32,48,120,55,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,76,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,76,69,65,83,84,56,95,77,65,88,95,95,32,32,32,48,120,102,102,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,76,69,65,83,84,49,54,95,77,65,88,95,95,32,32,48,120,102,102,102,102,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,76,69,65,83,84,51,50,95,77,65,88,95,95,32,32,48,120,102,102,102,102,102,102,102,102,85,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,76,69,65,83,84,54,52,95,77,65,88,95,95,32,32,48,120,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,85,76,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,70,65,83,84,56,95,77,65,88,95,95,32,32,32,32,32,48,120,55,102,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,70,65,83,84,49,54,95,77,65,88,95,95,32,32,32,32,48,120,55,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,76,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,70,65,83,84,51,50,95,77,65,88,95,95,32,32,32,32,48,120,55,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,76,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,70,65,83,84,54,52,95,77,65,88,95,95,32,32,32,32,48,120,55,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,76,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,70,65,83,84,56,95,77,65,88,95,95,32,32,32,32,48,120,102,102,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,70,65,83,84,49,54,95,77,65,88,95,95,32,32,32,48,120,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,85,76,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,70,65,83,84,51,50,95,77,65,88,95,95,32,32,32,48,120,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,85,76,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,95,70,65,83,84,54,52,95,77,65,88,95,95,32,32,32,48,120,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,85,76,10,35,100,101,102,105,110,101,32,95,95,73,78,84,80,84,82,95,77,65,88,95,95,32,32,32,32,32,32,32,32,48,120,55,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,76,10,35,100,101,102,105,110,101,32,95,95,85,73,78,84,80,84,82,95,77,65,88,95,95,32,32,32,32,32,32,32,48,120,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,85,76,10,35,100,101,102,105,110,101,32,95,95,87,67,72,65,82,95,77,73,78,95,95,32,32,32,32,32,32,32,32,40,45,48,120,55,102,102,102,102,102,102,102,32,45,32,49,41,10,35,100,101,102,105,110,101,32,95,95,87,73,78,84,95,77,73,78,95,95,32,32,32,32,32,32,32,32,32,48,85,10,35,100,101,102,105,110,101,32,95,95,83,73,71,95,65,84,79,77,73,67,95,77,73,78,95,95,32,40,45,48,120,55,102,102,102,102,102,102,102,32,45,32,49,41,10,35,100,101,102,105,110,101,32,95,95,73,78,84,56,95,67,32,40,45,48,120,55,102,102,102,102,102,102,102,32,45,32,49,41,10,35,100,101,102,105,110,101,32,95,95,83,67,72,65,82,95,87,73,68,84,72,95,95,32,56,10,35,100,101,102,105,110,101,32,95,95,83,72,82,84,95,87,73,68,84,72,95,95,32,49,54,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,87,73,68,84,72,95,95,32,51,50,10,35,100,101,102,105,110,101,32,95,95,76,79,78,71,95,87,73,68,84,72,95,95,32,54,52,10,35,100,101,102,105,110,101,32,95,95,76,79,78,71,95,76,79,78,71,95,87,73,68,84,72,95,95,32,54,52,10,35,100,101,102,105,110,101,32,95,95,80,84,82,68,73,70,70,95,87,73,68,84,72,95,95,32,54,52,10,35,100,101,102,105,110,101,32,95,95,83,73,71,95,65,84,79,77,73,67,95,87,73,68,84,72,95,95,32,51,50,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,95,87,73,68,84,72,95,95,32,54,52,10,35,100,101,102,105,110,101,32,95,95,87,67,72,65,82,95,87,73,68,84,72,95,95,32,51,50,10,35,100,101,102,105,110,101,32,95,95,87,73,78,84,95,87,73,68,84,72,95,95,32,51,50,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,76,69,65,83,84,56,95,87,73,68,84,72,95,95,32,56,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,76,69,65,83,84,49,54,95,87,73,68,84,72,95,95,32,49,54,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,76,69,65,83,84,51,50,95,87,73,68,84,72,95,95,32,51,50,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,76,69,65,83,84,54,52,95,87,73,68,84,72,95,95,32,54,52,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,70,65,83,84,56,95,87,73,68,84,72,95,95,32,56,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,70,65,83,84,49,54,95,87,73,68,84,72,95,95,32,54,52,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,70,65,83,84,51,50,95,87,73,68,84,72,95,95,32,54,52,10,35,100,101,102,105,110,101,32,95,95,73,78,84,95,70,65,83,84,54,52,95,87,73,68,84,72,95,95,32,54,52,10,35,100,101,102,105,110,101,32,95,95,73,78,84,80,84,82,95,87,73,68,84,72,95,95,32,54,52,10,35,100,101,102,105,110,101,32,95,95,73,78,84,77,65,88,95,87,73,68,84,72,95,95,32,54,52,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,79,70,95,73,78,84,95,95,32,52,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,79,70,95,76,79,78,71,95,95,32,56,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,79,70,95,76,79,78,71,95,76,79,78,71,95,95,32,56,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,79,70,95,83,72,79,82,84,95,95,32,50,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,79,70,95,80,79,73,78,84,69,82,95,95,32,56,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,79,70,95,70,76,79,65,84,95,95,32,52,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,79,70,95,68,79,85,66,76,69,95,95,32,56,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,79,70,95,76,79,78,71,95,68,79,85,66,76,69,95,95,32,49,54,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,79,70,95,83,73,90,69,95,84,95,95,32,56,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,79,70,95,87,67,72,65,82,95,84,95,95,32,52,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,79,70,95,87,73,78,84,95,84,95,95,32,52,10,35,100,101,102,105,110,101,32,95,95,83,73,90,69,79,70,95,80,84,82,68,73,70,70,95,84,95,95,32,56,10,10,0};

static char x86_msvc_macros[374] = {10,35,100,101,102,105,110,101,32,95,67,79,78,83,79,76,69,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,79,87,78,69,82,83,72,73,80,95,95,32,49,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,78,79,95,65,84,79,77,73,67,83,95,95,32,95,95,83,84,68,67,95,78,79,95,65,84,79,77,73,67,83,95,95,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,78,79,95,67,79,77,80,76,69,88,95,95,32,32,95,95,83,84,68,67,95,78,79,95,67,79,77,80,76,69,88,95,95,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,78,79,95,84,72,82,69,65,68,83,95,95,32,32,32,95,95,83,84,68,67,95,78,79,95,84,72,82,69,65,68,83,95,95,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,78,79,95,86,76,65,95,95,32,32,32,32,95,95,83,84,68,67,95,78,79,95,86,76,65,95,95,10,35,100,101,102,105,110,101,32,95,87,73,78,51,50,32,49,10,35,100,101,102,105,110,101,32,95,73,78,84,69,71,82,65,76,95,77,65,88,95,66,73,84,83,32,54,52,10,35,100,101,102,105,110,101,32,95,77,83,67,95,86,69,82,32,49,57,52,52,10,35,100,101,102,105,110,101,32,95,77,83,67,95,69,88,84,69,78,83,73,79,78,83,32,49,10,35,100,101,102,105,110,101,32,95,77,95,73,88,56,54,32,54,48,48,10,35,100,101,102,105,110,101,32,95,95,112,114,97,103,109,97,40,97,41,10,10,0};

static char x64_msvc_macros[252] = {35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,86,69,82,83,73,79,78,95,95,32,50,48,50,51,49,49,76,10,35,100,101,102,105,110,101,32,95,67,79,78,83,79,76,69,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,79,87,78,69,82,83,72,73,80,95,95,32,49,10,35,100,101,102,105,110,101,32,95,87,73,78,51,50,32,49,10,35,100,101,102,105,110,101,32,95,87,73,78,54,52,32,49,10,35,100,101,102,105,110,101,32,95,73,78,84,69,71,82,65,76,95,77,65,88,95,66,73,84,83,32,54,52,10,35,100,101,102,105,110,101,32,95,77,83,67,95,86,69,82,32,49,57,52,52,10,35,100,101,102,105,110,101,32,95,77,83,67,95,69,88,84,69,78,83,73,79,78,83,32,49,10,35,100,101,102,105,110,101,32,95,77,95,88,54,52,32,49,48,48,10,35,100,101,102,105,110,101,32,95,77,95,65,77,68,54,52,32,49,48,48,10,35,100,101,102,105,110,101,32,95,95,112,114,97,103,109,97,40,97,41,10,0};

static char ccu8_macros[432] = {35,100,101,102,105,110,101,32,95,95,69,73,40,41,10,35,100,101,102,105,110,101,32,95,95,68,73,40,41,10,35,100,101,102,105,110,101,32,95,95,97,115,109,40,41,10,35,100,101,102,105,110,101,32,95,95,83,69,71,66,65,83,69,95,78,40,41,10,35,100,101,102,105,110,101,32,95,95,83,69,71,66,65,83,69,95,70,40,41,10,35,100,101,102,105,110,101,32,95,95,83,69,71,83,73,90,69,40,41,10,35,100,101,102,105,110,101,32,95,95,110,101,97,114,10,35,100,101,102,105,110,101,32,95,95,102,97,114,10,35,100,101,102,105,110,101,32,95,95,104,117,103,101,10,35,100,101,102,105,110,101,32,95,95,80,65,67,75,69,68,10,35,100,101,102,105,110,101,32,95,95,85,78,80,65,67,75,69,68,10,35,100,101,102,105,110,101,32,95,95,110,111,114,101,103,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,95,10,35,100,101,102,105,110,101,32,95,95,67,67,85,56,95,95,10,35,100,101,102,105,110,101,32,95,95,86,69,82,83,73,79,78,95,95,10,35,100,101,102,105,110,101,32,95,95,65,82,67,72,73,84,69,67,84,85,82,69,95,95,10,35,100,101,102,105,110,101,32,95,95,68,69,66,85,71,95,95,10,35,100,101,102,105,110,101,32,95,95,77,83,95,95,10,35,100,101,102,105,110,101,32,95,95,77,76,95,95,10,35,100,101,102,105,110,101,32,95,95,77,76,95,95,10,35,100,101,102,105,110,101,32,95,95,85,78,83,73,71,78,69,68,67,72,65,82,95,95,10,35,100,101,102,105,110,101,32,95,95,78,79,70,65,82,95,95,10,35,100,101,102,105,110,101,32,95,95,76,67,67,85,49,54,95,95,10,35,100,101,102,105,110,101,32,95,95,76,65,80,73,83,79,77,70,95,95,10,0};

static char catalina_macros[236] = {35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,78,79,95,65,84,79,77,73,67,83,95,95,32,95,95,83,84,68,67,95,78,79,95,65,84,79,77,73,67,83,95,95,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,78,79,95,67,79,77,80,76,69,88,95,95,32,32,95,95,83,84,68,67,95,78,79,95,67,79,77,80,76,69,88,95,95,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,78,79,95,84,72,82,69,65,68,83,95,95,32,32,32,95,95,83,84,68,67,95,78,79,95,84,72,82,69,65,68,83,95,95,10,35,100,101,102,105,110,101,32,95,95,83,84,68,67,95,78,79,95,86,76,65,95,95,32,32,32,32,95,95,83,84,68,67,95,78,79,95,86,76,65,95,95,10,35,100,101,102,105,110,101,32,95,95,95,67,65,84,65,76,73,78,65,95,95,10,35,100,101,102,105,110,101,32,95,95,95,67,65,84,65,76,89,83,84,95,95,10,10,0};


char *target_get_predefined_macros(int e)
{
    /*switch*/
    {
        int __v0 = e;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 1) goto __L2; /*case 1*/
        if (__v0 == 2) goto __L3; /*case 2*/
        if (__v0 == 3) goto __L4; /*case 3*/
        if (__v0 == 4) goto __L5; /*case 4*/
        if (__v0 == 5) goto __L6; /*case 5*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            return x86_x64_gcc_macros;
            __L2: /*case 1*/ 
            return x86_msvc_macros;
            __L3: /*case 2*/ 
            return x64_msvc_macros;
            __L4: /*case 3*/ 
            return ccu8_macros;
            __L5: /*case 4*/ 
            return ccu8_macros;
            __L6: /*case 5*/ 
            return catalina_macros;
        }
        __L0:;
    }
    return "";
}


static char gcc_builtins_include[5184] = {10,116,121,112,101,100,101,102,32,116,121,112,101,111,102,40,115,105,122,101,111,102,40,49,41,41,32,115,105,122,101,95,116,59,10,10,10,47,42,10,32,32,104,116,116,112,115,58,47,47,103,99,99,46,103,110,117,46,111,114,103,47,111,110,108,105,110,101,100,111,99,115,47,103,99,99,47,73,110,116,101,103,101,114,45,79,118,101,114,102,108,111,119,45,66,117,105,108,116,105,110,115,46,104,116,109,108,10,42,47,10,98,111,111,108,32,95,95,98,117,105,108,116,105,110,95,97,100,100,95,111,118,101,114,102,108,111,119,40,47,42,116,121,112,101,49,32,97,44,32,116,121,112,101,50,32,98,44,32,116,121,112,101,51,32,42,114,101,115,42,47,41,59,10,98,111,111,108,32,95,95,98,117,105,108,116,105,110,95,115,97,100,100,95,111,118,101,114,102,108,111,119,40,105,110,116,32,97,44,32,105,110,116,32,98,44,32,105,110,116,42,32,114,101,115,41,59,10,98,111,111,108,32,95,95,98,117,105,108,116,105,110,95,115,97,100,100,108,95,111,118,101,114,102,108,111,119,40,108,111,110,103,32,105,110,116,32,97,44,32,108,111,110,103,32,105,110,116,32,98,44,32,108,111,110,103,32,105,110,116,42,32,114,101,115,41,59,10,98,111,111,108,32,95,95,98,117,105,108,116,105,110,95,115,97,100,100,108,108,95,111,118,101,114,102,108,111,119,40,108,111,110,103,32,108,111,110,103,32,105,110,116,32,97,44,32,108,111,110,103,32,108,111,110,103,32,105,110,116,32,98,44,32,108,111,110,103,32,108,111,110,103,32,105,110,116,42,32,114,101,115,41,59,10,98,111,111,108,32,95,95,98,117,105,108,116,105,110,95,117,97,100,100,95,111,118,101,114,102,108,111,119,40,117,110,115,105,103,110,101,100,32,105,110,116,32,97,44,32,117,110,115,105,103,110,101,100,32,105,110,116,32,98,44,32,117,110,115,105,103,110,101,100,32,105,110,116,42,32,114,101,115,41,59,10,98,111,111,108,32,95,95,98,117,105,108,116,105,110,95,117,97,100,100,108,95,111,118,101,114,102,108,111,119,40,117,110,115,105,103,110,101,100,32,108,111,110,103,32,105,110,116,32,97,44,32,117,110,115,105,103,110,101,100,32,108,111,110,103,32,105,110,116,32,98,44,32,117,110,115,105,103,110,101,100,32,108,111,110,103,32,105,110,116,42,32,114,101,115,41,59,10,98,111,111,108,32,95,95,98,117,105,108,116,105,110,95,117,97,100,100,108,108,95,111,118,101,114,102,108,111,119,40,117,110,115,105,103,110,101,100,32,108,111,110,103,32,108,111,110,103,32,105,110,116,32,97,44,32,117,110,115,105,103,110,101,100,32,108,111,110,103,32,108,111,110,103,32,105,110,116,32,98,44,32,117,110,115,105,103,110,101,100,32,108,111,110,103,32,108,111,110,103,32,105,110,116,42,32,114,101,115,41,59,10,10,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,104,117,103,101,95,118,97,108,40,118,111,105,100,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,104,117,103,101,95,118,97,108,102,40,118,111,105,100,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,104,117,103,101,95,118,97,108,108,40,118,111,105,100,41,59,10,10,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,102,112,99,108,97,115,115,105,102,121,40,105,110,116,44,32,105,110,116,44,32,105,110,116,44,32,105,110,116,44,32,105,110,116,44,32,46,46,46,41,59,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,105,110,102,40,118,111,105,100,41,59,10,10,95,68,101,99,105,109,97,108,51,50,32,95,95,98,117,105,108,116,105,110,95,105,110,102,100,51,50,40,118,111,105,100,41,59,10,95,68,101,99,105,109,97,108,54,52,32,95,95,98,117,105,108,116,105,110,95,105,110,102,100,54,52,40,118,111,105,100,41,59,10,95,68,101,99,105,109,97,108,49,50,56,32,95,95,98,117,105,108,116,105,110,95,105,110,102,100,49,50,56,40,118,111,105,100,41,59,10,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,105,110,102,102,40,118,111,105,100,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,105,110,102,108,40,118,111,105,100,41,59,10,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,105,115,105,110,102,95,115,105,103,110,40,46,46,46,41,59,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,110,97,110,40,99,111,110,115,116,32,99,104,97,114,42,32,115,116,114,41,59,10,10,10,95,68,101,99,105,109,97,108,54,52,32,95,95,98,117,105,108,116,105,110,95,110,97,110,100,54,52,40,99,111,110,115,116,32,99,104,97,114,42,32,115,116,114,41,59,10,95,68,101,99,105,109,97,108,49,50,56,32,95,95,98,117,105,108,116,105,110,95,110,97,110,100,49,50,56,40,99,111,110,115,116,32,99,104,97,114,42,32,115,116,114,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,110,97,110,102,40,99,111,110,115,116,32,99,104,97,114,42,32,115,116,114,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,110,97,110,108,40,99,111,110,115,116,32,99,104,97,114,42,32,115,116,114,41,59,10,10,10,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,110,97,110,115,40,99,111,110,115,116,32,99,104,97,114,42,32,115,116,114,41,59,10,95,68,101,99,105,109,97,108,51,50,32,95,95,98,117,105,108,116,105,110,95,110,97,110,115,100,51,50,40,99,111,110,115,116,32,99,104,97,114,42,32,115,116,114,41,59,10,95,68,101,99,105,109,97,108,54,52,32,95,95,98,117,105,108,116,105,110,95,110,97,110,115,100,54,52,40,99,111,110,115,116,32,99,104,97,114,42,32,115,116,114,41,59,10,95,68,101,99,105,109,97,108,49,50,56,32,95,95,98,117,105,108,116,105,110,95,110,97,110,115,100,49,50,56,40,99,111,110,115,116,32,99,104,97,114,42,32,115,116,114,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,110,97,110,115,102,40,99,111,110,115,116,32,99,104,97,114,42,32,115,116,114,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,110,97,110,115,108,40,99,111,110,115,116,32,99,104,97,114,42,32,115,116,114,41,59,10,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,105,115,115,105,103,110,97,108,105,110,103,40,46,46,46,41,59,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,112,111,119,105,40,100,111,117,98,108,101,44,32,105,110,116,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,112,111,119,105,102,40,102,108,111,97,116,44,32,105,110,116,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,112,111,119,105,108,40,108,111,110,103,32,100,111,117,98,108,101,44,32,105,110,116,41,59,10,10,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,97,98,115,40,105,110,116,32,120,41,59,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,102,97,98,115,40,100,111,117,98,108,101,32,120,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,102,97,98,115,102,40,102,108,111,97,116,32,120,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,102,97,98,115,108,40,108,111,110,103,32,100,111,117,98,108,101,32,120,41,59,10,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,115,105,110,40,100,111,117,98,108,101,32,120,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,115,105,110,102,40,102,108,111,97,116,32,120,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,115,105,110,108,40,108,111,110,103,32,100,111,117,98,108,101,32,120,41,59,10,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,99,111,115,40,100,111,117,98,108,101,32,120,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,99,111,115,102,40,102,108,111,97,116,32,120,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,99,111,115,108,40,108,111,110,103,32,100,111,117,98,108,101,32,120,41,59,10,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,116,97,110,40,100,111,117,98,108,101,32,120,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,116,97,110,102,40,102,108,111,97,116,32,120,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,116,97,110,108,40,108,111,110,103,32,100,111,117,98,108,101,32,120,41,59,10,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,115,113,114,116,40,100,111,117,98,108,101,32,120,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,115,113,114,116,102,40,102,108,111,97,116,32,120,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,115,113,114,116,108,40,108,111,110,103,32,100,111,117,98,108,101,32,120,41,59,10,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,112,111,119,40,100,111,117,98,108,101,32,120,44,32,100,111,117,98,108,101,32,121,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,112,111,119,102,40,102,108,111,97,116,32,120,44,32,102,108,111,97,116,32,121,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,112,111,119,108,40,108,111,110,103,32,100,111,117,98,108,101,32,120,44,32,108,111,110,103,32,100,111,117,98,108,101,32,121,41,59,10,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,101,120,112,40,100,111,117,98,108,101,32,120,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,101,120,112,102,40,102,108,111,97,116,32,120,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,101,120,112,108,40,108,111,110,103,32,100,111,117,98,108,101,32,120,41,59,10,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,108,111,103,40,100,111,117,98,108,101,32,120,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,108,111,103,102,40,102,108,111,97,116,32,120,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,108,111,103,108,40,108,111,110,103,32,100,111,117,98,108,101,32,120,41,59,10,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,108,111,103,49,48,40,100,111,117,98,108,101,32,120,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,108,111,103,49,48,102,40,102,108,111,97,116,32,120,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,108,111,103,49,48,108,40,108,111,110,103,32,100,111,117,98,108,101,32,120,41,59,10,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,102,108,111,111,114,40,100,111,117,98,108,101,32,120,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,102,108,111,111,114,102,40,102,108,111,97,116,32,120,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,102,108,111,111,114,108,40,108,111,110,103,32,100,111,117,98,108,101,32,120,41,59,10,10,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,99,101,105,108,40,100,111,117,98,108,101,32,120,41,59,10,102,108,111,97,116,32,95,95,98,117,105,108,116,105,110,95,99,101,105,108,102,40,102,108,111,97,116,32,120,41,59,10,108,111,110,103,32,100,111,117,98,108,101,32,95,95,98,117,105,108,116,105,110,95,99,101,105,108,108,40,108,111,110,103,32,100,111,117,98,108,101,32,120,41,59,10,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,102,102,115,40,105,110,116,32,105,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,102,102,115,108,40,108,111,110,103,32,105,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,102,102,115,108,108,40,108,111,110,103,32,108,111,110,103,32,105,41,59,10,10,118,111,105,100,42,32,95,95,98,117,105,108,116,105,110,95,109,101,109,99,112,121,40,118,111,105,100,42,32,100,101,115,116,44,32,99,111,110,115,116,32,118,111,105,100,42,32,115,114,99,44,32,115,105,122,101,95,116,32,110,41,59,10,118,111,105,100,42,32,95,95,98,117,105,108,116,105,110,95,109,101,109,115,101,116,40,118,111,105,100,42,32,115,44,32,105,110,116,32,99,44,32,115,105,122,101,95,116,32,110,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,109,101,109,99,109,112,40,99,111,110,115,116,32,118,111,105,100,42,32,115,49,44,32,99,111,110,115,116,32,118,111,105,100,42,32,115,50,44,32,115,105,122,101,95,116,32,110,41,59,10,10,99,104,97,114,42,32,95,95,98,117,105,108,116,105,110,95,115,116,114,99,112,121,40,99,104,97,114,42,32,100,101,115,116,44,32,99,111,110,115,116,32,99,104,97,114,42,32,115,114,99,41,59,10,99,104,97,114,42,32,95,95,98,117,105,108,116,105,110,95,115,116,114,110,99,112,121,40,99,104,97,114,42,32,100,101,115,116,44,32,99,111,110,115,116,32,99,104,97,114,42,32,115,114,99,44,32,115,105,122,101,95,116,32,110,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,114,99,109,112,40,99,111,110,115,116,32,99,104,97,114,42,32,115,49,44,32,99,111,110,115,116,32,99,104,97,114,42,32,115,50,41,59,10,115,105,122,101,95,116,32,95,95,98,117,105,108,116,105,110,95,115,116,114,108,101,110,40,99,111,110,115,116,32,99,104,97,114,42,32,115,41,59,10,10,95,78,111,114,101,116,117,114,110,32,118,111,105,100,32,95,95,98,117,105,108,116,105,110,95,97,98,111,114,116,40,118,111,105,100,41,59,10,95,78,111,114,101,116,117,114,110,32,118,111,105,100,32,95,95,98,117,105,108,116,105,110,95,101,120,105,116,40,105,110,116,32,115,116,97,116,117,115,41,59,10,118,111,105,100,32,95,95,98,117,105,108,116,105,110,95,102,114,101,101,40,118,111,105,100,42,32,112,116,114,41,59,10,118,111,105,100,42,32,95,95,98,117,105,108,116,105,110,95,109,97,108,108,111,99,40,115,105,122,101,95,116,32,115,105,122,101,41,59,10,118,111,105,100,42,32,95,95,98,117,105,108,116,105,110,95,114,101,97,108,108,111,99,40,118,111,105,100,42,32,112,116,114,44,32,115,105,122,101,95,116,32,115,105,122,101,41,59,10,10,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,105,103,110,98,105,116,40,100,111,117,98,108,101,32,120,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,105,103,110,98,105,116,102,40,102,108,111,97,116,32,120,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,105,103,110,98,105,116,108,40,108,111,110,103,32,100,111,117,98,108,101,32,120,41,59,10,10,10,10,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,102,102,115,40,105,110,116,32,120,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,99,108,122,40,117,110,115,105,103,110,101,100,32,105,110,116,32,120,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,99,116,122,40,117,110,115,105,103,110,101,100,32,105,110,116,32,120,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,99,108,114,115,98,40,105,110,116,32,120,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,112,111,112,99,111,117,110,116,40,117,110,115,105,103,110,101,100,32,105,110,116,32,120,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,112,97,114,105,116,121,40,117,110,115,105,103,110,101,100,32,105,110,116,32,120,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,102,102,115,108,40,108,111,110,103,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,99,108,122,108,40,117,110,115,105,103,110,101,100,32,108,111,110,103,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,99,116,122,108,40,117,110,115,105,103,110,101,100,32,108,111,110,103,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,99,108,114,115,98,108,40,108,111,110,103,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,112,111,112,99,111,117,110,116,108,40,117,110,115,105,103,110,101,100,32,108,111,110,103,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,112,97,114,105,116,121,108,40,117,110,115,105,103,110,101,100,32,108,111,110,103,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,102,102,115,108,108,40,108,111,110,103,32,108,111,110,103,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,99,108,122,108,108,40,117,110,115,105,103,110,101,100,32,108,111,110,103,32,108,111,110,103,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,99,116,122,108,108,40,117,110,115,105,103,110,101,100,32,108,111,110,103,32,108,111,110,103,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,99,108,114,115,98,108,108,40,108,111,110,103,32,108,111,110,103,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,112,111,112,99,111,117,110,116,108,108,40,117,110,115,105,103,110,101,100,32,108,111,110,103,32,108,111,110,103,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,112,97,114,105,116,121,108,108,40,117,110,115,105,103,110,101,100,32,108,111,110,103,32,108,111,110,103,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,102,102,115,103,40,46,46,46,41,59,10,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,99,108,114,115,98,103,40,46,46,46,41,59,10,105,110,116,32,95,95,98,117,105,108,116,105,110,95,112,97,114,105,116,121,103,40,46,46,46,41,59,10,10,117,110,115,105,103,110,101,100,32,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,100,99,95,98,105,116,95,119,105,100,116,104,40,47,42,116,121,112,101,32,97,114,103,42,47,41,59,10,117,110,115,105,103,110,101,100,32,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,100,99,95,99,111,117,110,116,95,111,110,101,115,40,47,42,116,121,112,101,32,97,114,103,42,47,41,59,10,117,110,115,105,103,110,101,100,32,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,100,99,95,99,111,117,110,116,95,122,101,114,111,115,40,47,42,116,121,112,101,32,97,114,103,42,47,41,59,10,117,110,115,105,103,110,101,100,32,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,100,99,95,102,105,114,115,116,95,108,101,97,100,105,110,103,95,111,110,101,40,47,42,116,121,112,101,32,97,114,103,42,47,41,59,10,117,110,115,105,103,110,101,100,32,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,100,99,95,102,105,114,115,116,95,108,101,97,100,105,110,103,95,122,101,114,111,40,47,42,116,121,112,101,32,97,114,103,42,47,41,59,10,117,110,115,105,103,110,101,100,32,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,100,99,95,102,105,114,115,116,95,116,114,97,105,108,105,110,103,95,111,110,101,40,47,42,116,121,112,101,32,97,114,103,42,47,41,59,10,117,110,115,105,103,110,101,100,32,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,100,99,95,102,105,114,115,116,95,116,114,97,105,108,105,110,103,95,122,101,114,111,40,47,42,116,121,112,101,32,97,114,103,42,47,41,59,10,117,110,115,105,103,110,101,100,32,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,100,99,95,104,97,115,95,115,105,110,103,108,101,95,98,105,116,40,47,42,116,121,112,101,32,97,114,103,42,47,41,59,10,117,110,115,105,103,110,101,100,32,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,100,99,95,108,101,97,100,105,110,103,95,111,110,101,115,40,47,42,116,121,112,101,32,97,114,103,42,47,41,59,10,117,110,115,105,103,110,101,100,32,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,100,99,95,108,101,97,100,105,110,103,95,122,101,114,111,115,40,47,42,116,121,112,101,32,97,114,103,42,47,41,59,10,117,110,115,105,103,110,101,100,32,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,100,99,95,116,114,97,105,108,105,110,103,95,111,110,101,115,40,47,42,116,121,112,101,32,97,114,103,42,47,41,59,10,117,110,115,105,103,110,101,100,32,105,110,116,32,95,95,98,117,105,108,116,105,110,95,115,116,100,99,95,116,114,97,105,108,105,110,103,95,122,101,114,111,115,40,47,42,116,121,112,101,32,97,114,103,42,47,41,59,10,10,0};

static char catalina_builtins[73] = {10,116,121,112,101,100,101,102,32,117,110,115,105,103,110,101,100,32,105,110,116,32,115,105,122,101,95,116,59,10,10,118,111,105,100,42,32,95,95,98,117,105,108,116,105,110,95,97,108,108,111,99,97,40,115,105,122,101,95,116,32,95,95,115,105,122,101,41,59,10,10,10,0};


char *target_get_builtins(int e)
{
    /*switch*/
    {
        int __v0 = e;
        if (__v0 == 0) goto __L1; /*case 0*/
        if (__v0 == 1) goto __L2; /*case 1*/
        if (__v0 == 2) goto __L3; /*case 2*/
        if (__v0 == 3) goto __L4; /*case 3*/
        if (__v0 == 4) goto __L5; /*case 4*/
        if (__v0 == 5) goto __L6; /*case 5*/
        goto __L0;

        {
            __L1: /*case 0*/ 
            return gcc_builtins_include;
            __L2: /*case 1*/ 
            return "";
            __L3: /*case 2*/ 
            return "";
            __L4: /*case 3*/ 
            return "";
            __L5: /*case 4*/ 
            return "";
            __L6: /*case 5*/ 
            return catalina_builtins;
        }
        __L0:;
    }
    return "";
}


unsigned char is_automatic_variable(int f)
{
    if (f & 2)
    {
        return 0;
    }
    if (f & 4)
    {
        return 0;
    }
    if (f & 2048)
    {
        return 1;
    }
    if (f & 4096)
    {
        return 1;
    }
    return 0;
}


void print_item(struct osstream * ss, unsigned char * first, char * item)
{
    if (!(*first))
    {
        ss_fprintf(ss, " ");
    }
    ss_fprintf(ss, "%s", item);
    *first = 0;
}


unsigned char print_type_alignment_flags(struct osstream * ss, unsigned char * first, int flags, int target)
{
    int align;

    align = 0;
    if (flags & 1)
    {
        align = 8;
    }
    else
    {
        if (flags & 2)
        {
            align = 16;
        }
        else
        {
            if (flags & 4)
            {
                align = 32;
            }
            else
            {
                if (flags & 8)
                {
                    align = 64;
                }
                else
                {
                    if (flags & 16)
                    {
                        align = 128;
                    }
                }
            }
        }
    }
    if (align != 0)
    {
        char * fmt;
        char buffer[50];

        fmt = get_platform(target)->alignas_fmt_must_have_one_percent_d;
        _cake_zmem(&buffer, 50);
        snprintf(buffer, 50, fmt, align);
        print_item(ss, first, buffer);
    }
    return *first;
}


unsigned char print_type_specifier_flags(struct osstream * ss, unsigned char * first, int e_type_specifier_flags)
{
    if (e_type_specifier_flags & 1)
    {
        print_item(ss, first, "void");
    }
    if (e_type_specifier_flags & 128)
    {
        print_item(ss, first, "signed");
    }
    if (e_type_specifier_flags & 256)
    {
        print_item(ss, first, "unsigned");
    }
    if (e_type_specifier_flags & 8)
    {
        print_item(ss, first, "int");
    }
    if (e_type_specifier_flags & 4)
    {
        print_item(ss, first, "short");
    }
    if (e_type_specifier_flags & 16)
    {
        print_item(ss, first, "long");
    }
    if (e_type_specifier_flags & 4194304)
    {
        print_item(ss, first, "long long");
    }
    if (e_type_specifier_flags & 2)
    {
        print_item(ss, first, "char");
    }
    if (e_type_specifier_flags & 64)
    {
        print_item(ss, first, "double");
    }
    if (e_type_specifier_flags & 32)
    {
        print_item(ss, first, "float");
    }
    if (e_type_specifier_flags & 512)
    {
        print_item(ss, first, "_Bool");
    }
    if (e_type_specifier_flags & 1024)
    {
        print_item(ss, first, "_Complex");
    }
    if (e_type_specifier_flags & 2048)
    {
        print_item(ss, first, "_Decimal32");
    }
    if (e_type_specifier_flags & 4096)
    {
        print_item(ss, first, "_Decimal64");
    }
    if (e_type_specifier_flags & 8192)
    {
        print_item(ss, first, "_Decimal128");
    }
    if (e_type_specifier_flags & 512)
    {
        print_item(ss, first, "bool");
    }
    if (e_type_specifier_flags & 16777216)
    {
        print_item(ss, first, "nullptr_t");
    }
    if (e_type_specifier_flags & 33554432)
    {
        print_item(ss, first, "__builtin_va_list");
    }
    return *first;
}


void print_type_qualifier_flags(struct osstream * ss, unsigned char * first, int e_type_qualifier_flags)
{
    if (e_type_qualifier_flags & 1)
    {
        print_item(ss, first, "const");
    }
    if (e_type_qualifier_flags & 2)
    {
        print_item(ss, first, "restrict");
    }
    if (e_type_qualifier_flags & 4)
    {
        print_item(ss, first, "volatile");
    }
    if (e_type_qualifier_flags & 16)
    {
        print_item(ss, first, "_Owner");
    }
    if (e_type_qualifier_flags & 128)
    {
        print_item(ss, first, "_Dtor");
    }
    if (e_type_qualifier_flags & 32)
    {
        print_item(ss, first, "_View");
    }
    if (e_type_qualifier_flags & 64)
    {
        print_item(ss, first, "_Opt");
    }
}


void print_msvc_declspec(struct osstream * ss, unsigned char * first, int msvc_declspec_flags)
{
    if (msvc_declspec_flags & 2)
    {
        print_item(ss, first, "__declspec(align(8))");
    }
    if (msvc_declspec_flags & 4)
    {
        print_item(ss, first, "__declspec(align(16))");
    }
    if (msvc_declspec_flags & 8)
    {
        print_item(ss, first, "__declspec(align(32))");
    }
    if (msvc_declspec_flags & 16)
    {
        print_item(ss, first, "__declspec(align(64))");
    }
    if (msvc_declspec_flags & 32)
    {
        print_item(ss, first, "__declspec(allocate)");
    }
    if (msvc_declspec_flags & 64)
    {
        print_item(ss, first, "__declspec(allocator)");
    }
    if (msvc_declspec_flags & 128)
    {
    }
    if (msvc_declspec_flags & 256)
    {
    }
    if (msvc_declspec_flags & 512)
    {
    }
    if (msvc_declspec_flags & 1024)
    {
        print_item(ss, first, "__declspec(dllimport)");
    }
    if (msvc_declspec_flags & 2048)
    {
        print_item(ss, first, "__declspec(dllexport)");
    }
    if (msvc_declspec_flags & 4096)
    {
    }
    if (msvc_declspec_flags & 8192)
    {
    }
    if (msvc_declspec_flags & 16384)
    {
    }
    if (msvc_declspec_flags & 32768)
    {
    }
    if (msvc_declspec_flags & 65536)
    {
    }
    if (msvc_declspec_flags & 131072)
    {
        print_item(ss, first, "__declspec(noinline)");
    }
    if (msvc_declspec_flags & 262144)
    {
    }
    if (msvc_declspec_flags & 524288)
    {
    }
    if (msvc_declspec_flags & 1048576)
    {
    }
    if (msvc_declspec_flags & 2097152)
    {
    }
    if (msvc_declspec_flags & 4194304)
    {
    }
    if (msvc_declspec_flags & 8388608)
    {
    }
    if (msvc_declspec_flags & 16777216)
    {
        print_item(ss, first, "__declspec(restrict)");
    }
    if (msvc_declspec_flags & 33554432)
    {
    }
    if (msvc_declspec_flags & 67108864)
    {
        print_item(ss, first, "__declspec(selectany)");
    }
    if (msvc_declspec_flags & 134217728)
    {
        print_item(ss, first, "__declspec(spectre(nomitigation))");
    }
    if (msvc_declspec_flags & 268435456)
    {
        print_item(ss, first, "__declspec(thread)");
    }
    if (msvc_declspec_flags & 536870912)
    {
    }
}


void print_type_qualifier_specifiers(struct osstream * ss, struct type * type, int target)
{
    unsigned char  first;

    first = 1;
    print_type_qualifier_flags(ss, &first, type->type_qualifier_flags);
    if (type->type_specifier_flags & 32768)
    {
        ;
        print_item(ss, &first, "struct ");
        ss_fprintf(ss, "%s", type->struct_or_union_specifier->tag_name);
    }
    else
    {
        if (type->type_specifier_flags & 65536)
        {
            ;
            print_item(ss, &first, "enum ");
            if (type->enum_specifier->tag_token)
            {
                ss_fprintf(ss, "%s", type->enum_specifier->tag_token->lexeme);
            }
        }
        else
        {
            if (type->type_specifier_flags & 131072)
            {
                ;
            }
            else
            {
                print_type_alignment_flags(ss, &first, type->alignment_specifier_flags, target);
                print_msvc_declspec(ss, &first, type->msvc_declspec_flags);
                print_type_specifier_flags(ss, &first, type->type_specifier_flags);
            }
        }
    }
}


void type_integer_promotion(struct type * a)
{
    if ((a->type_specifier_flags & 512) || (a->type_specifier_flags & 2) || (a->type_specifier_flags & 4))
    {
        a->type_specifier_flags = 8;
    }
}


void type_add_const(struct type * p_type)
{
    p_type->type_qualifier_flags |= 1;
}


void type_remove_qualifiers(struct type * p_type)
{
    p_type->type_qualifier_flags = 0;
}


struct type type_lvalue_conversion(struct type * p_type, unsigned char  nullchecks_enabled)
{
    int category;
    struct type  t;

    category = type_get_category(p_type);
    /*switch*/
    {
        int __v0 = category;
        if (__v0 == 1) goto __L1; /*case 1*/
        if (__v0 == 2) goto __L2; /*case 2*/
        if (__v0 == 3) goto __L3; /*case 3*/
        if (__v0 == 0) goto __L4; /*case 0*/
        goto __L5; /* default */

        {
            __L1: /*case 1*/ 
            {
                struct type  t;

                t = type_add_pointer(p_type, nullchecks_enabled);
                t.type_qualifier_flags &= -65;
                t.storage_class_specifier_flags &= -2049;
                t.category = t.category;
                return t;
            }
            goto __L0; /* break */

            __L2: /*case 2*/ 
            {
                struct type  t;
                struct type  t2;

                t = get_array_item_type(p_type);
                t2 = type_add_pointer(&t, nullchecks_enabled);
                type_remove_qualifiers(&t2);
                type_destroy(&t);
                t2.storage_class_specifier_flags &= -2049;
                return t2;
            }
            goto __L0; /* break */

            __L3: /*case 3*/ 
            goto __L0; /* break */

            __L4: /*case 0*/ 
            __L5: /* default */ 
            goto __L0; /* break */

        }
        __L0:;
    }
    t = type_dup(p_type);
    type_remove_qualifiers(&t);
    t.storage_class_specifier_flags &= -2049;
    t.category = type_get_category(&t);
    return t;
}


struct type make_void_ptr_type();

struct type type_convert_to(struct type * p_type, int target)
{
    if (target < 0 && type_is_nullptr_t(p_type))
    {
        struct type  t;

        t = make_void_ptr_type();
        ;
        if (p_type->name_opt)
        {
            t.name_opt = strdup(p_type->name_opt);
        }
        return t;
    }
    return type_dup(p_type);
}


void print_type(struct osstream * ss, struct type * type, int target);

void print_type_core(struct osstream * ss, struct type * p_type, unsigned char  onlydeclarator, unsigned char  printname, int target)
{
    struct type * p;

    p = p_type;
    while (p)
    {
        if (onlydeclarator && p->next == 0)
        {
            break;
        }
        /*switch*/
        {
            int __v0 = p->category;
            if (__v0 == 0) goto __L2; /*case 0*/
            if (__v0 == 2) goto __L9; /*case 2*/
            if (__v0 == 1) goto __L14; /*case 1*/
            if (__v0 == 3) goto __L17; /*case 3*/
            goto __L1;

            {
                unsigned char  b;
                struct param * pa;

                __L2: /*case 0*/ 
                {
                    struct osstream  local;
                    unsigned char  first;
                    struct osstream  local2;

                    _cake_zmem(&local, 12);
                    first = 1;
                    print_type_qualifier_flags(&local, &first, p->type_qualifier_flags);
                    if (p->struct_or_union_specifier)
                    {
                        ss_fprintf(&local, "struct %s", p->struct_or_union_specifier->tag_name);
                    }
                    else
                    {
                        if (p->enum_specifier)
                        {
                            if (p->enum_specifier->tag_token)
                            {
                                ss_fprintf(&local, "enum %s", p->enum_specifier->tag_token->lexeme);
                            }
                            else
                            {
                                ss_fprintf(&local, "enum ");
                            }
                        }
                        else
                        {
                            print_type_alignment_flags(&local, &first, p->alignment_specifier_flags, target);
                            print_msvc_declspec(&local, &first, p->msvc_declspec_flags);
                            print_type_specifier_flags(&local, &first, p->type_specifier_flags);
                        }
                    }
                    if (printname && p->name_opt)
                    {
                        if (first)
                        {
                            ss_fprintf(ss, " ");
                            first = 0;
                        }
                        ss_fprintf(ss, "%s", p->name_opt);
                    }
                    _cake_zmem(&local2, 12);
                    if (ss->size > 0)
                    {
                        ss_fprintf(&local2, "%s %s", local.c_str, ss->c_str);
                    }
                    else
                    {
                        ss_fprintf(&local2, "%s", local.c_str);
                    }
                    ss_swap(ss, &local2);
                    ss_close(&local);
                    ss_close(&local2);
                }
                goto __L1; /* break */

                __L9: /*case 2*/ 
                if (printname && p->name_opt)
                {
                    ss_fprintf(ss, "%s", p->name_opt);
                }
                ss_fprintf(ss, "[");
                b = 1;
                if (p->has_static_array_size)
                {
                    ss_fprintf(ss, "static");
                    b = 0;
                }
                print_type_qualifier_flags(ss, &b, p->type_qualifier_flags);
                if (p->num_of_elements > 0)
                {
                    if (!b)
                    {
                        ss_fprintf(ss, " ");
                    }
                    ss_fprintf(ss, "%d", p->num_of_elements);
                }
                ss_fprintf(ss, "]");
                goto __L1; /* break */

                __L14: /*case 1*/ 
                if (printname && p->name_opt)
                {
                    ss_fprintf(ss, "%s", p->name_opt);
                }
                ss_fprintf(ss, "(");
                pa = p->params.head;
                while (pa)
                {
                    struct osstream  sslocal;

                    _cake_zmem(&sslocal, 12);
                    print_type(&sslocal, &pa->type, target);
                    ss_fprintf(ss, "%s", sslocal.c_str);
                    if (pa->next)
                    {
                        ss_fprintf(ss, ",");
                    }
                    ss_close(&sslocal);
                    pa = pa->next;
                }
                ss_fprintf(ss, ")");
                goto __L1; /* break */

                __L17: /*case 3*/ 
                {
                    struct osstream  local;
                    unsigned char  first;

                    _cake_zmem(&local, 12);
                    if (p->next && (p->next->category == 1 || p->next->category == 2))
                    {
                        ss_fprintf(&local, "(");
                    }
                    ss_fprintf(&local, "*");
                    first = 0;
                    print_type_qualifier_flags(&local, &first, p->type_qualifier_flags);
                    if (printname && p->name_opt)
                    {
                        if (!first)
                        {
                            ss_fprintf(ss, " ");
                        }
                        ss_fprintf(ss, "%s", p->name_opt);
                        first = 0;
                    }
                    if (ss->c_str)
                    {
                        ss_fprintf(&local, "%s", ss->c_str);
                    }
                    if (p->next && (p->next->category == 1 || p->next->category == 2))
                    {
                        ss_fprintf(&local, ")", ss->c_str);
                    }
                    ss_swap(ss, &local);
                    ss_close(&local);
                }
                goto __L1; /* break */

            }
            __L1:;
        }
        p = p->next;
    }
}


void print_type(struct osstream * ss, struct type * p_type, int target)
{
    print_type_core(ss, p_type, 0, 1, target);
}


void print_type_no_names(struct osstream * ss, struct type * p_type, int target)
{
    print_type_core(ss, p_type, 0, 0, target);
}


void print_type_declarator(struct osstream * ss, struct type * p_type, int target)
{
    print_type_core(ss, p_type, 1, 1, target);
}


void type_print(struct type * a, int target)
{
    struct osstream  ss;

    _cake_zmem(&ss, 12);
    print_type(&ss, a, target);
    printf("%s", ss.c_str);
    ss_close(&ss);
}


void type_println(struct type * a, int target)
{
    type_print(a, target);
    puts("\n");
}


int type_get_category(struct type * p_type)
{
    return p_type->category;
}


void param_list_add(struct param_list * list, struct param * p_item)
{
    if (list->head == 0)
    {
        list->head = p_item;
    }
    else
    {
        ;
        ;
        list->tail->next = p_item;
    }
    list->tail = p_item;
}


void param_list_destroy(struct param_list * p)
{
    struct param * item;

    item = p->head;
    while (item)
    {
        struct param * next;

        next = item->next;
        type_destroy(&item->type);
        free(item);
        item = next;
    }
}


void type_destroy_one(struct type * p_type)
{
    free((void *)p_type->name_opt);
    param_list_destroy(&p_type->params);
    ;
}


void type_destroy(struct type * p_type)
{
    struct type * item;

    free((void *)p_type->name_opt);
    param_list_destroy(&p_type->params);
    item = p_type->next;
    while (item)
    {
        struct type * next;

        next = item->next;
        item->next = 0;
        type_destroy_one(item);
        free(item);
        item = next;
    }
}


void type_delete(struct type * p_type)
{
    if (p_type)
    {
        type_destroy(p_type);
        free(p_type);
    }
}


unsigned char type_has_attribute(struct type * p_type, int attributes)
{
    struct attribute_specifier_sequence * p_attribute_specifier_sequence;

    if (p_type->attributes_flags & attributes)
    {
        return 1;
    }
    p_attribute_specifier_sequence = 0;
    if (p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier * p_complete;

        p_attribute_specifier_sequence = p_type->struct_or_union_specifier->attribute_specifier_sequence_opt;
        p_complete = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
        if (p_attribute_specifier_sequence == 0 && p_complete)
        {
            p_attribute_specifier_sequence = p_complete->attribute_specifier_sequence_opt;
        }
    }
    else
    {
        if (p_type->enum_specifier)
        {
            struct enum_specifier * p_complete_enum_specifier;

            p_complete_enum_specifier = get_complete_enum_specifier(p_type->enum_specifier);
            p_attribute_specifier_sequence = p_type->enum_specifier->attribute_specifier_sequence_opt;
            if (p_attribute_specifier_sequence == 0 && p_complete_enum_specifier)
            {
                p_attribute_specifier_sequence = p_complete_enum_specifier->attribute_specifier_sequence_opt;
            }
        }
    }
    if (p_attribute_specifier_sequence && p_attribute_specifier_sequence->attributes_flags & attributes)
    {
        return 1;
    }
    return 0;
}


unsigned char type_is_maybe_unused(struct type * p_type)
{
    return type_has_attribute(p_type, 4);
}


unsigned char type_is_deprecated(struct type * p_type)
{
    return type_has_attribute(p_type, 1);
}


unsigned char type_is_nodiscard(struct type * p_type)
{
    return type_has_attribute(p_type, 8);
}


unsigned char type_is_array(struct type * p_type)
{
    return type_get_category(p_type) == 2;
}


unsigned char type_is_owner_or_pointer_to_dtor(struct type * p_type)
{
    if (type_is_pointed_dtor(p_type))
    {
        return 1;
    }
    if (type_is_owner(p_type))
    {
        return 1;
    }
    return ((p_type->type_qualifier_flags & 128) != 0);
}


unsigned char type_is_pointer_to_owner(struct type * p_type)
{
    if (p_type->next == 0)
    {
        return 0;
    }
    return type_is_owner(p_type->next);
}


unsigned char type_is_dtor(struct type * p_type)
{
    return ((p_type->type_qualifier_flags & 128) != 0);
}


unsigned char type_is_pointed_dtor(struct type * p_type)
{
    if (!type_is_pointer(p_type))
    {
        return 0;
    }
    ;
    return type_is_dtor(p_type->next);
}


unsigned char type_is_owner(struct type * p_type)
{
    if (p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier * p_complete;

        if (p_type->type_qualifier_flags & 32)
        {
            return 0;
        }
        p_complete = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
        if (p_complete && p_complete->is_owner)
        {
            return 1;
        }
    }
    return ((p_type->type_qualifier_flags & 16) != 0);
}


unsigned char type_is_opt(struct type * p_type, unsigned char  nullable_enabled)
{
    if (nullable_enabled)
    {
        return ((p_type->type_qualifier_flags & 64) != 0);
    }
    return 1;
}


unsigned char type_is_view(struct type * p_type)
{
    return ((p_type->type_qualifier_flags & 32) != 0);
}


unsigned char type_is_ctor(struct type * p_type)
{
    return ((p_type->type_qualifier_flags & 256) != 0);
}


unsigned char type_is_const(struct type * p_type)
{
    return ((p_type->type_qualifier_flags & 1) != 0);
}


unsigned char type_is_constexpr(struct type * p_type)
{
    return ((p_type->storage_class_specifier_flags & 64) != 0);
}


unsigned char type_is_const_or_constexpr(struct type * p_type)
{
    return (p_type->type_qualifier_flags & 1) || (p_type->storage_class_specifier_flags & 64);
}


unsigned char type_is_pointer_to_const(struct type * p_type)
{
    if (p_type->category == 3)
    {
        if (p_type->next)
        {
            return ((p_type->next->type_qualifier_flags & 1) != 0);
        }
    }
    return 0;
}


unsigned char type_is_void_ptr(struct type * p_type)
{
    if (p_type->category == 3)
    {
        if (p_type->next)
        {
            return ((p_type->next->type_specifier_flags & 1) != 0);
        }
    }
    return 0;
}


unsigned char type_is_void(struct type * p_type)
{
    if (p_type->category == 0)
    {
        return ((p_type->type_specifier_flags & 1) != 0);
    }
    return 0;
}


unsigned char type_is_nullptr_t(struct type * p_type)
{
    if (p_type->category == 0)
    {
        return ((p_type->type_specifier_flags & 16777216) != 0);
    }
    return 0;
}


unsigned char type_is_pointer_to_out(struct type * p_type)
{
    if (p_type->next == 0)
    {
        return 0;
    }
    if (p_type->category == 3)
    {
        return ((p_type->next->type_qualifier_flags & 256) != 0);
    }
    return 0;
}


unsigned char type_is_pointer(struct type * p_type)
{
    return p_type->category == 3;
}


unsigned char type_is_essential_bool(struct type * p_type)
{
    return ((p_type->attributes_flags & 33554432) != 0);
}


unsigned char type_is_essential_char(struct type * p_type)
{
    return ((p_type->attributes_flags & 67108864) != 0);
}


unsigned char type_is_enum(struct type * p_type)
{
    return type_get_category(p_type) == 0 && p_type->type_specifier_flags & 65536;
}


unsigned char type_is_struct_or_union(struct type * p_type)
{
    return type_get_category(p_type) == 0 && p_type->type_specifier_flags & 32768;
}


unsigned char type_is_union(struct type * p_type)
{
    if (type_get_category(p_type) != 0)
    {
        return 0;
    }
    if (p_type->struct_or_union_specifier == 0)
    {
        return 0;
    }
    return p_type->struct_or_union_specifier->first_token->type == 9038;
}


unsigned char type_is_character(struct type * p_type)
{
    return type_get_category(p_type) == 0 && p_type->type_specifier_flags & 2;
}


unsigned char type_is_vla(struct type * p_type)
{
    struct type * it;

    it = p_type;
    while (it && type_is_array(it))
    {
        if (it->array_num_elements_expression)
        {
            if (!object_has_constant_value(&it->array_num_elements_expression->object))
            {
                return 1;
            }
        }
        it = it->next;
    }
    return 0;
}


unsigned char type_is_decimal128(struct type * p_type)
{
    return type_get_category(p_type) == 0 && p_type->type_specifier_flags & 8192;
}


unsigned char type_is_decimal64(struct type * p_type)
{
    return type_get_category(p_type) == 0 && p_type->type_specifier_flags & 4096;
}


unsigned char type_is_decimal32(struct type * p_type)
{
    return type_get_category(p_type) == 0 && p_type->type_specifier_flags & 2048;
}


unsigned char type_is_long_double(struct type * p_type)
{
    if (type_get_category(p_type) != 0)
    {
        return 0;
    }
    if (p_type->type_specifier_flags & 64)
    {
        if (p_type->type_specifier_flags & 16)
        {
            return 1;
        }
    }
    return 0;
}


unsigned char type_is_double(struct type * p_type)
{
    if (type_get_category(p_type) != 0)
    {
        return 0;
    }
    if (p_type->type_specifier_flags & 64)
    {
        if (!(p_type->type_specifier_flags & 16))
        {
            return 1;
        }
    }
    return 0;
}


unsigned char type_is_int(struct type * p_type)
{
    if (type_get_category(p_type) != 0)
    {
        return 0;
    }
    if ((p_type->type_specifier_flags == 136) || (p_type->type_specifier_flags == 8))
    {
        return 1;
    }
    return 0;
}


unsigned char type_is_unsigned_int(struct type * p_type)
{
    if (type_get_category(p_type) != 0)
    {
        return 0;
    }
    if (p_type->type_specifier_flags == 264)
    {
        return 1;
    }
    return 0;
}


unsigned char type_is_float(struct type * p_type)
{
    if (type_get_category(p_type) != 0)
    {
        return 0;
    }
    if (p_type->type_specifier_flags & 32)
    {
        return 1;
    }
    return 0;
}


unsigned char type_is_bool(struct type * p_type)
{
    return type_get_category(p_type) == 0 && p_type->type_specifier_flags & 512;
}


unsigned char type_is_floating_point(struct type * p_type)
{
    if (type_get_category(p_type) != 0)
    {
        return 0;
    }
    return ((p_type->type_specifier_flags & 96) != 0);
}


unsigned char type_is_unsigned_integer(struct type * p_type)
{
    if (type_is_integer(p_type) && (p_type->type_specifier_flags & 256))
    {
        return 1;
    }
    return 0;
}


unsigned char type_is_signed_integer(struct type * p_type)
{
    if (type_is_integer(p_type) && !(p_type->type_specifier_flags & 256))
    {
        return 1;
    }
    return 0;
}


unsigned char type_is_array_of_char(struct type * p_type)
{
    if (p_type->category != 2)
    {
        return 0;
    }
    ;
    return ((p_type->next->type_specifier_flags & 2) != 0);
}


unsigned char type_is_char(struct type * p_type)
{
    if (type_get_category(p_type) != 0)
    {
        return 0;
    }
    return ((p_type->type_specifier_flags & 2) != 0);
}


unsigned char type_is_integer(struct type * p_type)
{
    if (type_get_category(p_type) != 0)
    {
        return 0;
    }
    if (p_type->type_specifier_flags & 64)
    {
        return 0;
    }
    if (p_type->type_specifier_flags & 65536)
    {
        return 1;
    }
    return ((p_type->type_specifier_flags & 4195230) != 0);
}


unsigned char type_is_arithmetic(struct type * p_type)
{
    return type_is_integer(p_type) || type_is_floating_point(p_type);
}


unsigned char type_is_scalar_decay(struct type * p_type)
{
    if (type_is_arithmetic(p_type))
    {
        return 1;
    }
    if (type_is_pointer_or_array(p_type))
    {
        return 1;
    }
    if (type_get_category(p_type) != 0)
    {
        return 0;
    }
    if (p_type->type_specifier_flags & 65536)
    {
        return 1;
    }
    if (p_type->type_specifier_flags & 16777216)
    {
        return 1;
    }
    if (p_type->type_specifier_flags & 512)
    {
        return 1;
    }
    return 0;
}


unsigned char type_is_scalar(struct type * p_type)
{
    if (type_is_arithmetic(p_type))
    {
        return 1;
    }
    if (type_is_pointer(p_type))
    {
        return 1;
    }
    if (type_get_category(p_type) != 0)
    {
        return 0;
    }
    if (p_type->type_specifier_flags & 65536)
    {
        return 1;
    }
    if (p_type->type_specifier_flags & 16777216)
    {
        return 1;
    }
    if (p_type->type_specifier_flags & 512)
    {
        return 1;
    }
    return 0;
}


struct param_list *type_get_func_or_func_ptr_params(struct type * p_type)
{
    if (p_type->category == 1)
    {
        return &p_type->params;
    }
    else
    {
        if (p_type->category == 3)
        {
            if (p_type->next && p_type->next->category == 1)
            {
                return &p_type->next->params;
            }
        }
    }
    return 0;
}


void check_ownership_qualifiers_of_argument_and_parameter(struct parser_ctx * ctx, struct argument_expression * current_argument, struct type * paramer_type, int param_num)
{
    unsigned char  paramer_is_obj_owner;
    unsigned char  paramer_is_owner;
    unsigned char  paramer_is_view;
    struct type * argument_type;
    unsigned char  argument_is_owner;
    unsigned char  argument_is_obj_owner;
    unsigned char  argument_is_view;

    paramer_is_obj_owner = type_is_pointed_dtor(paramer_type);
    paramer_is_owner = type_is_owner(paramer_type);
    paramer_is_view = !paramer_is_obj_owner && !paramer_is_owner;
    argument_type = &current_argument->expression->type;
    argument_is_owner = type_is_owner(&current_argument->expression->type);
    argument_is_obj_owner = type_is_pointed_dtor(&current_argument->expression->type);
    argument_is_view = !argument_is_owner && !argument_is_obj_owner;
    if (argument_is_owner && paramer_is_owner)
    {
    }
    else
    {
        if (argument_is_owner && paramer_is_obj_owner)
        {
        }
        else
        {
            if (argument_is_owner && paramer_is_view)
            {
                if (current_argument->expression->type.storage_class_specifier_flags & 8192)
                {
                    compiler_diagnostic(23, ctx, current_argument->expression->first_token, 0, "passing a temporary owner to a view");
                }
            }
            else
            {
                if (argument_is_obj_owner && paramer_is_owner)
                {
                    compiler_diagnostic(24, ctx, current_argument->expression->first_token, 0, "cannot move _Dtor to _Owner");
                }
                else
                {
                    if (argument_is_obj_owner && paramer_is_obj_owner)
                    {
                    }
                    else
                    {
                        if (argument_is_obj_owner && paramer_is_view)
                        {
                            if (current_argument->expression->type.storage_class_specifier_flags & 8192)
                            {
                                compiler_diagnostic(23, ctx, current_argument->expression->first_token, 0, "passing a temporary owner to a view");
                            }
                        }
                        else
                        {
                            if (argument_is_view && paramer_is_owner)
                            {
                                if (!expression_is_null_pointer_constant(current_argument->expression))
                                {
                                    compiler_diagnostic(24, ctx, current_argument->expression->first_token, 0, "passing a _View argument to a _Owner parameter");
                                }
                            }
                            else
                            {
                                if (argument_is_view && paramer_is_obj_owner)
                                {
                                    if (type_is_pointer(argument_type))
                                    {
                                        struct type  t2;

                                        t2 = type_remove_pointer(argument_type);
                                        if (!type_is_owner(&t2))
                                        {
                                            compiler_diagnostic(24, ctx, current_argument->expression->first_token, 0, "pointed object is not _Owner");
                                        }
                                        else
                                        {
                                            if (!argument_type->address_of)
                                            {
                                                compiler_diagnostic(19, ctx, current_argument->expression->first_token, 0, "_Dtor pointer must be created using address of operator &");
                                            }
                                        }
                                        type_destroy(&t2);
                                    }
                                    else
                                    {
                                        if (!expression_is_null_pointer_constant(current_argument->expression))
                                        {
                                            compiler_diagnostic(24, ctx, current_argument->expression->first_token, 0, "passing a _View argument to a _Dtor parameter");
                                        }
                                    }
                                }
                                else
                                {
                                    if (argument_is_view && paramer_is_view)
                                    {
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


void check_argument_and_parameter(struct parser_ctx * ctx, struct argument_expression * current_argument, struct type * paramer_type, int param_num)
{
    struct type * argument_type;
    unsigned char  is_null_pointer_constant;
    struct type  parameter_type_converted;
    struct type  argument_type_converted;

    if (type_is_owner_or_pointer_to_dtor(paramer_type))
    {
        if (type_is_pointed_dtor(paramer_type))
        {
            if (current_argument->expression->type.category == 3)
            {
                if (type_is_pointer(&current_argument->expression->type) && !type_is_pointer_to_owner(&current_argument->expression->type))
                {
                    compiler_diagnostic(22, ctx, current_argument->expression->first_token, 0, "parameter %d requires a pointer to _Owner object", param_num);
                }
            }
            else
            {
                compiler_diagnostic(22, ctx, current_argument->expression->first_token, 0, "parameter %d requires a pointer to _Owner type", param_num);
            }
        }
    }
    argument_type = &current_argument->expression->type;
    is_null_pointer_constant = expression_is_null_pointer_constant(current_argument->expression);
    parameter_type_converted = (type_is_array(paramer_type)) ? type_lvalue_conversion(paramer_type, ctx->options.null_checks_enabled) : type_dup(paramer_type);
    argument_type_converted = expression_is_subjected_to_lvalue_conversion(current_argument->expression) ? type_lvalue_conversion(argument_type, ctx->options.null_checks_enabled) : type_dup(argument_type);
    if (type_is_enum(argument_type) && type_is_enum(paramer_type))
    {
        if (!type_is_same(argument_type, paramer_type, 0))
        {
            compiler_diagnostic(950, ctx, current_argument->expression->first_token, 0, " incompatible types at argument %d", param_num);
        }
        check_ownership_qualifiers_of_argument_and_parameter(ctx, current_argument, paramer_type, param_num);
        type_destroy(&parameter_type_converted);
        type_destroy(&argument_type_converted);
        return;
    }
    if (type_is_arithmetic(argument_type) && type_is_arithmetic(paramer_type))
    {
        check_ownership_qualifiers_of_argument_and_parameter(ctx, current_argument, paramer_type, param_num);
        type_destroy(&parameter_type_converted);
        type_destroy(&argument_type_converted);
        return;
    }
    if (is_null_pointer_constant && type_is_pointer(paramer_type))
    {
        check_ownership_qualifiers_of_argument_and_parameter(ctx, current_argument, paramer_type, param_num);
        type_destroy(&parameter_type_converted);
        type_destroy(&argument_type_converted);
        return;
    }
    if (is_null_pointer_constant && type_is_array(paramer_type))
    {
        compiler_diagnostic(28, ctx, current_argument->expression->first_token, 0, " passing null as array");
        check_ownership_qualifiers_of_argument_and_parameter(ctx, current_argument, paramer_type, param_num);
        type_destroy(&parameter_type_converted);
        type_destroy(&argument_type_converted);
        return;
    }
    if (type_is_pointer_or_array(argument_type) && type_is_pointer_or_array(paramer_type))
    {
        if (type_is_void_ptr(argument_type))
        {
            check_ownership_qualifiers_of_argument_and_parameter(ctx, current_argument, paramer_type, param_num);
            type_destroy(&parameter_type_converted);
            type_destroy(&argument_type_converted);
            return;
        }
        if (type_is_void_ptr(paramer_type))
        {
            check_ownership_qualifiers_of_argument_and_parameter(ctx, current_argument, paramer_type, param_num);
            type_destroy(&parameter_type_converted);
            type_destroy(&argument_type_converted);
            return;
        }
        if (type_is_array(paramer_type))
        {
            unsigned long long parameter_array_size;

            parameter_array_size = paramer_type->num_of_elements;
            if (type_is_array(argument_type))
            {
                unsigned long long argument_array_size;

                argument_array_size = argument_type->num_of_elements;
                if (parameter_array_size != 0 && argument_array_size < parameter_array_size)
                {
                    compiler_diagnostic(1130, ctx, current_argument->expression->first_token, 0, " argument of size [%d] is smaller than parameter of size [%d]", argument_array_size, parameter_array_size);
                }
            }
            else
            {
                if (is_null_pointer_constant || type_is_nullptr_t(argument_type))
                {
                    compiler_diagnostic(39, ctx, current_argument->expression->first_token, 0, " passing null as array");
                }
            }
        }
        if (!type_is_same(&argument_type_converted, &parameter_type_converted, 0))
        {
            type_print(&argument_type_converted, ctx->options.target);
            type_print(&parameter_type_converted, ctx->options.target);
            compiler_diagnostic(950, ctx, current_argument->expression->first_token, 0, " incompatible types at argument %d", param_num);
        }
        if (type_is_pointer(&argument_type_converted) && type_is_pointer(&parameter_type_converted))
        {
            struct type  argument_pointer_to;
            struct type  parameter_pointer_to;

            argument_pointer_to = type_remove_pointer(&argument_type_converted);
            parameter_pointer_to = type_remove_pointer(&parameter_type_converted);
            if (type_is_const(&argument_pointer_to) && !type_is_const(&parameter_pointer_to) && !type_is_owner_or_pointer_to_dtor(&parameter_pointer_to))
            {
                compiler_diagnostic(15, ctx, current_argument->expression->first_token, 0, " discarding const at argument %d", param_num);
            }
            type_destroy(&argument_pointer_to);
            type_destroy(&parameter_pointer_to);
        }
    }
    check_ownership_qualifiers_of_argument_and_parameter(ctx, current_argument, paramer_type, param_num);
    type_destroy(&argument_type_converted);
    type_destroy(&parameter_type_converted);
}


unsigned char type_is_function(struct type * p_type)
{
    return type_get_category(p_type) == 1;
}


unsigned char type_is_function_or_function_pointer(struct type * p_type)
{
    if (type_is_function(p_type))
    {
        return 1;
    }
    if (type_is_pointer(p_type))
    {
        struct type  t;
        unsigned char  r;

        t = type_remove_pointer(p_type);
        r = type_is_function(&t);
        type_destroy(&t);
        return r;
    }
    return 0;
}


unsigned char type_is_empty(struct type * p_type)
{
    return p_type->category == 0 && p_type->type_specifier_flags == 0;
}


struct type type_add_pointer(struct type * p_type, unsigned char  null_checks_enabled)
{
    struct type  r;

    r = type_dup(p_type);
    if (1) /*try*/
    {
        struct type * p;
        struct type  __v0;

        p = calloc(1, 68);
        if (p == 0)
        {
            goto __L0; /* throw */
        }
        *p = r;
        __v0.category = 0;
        __v0.attributes_flags = 0;
        __v0.msvc_declspec_flags = 0;
        __v0.alignment_specifier_flags = 0;
        __v0.type_specifier_flags = 0;
        __v0.type_qualifier_flags = 0;
        __v0.storage_class_specifier_flags = 0;
        __v0.name_opt = 0;
        __v0.struct_or_union_specifier = 0;
        __v0.enum_specifier = 0;
        __v0.array_num_elements_expression = 0;
        __v0.num_of_elements = 0;
        __v0.has_static_array_size = 0;
        __v0.address_of = 0;
        __v0.params.is_var_args = 0;
        __v0.params.is_void = 0;
        __v0.params.head = 0;
        __v0.params.tail = 0;
        __v0.next = 0;
        r = __v0;
        r.next = p;
        r.category = 3;
        r.storage_class_specifier_flags = p_type->storage_class_specifier_flags;
    }
    else __L0: /*catch*/ 
    {
    }
    return r;
}


struct type type_remove_pointer(struct type * p_type)
{
    struct type  r;

    r = type_dup(p_type);
    if (!type_is_pointer(p_type))
    {
        return r;
    }
    if (r.next)
    {
        struct type  next;

        next = *r.next;
        free(r.next);
        r.next = 0;
        type_destroy_one(&r);
        r = next;
    }
    else
    {
        ;
    }
    ;
    r.storage_class_specifier_flags = p_type->next->storage_class_specifier_flags;
    r.type_qualifier_flags = p_type->next->type_qualifier_flags;
    return r;
}


struct type get_array_item_type(struct type * p_type)
{
    struct type  r;

    r = type_dup(p_type);
    if (r.next)
    {
        struct type  r2;

        r2 = *r.next;
        free(r.next);
        free((void *)r.name_opt);
        param_list_destroy(&r.params);
        return r2;
    }
    return r;
}


struct type type_param_array_to_pointer(struct type * p_type, unsigned char  null_checks_enabled)
{
    struct type  t;
    struct type  t2;

    ;
    t = get_array_item_type(p_type);
    t2 = type_add_pointer(&t, null_checks_enabled);
    if (p_type->type_qualifier_flags & 1)
    {
        t2.type_qualifier_flags |= 1;
    }
    type_destroy(&t);
    t2.storage_class_specifier_flags &= -2049;
    return t2;
}


unsigned char type_is_pointer_or_array(struct type * p_type)
{
    int category;

    category = type_get_category(p_type);
    if (category == 3 || category == 2)
    {
        return 1;
    }
    if (category == 0 && p_type->type_specifier_flags == 16777216)
    {
        return 1;
    }
    return 0;
}


int type_get_integer_rank(struct type * p_type1)
{
    if (type_is_pointer_or_array(p_type1))
    {
        ;
        return 40;
    }
    if (p_type1->type_specifier_flags & 4194304)
    {
        return 80;
    }
    else
    {
        if ((p_type1->type_specifier_flags & 16777216))
        {
            return 50;
        }
        else
        {
            if (p_type1->type_specifier_flags & 16)
            {
                return 50;
            }
            else
            {
                if ((p_type1->type_specifier_flags & 8) || (p_type1->type_specifier_flags & 65536))
                {
                    return 40;
                }
                else
                {
                    if (p_type1->type_specifier_flags & 4)
                    {
                        return 30;
                    }
                    else
                    {
                        if (p_type1->type_specifier_flags & 2)
                        {
                            return 20;
                        }
                        else
                        {
                            if (p_type1->type_specifier_flags & 512)
                            {
                                return 10;
                            }
                        }
                    }
                }
            }
        }
    }
    return 0;
}


struct type type_make_int();

struct type type_get_enum_underlying_type(struct type * p)
{
    struct type  r;

    r = type_make_int();
    return r;
}


struct type type_common(struct type * p_type1, struct type * p_type2, int target)
{
    struct type  promoted_a;
    struct type  promoted_b;
    struct type * p_signed_promoted;
    struct type * p_unsigned_promoted;
    unsigned int signed_promoted_sizeof;
    unsigned int unsigned_promoted_sizeof;
    struct type  r;

    if (type_is_decimal128(p_type1))
    {
        return type_dup(p_type1);
    }
    if (type_is_decimal128(p_type2))
    {
        return type_dup(p_type2);
    }
    if (type_is_decimal64(p_type1))
    {
        return type_dup(p_type1);
    }
    if (type_is_decimal64(p_type2))
    {
        return type_dup(p_type2);
    }
    if (type_is_decimal32(p_type1))
    {
        return type_dup(p_type1);
    }
    if (type_is_decimal32(p_type2))
    {
        return type_dup(p_type2);
    }
    if (type_is_long_double(p_type1))
    {
        return type_dup(p_type1);
    }
    if (type_is_long_double(p_type2))
    {
        return type_dup(p_type2);
    }
    if (type_is_double(p_type1))
    {
        return type_dup(p_type1);
    }
    if (type_is_double(p_type2))
    {
        return type_dup(p_type2);
    }
    if (type_is_float(p_type1))
    {
        return type_dup(p_type1);
    }
    if (type_is_float(p_type2))
    {
        return type_dup(p_type2);
    }
    _cake_zmem(&promoted_a, 68);
    _cake_zmem(&promoted_b, 68);
    if (type_is_enum(p_type1))
    {
        promoted_a = type_get_enum_underlying_type(p_type1);
    }
    else
    {
        promoted_a = type_dup(p_type1);
    }
    if (type_is_enum(p_type2))
    {
        promoted_b = type_get_enum_underlying_type(p_type2);
    }
    else
    {
        promoted_b = type_dup(p_type2);
    }
    type_integer_promotion(&promoted_a);
    type_integer_promotion(&promoted_b);
    if (type_is_same(&promoted_a, &promoted_b, 0))
    {
        type_destroy(&promoted_b);
        return promoted_a;
    }
    if (type_is_signed_integer(&promoted_a) == type_is_signed_integer(&promoted_b))
    {
        if (type_get_integer_rank(&promoted_a) > type_get_integer_rank(&promoted_b))
        {
            type_destroy(&promoted_b);
            return promoted_a;
        }
        type_destroy(&promoted_a);
        return promoted_b;
    }
    p_signed_promoted = type_is_signed_integer(&promoted_a) ? &promoted_a : &promoted_b;
    p_unsigned_promoted = type_is_unsigned_integer(&promoted_a) ? &promoted_a : &promoted_b;
    ;
    if (type_get_integer_rank(p_unsigned_promoted) >= type_get_integer_rank(p_signed_promoted))
    {
        struct type  r;

        _cake_zmem(&r, 68);
        type_swap(&r, p_unsigned_promoted);
        type_destroy(&promoted_a);
        type_destroy(&promoted_b);
        return r;
    }
    signed_promoted_sizeof = 0;
    if (type_get_sizeof(p_signed_promoted, &signed_promoted_sizeof, target) != 0)
    {
        ;
    }
    unsigned_promoted_sizeof = 0;
    if (type_get_sizeof(p_unsigned_promoted, &unsigned_promoted_sizeof, target) != 0)
    {
        ;
    }
    if (signed_promoted_sizeof > unsigned_promoted_sizeof)
    {
        struct type  r;

        _cake_zmem(&r, 68);
        type_swap(&r, p_signed_promoted);
        type_destroy(&promoted_a);
        type_destroy(&promoted_b);
        return r;
    }
    _cake_zmem(&r, 68);
    type_swap(&r, p_signed_promoted);
    r.type_specifier_flags |= 256;
    type_destroy(&promoted_a);
    type_destroy(&promoted_b);
    return r;
}


void type_set(struct type * a, struct type * b)
{
    struct type  t;

    t = type_dup(b);
    type_swap(&t, a);
    type_destroy(&t);
}


void type_list_destroy(struct type_list * p_type_list);
void type_list_push_back(struct type_list * books, struct type * new_book);

struct type type_dup(struct type * p_type)
{
    struct type  empty;

    if (1) /*try*/
    {
        struct type_list  l;
        struct type * p;
        struct type  r;

        _cake_zmem(&l, 8);
        p = p_type;
        while (p)
        {
            struct type * p_new;

            p_new = calloc(1, 68);
            if (p_new == 0)
            {
                type_list_destroy(&l);
                goto __L0; /* throw */
            }
            *p_new = *p;
            p_new->next = 0;
            if (p->name_opt)
            {
                p_new->name_opt = strdup(p->name_opt);
            }
            if (p->category == 1)
            {
                struct param * p_param;

                p_new->params.head = 0;
                p_new->params.tail = 0;
                p_param = p->params.head;
                while (p_param)
                {
                    struct param * p_new_param;

                    p_new_param = calloc(1, 72);
                    if (p_new_param == 0)
                    {
                        type_list_destroy(&l);
                        type_delete(p_new);
                        goto __L0; /* throw */
                    }
                    p_new_param->type = type_dup(&p_param->type);
                    param_list_add(&p_new->params, p_new_param);
                    p_param = p_param->next;
                }
            }
            type_list_push_back(&l, p_new);
            p = p->next;
        }
        if (l.head == 0)
        {
            goto __L0; /* throw */
        }
        r = *l.head;
        free(l.head);
        return r;
    }
    else __L0: /*catch*/ 
    {
    }
    _cake_zmem(&empty, 68);
    return empty;
}


int get_sizeof_struct(struct struct_or_union_specifier * complete_struct_or_union_specifier, unsigned int * sz, int target)
{
    int sizeof_error;
    unsigned char  is_union;
    unsigned int size;

    sizeof_error = 0;
    is_union = (complete_struct_or_union_specifier->first_token->type == 9038);
    size = 0;
    if (1) /*try*/
    {
        unsigned int maxalign;
        struct member_declaration * d;

        maxalign = 0;
        d = complete_struct_or_union_specifier->member_declaration_list.head;
        while (d)
        {
            if (d->member_declarator_list_opt)
            {
                struct member_declarator * md;

                md = d->member_declarator_list_opt->head;
                while (md)
                {
                    unsigned int align;

                    align = 1;
                    if (md->declarator)
                    {
                        unsigned int item_size;

                        align = type_get_alignof(&md->declarator->type, target);
                        if (align > maxalign)
                        {
                            maxalign = align;
                        }
                        if (size % align != 0)
                        {
                            size += align - (size % align);
                        }
                        item_size = 0;
                        sizeof_error = type_get_sizeof(&md->declarator->type, &item_size, target);
                        if (sizeof_error != 0)
                        {
                            goto __L0; /* throw */
                        }
                        if (is_union)
                        {
                            if (item_size > size)
                            {
                                size = item_size;
                            }
                        }
                        else
                        {
                            size += item_size;
                        }
                    }
                    else
                    {
                        sizeof_error = 3;
                        goto __L0; /* throw */
                    }
                    md = md->next;
                }
            }
            else
            {
                if (d->specifier_qualifier_list)
                {
                    if (d->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type  t;
                        unsigned int align;
                        unsigned int item_size;

                        _cake_zmem(&t, 68);
                        t.category = 0;
                        t.struct_or_union_specifier = d->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = 32768;
                        align = type_get_alignof(&t, target);
                        if (align > maxalign)
                        {
                            maxalign = align;
                        }
                        if (size % align != 0)
                        {
                            size += align - (size % align);
                        }
                        item_size = 0;
                        sizeof_error = type_get_sizeof(&t, &item_size, target);
                        if (sizeof_error != 0)
                        {
                            goto __L0; /* throw */
                        }
                        if (is_union)
                        {
                            if (item_size > size)
                            {
                                size = item_size;
                            }
                        }
                        else
                        {
                            size += item_size;
                        }
                        type_destroy(&t);
                    }
                    else
                    {
                        sizeof_error = 3;
                        goto __L0; /* throw */
                    }
                }
            }
            d = d->next;
        }
        if (maxalign != 0)
        {
            if (size % maxalign != 0)
            {
                size += maxalign - (size % maxalign);
            }
        }
        else
        {
            sizeof_error = 3;
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        return sizeof_error;
    }
    *sz = size;
    return sizeof_error;
}


unsigned int get_alignof_struct(struct struct_or_union_specifier * complete_struct_or_union_specifier, int target)
{
    unsigned int align;
    struct member_declaration * d;

    align = 0;
    d = complete_struct_or_union_specifier->member_declaration_list.head;
    while (d)
    {
        if (d->member_declarator_list_opt)
        {
            struct member_declarator * md;

            md = d->member_declarator_list_opt->head;
            while (md)
            {
                if (md->declarator)
                {
                    unsigned int temp_align;

                    temp_align = type_get_alignof(&md->declarator->type, target);
                    if (temp_align > align)
                    {
                        align = temp_align;
                    }
                }
                else
                {
                    ;
                }
                md = md->next;
            }
        }
        else
        {
            if (d->specifier_qualifier_list)
            {
                struct type  type;
                unsigned int temp_align;

                _cake_zmem(&type, 68);
                type.type_specifier_flags = d->specifier_qualifier_list->type_specifier_flags;
                type.enum_specifier = d->specifier_qualifier_list->enum_specifier;
                type.struct_or_union_specifier = d->specifier_qualifier_list->struct_or_union_specifier;
                temp_align = type_get_alignof(&type, target);
                if (temp_align > align)
                {
                    align = temp_align;
                }
                type_destroy(&type);
            }
            else
            {
            }
        }
        d = d->next;
    }
    ;
    return align;
}


unsigned int type_get_alignof(struct type * p_type, int target)
{
    unsigned int align;
    int category;

    align = 0;
    category = type_get_category(p_type);
    if (category == 3)
    {
        align = get_platform(target)->pointer_alignment;
    }
    else
    {
        if (category == 1)
        {
            align = 4294967294;
        }
        else
        {
            if (category == 0)
            {
                if (p_type->alignment_specifier_flags & 1)
                {
                    align = 8;
                }
                else
                {
                    if (p_type->alignment_specifier_flags & 2)
                    {
                        align = 16;
                    }
                    else
                    {
                        if (p_type->alignment_specifier_flags & 4)
                        {
                            align = 32;
                        }
                        else
                        {
                            if (p_type->alignment_specifier_flags & 8)
                            {
                                align = 64;
                            }
                            else
                            {
                                if (p_type->alignment_specifier_flags & 16)
                                {
                                    align = 128;
                                }
                                else
                                {
                                    if (p_type->type_specifier_flags & 2)
                                    {
                                        align = get_platform(target)->char_alignment;
                                    }
                                    else
                                    {
                                        if (p_type->type_specifier_flags & 512)
                                        {
                                            align = get_platform(target)->bool_alignment;
                                        }
                                        else
                                        {
                                            if (p_type->type_specifier_flags & 4)
                                            {
                                                align = get_platform(target)->short_alignment;
                                            }
                                            else
                                            {
                                                if (p_type->type_specifier_flags & 65536)
                                                {
                                                    if (p_type->enum_specifier)
                                                    {
                                                        int enum_type_specifier_flags;
                                                        struct type  t;

                                                        enum_type_specifier_flags = get_enum_type_specifier_flags(p_type->enum_specifier);
                                                        t = make_with_type_specifier_flags(enum_type_specifier_flags);
                                                        align = type_get_alignof(&t, target);
                                                        type_destroy(&t);
                                                    }
                                                    else
                                                    {
                                                        align = get_platform(target)->int_alignment;
                                                    }
                                                }
                                                else
                                                {
                                                    if (p_type->type_specifier_flags == 80)
                                                    {
                                                        align = get_platform(target)->long_double_alignment;
                                                    }
                                                    else
                                                    {
                                                        if (p_type->type_specifier_flags & 16)
                                                        {
                                                            align = get_platform(target)->long_alignment;
                                                        }
                                                        else
                                                        {
                                                            if (p_type->type_specifier_flags & 4194304)
                                                            {
                                                                align = get_platform(target)->long_long_alignment;
                                                            }
                                                            else
                                                            {
                                                                if (p_type->type_specifier_flags & 8)
                                                                {
                                                                    align = get_platform(target)->int_alignment;
                                                                }
                                                                else
                                                                {
                                                                    if (p_type->type_specifier_flags & 32)
                                                                    {
                                                                        align = get_platform(target)->float_alignment;
                                                                    }
                                                                    else
                                                                    {
                                                                        if (p_type->type_specifier_flags & 64)
                                                                        {
                                                                            align = get_platform(target)->double_alignment;
                                                                        }
                                                                        else
                                                                        {
                                                                            if (p_type->type_specifier_flags & 33554432)
                                                                            {
                                                                                align = get_platform(target)->pointer_alignment;
                                                                            }
                                                                            else
                                                                            {
                                                                                if (p_type->type_specifier_flags & 32768)
                                                                                {
                                                                                    if (p_type->struct_or_union_specifier)
                                                                                    {
                                                                                        struct struct_or_union_specifier * p_complete;

                                                                                        p_complete = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
                                                                                        align = 1;
                                                                                        if (p_complete)
                                                                                        {
                                                                                            align = get_alignof_struct(p_complete, target);
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                            align = 4294967293;
                                                                                        }
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        align = 4294967293;
                                                                                        ;
                                                                                    }
                                                                                }
                                                                                else
                                                                                {
                                                                                    if (p_type->type_specifier_flags == 0)
                                                                                    {
                                                                                        align = 4294967292;
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        if (p_type->type_specifier_flags == 1)
                                                                                        {
                                                                                            align = 1;
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                            if (p_type->type_specifier_flags == 16777216)
                                                                                            {
                                                                                                align = get_platform(target)->pointer_alignment;
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                                ;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                if (category == 2)
                {
                    struct type  type;

                    type = get_array_item_type(p_type);
                    align = type_get_alignof(&type, target);
                    type_destroy(&type);
                }
            }
        }
    }
    ;
    return align;
}


static int get_offsetof_struct(struct struct_or_union_specifier * complete_struct_or_union_specifier, char * member, unsigned int * sz, int target);

int type_get_offsetof(struct type * p_type, char * member, unsigned int * size, int target)
{
    int category;
    struct struct_or_union_specifier * p_complete;

    *size = 0;
    category = type_get_category(p_type);
    if (category != 0)
    {
        *size = 4;
        return 4;
    }
    if (!(p_type->type_specifier_flags & 32768))
    {
        return 3;
    }
    if (p_type->struct_or_union_specifier == 0)
    {
        return 3;
    }
    p_complete = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
    if (p_complete == 0)
    {
        return 3;
    }
    return get_offsetof_struct(p_complete, member, size, target);
}



static int get_offsetof_struct(struct struct_or_union_specifier * complete_struct_or_union_specifier, char * member, unsigned int * sz, int target)
{
    int sizeof_error;
    unsigned char  is_union;
    unsigned int size;

    sizeof_error = 0;
    is_union = (complete_struct_or_union_specifier->first_token->type == 9038);
    size = 0;
    if (1) /*try*/
    {
        unsigned int maxalign;
        struct member_declaration * d;

        maxalign = 0;
        d = complete_struct_or_union_specifier->member_declaration_list.head;
        while (d)
        {
            if (d->member_declarator_list_opt)
            {
                struct member_declarator * md;

                md = d->member_declarator_list_opt->head;
                while (md)
                {
                    unsigned int align;

                    align = 1;
                    if (md->declarator)
                    {
                        unsigned int item_size;

                        ;
                        align = type_get_alignof(&md->declarator->type, target);
                        if (align > maxalign)
                        {
                            maxalign = align;
                        }
                        if (size % align != 0)
                        {
                            size += align - (size % align);
                        }
                        if (strcmp(md->declarator->name_opt->lexeme, member) == 0)
                        {
                            *sz = size;
                            return 0;
                        }
                        item_size = 0;
                        sizeof_error = type_get_sizeof(&md->declarator->type, &item_size, target);
                        if (sizeof_error != 0)
                        {
                            goto __L0; /* throw */
                        }
                        if (is_union)
                        {
                            if (item_size > size)
                            {
                                size = item_size;
                            }
                        }
                        else
                        {
                            size += item_size;
                        }
                    }
                    else
                    {
                        sizeof_error = 3;
                        goto __L0; /* throw */
                    }
                    md = md->next;
                }
            }
            else
            {
                if (d->specifier_qualifier_list)
                {
                    if (d->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type  t;
                        unsigned int align;
                        unsigned int item_size;

                        _cake_zmem(&t, 68);
                        t.category = 0;
                        t.struct_or_union_specifier = d->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = 32768;
                        align = type_get_alignof(&t, target);
                        if (align > maxalign)
                        {
                            maxalign = align;
                        }
                        if (size % align != 0)
                        {
                            size += align - (size % align);
                        }
                        item_size = 0;
                        sizeof_error = type_get_sizeof(&t, &item_size, target);
                        if (sizeof_error != 0)
                        {
                            goto __L0; /* throw */
                        }
                        if (is_union)
                        {
                            if (item_size > size)
                            {
                                size = item_size;
                            }
                        }
                        else
                        {
                            size += item_size;
                        }
                        type_destroy(&t);
                    }
                    else
                    {
                        sizeof_error = 3;
                        goto __L0; /* throw */
                    }
                }
            }
            d = d->next;
        }
        if (maxalign != 0)
        {
            if (size % maxalign != 0)
            {
                size += maxalign - (size % maxalign);
            }
        }
        else
        {
            sizeof_error = 3;
            goto __L0; /* throw */
        }
    }
    else __L0: /*catch*/ 
    {
        return sizeof_error;
    }
    *sz = size;
    return sizeof_error;
}
int type_get_sizeof(struct type * p_type, unsigned int * size, int target)
{
    int category;

    *size = 0;
    category = type_get_category(p_type);
    if (category == 3)
    {
        *size = get_platform(target)->pointer_n_bits / 8;
        return 0;
    }
    if (category == 1)
    {
        return 4;
    }
    if (category == 2)
    {
        if (p_type->storage_class_specifier_flags & 2048)
        {
            *size = get_platform(target)->pointer_n_bits / 8;
            return 0;
        }
        else
        {
            unsigned long long arraysize;
            struct type  type;
            unsigned int sz;
            int er;
            unsigned long long result;

            if (type_is_vla(p_type))
            {
                return 2;
            }
            arraysize = p_type->num_of_elements;
            type = get_array_item_type(p_type);
            sz = 0;
            er = type_get_sizeof(&type, &sz, target);
            if (er != 0)
            {
                type_destroy(&type);
                return er;
            }
            type_destroy(&type);
            result = 0;
            if (unsigned_long_long_mul(&result, sz, arraysize))
            {
                if (result > 4294967295)
                {
                    return 1;
                }
                if (result > 4294967295L)
                {
                    return 1;
                }
                *size = (unsigned int)result;
            }
            else
            {
                return 1;
            }
            return 0;
        }
    }
    ;
    if (p_type->type_specifier_flags & 2)
    {
        *size = get_platform(target)->char_n_bits / 8;
        return 0;
    }
    if (p_type->type_specifier_flags & 512)
    {
        *size = get_platform(target)->bool_n_bits / 8;
        return 0;
    }
    if (p_type->type_specifier_flags & 4)
    {
        *size = get_platform(target)->short_n_bits / 8;
        return 0;
    }
    else
    {
        if (p_type->type_specifier_flags & 33554432)
        {
            *size = get_platform(target)->pointer_n_bits / 8;
            return 0;
        }
    }
    if (p_type->type_specifier_flags == 80)
    {
        *size = get_platform(target)->long_double_n_bits / 8;
        return 0;
    }
    if (p_type->type_specifier_flags & 16)
    {
        *size = get_platform(target)->long_n_bits / 8;
        return 0;
    }
    if (p_type->type_specifier_flags & 4194304)
    {
        *size = get_platform(target)->long_long_n_bits / 8;
        return 0;
    }
    if (p_type->type_specifier_flags & 8)
    {
        *size = get_platform(target)->int_n_bits / 8;
        return 0;
    }
    if (p_type->type_specifier_flags & 32)
    {
        *size = get_platform(target)->float_n_bits / 8;
        return 0;
    }
    if (p_type->type_specifier_flags & 64)
    {
        *size = get_platform(target)->double_n_bits / 8;
        return 0;
    }
    if (p_type->type_specifier_flags & 32768)
    {
        struct struct_or_union_specifier * p_complete;

        if (p_type->struct_or_union_specifier == 0)
        {
            return 3;
        }
        p_complete = get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
        if (p_complete == 0)
        {
            return 3;
        }
        return get_sizeof_struct(p_complete, size, target);
    }
    if (p_type->type_specifier_flags & 65536)
    {
        if (p_type->enum_specifier)
        {
            int enum_type_specifier_flags;
            struct type  t;
            int e;

            enum_type_specifier_flags = get_enum_type_specifier_flags(p_type->enum_specifier);
            t = make_with_type_specifier_flags(enum_type_specifier_flags);
            e = type_get_sizeof(&t, size, target);
            type_destroy(&t);
            return e;
        }
        else
        {
            *size = get_platform(target)->int_n_bits / 8;
        }
        return 0;
    }
    if (p_type->type_specifier_flags == 0)
    {
        *size = 0;
        return 3;
    }
    if (p_type->type_specifier_flags == 1)
    {
        *size = 1;
        return 0;
    }
    if (p_type->type_specifier_flags == 16777216)
    {
        *size = get_platform(target)->pointer_n_bits / 8;
        return 0;
    }
    if (p_type->type_specifier_flags == 2048)
    {
        *size = 4;
        return 0;
    }
    if (p_type->type_specifier_flags == 4096)
    {
        *size = 8;
        return 0;
    }
    if (p_type->type_specifier_flags == 8192)
    {
        *size = 16;
        return 0;
    }
    return 3;
}


void type_set_attributes(struct type * p_type, struct declarator * pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->attributes_flags = pdeclarator->declaration_specifiers->attributes_flags;
    }
    else
    {
        if (pdeclarator->specifier_qualifier_list)
        {
        }
    }
}


unsigned char function_returns_void(struct type * p_type)
{
    struct type  t;
    unsigned char  r;

    t = get_function_return_type(p_type);
    r = type_is_void(&t);
    type_destroy(&t);
    return r;
}


struct type get_function_return_type(struct type * p_type)
{
    struct type  empty;

    if (1) /*try*/
    {
        struct type  r;

        if (p_type->next == 0)
        {
            goto __L0; /* throw */
        }
        if (type_is_pointer(p_type))
        {
            struct type  r;

            if (p_type->next->next == 0)
            {
                goto __L0; /* throw */
            }
            r = type_dup(p_type->next->next);
            return r;
        }
        r = type_dup(p_type->next);
        return r;
    }
    else __L0: /*catch*/ 
    {
    }
    _cake_zmem(&empty, 68);
    return empty;
}


void type_set_int(struct type * p_type)
{
    p_type->type_specifier_flags = 8;
    p_type->type_qualifier_flags = 0;
    p_type->category = 0;
}


struct type type_make_enumerator(struct enum_specifier * enum_specifier)
{
    struct type  t;

    _cake_zmem(&t, 68);
    t.type_specifier_flags = 65536;
    t.enum_specifier = enum_specifier;
    t.category = 0;
    return t;
}


struct type type_get_enum_type(struct type * p_type)
{
    struct type  empty;

    if (1) /*try*/
    {
        struct enum_specifier * p_complete_enum_specifier;
        struct type  t;

        if (p_type->enum_specifier == 0)
        {
            goto __L0; /* throw */
        }
        p_complete_enum_specifier = get_complete_enum_specifier(p_type->enum_specifier);
        if (p_complete_enum_specifier && p_complete_enum_specifier->specifier_qualifier_list)
        {
            struct type  t;

            _cake_zmem(&t, 68);
            t.type_qualifier_flags = p_complete_enum_specifier->specifier_qualifier_list->type_qualifier_flags;
            t.type_specifier_flags = p_complete_enum_specifier->specifier_qualifier_list->type_specifier_flags;
            return t;
        }
        _cake_zmem(&t, 68);
        t.type_specifier_flags = 8;
        return t;
    }
    else __L0: /*catch*/ 
    {
    }
    _cake_zmem(&empty, 68);
    return empty;
}


struct type type_make_long_double()
{
    struct type  t;

    _cake_zmem(&t, 68);
    t.type_specifier_flags = 80;
    t.category = 0;
    return t;
}


struct type type_make_double()
{
    struct type  t;

    _cake_zmem(&t, 68);
    t.type_specifier_flags = 64;
    t.category = 0;
    return t;
}


struct type type_make_float()
{
    struct type  t;

    _cake_zmem(&t, 68);
    t.type_specifier_flags = 32;
    t.category = 0;
    return t;
}


struct type type_make_ptrdiff_t(int target)
{
    struct type  t;

    _cake_zmem(&t, 68);
    t.type_specifier_flags = object_type_to_type_specifier(get_platform(target)->ptrdiff_type);
    t.category = 0;
    return t;
}


struct type type_make_size_t(int target)
{
    struct type  t;

    _cake_zmem(&t, 68);
    t.type_specifier_flags = object_type_to_type_specifier(get_platform(target)->size_t_type);
    t.category = 0;
    return t;
}


struct type make_void_ptr_type()
{
    struct type  t;

    _cake_zmem(&t, 68);
    if (1) /*try*/
    {
        struct type * p;

        p = calloc(1, 68);
        if (p == 0)
        {
            goto __L0; /* throw */
        }
        t.category = 3;
        p->category = 0;
        p->type_specifier_flags = 1;
        t.next = p;
    }
    else __L0: /*catch*/ 
    {
    }
    return t;
}


struct type make_void_type()
{
    struct type  t;

    _cake_zmem(&t, 68);
    t.type_specifier_flags = 1;
    t.category = 0;
    return t;
}


struct type type_make_int_bool_like()
{
    struct type  t;

    _cake_zmem(&t, 68);
    t.type_specifier_flags = 8;
    t.attributes_flags = 33554432;
    t.category = 0;
    return t;
}


struct type make_with_type_specifier_flags(int f)
{
    struct type  t;

    _cake_zmem(&t, 68);
    t.type_specifier_flags = f;
    t.category = 0;
    return t;
}


struct type make_size_t_type(int target)
{
    struct type  t;

    _cake_zmem(&t, 68);
    t.type_specifier_flags = object_type_to_type_specifier(get_platform(target)->size_t_type);
    t.category = 0;
    return t;
}


struct type type_make_int()
{
    struct type  t;

    _cake_zmem(&t, 68);
    t.type_specifier_flags = 8;
    t.category = 0;
    return t;
}


struct type type_make_literal_string(int number_of_chars_including_zero, int chartype, int qualifiers, int target)
{
    struct type  t;

    _cake_zmem(&t, 68);
    if (1) /*try*/
    {
        struct type * p2;

        p2 = calloc(1, 68);
        if (p2 == 0)
        {
            goto __L0; /* throw */
        }
        t.category = 2;
        t.num_of_elements = number_of_chars_including_zero;
        p2->category = 0;
        p2->type_specifier_flags = chartype;
        p2->type_qualifier_flags = qualifiers;
        t.next = p2;
    }
    else __L0: /*catch*/ 
    {
    }
    return t;
}


unsigned char struct_or_union_specifier_is_same(struct struct_or_union_specifier * a, struct struct_or_union_specifier * b)
{
    if (a && b)
    {
        struct struct_or_union_specifier * p_complete_a;
        struct struct_or_union_specifier * p_complete_b;

        p_complete_a = get_complete_struct_or_union_specifier(a);
        p_complete_b = get_complete_struct_or_union_specifier(b);
        if (p_complete_a != 0 && p_complete_b != 0)
        {
            if (p_complete_a != p_complete_b)
            {
                return 0;
            }
            return 1;
        }
        else
        {
            if (a->tagtoken != 0 && b->tagtoken != 0)
            {
                if (strcmp(a->tagtoken->lexeme, b->tagtoken->lexeme) == 0)
                {
                    return 1;
                }
            }
        }
        return p_complete_a == 0 && p_complete_b == 0;
    }
    return a == 0 && b == 0;
}


unsigned char enum_specifier_is_same(struct enum_specifier * a, struct enum_specifier * b)
{
    if (a && b)
    {
        if (get_complete_enum_specifier(a) && get_complete_enum_specifier(b))
        {
            if (get_complete_enum_specifier(a) != get_complete_enum_specifier(b))
            {
                return 0;
            }
            return 1;
        }
        return get_complete_enum_specifier(a) == 0 && get_complete_enum_specifier(b) == 0;
    }
    return a == 0 && b == 0;
}


static unsigned char type_is_same_core(struct type * a, struct type * b, unsigned char  compare_qualifiers);

unsigned char type_is_same(struct type * a, struct type * b, unsigned char  compare_qualifiers)
{
    return type_is_same_core(a, b, compare_qualifiers);
}



static unsigned char type_is_same_core(struct type * a, struct type * b, unsigned char  compare_qualifiers)
{
    struct type * pa;
    struct type * pb;

    pa = a;
    pb = b;
    while (pa && pb)
    {
        int a_flags;
        int b_flags;

        if (pa->num_of_elements != pb->num_of_elements)
        {
            return 0;
        }
        if (pa->category != pb->category)
        {
            return 0;
        }
        if (pa->enum_specifier && pb->enum_specifier && get_complete_enum_specifier(pa->enum_specifier) != get_complete_enum_specifier(pb->enum_specifier))
        {
            return 0;
        }
        if (pa->enum_specifier && !pb->enum_specifier)
        {
        }
        if (!pa->enum_specifier && pb->enum_specifier)
        {
        }
        if (pa->has_static_array_size != pb->has_static_array_size)
        {
            return 0;
        }
        if (pa->category == 1)
        {
            struct param * p_param_a;
            struct param * p_param_b;

            if (pa->params.is_var_args != pb->params.is_var_args)
            {
                return 0;
            }
            if (pa->params.is_void != pb->params.is_void)
            {
                return 0;
            }
            p_param_a = pa->params.head;
            p_param_b = pb->params.head;
            while (p_param_a && p_param_b)
            {
                if (!type_is_same(&p_param_a->type, &p_param_b->type, compare_qualifiers))
                {
                    return 0;
                }
                p_param_a = p_param_a->next;
                p_param_b = p_param_b->next;
            }
            return p_param_a == 0 && p_param_b == 0;
        }
        if (pa->struct_or_union_specifier && pb->struct_or_union_specifier)
        {
            if (pa->struct_or_union_specifier->complete_struct_or_union_specifier_indirection != pb->struct_or_union_specifier->complete_struct_or_union_specifier_indirection)
            {
            }
            if (strcmp(pa->struct_or_union_specifier->tag_name, pb->struct_or_union_specifier->tag_name) != 0)
            {
                return 0;
            }
        }
        if (compare_qualifiers)
        {
            int aq;
            int bq;
            unsigned int all;

            aq = pa->type_qualifier_flags;
            bq = pb->type_qualifier_flags;
            all = 496;
            aq = aq & ~all;
            bq = bq & ~all;
            if (aq != bq)
            {
                return 0;
            }
        }
        a_flags = pa->type_specifier_flags;
        b_flags = pb->type_specifier_flags;
        if ((a_flags & 2) == 0)
        {
            a_flags &= -129;
        }
        if ((b_flags & 2) == 0)
        {
            b_flags &= -129;
        }
        if (a_flags != b_flags)
        {
            return 0;
        }
        pa = pa->next;
        pb = pb->next;
    }
    return pa == 0 && pb == 0;
}
unsigned char type_is_compatible(struct type * a, struct type * b)
{
    return type_is_same_core(a, b, 0);
}


void type_clear(struct type * a)
{
    struct type  tmp;

    _cake_zmem(&tmp, 68);
    type_swap(&tmp, a);
    type_destroy(&tmp);
}


void type_swap(struct type * a, struct type * b)
{
    struct type  temp;

    temp = *a;
    *a = *b;
    *b = temp;
}


void type_visit_to_mark_anonymous(struct type * p_type)
{
    if (p_type->struct_or_union_specifier != 0 && p_type->struct_or_union_specifier->has_anonymous_tag)
    {
        if (p_type->struct_or_union_specifier->complete_struct_or_union_specifier_indirection)
        {
            p_type->struct_or_union_specifier->complete_struct_or_union_specifier_indirection->show_anonymous_tag = 1;
        }
        p_type->struct_or_union_specifier->show_anonymous_tag = 1;
    }
}


void type_merge_qualifiers_using_declarator(struct type * p_type, struct declarator * pdeclarator)
{
    int type_qualifier_flags;

    type_qualifier_flags = 0;
    if (pdeclarator->declaration_specifiers)
    {
        type_qualifier_flags = pdeclarator->declaration_specifiers->type_qualifier_flags;
    }
    else
    {
        if (pdeclarator->specifier_qualifier_list)
        {
            type_qualifier_flags = pdeclarator->specifier_qualifier_list->type_qualifier_flags;
        }
    }
    p_type->type_qualifier_flags |= type_qualifier_flags;
}


void type_set_qualifiers_using_declarator(struct type * p_type, struct declarator * pdeclarator)
{
    int type_qualifier_flags;

    type_qualifier_flags = 0;
    if (pdeclarator->declaration_specifiers)
    {
        type_qualifier_flags = pdeclarator->declaration_specifiers->type_qualifier_flags;
    }
    else
    {
        if (pdeclarator->specifier_qualifier_list)
        {
            type_qualifier_flags = pdeclarator->specifier_qualifier_list->type_qualifier_flags;
        }
    }
    p_type->type_qualifier_flags = type_qualifier_flags;
}


void type_set_alignment_specifier_flags_using_declarator(struct type * p_type, struct declarator * pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->alignment_specifier_flags |= pdeclarator->declaration_specifiers->alignment_specifier_flags;
    }
    else
    {
        if (pdeclarator->specifier_qualifier_list)
        {
            p_type->alignment_specifier_flags = pdeclarator->specifier_qualifier_list->alignment_specifier_flags;
        }
    }
}


void type_set_msvc_declspec_using_declarator(struct type * p_type, struct declarator * pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->msvc_declspec_flags |= pdeclarator->declaration_specifiers->msvc_declspec_flags;
    }
}


void type_set_storage_specifiers_using_declarator(struct type * p_type, struct declarator * pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->storage_class_specifier_flags |= pdeclarator->declaration_specifiers->storage_class_specifier_flags;
    }
    else
    {
    }
}


void type_set_specifiers_using_declarator(struct type * p_type, struct declarator * pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->type_specifier_flags = pdeclarator->declaration_specifiers->type_specifier_flags;
        p_type->enum_specifier = pdeclarator->declaration_specifiers->enum_specifier;
        p_type->struct_or_union_specifier = pdeclarator->declaration_specifiers->struct_or_union_specifier;
    }
    else
    {
        if (pdeclarator->specifier_qualifier_list)
        {
            p_type->type_specifier_flags = pdeclarator->specifier_qualifier_list->type_specifier_flags;
            p_type->enum_specifier = pdeclarator->specifier_qualifier_list->enum_specifier;
            p_type->struct_or_union_specifier = pdeclarator->specifier_qualifier_list->struct_or_union_specifier;
        }
    }
}


void type_set_attributes_using_declarator(struct type * p_type, struct declarator * pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        if (pdeclarator->declaration_specifiers->attributes_flags & 8)
        {
            p_type->storage_class_specifier_flags |= 16384;
        }
        p_type->attributes_flags = pdeclarator->declaration_specifiers->attributes_flags;
    }
    else
    {
        if (pdeclarator->specifier_qualifier_list)
        {
        }
    }
}


void type_list_push_front(struct type_list * books, struct type * new_book)
{
    ;
    if (books->head == 0)
    {
        books->head = new_book;
        books->tail = new_book;
    }
    else
    {
        new_book->next = books->head;
        books->head = new_book;
    }
}


void type_list_destroy(struct type_list * p_type_list)
{
    struct type * item;

    item = p_type_list->head;
    while (item)
    {
        struct type * next;

        next = item->next;
        item->next = 0;
        type_destroy_one(item);
        free(item);
        item = next;
    }
}


void type_list_push_back(struct type_list * type_list, struct type * new_book)
{
    if (type_list->tail == 0)
    {
        ;
        type_list->head = new_book;
    }
    else
    {
        ;
        type_list->tail->next = new_book;
    }
    type_list->tail = new_book;
}


void make_type_using_declarator_core(struct parser_ctx * ctx, struct declarator * pdeclarator, char ** ppname, struct type_list * list);

void make_type_using_direct_declarator(struct parser_ctx * ctx, struct direct_declarator * pdirectdeclarator, char ** ppname, struct type_list * list)
{
    if (1) /*try*/
    {
        if (pdirectdeclarator->declarator)
        {
            make_type_using_declarator_core(ctx, pdirectdeclarator->declarator, ppname, list);
        }
        else
        {
            if (pdirectdeclarator->function_declarator)
            {
                struct type * p_func;

                if (pdirectdeclarator->function_declarator->direct_declarator)
                {
                    make_type_using_direct_declarator(ctx, pdirectdeclarator->function_declarator->direct_declarator, ppname, list);
                }
                p_func = calloc(1, 68);
                if (p_func == 0)
                {
                    goto __L0; /* throw */
                }
                p_func->category = 1;
                ;
                if (pdirectdeclarator->function_declarator->direct_declarator->p_calling_convention)
                {
                    char * calling_convention_lexeme;

                    calling_convention_lexeme = pdirectdeclarator->function_declarator->direct_declarator->p_calling_convention->lexeme;
                    if (strcmp(calling_convention_lexeme, "__fastcall") == 0)
                    {
                        p_func->attributes_flags |= 134217728;
                    }
                    else
                    {
                        if (strcmp(calling_convention_lexeme, "__stdcall") == 0)
                        {
                            p_func->attributes_flags |= 268435456;
                        }
                        else
                        {
                            if (strcmp(calling_convention_lexeme, "__cdecl") == 0)
                            {
                                p_func->attributes_flags |= 536870912;
                            }
                            else
                            {
                                type_delete(p_func);
                                goto __L0; /* throw */
                            }
                        }
                    }
                }
                if (pdirectdeclarator->function_declarator->parameter_type_list_opt)
                {
                    p_func->params.is_var_args = pdirectdeclarator->function_declarator->parameter_type_list_opt->is_var_args;
                    p_func->params.is_void = pdirectdeclarator->function_declarator->parameter_type_list_opt->is_void;
                }
                if (pdirectdeclarator->function_declarator->parameter_type_list_opt && pdirectdeclarator->function_declarator->parameter_type_list_opt->parameter_list)
                {
                    struct parameter_declaration * p;

                    p = pdirectdeclarator->function_declarator->parameter_type_list_opt->parameter_list->head;
                    while (p)
                    {
                        struct param * p_new_param;

                        if (p->declarator == 0)
                        {
                            type_delete(p_func);
                            goto __L0; /* throw */
                        }
                        p_new_param = calloc(1, 72);
                        if (p_new_param == 0)
                        {
                            type_delete(p_func);
                            goto __L0; /* throw */
                        }
                        p_new_param->type = type_dup(&p->declarator->type);
                        param_list_add(&p_func->params, p_new_param);
                        p = p->next;
                    }
                }
                type_list_push_back(list, p_func);
            }
            else
            {
                if (pdirectdeclarator->array_declarator)
                {
                    struct type * p;

                    if (pdirectdeclarator->array_declarator->direct_declarator)
                    {
                        make_type_using_direct_declarator(ctx, pdirectdeclarator->array_declarator->direct_declarator, ppname, list);
                    }
                    p = calloc(1, 68);
                    if (p == 0)
                    {
                        goto __L0; /* throw */
                    }
                    p->category = 2;
                    p->num_of_elements = array_declarator_get_size(pdirectdeclarator->array_declarator);
                    p->array_num_elements_expression = pdirectdeclarator->array_declarator->assignment_expression;
                    if (pdirectdeclarator->array_declarator->static_token_opt)
                    {
                        p->has_static_array_size = 1;
                    }
                    if (pdirectdeclarator->array_declarator->type_qualifier_list_opt)
                    {
                        p->type_qualifier_flags = pdirectdeclarator->array_declarator->type_qualifier_list_opt->flags;
                    }
                    type_list_push_back(list, p);
                }
            }
        }
        if (pdirectdeclarator->name_opt)
        {
            *ppname = pdirectdeclarator->name_opt->lexeme;
        }
    }
    else __L0: /*catch*/ 
    {
    }
}


void make_type_using_declarator_core(struct parser_ctx * ctx, struct declarator * pdeclarator, char ** ppname, struct type_list * list)
{
    if (1) /*try*/
    {
        struct type_list  pointers;
        struct pointer * pointer;

        _cake_zmem(&pointers, 8);
        pointer = pdeclarator->pointer;
        while (pointer)
        {
            struct type * p_flat;

            p_flat = calloc(1, 68);
            if (p_flat == 0)
            {
                type_list_destroy(&pointers);
                goto __L0; /* throw */
            }
            if (pointer->type_qualifier_list_opt)
            {
                p_flat->type_qualifier_flags = pointer->type_qualifier_list_opt->flags;
            }
            if (pointer->attribute_specifier_sequence_opt)
            {
                p_flat->attributes_flags |= pointer->attribute_specifier_sequence_opt->attributes_flags;
            }
            p_flat->category = 3;
            if (pointer->calling_convention)
            {
                char * calling_convention_lexeme;

                calling_convention_lexeme = pointer->calling_convention->lexeme;
                if (strcmp(calling_convention_lexeme, "__fastcall") == 0)
                {
                    p_flat->attributes_flags |= 134217728;
                }
                else
                {
                    if (strcmp(calling_convention_lexeme, "__stdcall") == 0)
                    {
                        p_flat->attributes_flags |= 268435456;
                    }
                    else
                    {
                        if (strcmp(calling_convention_lexeme, "__cdecl") == 0)
                        {
                            p_flat->attributes_flags |= 536870912;
                        }
                        else
                        {
                            type_list_destroy(&pointers);
                            type_delete(p_flat);
                            goto __L0; /* throw */
                        }
                    }
                }
            }
            type_list_push_front(&pointers, p_flat);
            pointer = pointer->pointer;
        }
        if (pdeclarator->direct_declarator)
        {
            make_type_using_direct_declarator(ctx, pdeclarator->direct_declarator, ppname, list);
            if (list->head && list->head->category == 1)
            {
                if (pointers.head)
                {
                    pointers.head->storage_class_specifier_flags |= 8192;
                }
            }
        }
        while (pointers.head)
        {
            struct type * p;

            p = pointers.head;
            pointers.head = p->next;
            p->next = 0;
            type_list_push_back(list, p);
        }
    }
    else __L0: /*catch*/ 
    {
    }
}


struct enum_specifier *declarator_get_enum_specifier(struct declarator * pdeclarator)
{
    if (pdeclarator->declaration_specifiers && pdeclarator->declaration_specifiers->enum_specifier)
    {
        return pdeclarator->declaration_specifiers->enum_specifier;
    }
    if (pdeclarator->specifier_qualifier_list && pdeclarator->specifier_qualifier_list->enum_specifier)
    {
        return pdeclarator->specifier_qualifier_list->enum_specifier;
    }
    return 0;
}


struct struct_or_union_specifier *declarator_get_struct_or_union_specifier(struct declarator * pdeclarator)
{
    if (pdeclarator->declaration_specifiers && pdeclarator->declaration_specifiers->struct_or_union_specifier)
    {
        return pdeclarator->declaration_specifiers->struct_or_union_specifier;
    }
    if (pdeclarator->specifier_qualifier_list && pdeclarator->specifier_qualifier_list->struct_or_union_specifier)
    {
        return pdeclarator->specifier_qualifier_list->struct_or_union_specifier;
    }
    return 0;
}


struct typeof_specifier *declarator_get_typeof_specifier(struct declarator * pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        return pdeclarator->declaration_specifiers->typeof_specifier;
    }
    else
    {
        if (pdeclarator->specifier_qualifier_list)
        {
            return pdeclarator->specifier_qualifier_list->typeof_specifier;
        }
    }
    return 0;
}


struct declarator *declarator_get_typedef_declarator(struct declarator * pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        return pdeclarator->declaration_specifiers->typedef_declarator;
    }
    else
    {
        if (pdeclarator->specifier_qualifier_list)
        {
            return pdeclarator->specifier_qualifier_list->typedef_declarator;
        }
    }
    return 0;
}


static unsigned char is_valid_type(struct parser_ctx * ctx, struct token * p_token, struct type * p_type);

struct type make_type_using_declarator(struct parser_ctx * ctx, struct declarator * pdeclarator)
{
    struct type  empty;

    if (1) /*try*/
    {
        struct type_list  list;
        char * name;
        struct type  r;

        _cake_zmem(&list, 8);
        name = 0;
        make_type_using_declarator_core(ctx, pdeclarator, &name, &list);
        if (declarator_get_typeof_specifier(pdeclarator))
        {
            struct type * p_nt;
            struct type  nt;

            p_nt = calloc(1, 68);
            if (p_nt == 0)
            {
                type_list_destroy(&list);
                goto __L0; /* throw */
            }
            nt = type_dup(&declarator_get_typeof_specifier(pdeclarator)->type);
            *p_nt = nt;
            if (list.head != 0)
            {
                type_set_qualifiers_using_declarator(list.head, pdeclarator);
            }
            if (list.tail)
            {
                ;
                list.tail->next = p_nt;
            }
            else
            {
                type_list_push_back(&list, p_nt);
            }
        }
        else
        {
            if (declarator_get_typedef_declarator(pdeclarator))
            {
                struct declarator * p_typedef_declarator;
                struct type  nt;
                struct type * p_nt;

                p_typedef_declarator = declarator_get_typedef_declarator(pdeclarator);
                if (p_typedef_declarator == 0)
                {
                    type_list_destroy(&list);
                    goto __L0; /* throw */
                }
                nt = type_dup(&p_typedef_declarator->type);
                free((void *)nt.name_opt);
                nt.name_opt = 0;
                if (pdeclarator->name_opt)
                {
                    nt.name_opt = strdup(pdeclarator->name_opt->lexeme);
                }
                p_nt = calloc(1, 68);
                if (p_nt == 0)
                {
                    type_list_destroy(&list);
                    type_destroy(&nt);
                    goto __L0; /* throw */
                }
                *p_nt = nt;
                type_merge_qualifiers_using_declarator(p_nt, pdeclarator);
                if (list.tail)
                {
                    ;
                    list.tail->next = p_nt;
                }
                else
                {
                    type_list_push_back(&list, p_nt);
                }
            }
            else
            {
                struct type * p;

                p = calloc(1, 68);
                if (p == 0)
                {
                    type_list_destroy(&list);
                    goto __L0; /* throw */
                }
                p->category = 0;
                type_set_specifiers_using_declarator(p, pdeclarator);
                type_set_attributes_using_declarator(p, pdeclarator);
                type_set_alignment_specifier_flags_using_declarator(p, pdeclarator);
                type_set_qualifiers_using_declarator(p, pdeclarator);
                if (list.tail && list.tail->category == 1)
                {
                    p->storage_class_specifier_flags |= 8192;
                }
                type_list_push_back(&list, p);
                if (list.head)
                {
                    type_set_storage_specifiers_using_declarator(list.head, pdeclarator);
                }
            }
        }
        if (list.head == 0)
        {
            goto __L0; /* throw */
        }
        if (pdeclarator->name_opt)
        {
            char * temp;

            temp = strdup(pdeclarator->name_opt->lexeme);
            if (temp == 0)
            {
                type_list_destroy(&list);
                goto __L0; /* throw */
            }
            free((void *)list.head->name_opt);
            list.head->name_opt = temp;
        }
        r = *list.head;
        free(list.head);
        type_set_storage_specifiers_using_declarator(&r, pdeclarator);
        type_set_msvc_declspec_using_declarator(&r, pdeclarator);
        type_set_alignment_specifier_flags_using_declarator(&r, pdeclarator);
        if (!is_valid_type(ctx, pdeclarator->first_token_opt, &r))
        {
            struct type  empty;

            type_destroy(&r);
            _cake_zmem(&empty, 68);
            return empty;
        }
        return r;
    }
    else __L0: /*catch*/ 
    {
    }
    _cake_zmem(&empty, 68);
    return empty;
}



static unsigned char is_valid_type(struct parser_ctx * ctx, struct token * p_token, struct type * p_type)
{
    struct type * p;

    if (p_token == 0)
    {
        p_token = ctx->current;
    }
    p = p_type;
    while (p)
    {
        if (p->category == 1)
        {
            if (p->next && p->next->category == 1)
            {
                compiler_diagnostic(1410, ctx, p_token, 0, "function returning function");
                return 0;
            }
            else
            {
                if (p->next && p->next->category == 2)
                {
                    compiler_diagnostic(1420, ctx, p_token, 0, "function returning array");
                    return 0;
                }
            }
        }
        else
        {
            if (p->category == 0 && p->type_specifier_flags == 0)
            {
                compiler_diagnostic(860, ctx, p_token, 0, "invalid type");
                return 0;
            }
        }
        p = p->next;
    }
    return 1;
}
void type_remove_names(struct type * p_type)
{
    struct type * p;

    p = p_type;
    while (p)
    {
        if (p->name_opt)
        {
            free((void *)p->name_opt);
            p->name_opt = 0;
        }
        p = p->next;
    }
}


struct type *type_get_specifer_part(struct type * p_type)
{
    struct type * p;

    p = p_type;
    while (p->next)
    p = p->next;
    return p;
}


int main(int argc, char ** argv)
{
    struct report  report;
    int result;

    enable_vt_mode();
    printf("Cake 0.12.56 (%s)\n", get_platform(1)->name);
    if (argc < 2)
    {
        print_help();
        return 1;
    }
    if (argc > 1 && strcmp(argv[1], "-selftest") == 0)
    {
        printf("*** SELF TEST ***.\n");
        printf("Error: self-tests not included. To run the self-tests, compile with -DTEST and try again.\n");
        return 1;
    }
    _cake_zmem(&report, 48);
    result = compile(argc, (char **)argv, &report);
    return result;
}


